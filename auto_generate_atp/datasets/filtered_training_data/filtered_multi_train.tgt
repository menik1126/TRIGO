intros
cases b; unfold write write'; simp [array.write_eq_write']
cases b; unfold write write'
cases b
unfold write write'
simp [array.write_eq_write']
intros
cases v
cases w
reflexivity
intros
cases x; cases x'; simp * at *
cases x; cases x'
cases x
cases x'
simp * at *
intros
rw [int.add_comm, int.add_left_neg]
intros
have h := int.add_le_add_right h b
rwa int.sub_add_cancel at h
intros
refine nat.eq_of_mul_eq_mul_left dec_trivial (nat.add_left_cancel (eq.trans _ (nat.mod_add_div n 2).symm))
rw [mod_two_of_bodd, bodd_add_div2]
intros
rw [nat.mul_comm, add_mul_div_left _ _ H]
intros
tactic.mk_inj_eq
intros
{ ext, rw associated_iff_eq }
ext
rw associated_iff_eq
intros
refine (finset.prod_image' f (Œª x hx, _)).symm
refl
intros
apply ext'
intro b
rw count_sum'
have h : count b s = count b (count b s ‚Ä¢ {b})
{ rw [count_nsmul, count_singleton_self, mul_one] }
rw [count_nsmul, count_singleton_self, mul_one]
rw h
clear h
apply finset.sum_eq_single b
intros c h hcb
{ intros c h hcb, rw count_nsmul, convert mul_zero (count c s), apply count_eq_zero.mpr, exact finset.not_mem_singleton.mpr (ne.symm hcb) }
rw count_nsmul
convert mul_zero (count c s)
apply count_eq_zero.mpr
exact finset.not_mem_singleton.mpr (ne.symm hcb)
intro hb
{ intro hb, rw [count_eq_zero_of_not_mem (mt mem_to_finset.2 hb), count_nsmul, zero_mul]}
rw [count_eq_zero_of_not_mem (mt mem_to_finset.2 hb), count_nsmul, zero_mul]
intros
simp [prod_apply_ite _ _ (Œª x, x)]
intros
induction n with n ih
{ rw [prod_range_one, prod_range_one] }
rw [prod_range_one, prod_range_one]
rw [prod_range_succ', prod_range_succ _ (nat.succ n)]
{ rw [prod_range_succ', prod_range_succ _ (nat.succ n)], simp [‚Üê ih] }
simp [‚Üê ih]
intros
contrapose! Hle with Hlt
exact prod_lt_prod_of_nonempty' hs Hlt
intros
{ ext, refl, }
ext
refl
intros
induction n
simp
{ simp, }
rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]
apply add_pow_char_of_commute
apply commute.pow_pow h
intros
simpa [linear_ordered_add_comm_group.tendsto_nhds, abs_sub_comm] using (of_convergence_epsilon v)
intros
cases decidable.em (g.terminated_at n) with terminated_at_n not_terminated_at_n
have : squash_gcf g n = g
{ have : squash_gcf g n = g, from squash_gcf_eq_self_of_terminated terminated_at_n, simp only [this, (convergents_stable_of_terminated n.le_succ terminated_at_n)] }
from squash_gcf_eq_self_of_terminated terminated_at_n
simp only [this, (convergents_stable_of_terminated n.le_succ terminated_at_n)]
obtain ‚ü®‚ü®a, b‚ü©, s_nth_eq‚ü© : ‚àÉ gp_n, g.s.nth n = some gp_n
{ obtain ‚ü®‚ü®a, b‚ü©, s_nth_eq‚ü© : ‚àÉ gp_n, g.s.nth n = some gp_n, from option.ne_none_iff_exists'.mp not_terminated_at_n, have b_ne_zero : b ‚â† 0, from nth_part_denom_ne_zero (part_denom_eq_s_b s_nth_eq), cases n with n', case nat.zero { suffices : (b * g.h + a) / b = g.h + a / b, by simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)], calc (b * g.h + a) / b = b * g.h / b + a / b : by ring ... = g.h + a / b : by rw (mul_div_cancel_left _ b_ne_zero) }, case nat.succ { obtain ‚ü®‚ü®pa, pb‚ü©, s_n'th_eq‚ü© : ‚àÉ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq, let g' := squash_gcf g (n' + 1), set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq, set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq, let pA := pred_conts.a, let pB := pred_conts.b, let ppA := ppred_conts.a, let ppB := ppred_conts.b, set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq', set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq', let pA' := pred_conts'.a, let pB' := pred_conts'.b, let ppA' := ppred_conts'.a, let ppB' := ppred_conts'.b, have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB'), { have : g'.s.nth n' = some ‚ü®pa, pb + a / b‚ü© := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm], }, rw this, have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { have : g.continuants_aux (n' + 2) = ‚ü®pb * pA + pa * ppA, pb * pB + pa * ppB‚ü© := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this] }, rw this, suffices : ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { obtain ‚ü®eq1, eq2, eq3, eq4‚ü© : pA' = pA ‚àß pB' = pB ‚àß ppA' = ppA ‚àß ppB' = ppB, { simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }, symmetry, simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero] }, field_simp, congr' 1; ring } }
from option.ne_none_iff_exists'.mp not_terminated_at_n
have b_ne_zero : b ‚â† 0
from nth_part_denom_ne_zero (part_denom_eq_s_b s_nth_eq)
cases n with n'
case nat.zero { suffices : (b * g.h + a) / b = g.h + a / b, by simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)], calc (b * g.h + a) / b = b * g.h / b + a / b : by ring ... = g.h + a / b : by rw (mul_div_cancel_left _ b_ne_zero) }
suffices : (b * g.h + a) / b = g.h + a / b
simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)]
simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)]
calc (b * g.h + a) / b = b * g.h / b + a / b : by ring ... = g.h + a / b : by rw (mul_div_cancel_left _ b_ne_zero)
case nat.succ { obtain ‚ü®‚ü®pa, pb‚ü©, s_n'th_eq‚ü© : ‚àÉ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq, let g' := squash_gcf g (n' + 1), set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq, set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq, let pA := pred_conts.a, let pB := pred_conts.b, let ppA := ppred_conts.a, let ppB := ppred_conts.b, set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq', set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq', let pA' := pred_conts'.a, let pB' := pred_conts'.b, let ppA' := ppred_conts'.a, let ppB' := ppred_conts'.b, have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB'), { have : g'.s.nth n' = some ‚ü®pa, pb + a / b‚ü© := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm], }, rw this, have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { have : g.continuants_aux (n' + 2) = ‚ü®pb * pA + pa * ppA, pb * pB + pa * ppB‚ü© := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this] }, rw this, suffices : ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { obtain ‚ü®eq1, eq2, eq3, eq4‚ü© : pA' = pA ‚àß pB' = pB ‚àß ppA' = ppA ‚àß ppB' = ppB, { simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }, symmetry, simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero] }, field_simp, congr' 1; ring }
obtain ‚ü®‚ü®pa, pb‚ü©, s_n'th_eq‚ü© : ‚àÉ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq
let g' := squash_gcf g (n' + 1)
set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq
set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq
let pA := pred_conts.a
let pB := pred_conts.b
let ppA := ppred_conts.a
let ppB := ppred_conts.b
set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq'
set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq'
let pA' := pred_conts'.a
let pB' := pred_conts'.b
let ppA' := ppred_conts'.a
let ppB' := ppred_conts'.b
have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB')
have : g'.s.nth n' = some ‚ü®pa, pb + a / b‚ü© := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq
{ have : g'.s.nth n' = some ‚ü®pa, pb + a / b‚ü© := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm], }
rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm]
rw this
have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB)
have : g.continuants_aux (n' + 2) = ‚ü®pb * pA + pa * ppA, pb * pB + pa * ppB‚ü© := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm
{ have : g.continuants_aux (n' + 2) = ‚ü®pb * pA + pa * ppA, pb * pB + pa * ppB‚ü© := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this] }
rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this]
rw this
suffices : ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB)
obtain ‚ü®eq1, eq2, eq3, eq4‚ü© : pA' = pA ‚àß pB' = pB ‚àß ppA' = ppA ‚àß ppB' = ppB
{ obtain ‚ü®eq1, eq2, eq3, eq4‚ü© : pA' = pA ‚àß pB' = pB ‚àß ppA' = ppA ‚àß ppB' = ppB, { simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }, symmetry, simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero] }
simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm]
{ simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }
symmetry
simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero]
field_simp
congr' 1; ring
congr' 1
ring
ring
intros
rw is_symm_op.flip_eq
intros
{ rcases hu with ‚ü®u, rfl‚ü©, apply units.mul_left_dvd, }
rcases hu with ‚ü®u, rfl‚ü©
apply units.mul_left_dvd
intros
simp [lcm_def]
intros
rw [sum_Ico_eq_sub _ hmn, ‚Üê geom_sum_def, ‚Üê geom_sum_def, sub_mul, geom_sum_mul_neg, geom_sum_mul_neg, sub_sub_sub_cancel_left]
intros
simp [h]
intros
rw [add_left_comm, sub_add_cancel, add_comm]
intros
by_cases h : a = 0
{ rw [h, inv_zero, mul_zero] }
rw [h, inv_zero, mul_zero]
{ rw [mul_assoc, mul_inv_cancel h, mul_one] }
rw [mul_assoc, mul_inv_cancel h, mul_one]
intros
simp [h]
intros
rw [‚Üê div_div_eq_div_mul, ‚Üê div_eq_mul_one_div]
intros
rw [‚Üêkernel.lift_Œπ _ _ hŒπ, ‚Üêcokernel.œÄ_desc _ _ hœÄ, category.assoc, kernel_comp_cokernel_assoc, zero_comp, comp_zero]
intros
simp [h]
intros
{ dunfold cycles_map, simp, }
dunfold cycles_map
simp
intros
{ ext, simp, }
ext
simp
intros
rw [derived_series_def, derived_series_of_ideal_succ, derived_series_of_ideal_zero, ‚Üê lie_submodule.mem_coe_submodule, lie_submodule.lie_ideal_oper_eq_linear_span] at h
apply submodule.span_induction h
rintros y ‚ü®‚ü®z, hz‚ü©, ‚ü®‚ü®w, hw‚ü©, rfl‚ü©‚ü©
{ rintros y ‚ü®‚ü®z, hz‚ü©, ‚ü®‚ü®w, hw‚ü©, rfl‚ü©‚ü©, apply lie_character_apply_lie, }
apply lie_character_apply_lie
{ exact œá.map_zero, }
exact œá.map_zero
intros y z hy hz
{ intros y z hy hz, rw [lie_hom.map_add, hy, hz, add_zero], }
rw [lie_hom.map_add, hy, hz, add_zero]
{ intros t y hy, rw [lie_hom.map_smul, hy, smul_zero], }
intros t y hy
rw [lie_hom.map_smul, hy, smul_zero]
intros
rw [‚Üê function.comp_app (lift R f) (of R) x, of_comp_lift]
intros
rw mem_skew_adjoint_submodule at *
have hfg : is_adjoint_pair B B (f * g) (g * f)
rw ‚Üêneg_mul_neg g f
{ rw ‚Üêneg_mul_neg g f, exact hf.mul hg, }
exact hf.mul hg
have hgf : is_adjoint_pair B B (g * f) (f * g)
rw ‚Üêneg_mul_neg f g
{ rw ‚Üêneg_mul_neg f g, exact hg.mul hf, }
exact hg.mul hf
change bilin_form.is_adjoint_pair B B (f * g - g * f) (-(f * g - g * f))
rw neg_sub
exact hfg.sub hgf
intros
rw [set_like.ext'_iff, lie_submodule.coe_to_submodule, h, submodule.map_coe]
{ rw [set_like.ext'_iff, lie_submodule.coe_to_submodule, h, submodule.map_coe], refl, }
refl
intros
{ ext, simp [lie_submodule.mem_map], }
ext
simp [lie_submodule.mem_map]
intros
refine le_antisymm _ (lie_subalgebra.le_normalizer _)
intros x hx
rw lie_subalgebra.mem_normalizer_iff at hx
rw mem_zero_root_subalgebra
rintros ‚ü®y, hy‚ü©
specialize hx y (le_zero_root_subalgebra R L H hy)
rw mem_zero_root_subalgebra at hx
obtain ‚ü®k, hk‚ü© := hx ‚ü®y, hy‚ü©
rw [‚Üê lie_skew, linear_map.map_neg, neg_eq_zero] at hk
use k + 1
rw [linear_map.iterate_succ, linear_map.coe_comp, function.comp_app, to_endomorphism_apply_apply, lie_subalgebra.coe_bracket_of_module, submodule.coe_mk, hk]
intros
rw [‚Üêneg_neg c, ‚Üêneg_neg b, neg_smul_neg, inv_neg, neg_smul _ a, neg_lt_neg_iff]
exact lt_smul_iff_of_pos (neg_pos_of_neg hc)
intros
rw [‚Üênot_lt, ‚Üênot_lt]
{ rw [‚Üênot_lt, ‚Üênot_lt], apply not_congr, apply lt_iff_lt_of_cmp_eq_cmp, rwa cmp_eq_cmp_symm }
apply not_congr
apply lt_iff_lt_of_cmp_eq_cmp
rwa cmp_eq_cmp_symm
intros
rwa [inv_le ((@zero_lt_one Œ± _ _).trans_le ha) zero_lt_one, inv_one]
intros
simpa [one_div] using inv_le_inv_of_neg ha hb
intros
cases le_total a b; simp *
cases le_total a b
simp *
simp *
intros
rw [‚Üê inv_lt_inv_iff, inv_inv]
intros
rw [div_eq_mul_inv b, mul_comm]
exact div_le_inv_mul_iff
intros
simp_rw [lt_iff_le_and_ne, and_comm, le_iff_exists_mul, ‚Üê exists_and_distrib_left, exists_prop]
apply exists_congr
intro c
rw [and.congr_left_iff, gt_iff_lt]
rintro rfl
split
rw [one_lt_iff_ne_one]
{ rw [one_lt_iff_ne_one], apply mt, rintro rfl, rw [mul_one] }
apply mt
rintro rfl
rw [mul_one]
rw [‚Üê (self_le_mul_right a c).lt_iff_ne]
{ rw [‚Üê (self_le_mul_right a c).lt_iff_ne], apply lt_mul_of_one_lt_right' }
apply lt_mul_of_one_lt_right'
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ico]
split
rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©
{ rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©, split, exact (mul_le_mul_left hr).mpr a_h_left_left, exact (mul_lt_mul_left hr).mpr a_h_left_right, }
split
exact (mul_le_mul_left hr).mpr a_h_left_left
exact (mul_lt_mul_left hr).mpr a_h_left_right
rintro ‚ü®a_left, a_right‚ü©
{ rintro ‚ü®a_left, a_right‚ü©, use x / r, refine ‚ü®‚ü®(le_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right‚ü©, _‚ü©, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ‚ü®‚ü®(le_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right‚ü©, _‚ü©
rw mul_div_cancel' _ (ne_of_gt hr)
intros
cases abs_choice a with h h; simp only [h, neg_dvd]
{ cases abs_choice a with h h; simp only [h, neg_dvd] }
cases abs_choice a with h h
simp only [h, neg_dvd]
simp only [h, neg_dvd]
intros
haveI := @linear_order.decidable_le Œ± _; exact Œª x y h, decidable.mul_le_mul (hf h) (hg h) (hg0 x) (hf0 y)
haveI := @linear_order.decidable_le Œ± _
exact Œª x y h, decidable.mul_le_mul (hf h) (hg h) (hg0 x) (hf0 y)
intros
simp [*, ‚Üê add_assoc] at *
intros
simp [*, ‚Üê add_assoc] at *
intros
{ rw mem_finset_prod, simp }
rw mem_finset_prod
simp
intros
{ intro b, dsimp [dihedral_act], ring }
intro b
dsimp [dihedral_act]
ring
intros
refine ‚ü®_, pow n‚ü©
rw [‚Üê nat.succ_pred_eq_of_pos n0, pow_succ', ‚Üê smul_eq_mul]
exact of_smul _
intros
{ ext x, simp [odd, eq_comm] }
ext x
simp [odd, eq_comm]
intros
rw add_comm; exact dvd_add_iff_left h
rw add_comm
exact dvd_add_iff_left h
intros
erw [not_forall]
exact ‚ü®0, (by simp)‚ü©
intros
rw [stalk_map, stalk_functor_map_germ_assoc, stalk_pushforward_germ]
intros
refine tsum_of_nnnorm_bounded _ (Œª l, p.nnnorm_change_origin_series_apply_le_tsum k l x)
have := p.change_origin_series_summable_aux‚ÇÇ h k
refine has_sum.sigma this.has_sum (Œª l, _)
exact ((nnreal.summable_sigma.1 this).1 l).has_sum
intros
rcases i with ‚ü®n, c‚ü©
refine ‚ü®‚ü®c.length, c.blocks_fun‚ü©, _, _‚ü©
simp only [comp_partial_sum_target_set, set.mem_set_of_eq] at hi
{ simp only [comp_partial_sum_target_set, set.mem_set_of_eq] at hi, simp only [mem_comp_partial_sum_source_iff, hi.left, hi.right, true_and, and_true], exact Œª a, c.one_le_blocks' _ }
simp only [mem_comp_partial_sum_source_iff, hi.left, hi.right, true_and, and_true]
exact Œª a, c.one_le_blocks' _
dsimp [comp_change_of_variables]
{ dsimp [comp_change_of_variables], rw composition.sigma_eq_iff_blocks_eq, simp only [composition.blocks_fun, composition.blocks, subtype.coe_eta, nth_le_map'], conv_lhs { rw ‚Üê of_fn_nth_le c.blocks } }
rw composition.sigma_eq_iff_blocks_eq
simp only [composition.blocks_fun, composition.blocks, subtype.coe_eta, nth_le_map']
conv_lhs { rw ‚Üê of_fn_nth_le c.blocks }
intros
by_cases h : c = 0
rw [h, ‚Üê is_o_one_iff ‚Ñù] at *
{ rw [h, ‚Üê is_o_one_iff ‚Ñù] at *, convert (huv.symm.is_o.trans hu).add hu, simp }
convert (huv.symm.is_o.trans hu).add hu
simp
rw ‚Üê is_equivalent_const_iff_tendsto h at hu ‚ä¢
{ rw ‚Üê is_equivalent_const_iff_tendsto h at hu ‚ä¢, exact huv.symm.trans hu }
exact huv.symm.trans hu
intros
split
intro h
{ intro h, use (Œª x, u x / v x), refine ‚ü®eventually.mono h.bound (Œª y hy, _), h.eventually_mul_div_cancel.symm‚ü©, simpa using div_le_of_nonneg_of_le_mul (norm_nonneg _) hc hy }
use (Œª x, u x / v x)
refine ‚ü®eventually.mono h.bound (Œª y hy, _), h.eventually_mul_div_cancel.symm‚ü©
simpa using div_le_of_nonneg_of_le_mul (norm_nonneg _) hc hy
rintros ‚ü®œÜ, hœÜ, h‚ü©
{ rintros ‚ü®œÜ, hœÜ, h‚ü©, exact is_O_with_of_eq_mul œÜ hœÜ h }
exact is_O_with_of_eq_mul œÜ hœÜ h
intros
unfold is_o
{ unfold is_o, exact forall_congr (Œª _, forall_congr $ Œª _, is_O_with_norm_right) }
exact forall_congr (Œª _, forall_congr $ Œª _, is_O_with_norm_right)
intros
rw is_O
intros
have := has_fderiv_within_at.iterate hf hx hs n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
have := (hc.has_fderiv_within_at.clm_apply hu.has_fderiv_within_at).has_deriv_within_at
rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw fderiv_within_congr hs hL hx }
unfold deriv_within
rw fderiv_within_congr hs hL hx
intros
{ convert hc.mul' hd, ext z, apply mul_comm }
convert hc.mul' hd
ext z
apply mul_comm
intros
rw ‚Üê has_fderiv_within_at_univ at h‚ÇÄ h‚ÇÅ
exact unique_diff_within_at_univ.eq h‚ÇÄ h‚ÇÅ
intros
rw differentiable_at.fderiv_within (differentiable_at_const _) hxs
exact fderiv_const_apply _
intros
apply implicit_to_local_homeomorph_of_complemented_apply_ker
intros
{ ext x, refl }
ext x
refl
intros
rw ‚Üê has_ftaylor_series_up_to_on_univ_iff at h
rw continuous_iff_continuous_on_univ
exact h.continuous_on
intros
let A : Œ† m : ‚Ñï, (E [√óm]‚ÜíL[ùïú] F) ‚Üí (G [√óm]‚ÜíL[ùïú] F) := Œª m h, h.comp_continuous_linear_map (Œª _, g)
have hA : ‚àÄ m, is_bounded_linear_map ùïú (A m) := Œª m, is_bounded_linear_map_continuous_multilinear_map_comp_linear g
split
assume x hx
{ assume x hx, simp only [(hf.zero_eq (g x) hx).symm, function.comp_app], change p (g x) 0 (Œª (i : fin 0), g 0) = p (g x) 0 0, rw continuous_linear_map.map_zero, refl }
simp only [(hf.zero_eq (g x) hx).symm, function.comp_app]
change p (g x) 0 (Œª (i : fin 0), g 0) = p (g x) 0 0
rw continuous_linear_map.map_zero
refl
assume m hm x hx
{ assume m hm x hx, convert ((hA m).has_fderiv_at).comp_has_fderiv_within_at x ((hf.fderiv_within m hm (g x) hx).comp x (g.has_fderiv_within_at) (subset.refl _)), ext y v, change p (g x) (nat.succ m) (g ‚àò (cons y v)) = p (g x) m.succ (cons (g y) (g ‚àò v)), rw comp_cons }
convert ((hA m).has_fderiv_at).comp_has_fderiv_within_at x ((hf.fderiv_within m hm (g x) hx).comp x (g.has_fderiv_within_at) (subset.refl _))
ext y v
change p (g x) (nat.succ m) (g ‚àò (cons y v)) = p (g x) m.succ (cons (g y) (g ‚àò v))
rw comp_cons
assume m hm
{ assume m hm, exact (hA m).continuous.comp_continuous_on ((hf.cont m hm).comp g.continuous.continuous_on (subset.refl _)) }
exact (hA m).continuous.comp_continuous_on ((hf.cont m hm).comp g.continuous.continuous_on (subset.refl _))
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_const
intros
{ rw complex.norm_sq_pos, exact z.ne_zero }
rw complex.norm_sq_pos
exact z.ne_zero
intros
split
rintro h x y hx hy z ‚ü®a, b, ha, hb, hab, rfl‚ü©
{ rintro h x y hx hy z ‚ü®a, b, ha, hb, hab, rfl‚ü©, exact h hx hy ha hb hab }
exact h hx hy ha hb hab
rintro h x y hx hy a b ha hb hab
{ rintro h x y hx hy a b ha hb hab, exact h hx hy ‚ü®a, b, ha, hb, hab, rfl‚ü© }
exact h hx hy ‚ü®a, b, ha, hb, hab, rfl‚ü©
intros
simp_rw [convex_iff_segment_subset, segment_eq_interval, ord_connected_iff_interval_subset]
exact forall_congr (Œª x, forall_swap)
intros
obtain ‚ü®l, a, rfl‚ü© := hAB.eq_inter_halfspace
exact hA.is_closed_le continuous_on_const l.continuous.continuous_on
intros
let f := Œª z, x + t ‚Ä¢ (z - x)
have : is_open_map f := (is_open_map_add_left _).comp ((is_open_map_smul (units.mk0 _ ht.1.ne')).comp (is_open_map_sub_right _))
apply mem_interior.2 ‚ü®f '' (interior s), _, this _ is_open_interior, mem_image_of_mem _ hy‚ü©
refine image_subset_iff.2 (Œª z hz, _)
exact hs.add_smul_sub_mem hx (interior_subset hz) ‚ü®ht.1.le, ht.2‚ü©
intros
rw [‚Üêinner_conj_sym, inner_smul_left]; simp only [conj_conj, inner_conj_sym, ring_hom.map_mul]
rw [‚Üêinner_conj_sym, inner_smul_left]
simp only [conj_conj, inner_conj_sym, ring_hom.map_mul]
intros
{ have h := @inner_self_nonpos ‚Ñù F _ _ x, simpa using h }
have h := @inner_self_nonpos ‚Ñù F _ _ x
simpa using h
intros
simpa using (hf.has_fderiv_within_at.inner hg.has_fderiv_within_at).has_deriv_within_at
intros
apply normed_group_hom.isometry_of_norm
intro v
apply le_antisymm (i.hom.2 v)
calc ‚à•v‚à• = ‚à•i.inv (i.hom v)‚à• : by rw [coe_hom_inv_id] ... ‚â§ ‚à•i.hom v‚à• : i.inv.2 _
intros
rw [dist_comm, dist_vadd_left]
intros
simp only [sub_eq_add_neg, dist_add_left, dist_neg_neg]
intros
rw [mem_ball', dist_eq_norm]
intros
simp only [nnreal.eq_iff.symm, nnreal.coe_zero, coe_nnnorm, norm_eq_zero]
intros
apply le_antisymm
exact continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Œªm, by simp)
{ exact continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Œªm, by simp) }
simpa using (continuous_multilinear_map.curry0 ùïú G x).le_op_norm 0
{ simpa using (continuous_multilinear_map.curry0 ùïú G x).le_op_norm 0 }
intros
{ ext x, exact normed_group_hom.completion_def f x }
ext x
exact normed_group_hom.completion_def f x
intros
simpa only [dist_zero_right, f.map_zero] using h.le_mul_dist x 0
intros
rintro b hb _ ‚ü®_, ‚ü®x, hx, rfl‚ü©, rfl‚ü©
exact ‚ü®b ‚Ä¢ x, hA _ hb ‚ü®_, hx, rfl‚ü©, smul_comm _ _ _‚ü©
intros
simp only [log_im, arg_le_pi]
intros
simpa using integral_sin_pow_odd_mul_cos_pow 0 2
intros
rw [‚Üê nnreal.coe_eq, coe_rpow, ‚Üê nnreal.coe_eq_zero]
exact real.rpow_eq_zero_iff_of_nonneg x.2
intros
simp [*, mul_rpow_eq_ite]
intros
convert ennreal.tendsto.const_mul (ennreal.continuous_rpow_const.tendsto 0) _
{ simp [hy] }
simp [hy]
{ exact or.inr hc }
exact or.inr hc
intros
rw cpow_def; split_ifs; simp [one_ne_zero, *] at *
rw cpow_def; split_ifs
rw cpow_def
split_ifs
simp [one_ne_zero, *] at *
simp [one_ne_zero, *] at *
simp [one_ne_zero, *] at *
intros
rw [one_div, ‚Üê inv_one_add_tan_sq (cos_arctan_pos x).ne', tan_arctan]
intros
simp [sub_eq_add_neg, sin_add]
{ convert continuous_sin.continuous_within_at, simp }
convert continuous_sin.continuous_within_at
simp
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]; exact (classical.some_spec exists_cos_eq_zero).1.2
exact (classical.some_spec exists_cos_eq_zero).1.2
intros
rw [‚Üê arcsin_sin' hy, strict_mono_on_arcsin.le_iff_le hx (sin_mem_Icc _), arcsin_sin' hy]
intros
refine ‚ü®Œª h, _, summable_geometric_of_norm_lt_1‚ü©
obtain ‚ü®k : ‚Ñï, hk : dist (Œæ ^ k) 0 < 1‚ü© := (h.tendsto_cofinite_zero.eventually (ball_mem_nhds _ zero_lt_one)).exists
simp only [normed_field.norm_pow, dist_zero_right] at hk
rw [‚Üê one_pow k] at hk
exact lt_of_pow_lt_pow _ zero_le_one hk
intros
ext
dsimp
erw [‚Üê adj.hom_equiv_counit, equiv.symm_apply_eq, adj.hom_equiv_unit]
simp
intros
simp [nat_trans.left_derived]
intros
{ cases h, refl, }
cases h
refl
intros
apply is_connected.of_induct
intros p hp hjp j
have: ‚àÄ (j‚ÇÅ j‚ÇÇ : J), zigzag j‚ÇÅ j‚ÇÇ ‚Üí (j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p)
introv k
{ introv k, induction k with _ _ rt_zag zag, { refl }, { rw k_ih, rcases zag with ‚ü®‚ü®_‚ü©‚ü© | ‚ü®‚ü®_‚ü©‚ü©, apply hjp zag, apply (hjp zag).symm } }
induction k with _ _ rt_zag zag
{ refl }
refl
rw k_ih
{ rw k_ih, rcases zag with ‚ü®‚ü®_‚ü©‚ü© | ‚ü®‚ü®_‚ü©‚ü©, apply hjp zag, apply (hjp zag).symm }
rcases zag with ‚ü®‚ü®_‚ü©‚ü© | ‚ü®‚ü®_‚ü©‚ü©
apply hjp zag
apply (hjp zag).symm
rwa this j (classical.arbitrary J) (h _ _)
intros
simp only [cancel_mono]
intros
dsimp [colimit_obj_iso_colimit_comp_evaluation]
rw ‚Üêiso.eq_comp_inv
simp
intros
ext
ext; rw [‚Üêassoc, colimit.Œπ_pre]; simp
ext; rw [‚Üêassoc, colimit.Œπ_pre]
rw [‚Üêassoc, colimit.Œπ_pre]
simp
intros
simp
intros
simp
intros
ext
ext; simp [add_comp]
simp [add_comp]
simp [add_comp]
intros
simp
intros
{ ext, simp [h‚ÇÇ], }
ext
simp [h‚ÇÇ]
intros
{ ext, simp [‚Üê G.map_comp] }
ext
simp [‚Üê G.map_comp]
intros
rw [left_unitor_naturality, ‚Üêcategory.assoc, iso.inv_hom_id, category.id_comp]
intros
tidy
intros
have := f.w; tidy
have := f.w
tidy
intros
{ ext, rw [comp_as_mul, inv_mul_self, id_as_one] }
ext
rw [comp_as_mul, inv_mul_self, id_as_one]
intros
rw presieve.compatible_iff_sieve_compatible
split
intro t
{ intro t, ext ‚ü®Y, Z, g, f, hf‚ü©, simpa [first_map, second_map] using t _ g hf }
ext ‚ü®Y, Z, g, f, hf‚ü©
simpa [first_map, second_map] using t _ g hf
intros t Y Z f g hf
{ intros t Y Z f g hf, rw types.limit_ext_iff at t, simpa [first_map, second_map] using t ‚ü®Y, Z, g, f, hf‚ü© }
rw types.limit_ext_iff at t
simpa [first_map, second_map] using t ‚ü®Y, Z, g, f, hf‚ü©
intros
have := f.w; tidy
{ have := f.w; tidy }
have := f.w
tidy
intros
rw [colex.lt_def, colex.lt_def]
apply exists_congr
intro k
simp only [mem_sdiff, not_and, not_not]
split
rintro ‚ü®z, kAB, kB, kA‚ü©
{ rintro ‚ü®z, kAB, kB, kA‚ü©, refine ‚ü®_, kA, kB‚ü©, { intros x hx, specialize z hx, tauto } }
refine ‚ü®_, kA, kB‚ü©
intros x hx
{ intros x hx, specialize z hx, tauto }
specialize z hx
tauto
rintro ‚ü®z, kA, kB‚ü©
{ rintro ‚ü®z, kA, kB‚ü©, refine ‚ü®_, Œª _, kB, kB, kA‚ü©, intros x hx, rw z hx }
refine ‚ü®_, Œª _, kB, kB, kA‚ü©
intros x hx
rw z hx
intros
symmetry
rw ‚Üê mem_range_embedding_iff'
apply set.mem_range_self
intros
split
assume hj
{ assume hj, rcases (c.boundaries.order_iso_of_fin rfl).surjective ‚ü®j, hj‚ü© with ‚ü®i, hi‚ü©, rw [subtype.ext_iff, subtype.coe_mk] at hi, refine ‚ü®i.1, i.2, _‚ü©, rw [‚Üê hi, c.blocks_partial_sum i.2], refl }
rcases (c.boundaries.order_iso_of_fin rfl).surjective ‚ü®j, hj‚ü© with ‚ü®i, hi‚ü©
rw [subtype.ext_iff, subtype.coe_mk] at hi
refine ‚ü®i.1, i.2, _‚ü©
rw [‚Üê hi, c.blocks_partial_sum i.2]
refl
rintros ‚ü®i, hi, H‚ü©
{ rintros ‚ü®i, hi, H‚ü©, convert (c.boundaries.order_iso_of_fin rfl ‚ü®i, hi‚ü©).2, have : c.boundary ‚ü®i, hi‚ü© = j, by rwa [fin.ext_iff, ‚Üê c.blocks_partial_sum hi], exact this.symm }
convert (c.boundaries.order_iso_of_fin rfl ‚ü®i, hi‚ü©).2
have : c.boundary ‚ü®i, hi‚ü© = j
rwa [fin.ext_iff, ‚Üê c.blocks_partial_sum hi]
rwa [fin.ext_iff, ‚Üê c.blocks_partial_sum hi]
exact this.symm
intros
haveI : nonempty Œπ := fintype.card_pos_iff.mp (hn.symm ‚ñ∏ nat.succ_pos _)
haveI := classical.dec_eq Œπ
let x := classical.arbitrary Œπ
have tx_ne : (t x).nonempty
rw ‚Üêfinset.card_pos
{ rw ‚Üêfinset.card_pos, apply nat.lt_of_lt_of_le nat.one_pos, convert ht {x}, rw finset.singleton_bUnion, }
apply nat.lt_of_lt_of_le nat.one_pos
convert ht {x}
rw finset.singleton_bUnion
rcases classical.indefinite_description _ tx_ne with ‚ü®y, hy‚ü©
let Œπ' := {x' : Œπ | x' ‚â† x}
let t' : Œπ' ‚Üí finset Œ± := Œª x', (t x').erase y
have card_Œπ' : fintype.card Œπ' = n
convert congr_arg (Œª m, m - 1) hn
{ convert congr_arg (Œª m, m - 1) hn, convert set.card_ne_eq _, }
convert set.card_ne_eq _
rcases ih t' card_Œπ'.le (hall_cond_of_erase y ha) with ‚ü®f', hfinj, hfr‚ü©
refine ‚ü®Œª z, if h : z = x then y else f' ‚ü®z, h‚ü©, _, _‚ü©
rintro z‚ÇÅ z‚ÇÇ
{ rintro z‚ÇÅ z‚ÇÇ, have key : ‚àÄ {x}, y ‚â† f' x, { intros x h, specialize hfr x, rw ‚Üêh at hfr, simpa using hfr, }, by_cases h‚ÇÅ : z‚ÇÅ = x; by_cases h‚ÇÇ : z‚ÇÇ = x; simp [h‚ÇÅ, h‚ÇÇ, hfinj.eq_iff, key, key.symm], }
have key : ‚àÄ {x}, y ‚â† f' x
intros x h
{ intros x h, specialize hfr x, rw ‚Üêh at hfr, simpa using hfr, }
specialize hfr x
rw ‚Üêh at hfr
simpa using hfr
by_cases h‚ÇÅ : z‚ÇÅ = x; by_cases h‚ÇÇ : z‚ÇÇ = x; simp [h‚ÇÅ, h‚ÇÇ, hfinj.eq_iff, key, key.symm]
by_cases h‚ÇÅ : z‚ÇÅ = x; by_cases h‚ÇÇ : z‚ÇÇ = x
by_cases h‚ÇÅ : z‚ÇÅ = x
by_cases h‚ÇÇ : z‚ÇÇ = x
simp [h‚ÇÅ, h‚ÇÇ, hfinj.eq_iff, key, key.symm]
simp [h‚ÇÅ, h‚ÇÇ, hfinj.eq_iff, key, key.symm]
by_cases h‚ÇÇ : z‚ÇÇ = x
simp [h‚ÇÅ, h‚ÇÇ, hfinj.eq_iff, key, key.symm]
simp [h‚ÇÅ, h‚ÇÇ, hfinj.eq_iff, key, key.symm]
intro z
{ intro z, split_ifs with hz, { rwa hz }, { specialize hfr ‚ü®z, hz‚ü©, rw mem_erase at hfr, exact hfr.2, }, }
split_ifs with hz
{ rwa hz }
rwa hz
specialize hfr ‚ü®z, hz‚ü©
{ specialize hfr ‚ü®z, hz‚ü©, rw mem_erase at hfr, exact hfr.2, }
rw mem_erase at hfr
exact hfr.2
intros
simp [neighbor_finset_eq_filter, dot_product, sum_filter]
intros
have : traverse pure x = pure (traverse id.mk x) := (naturality (pure_transformation F) id.mk x).symm
have : traverse pure x = pure (traverse id.mk x) := (naturality (pure_transformation F) id.mk x).symm; rwa id_traverse at this
rwa id_traverse at this
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, ‚Üêorelse_eq_orelse, parser.orelse]
by_cases h : np = n
{ by_cases h : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, ne_of_gt hn, ‚Üêorelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|H|H, { simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt (hn.trans H), ‚Üêorelse_eq_orelse, parser.orelse] } } }, { simp [hp, h, ‚Üêorelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, ne_of_gt hn, ‚Üêorelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|H|H, { simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt (hn.trans H), ‚Üêorelse_eq_orelse, parser.orelse] } } }
{ simp [hp, h, hn, hq, ne_of_gt hn, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, h, hn, hq, ne_of_gt hn, ‚Üêorelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|H|H
{ rcases lt_trichotomy nq n with H|H|H, { simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt (hn.trans H), ‚Üêorelse_eq_orelse, parser.orelse] } }
simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ‚Üêorelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hq, h, H, ne_of_gt (hn.trans H), ‚Üêorelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, H, ne_of_gt (hn.trans H), ‚Üêorelse_eq_orelse, parser.orelse] }
{ simp [hp, h, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, h, ‚Üêorelse_eq_orelse, parser.orelse]
intros
simp [ch, eps_eq_done, sat_eq_done, and.comm, @eq_comm _ n']
intros
simp [sep_by1, seq_eq_done]
intros
rw [pow_bit1', I_mul_I]
intros
simp [exp_near]
{ simp [exp_near], convert exp_bound h _ using 1, field_simp [mul_comm], linarith }
convert exp_bound h _ using 1
field_simp [mul_comm]
linarith
intros
rw [‚Üê mul_right_inj' (@two_ne_zero' ‚ÑÇ _ _ _), two_sinh, ‚Üê mul_assoc, two_sin, mul_assoc, I_mul_I, mul_neg_one, neg_sub, neg_mul_eq_neg_mul]
intros
simp [bit0, ext_iff]
intros
rw [‚Üê of_real_nat_cast, of_real_im]
intros
simp [is_R_or_C.norm_sq]
intros
{ ext, simp only [map_range_apply] }
ext
simp only [map_range_apply]
intros
{ ext ‚ü®a, b‚ü© : 1, simp }
ext ‚ü®a, b‚ü© : 1
simp
intros
rw [apply_eq_iff_eq_symm_apply, symm_swap]
intros
simp [perm_congr_def]
intros
ext x
by_cases h : p x
have : p (ep ‚ü®x, h‚ü©) := subtype.property _
{ have : p (ep ‚ü®x, h‚ü©) := subtype.property _, simp [perm.subtype_congr.apply, h, this] }
simp [perm.subtype_congr.apply, h, this]
have : ¬¨ p (en ‚ü®x, h‚ü©) := subtype.property (en _)
{ have : ¬¨ p (en ‚ü®x, h‚ü©) := subtype.property (en _), simp [perm.subtype_congr.apply, h, symm_apply_eq, this] }
simp [perm.subtype_congr.apply, h, symm_apply_eq, this]
intros
simp
simp; cases decode Œ± n.unpair.1; simp; cases decode Œ≤ n.unpair.2; refl
simp; cases decode Œ± n.unpair.1; simp; cases decode Œ≤ n.unpair.2
simp; cases decode Œ± n.unpair.1; simp
simp; cases decode Œ± n.unpair.1
cases decode Œ± n.unpair.1
simp
simp
cases decode Œ≤ n.unpair.2
refl
refl
intros
rw [‚Üê fin.succ_above_below _ _ h, fin_succ_equiv'_succ_above]
intros
apply local_equiv.ext (Œªx, _) (Œªx, _) h.1
apply h.2
{ apply h.2, rw s, exact mem_univ _ }
rw s
exact mem_univ _
apply h.symm'.2
{ apply h.symm'.2, rw [symm_source, t], exact mem_univ _ }
rw [symm_source, t]
exact mem_univ _
intros
refine ‚ü®_, exists_succ_above_eq‚ü©
rintro ‚ü®y, rfl‚ü©
exact succ_above_ne _ _
intros
ext j
by_cases h : j.val < n
simp only [snoc, h, dif_pos]
{ simp only [snoc, h, dif_pos], by_cases h' : j = cast_succ i, { have C1 : Œ± i.cast_succ = Œ± j, by rw h', have E1 : update (snoc p x) i.cast_succ y j = _root_.cast C1 y, { have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y, by simp, convert this, { exact h'.symm }, { exact heq_of_cast_eq (congr_arg Œ± (eq.symm h')) rfl } }, have C2 : Œ± i.cast_succ = Œ± (cast_succ (cast_lt j h)), by rw [cast_succ_cast_lt, h'], have E2 : update p i y (cast_lt j h) = _root_.cast C2 y, { have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y, by simp, convert this, { simp [h, h'] }, { exact heq_of_cast_eq C2 rfl } }, rw [E1, E2], exact eq_rec_compose _ _ _ }, { have : ¬¨(cast_lt j h = i), by { assume E, apply h', rw [‚Üê E, cast_succ_cast_lt] }, simp [h', this, snoc, h] } }
by_cases h' : j = cast_succ i
have C1 : Œ± i.cast_succ = Œ± j
{ have C1 : Œ± i.cast_succ = Œ± j, by rw h', have E1 : update (snoc p x) i.cast_succ y j = _root_.cast C1 y, { have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y, by simp, convert this, { exact h'.symm }, { exact heq_of_cast_eq (congr_arg Œ± (eq.symm h')) rfl } }, have C2 : Œ± i.cast_succ = Œ± (cast_succ (cast_lt j h)), by rw [cast_succ_cast_lt, h'], have E2 : update p i y (cast_lt j h) = _root_.cast C2 y, { have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y, by simp, convert this, { simp [h, h'] }, { exact heq_of_cast_eq C2 rfl } }, rw [E1, E2], exact eq_rec_compose _ _ _ }
rw h'
rw h'
have E1 : update (snoc p x) i.cast_succ y j = _root_.cast C1 y
have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y
{ have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y, by simp, convert this, { exact h'.symm }, { exact heq_of_cast_eq (congr_arg Œ± (eq.symm h')) rfl } }
simp
simp
convert this
exact h'.symm
{ exact h'.symm }
exact heq_of_cast_eq (congr_arg Œ± (eq.symm h')) rfl
{ exact heq_of_cast_eq (congr_arg Œ± (eq.symm h')) rfl }
have C2 : Œ± i.cast_succ = Œ± (cast_succ (cast_lt j h))
rw [cast_succ_cast_lt, h']
rw [cast_succ_cast_lt, h']
have E2 : update p i y (cast_lt j h) = _root_.cast C2 y
have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y
{ have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y, by simp, convert this, { simp [h, h'] }, { exact heq_of_cast_eq C2 rfl } }
simp
simp
convert this
simp [h, h']
{ simp [h, h'] }
exact heq_of_cast_eq C2 rfl
{ exact heq_of_cast_eq C2 rfl }
rw [E1, E2]
exact eq_rec_compose _ _ _
have : ¬¨(cast_lt j h = i)
{ have : ¬¨(cast_lt j h = i), by { assume E, apply h', rw [‚Üê E, cast_succ_cast_lt] }, simp [h', this, snoc, h] }
assume E
assume E
{ assume E, apply h', rw [‚Üê E, cast_succ_cast_lt] }
{ assume E, apply h', rw [‚Üê E, cast_succ_cast_lt] }
apply h'
apply h'
rw [‚Üê E, cast_succ_cast_lt]
rw [‚Üê E, cast_succ_cast_lt]
simp [h', this, snoc, h]
rw eq_last_of_not_lt h
{ rw eq_last_of_not_lt h, simp [ne.symm (ne_of_lt (cast_succ_lt_last i))] }
simp [ne.symm (ne_of_lt (cast_succ_lt_last i))]
intros
{ subst h, simp }
subst h
simp
intros
induction l with hd tl hl
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
simp only [eq_singleton_iff_unique_mem, exists_unique]
intros
rw [‚Üê union_eq_right_iff_subset, eq_comm]
intros
simp [@supr_comm _ Œ±, supr_and]
intros
induction s using quotient.induction_on
simp
intros
simp only [‚Üê coe_subset, coe_pimage, coe_inter, pfun.image_inter]
intros
substs k l
exact (s.order_emb_of_fin rfl).eq_iff_eq.trans (fin.ext_iff _ _)
intros
rw [‚Üê not_nonempty_iff, ‚Üê univ_nonempty_iff, not_nonempty_iff_eq_empty]
intros
rw [eq_comm, eq_univ_iff_forall]
simp only [mem_union, mem_map, exists_prop, mem_univ, true_and]
rintro (x|y)
exacts [or.inl ‚ü®x, rfl‚ü©, or.inr ‚ü®y, rfl‚ü©]
intros
simp only [‚Üê fintype.prod_sum_elim, sum.elim_comp_inl_inr]
intros
simp [mul, has_scalar.smul, holor_index.take, holor_index.drop]
intros
split
split; intro h
intro h
cases int.nat_abs_eq a with h‚ÇÅ h‚ÇÅ; cases int.nat_abs_eq b with h‚ÇÇ h‚ÇÇ; rw [h‚ÇÅ, h‚ÇÇ]; simp [h]
cases int.nat_abs_eq a with h‚ÇÅ h‚ÇÅ; cases int.nat_abs_eq b with h‚ÇÇ h‚ÇÇ; rw [h‚ÇÅ, h‚ÇÇ]
cases int.nat_abs_eq a with h‚ÇÅ h‚ÇÅ; cases int.nat_abs_eq b with h‚ÇÇ h‚ÇÇ
cases int.nat_abs_eq a with h‚ÇÅ h‚ÇÅ
{ cases int.nat_abs_eq a with h‚ÇÅ h‚ÇÅ; cases int.nat_abs_eq b with h‚ÇÇ h‚ÇÇ; rw [h‚ÇÅ, h‚ÇÇ]; simp [h], }
cases int.nat_abs_eq b with h‚ÇÇ h‚ÇÇ
rw [h‚ÇÅ, h‚ÇÇ]
simp [h]
rw [h‚ÇÅ, h‚ÇÇ]
simp [h]
cases int.nat_abs_eq b with h‚ÇÇ h‚ÇÇ
rw [h‚ÇÅ, h‚ÇÇ]
simp [h]
rw [h‚ÇÅ, h‚ÇÇ]
simp [h]
intro h
cases h; rw h
{ cases h; rw h, rw int.nat_abs_neg, }
cases h
rw h
rw h
rw int.nat_abs_neg
intros
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
intros
rw [‚Üênat_abs_dvd, ‚Üêdvd_nat_abs, coe_nat_dvd] at w
rw ‚Üênat_abs_eq_zero
exact eq_zero_of_dvd_of_lt w h
intros
rw [int.gcd, int.lcm, nat.gcd_mul_lcm, nat_abs_mul]
intros
rw int.lcm at h ‚ä¢; rwa int.nat_abs_neg
rw int.lcm at h ‚ä¢
rwa int.nat_abs_neg
intros
convert dif_pos _ using 1
convert coe_greatest_of_bdd_eq _ (classical.some_spec (‚ü®b, Hb‚ü© : bdd_above s)) _
{ convert coe_greatest_of_bdd_eq _ (classical.some_spec (‚ü®b, Hb‚ü© : bdd_above s)) _ }
{ exact ‚ü®Hinh, b, Hb‚ü©, }
exact ‚ü®Hinh, b, Hb‚ü©
intros
rcases even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©
rcases even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©; use k
use k
simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm
{ simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm }
use k
simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self]
{ simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self] }
intros
{ simp at hi, rw nth_le_take L _ hi.1 }
simp at hi
rw nth_le_take L _ hi.1
intros
split
intro h
{ intro h, refine ‚ü®Œª x y, _‚ü©, suffices : [x] = [y], { simpa using this }, apply h, refl }
refine ‚ü®Œª x y, _‚ü©
suffices : [x] = [y]
simpa using this
{ simpa using this }
apply h
refl
intros hŒ± l1 l2 hl
{ intros hŒ± l1 l2 hl, induction l1 generalizing l2; cases l2, { refl }, { cases hl }, { cases hl }, congr, exactI subsingleton.elim _ _, apply l1_ih, simpa using hl }
induction l1 generalizing l2
induction l1 generalizing l2; cases l2
cases l2
{ refl }
refl
cases hl
{ cases hl }
cases l2
cases hl
{ cases hl }
congr
apply l1_ih
simpa using hl
intros
simp only [all_iff_forall, bool.of_to_bool_iff]
intros
rw [‚Üê filter_map_eq_filter, filter_map_filter_map]
rw [‚Üê filter_map_eq_filter, filter_map_filter_map]; refl
refl
intros
induction l with x l ih; [refl, by_cases (p x)]; [simp only [filter_cons_of_pos _ h, countp, ih, if_pos h], simp only [countp_cons_of_neg _ _ h, ih, filter_cons_of_neg _ h]]; refl
induction l with x l ih; [refl, by_cases (p x)]; [simp only [filter_cons_of_pos _ h, countp, ih, if_pos h], simp only [countp_cons_of_neg _ _ h, ih, filter_cons_of_neg _ h]]
induction l with x l ih; [refl, by_cases (p x)]
induction l with x l ih
refl
by_cases (p x)
simp only [filter_cons_of_pos _ h, countp, ih, if_pos h]
refl
simp only [countp_cons_of_neg _ _ h, ih, filter_cons_of_neg _ h]
intros
induction ts with a ts ih
refl
{refl}
simp [permutations'_aux, permutations_aux2_snd_cons, ih]
simp only [‚Üê permutations_aux2_append] {single_pass := tt}
simp [map_permutations_aux2]
intros
induction l‚ÇÅ with x l‚ÇÅ IH; [refl, simp only [map, sigma_cons, length_append, length_map, IH, sum_cons]]
induction l‚ÇÅ with x l‚ÇÅ IH
refl
simp only [map, sigma_cons, length_append, length_map, IH, sum_cons]
intros
cases bs; refl
cases bs
refl
refl
intros
induction l; [refl, simp only [*, map, reverse_cons, map_append]]
induction l
refl
simp only [*, map, reverse_cons, map_append]
intros
induction l with b l ih
cases h
{cases h}
rcases h with rfl | h
{ exact ‚ü®[], l, rfl‚ü© }
exact ‚ü®[], l, rfl‚ü©
rcases ih h with ‚ü®s, t, rfl‚ü©
{ rcases ih h with ‚ü®s, t, rfl‚ü©, exact ‚ü®b::s, t, rfl‚ü© }
exact ‚ü®b::s, t, rfl‚ü©
intros
cases l
{ simpa [hy, hz] using h }
simpa [hy, hz] using h
{ rw [prev, dif_neg hy, if_neg hz] }
rw [prev, dif_neg hy, if_neg hz]
intros
apply mmap_with_index'_aux_eq_mmap_with_index_aux
intros
classical; exact decidable.list.lex.ne_iff H
classical
exact decidable.list.lex.ne_iff H
intros
rw nodup_erase_eq_filter b d; simp only [mem_filter, and_comm]
rw nodup_erase_eq_filter b d
simp only [mem_filter, and_comm]
intros
simp only [pairwise_cons, mem_singleton, forall_eq, forall_prop_of_false (not_mem_nil _), forall_true_iff, pairwise.nil, and_true]
intros
induction l with a l IH; simp; exact (h a).append IH
induction l with a l IH; simp
induction l with a l IH
simp
simp
exact (h a).append IH
intros
simp only [fin_range, nth_le_range, nth_le_pmap, fin.mk_eq_subtype_mk]
intros
have : (l.rotate k).cyclic_permutations.length = length (l.cyclic_permutations.rotate k)
cases l
{ cases l, { simp }, { rw length_cyclic_permutations_of_ne_nil; simp } }
{ simp }
simp
rw length_cyclic_permutations_of_ne_nil; simp
rw length_cyclic_permutations_of_ne_nil
{ rw length_cyclic_permutations_of_ne_nil; simp }
simp
simp
refine ext_le this (Œª n hn hn', _)
rw [nth_le_cyclic_permutations, nth_le_rotate, nth_le_cyclic_permutations, rotate_rotate, ‚Üêrotate_mod, add_comm]
cases l; simp
cases l
simp
simp
intros
induction l with _ _ ih; [refl, { simp [not_or_distrib] at h, simp [h.1, ih h.2] }]
induction l with _ _ ih
refl
simp [not_or_distrib] at h
simp [h.1, ih h.2]
intros
rw [‚Üê zip_swap, unzip_swap]; exact unzip_zip_left h
rw [‚Üê zip_swap, unzip_swap]
exact unzip_zip_left h
intros
ext i
{ ext i, simp only [mul_vec, dot_product, finset.smul_sum, pi.smul_apply, mul_smul_comm] }
simp only [mul_vec, dot_product, finset.smul_sum, pi.smul_apply, mul_smul_comm]
intros
{ ext, simp [diagonal] }
ext
simp [diagonal]
intros
{ ext i j, apply zero_dot_product }
ext i j
apply zero_dot_product
intros
simp [hi]
intros
simp [sub_eq_add_neg]
intros
{ rw [‚Üê fin.succ_zero_eq_one, cons_val_succ], refl }
rw [‚Üê fin.succ_zero_eq_one, cons_val_succ]
refl
intros
simp [h]
intros
rw [‚Üê sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_cons]
rw [‚Üê sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_cons]; simp
simp
intros
apply mv_polynomial.induction_on p; simp [eval‚ÇÇ_add, eval‚ÇÇ_mul] {contextual := tt}
apply mv_polynomial.induction_on p
simp [eval‚ÇÇ_add, eval‚ÇÇ_mul] {contextual := tt}
simp [eval‚ÇÇ_add, eval‚ÇÇ_mul] {contextual := tt}
simp [eval‚ÇÇ_add, eval‚ÇÇ_mul] {contextual := tt}
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
rw [vars, degrees_C, multiset.to_finset_zero]
intros
split
rintro rfl
{ rintro rfl, exact ‚ü®nat.find_spec h, Œª _, nat.find_min h‚ü© }
exact ‚ü®nat.find_spec h, Œª _, nat.find_min h‚ü©
rintro ‚ü®hm, hlt‚ü©
{ rintro ‚ü®hm, hlt‚ü©, exact le_antisymm (nat.find_min' h hm) (not_lt.1 $ imp_not_comm.1 (hlt _) $ nat.find_spec h) }
exact le_antisymm (nat.find_min' h hm) (not_lt.1 $ imp_not_comm.1 (hlt _) $ nat.find_spec h)
intros
simp [test_bit]
intros
cases b
cases n; simp
{ cases n; simp }
cases n
simp
simp
cases b
{ cases b, { simp }, { apply nat.strong_induction_on n, clear n, intros n IH, cases n, { simp }, { rw [digits_add_two_add_one, digits_add_two_add_one], by_cases hdvd : (b.succ.succ) ‚à£ (n.succ+1), { rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }, { rw nat.succ_div_of_not_dvd hdvd, refl } } } }
{ simp }
simp
apply nat.strong_induction_on n
{ apply nat.strong_induction_on n, clear n, intros n IH, cases n, { simp }, { rw [digits_add_two_add_one, digits_add_two_add_one], by_cases hdvd : (b.succ.succ) ‚à£ (n.succ+1), { rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }, { rw nat.succ_div_of_not_dvd hdvd, refl } } }
clear n
intros n IH
cases n
{ simp }
simp
rw [digits_add_two_add_one, digits_add_two_add_one]
{ rw [digits_add_two_add_one, digits_add_two_add_one], by_cases hdvd : (b.succ.succ) ‚à£ (n.succ+1), { rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }, { rw nat.succ_div_of_not_dvd hdvd, refl } }
by_cases hdvd : (b.succ.succ) ‚à£ (n.succ+1)
rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff]
{ rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }
apply IH
exact nat.div_lt_self (by linarith) (by linarith)
rw nat.succ_div_of_not_dvd hdvd
{ rw nat.succ_div_of_not_dvd hdvd, refl }
refl
intros
rw [add_comm a, add_comm a, enat.add_right_cancel_iff ha]
intros
obtain ‚ü®n, rfl‚ü© := exists_eq_succ_of_ne_zero hn.ne'
rw [pow_succ, nat.coprime_mul_iff_left]
exact ‚ü®and.left, Œª hab, ‚ü®hab, hab.pow_left _‚ü©‚ü©
intros
rw [clog_of_two_le (hn.trans h) hn, clog_of_right_le_one]
have n_pos : 0 < n := zero_lt_two.trans_le hn
rw [‚Üêlt_succ_iff, nat.div_lt_iff_lt_mul _ _ (n_pos.trans_le h), ‚Üêsucc_le_iff, ‚Üêpred_eq_sub_one, succ_pred_eq_of_pos (add_pos n_pos (n_pos.trans_le h)), succ_mul, one_mul]
exact add_le_add_right h _
intros
rwa [add_comm, nat.add_div_of_dvd_right, add_comm]
intros
rw [even_iff, mod_two_ne_zero]
intros
refine ‚ü®_, Œª h, by rw [h.1, h.2, pow_one]‚ü©
rintro rfl
rw [hp.eq_one_of_pow, eq_self_iff_true, and_true, pow_one]
intros
rw [psub']; split_ifs; [exact (psub_eq_sub h).symm, exact (psub_eq_none.2 (not_le.1 h)).symm]
rw [psub']; split_ifs
rw [psub']
split_ifs
exact (psub_eq_sub h).symm
exact (psub_eq_none.2 (not_le.1 h)).symm
intros
cases x; simp
{ cases x; simp }
cases x
simp
simp
intros
rw h.1; apply nat.le_add_left
rw h.1
apply nat.le_add_left
intros
rw [‚Üê dual_dual (balance_l _ _ _), dual_balance_l, dual_dual, dual_dual]
intros
cases o; refl
cases o
refl
refl
intros
generalize_hyp ef : @split_fun n _ (append1 Œ± (M P Œ±)) f' f‚ÇÅ' = ff at e‚ÇÅ
cases e‚ÇÅ' : pfunctor.M.dest a‚ÇÅ with a‚ÇÅ' g‚ÇÅ'
rw M.dest_eq_dest' _ e‚ÇÅ' at e‚ÇÅ
cases e‚ÇÅ
exact ‚ü®_, e‚ÇÅ', split_fun_inj ef‚ü©
intros
cases x
cases x; refl
{ cases x; refl }
refl
intros
split
split; intro h
intro h
rcases h with ‚ü®_, rfl‚ü©
apply dvd_mul_right
intro h
rcases h with ‚ü®a, h‚ü©
cases a
contrapose h
{ contrapose h, apply ne_zero, }
apply ne_zero
use a.succ
apply nat.succ_pos
rw [‚Üê coe_inj, h, mul_coe, mk_coe]
intros
let n := u.prod
let m := v.prod
change (u ‚äì v).prod = pnat.gcd n m
have : u = n.factor_multiset := u.factor_multiset_prod.symm
rw [this]
have : v = m.factor_multiset := v.factor_multiset_prod.symm
rw [this]
rw [‚Üê pnat.factor_multiset_gcd n m, pnat.prod_factor_multiset]
intros
simp [aeval_def]
intros
convert support_monomial n 1 H
exact X_pow_eq_monomial n
intros
split_ifs
rw [‚Üê@nat.sub_add_cancel d n h, coeff_mul_X_pow, nat.add_sub_cancel]
{ rw [‚Üê@nat.sub_add_cancel d n h, coeff_mul_X_pow, nat.add_sub_cancel] }
refine (coeff_mul _ _ _).trans (finset.sum_eq_zero (Œª x hx, _))
{ refine (coeff_mul _ _ _).trans (finset.sum_eq_zero (Œª x hx, _)), rw [coeff_X_pow, if_neg, mul_zero], exact ne_of_lt (lt_of_le_of_lt (nat.le_of_add_le_right (le_of_eq (finset.nat.mem_antidiagonal.mp hx))) (not_le.mp h)) }
rw [coeff_X_pow, if_neg, mul_zero]
exact ne_of_lt (lt_of_le_of_lt (nat.le_of_add_le_right (le_of_eq (finset.nat.mem_antidiagonal.mp hx))) (not_le.mp h))
intros
rw [degree, support_monomial _ _ ha]; refl
rw [degree, support_monomial _ _ ha]
refl
intros
apply (degree_le_iff_coeff_zero _ _).2 (Œª m hm, _)
rw degree_lt_iff_coeff_zero at hm
simp [hm m (le_refl _)]
intros
simp_rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero, with_bot.coe_lt_coe]
intros
simp [bit1]
intros
rw [C_mul_X_pow_eq_monomial, erase_lead_monomial]
intros
convert eval‚ÇÇ_at_apply f 1
simp
intros
apply polynomial.induction_on' p
{ intros p q hp hq, simp [hp, hq], }
intros p q hp hq
simp [hp, hq]
{ intros n r, simp, }
intros n r
simp
intros
refine bInter_subset_of_mem _
rintros _ ‚ü®i, rfl‚ü©
exact set_like.mem_coe.mpr (cf i)
intros
simp only [iterated_deriv, derivative_X, function.iterate_one]
intros
by_cases hp : p = 0
{ rw [hp, mirror_zero] }
rw [hp, mirror_zero]
by_cases hR : nontrivial R
haveI := hR
{ haveI := hR, rw [mirror, nat_degree_mul', reverse_nat_degree, nat_degree_X_pow, nat.sub_add_cancel p.nat_trailing_degree_le_nat_degree], rwa [leading_coeff_X_pow, mul_one, reverse_leading_coeff, ne, trailing_coeff_eq_zero] }
rw [mirror, nat_degree_mul', reverse_nat_degree, nat_degree_X_pow, nat.sub_add_cancel p.nat_trailing_degree_le_nat_degree]
rwa [leading_coeff_X_pow, mul_one, reverse_leading_coeff, ne, trailing_coeff_eq_zero]
haveI := not_nontrivial_iff_subsingleton.mp hR
{ haveI := not_nontrivial_iff_subsingleton.mp hR, exact congr_arg nat_degree (subsingleton.elim p.mirror p) }
exact congr_arg nat_degree (subsingleton.elim p.mirror p)
intros
rw [trailing_coeff, reverse_nat_trailing_degree, coeff_zero_reverse]
intros
rw [‚Üê sub_eq_zero]
apply eq_zero_of_infinite_is_root
simpa only [is_root, eval_sub, sub_eq_zero]
intros
rcases h1 with ‚ü®q, rfl‚ü©
rw mul_ne_zero_iff at h2
rw [nat_degree_mul h2.1 h2.2]
exact nat.le_add_right _ _
intros
rw [‚Üê int.cast_coe_nat, coe_int_eq_mk]
intros
rw ‚Üê neg_one_mul; exact mul_lim_zero_right _ hf
rw ‚Üê neg_one_mul
exact mul_lim_zero_right _ hf
intros
rw [div_eq_mul_inv, inv_top, mul_zero]
intros
split_ifs
simp [h]
{ simp [h] }
exact with_top.mul_top h
{ exact with_top.mul_top h }
rw [coe_inv (ne_of_gt _root_.zero_lt_two), coe_two]
rw [golden_ratio, ‚Üêsub_eq_zero]
ring_exp
rw real.sq_sqrt; norm_num
rw real.sq_sqrt
norm_num
norm_num
rw ‚Üêinv_epsilon_eq_omega
rw ‚Üêinv_epsilon_eq_omega; exact inv_pos.2 epsilon_pos
exact inv_pos.2 epsilon_pos
intros
rw [‚Üê mul_lt_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h, mul_comm]
intros
refine le_trans _ hz
rw sqrt_two_add_series_succ
apply sqrt_two_add_series_monotone_left
have hb' : 0 < (b:‚Ñù) := nat.cast_pos.2 hb
have hd' : 0 < (d:‚Ñù) := nat.cast_pos.2 hd
rw [sqrt_le_left (div_nonneg c.cast_nonneg d.cast_nonneg), div_pow, add_div_eq_mul_add_div _ _ (ne_of_gt hb'), div_le_div_iff hb' (pow_pos hd' _)]
exact_mod_cast h
intros
rw ‚Üê sqrt_sq_eq_abs; exact sqrt_le_sqrt h
rw ‚Üê sqrt_sq_eq_abs
exact sqrt_le_sqrt h
intros
ext x y
{ ext x y, reflexivity }
reflexivity
intros
have := results_thinkN n (results_ret a); rwa nat.zero_add at this
have := results_thinkN n (results_ret a)
rwa nat.zero_add at this
intros
cases s' with st'
have : st' n = none
from s'_nth_eq_none
cases s with st
cases st_nth_eq : st n; simp only [zip_with, seq.nth, *]
cases st_nth_eq : st n
simp only [zip_with, seq.nth, *]
simp only [zip_with, seq.nth, *]
intros
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]; simp
simp
intros
ext
{ ext, simp [and_iff_left_of_imp (Œª hx : x ‚àà s, show x ‚â† a, from Œª hxa, h $ hxa ‚ñ∏ hx)] }
simp [and_iff_left_of_imp (Œª hx : x ‚àà s, show x ‚â† a, from Œª hxa, h $ hxa ‚ñ∏ hx)]
intros
simp
intros
refine ‚ü®Œª h y, _, surjective.image_surjective‚ü©
cases h {y} with s hs
have := mem_singleton y
rw [‚Üê hs] at this
rcases this with ‚ü®x, h1x, h2x‚ü©
exact ‚ü®x, h2x‚ü©
intros
rw [inter_comm, singleton_inter_nonempty]
intros
ext
ext; simp
simp
intros
simp [piecewise]
ext i
by_cases h : i = j
{ rw h, simp }
rw h
simp
by_cases h' : i ‚àà s; simp [h, h']
{ by_cases h' : i ‚àà s; simp [h, h'] }
by_cases h' : i ‚àà s
simp [h, h']
simp [h, h']
intros
{ ext x, simp [Ici] }
ext x
simp [Ici]
intros
rw [diff_eq, compl_Ioi, Ioi_inter_Iic]
intros
ext1 x
simp_rw [mem_union, mem_Ico, min_le_iff, lt_max_iff]
by_cases hc : c ‚â§ x; by_cases hd : x < d
by_cases hc : c ‚â§ x
by_cases hd : x < d
{ tauto }
tauto
have hax : a ‚â§ x := h‚ÇÇ.trans (le_of_not_gt hd)
{ have hax : a ‚â§ x := h‚ÇÇ.trans (le_of_not_gt hd), tauto }
tauto
by_cases hd : x < d
have hxb : x < b := (lt_of_not_ge hc).trans_le h‚ÇÅ
{ have hxb : x < b := (lt_of_not_ge hc).trans_le h‚ÇÅ, tauto }
tauto
{ tauto }
tauto
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
refine ‚ü®Œª _ h, ‚ü®add_lt_add_right h.1 _, add_le_add_right h.2 _‚ü©, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
obtain ‚ü®c, rfl‚ü© := exists_add_of_le h.1.le
rw [mem_Ioc, add_right_comm, add_lt_add_iff_right, add_le_add_iff_right] at h
exact ‚ü®a + c, h, by rw add_right_comm‚ü©
intros
simp only [Inter, infi_subtype']
haveI : nonempty {i // p i} := nonempty_subtype.2 hp
apply inj_on.image_Inter_eq
simpa only [Union, supr_subtype'] using h
intros
rw [‚Üê prod_eq_seq, ‚Üê image_swap_prod, prod_eq_seq, image_seq, ‚Üê image_comp, prod.swap]
intros
simp only [Inter_or, Inter_inter_distrib, Inter_Inter_eq_left]
intros
simp
intros
rw ‚Üê update_inr_comp_inr
intros
apply elim_of_ne
{ apply elim_of_ne, rintro rfl, exact not_mem_of_nodup_cons hl hj }
rintro rfl
exact not_mem_of_nodup_cons hl hj
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
intros
rw [‚Üê nat.cast_one, val_nat_cast]
intros
have : (a.val : ‚Ñ§) - n ‚â§ 0
erw [sub_nonpos, int.coe_nat_le]
erw [sub_nonpos, int.coe_nat_le]
{ erw [sub_nonpos, int.coe_nat_le], exact a.val_le, }
{ erw [sub_nonpos, int.coe_nat_le], exact a.val_le, }
exact a.val_le
exact a.val_le
rw [zmod.val_min_abs_def_pos]
split_ifs
{ rw [int.nat_abs_of_nat, nat_cast_zmod_val] }
rw [int.nat_abs_of_nat, nat_cast_zmod_val]
rw [‚Üê int.cast_coe_nat, int.of_nat_nat_abs_of_nonpos this, int.cast_neg, int.cast_sub]
{ rw [‚Üê int.cast_coe_nat, int.of_nat_nat_abs_of_nonpos this, int.cast_neg, int.cast_sub], rw [int.cast_coe_nat, int.cast_coe_nat, nat_cast_self, sub_zero, nat_cast_zmod_val], }
rw [int.cast_coe_nat, int.cast_coe_nat, nat_cast_self, sub_zero, nat_cast_zmod_val]
intros
simpa only [sub_eq_add_neg] using (f.commute_add_nat n).inverses_right (equiv.add_right _).right_inv (equiv.add_right _).left_inv
intros
refine ‚ü®Œª h, h ‚ñ∏ f.exists_eq_add_translation_number hf, _‚ü©
rintros ‚ü®x, hx‚ü©
exact f.translation_number_of_eq_add_int hx
intros
{ rw omega_limit_eq_bInter_inter _ _ _ hv, apply bInter_eq_Inter }
rw omega_limit_eq_bInter_inter _ _ _ hv
apply bInter_eq_Inter
intros
ext
rw iff_true_right intermediate_field.mem_top
exact finrank_adjoin_simple_eq_one_iff.mp (h x)
intros
rw [‚Üê cardinal.lift_inj, ‚Üê (basis_monomials œÉ K).mk_eq_dim]
intros
rcases x with ‚ü®m, x‚ü©
induction m with m ih
refl
{refl}
rw [iterate_succ_apply', ‚Üê ih]; refl
rw [iterate_succ_apply', ‚Üê ih]
refl
intros
simp_rw [root_set_def, finset.coe_sort_coe, fintype.card_coe]
rw [multiset.to_finset_card_of_nodup, ‚Üênat_degree_eq_card_roots hsplit]
exact nodup_roots hsep.map
intros
simpa using eq_prod_roots_of_splits hsplit
intros
cases h : degree f with n
rw [degree_eq_bot.1 h]; exact splits_zero i
{ rw [degree_eq_bot.1 h]; exact splits_zero i }
rw [degree_eq_bot.1 h]
exact splits_zero i
cases n with n
{ cases n with n, { rw [eq_C_of_degree_le_zero (trans_rel_right (‚â§) h (le_refl _))]; exact splits_C _ _ }, { have hn : n = 0, { rw h at hf, cases n, { refl }, { exact absurd hf dec_trivial } }, exact splits_of_degree_eq_one _ (by rw [h, hn]; refl) } }
rw [eq_C_of_degree_le_zero (trans_rel_right (‚â§) h (le_refl _))]; exact splits_C _ _
rw [eq_C_of_degree_le_zero (trans_rel_right (‚â§) h (le_refl _))]
{ rw [eq_C_of_degree_le_zero (trans_rel_right (‚â§) h (le_refl _))]; exact splits_C _ _ }
exact splits_C _ _
have hn : n = 0
{ have hn : n = 0, { rw h at hf, cases n, { refl }, { exact absurd hf dec_trivial } }, exact splits_of_degree_eq_one _ (by rw [h, hn]; refl) }
rw h at hf
{ rw h at hf, cases n, { refl }, { exact absurd hf dec_trivial } }
cases n
refl
{ refl }
exact absurd hf dec_trivial
{ exact absurd hf dec_trivial }
exact splits_of_degree_eq_one _ (by rw [h, hn]; refl)
intros
use add_torsor.nonempty.some
simp
intros
ext
{ ext, simp only [times_cont_mdiff_map.comp_apply, R_apply, mul_assoc] }
simp only [times_cont_mdiff_map.comp_apply, R_apply, mul_assoc]
intros
simp [atlas, charted_space.atlas]
intros
rw ‚Üê lift_prop_within_at_univ at h
exact lift_prop_within_at_mono mono h (subset_univ _)
intros
rw [has_mfderiv_within_at, has_mfderiv_within_at, ext_chart_preimage_inter_eq, has_fderiv_within_at_inter, continuous_within_at_inter h]
exact ext_chart_preimage_mem_nhds I x h
intros
apply has_mfderiv_at.mfderiv
exact has_mfderiv_at.comp x hg.has_mfderiv_at hf.has_mfderiv_at
intros
rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid]
suffices h : times_cont_diff_on ùïú n (I ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I)
simp [h]
simp [h]
have : times_cont_diff_on ùïú n id (univ : set E) := times_cont_diff_id.times_cont_diff_on
exact this.congr_mono (Œª x hx, by simp [hx.2]) (subset_univ _)
intros
apply h.mono (Œª y hy, _)
simp only with mfld_simps at hy
simp only [hy, hts _] with mfld_simps
intros
simp only [pi.one_def, times_cont_mdiff_const]
intros
ext x y
simp only [add_monoid_hom.id_comp]
rw [add_monoid_hom.comp_assoc, finsupp.to_free_abelian_group_comp_single_add_hom]
simp only [to_finsupp, add_monoid_hom.coe_comp, finsupp.single_add_hom_apply, function.comp_app, one_smul, lift.of, add_monoid_hom.flip_apply, smul_add_hom_apply, add_monoid_hom.id_apply]
intros
rcases x with ‚ü®L‚ü©; simp
rcases x with ‚ü®L‚ü©
simp
intros
ext z
show j.to_map _ * _ = j.to_map (l _) * _
rw [mul_inv_left, ‚Üêmul_assoc, mul_inv_right]
{ rw [mul_inv_left, ‚Üêmul_assoc, mul_inv_right], show j.to_map _ * j.to_map (l (g _)) = j.to_map (l _) * _, rw [‚Üêj.to_map.map_mul, ‚Üêj.to_map.map_mul, ‚Üêl.map_mul, ‚Üêl.map_mul], exact k.comp_eq_of_eq hl j (by rw [k.to_map.map_mul, k.to_map.map_mul, sec_spec', mul_assoc, map_mul_right]) }
show j.to_map _ * j.to_map (l (g _)) = j.to_map (l _) * _
rw [‚Üêj.to_map.map_mul, ‚Üêj.to_map.map_mul, ‚Üêl.map_mul, ‚Üêl.map_mul]
exact k.comp_eq_of_eq hl j (by rw [k.to_map.map_mul, k.to_map.map_mul, sec_spec', mul_assoc, map_mul_right])
intros
rw [order_of, one_mul_eq_id, minimal_period_id]
intros
rw [is_periodic_pt, is_fixed_pt, add_left_iterate, add_zero]
intros
convert function.commute.minimal_period_of_comp_dvd_lcm h.function_commute_mul_left
rw [order_of, comp_mul_left]
intros
induction s using quot.induction_on
exact list.is_cycle_form_perm h (length_nontrivial hn)
intros
simp_rw [set.eq_singleton_iff_unique_mem, mem_iff, vector.to_list_singleton, list.prod_singleton, vector.head_cons]
exact ‚ü®rfl, Œª v hv, v.cons_head_tail.symm.trans (congr_arg2 vector.cons hv v.tail.eq_nil)‚ü©
intros
classical
have : is_of_fin_order f := exists_pow_eq_one f
rw is_of_fin_order_iff_pow_eq_one at this
obtain ‚ü®x, hx, hx'‚ü© := hf
obtain ‚ü®_ | _ | k, hk, hk'‚ü© := this
{ exact absurd hk (lt_asymm hk) }
exact absurd hk (lt_asymm hk)
rw pow_one at hk'
{ rw pow_one at hk', simpa [hk'] using hx }
simpa [hk'] using hx
{ exact ‚ü®k + 2, by simp, hk'‚ü© }
exact ‚ü®k + 2, by simp, hk'‚ü©
intros
rw order_of_dvd_iff_pow_eq_one
split
intros h H
{ intros h H, refine hf.ne_one _, rw [‚Üêsupport_eq_empty_iff, ‚Üêh, H, support_one] }
refine hf.ne_one _
rw [‚Üêsupport_eq_empty_iff, ‚Üêh, H, support_one]
intro H
{ intro H, apply le_antisymm (support_pow_le _ n) _, intros x hx, contrapose! H, ext z, by_cases hz : f z = z, { rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply] }, { obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq hz (mem_support.mp hx), apply (f ^ k).injective, rw [‚Üêmul_apply, (commute.pow_pow_self _ _ _).eq, mul_apply], simpa using H } }
apply le_antisymm (support_pow_le _ n) _
intros x hx
contrapose! H
ext z
by_cases hz : f z = z
{ rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply] }
rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply]
obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq hz (mem_support.mp hx)
{ obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq hz (mem_support.mp hx), apply (f ^ k).injective, rw [‚Üêmul_apply, (commute.pow_pow_self _ _ _).eq, mul_apply], simpa using H }
apply (f ^ k).injective
rw [‚Üêmul_apply, (commute.pow_pow_self _ _ _).eq, mul_apply]
simpa using H
intros
have : f.cycle_factors_finset = f.cycle_factors_finset := rfl
obtain ‚ü®-, hd, -‚ü© := cycle_factors_finset_eq_finset.mp this
exact hd p hp q hq h
intros
rw [‚Üê fin.succ_zero_eq_one, equiv.perm.decompose_fin_symm_apply_succ e p 0]
intros
induction xs using list.reverse_rec_on with xs y IH generalizing x
induction xs using list.reverse_rec_on with xs y IH generalizing x; simp
simp
simp
intros
rw [monoid_hom.map_inv sign f, int.units_inv_eq_self]
intros
rw [support, mem_filter, and_iff_right (mem_univ x)]
intros
intro x
rw [inv_eq_iff_eq, eq_comm]
exact h x
intros
induction k with k IH
{ refl }
refl
rw [pow_succ, IH, r_mul_r]
{ rw [pow_succ, IH, r_mul_r], congr' 1, norm_cast, rw nat.one_add }
congr' 1
norm_cast
rw nat.one_add
intros
rintros a hc
{ rintros a hc, obtain ‚ü®c, rfl‚ü© := is_conj_iff.1 hc, exact tn.conj_mem a h c }
obtain ‚ü®c, rfl‚ü© := is_conj_iff.1 hc
exact tn.conj_mem a h c
intros
rwa [map_comap_eq, inf_eq_right]
intros
refine map_injective_of_ker_le B.subtype (ker_le_comap _ _) (le_trans (ker_le_comap B.subtype _) le_sup_left) _
simp only [subgroup_of, map_comap_eq, map_sup, subtype_range]
{ simp only [subgroup_of, map_comap_eq, map_sup, subtype_range], rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA] }
rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]
intros
simpa only [mrange_eq_map] using (‚ä§ : submonoid M).map_map g f
intros
ext x
rw [mem_coe, ‚Üêvsub_right_mem_direction_iff_mem (mem_affine_span k (set.mem_singleton p)) _, direction_affine_span]
simp
intros
rw [attach_affine_combination_of_injective s w (coe : s ‚Üí P) subtype.coe_injective, univ_eq_attach, attach_image_coe]
intros
split
exact Œª h w hw hs i, h finset.univ w hw hs i (finset.mem_univ _)
{ exact Œª h w hw hs i, h finset.univ w hw hs i (finset.mem_univ _) }
intros h s w hw hs i hi
{ intros h s w hw hs i hi, rw finset.weighted_vsub_indicator_subset _ _ (finset.subset_univ s) at hs, rw set.sum_indicator_subset _ (finset.subset_univ s) at hw, replace h := h ((‚Üës : set Œπ).indicator w) hw hs i, simpa [hi] using h }
rw finset.weighted_vsub_indicator_subset _ _ (finset.subset_univ s) at hs
rw set.sum_indicator_subset _ (finset.subset_univ s) at hw
replace h := h ((‚Üës : set Œπ).indicator w) hw hs i
simpa [hi] using h
intros
rw [span_int_eq_add_subgroup_closure, s.closure_eq]
intros
ext b
ext b; simp only [submodule.mem_comap, p.smul_mem_iff h, linear_map.smul_apply]
simp only [submodule.mem_comap, p.smul_mem_iff h, linear_map.smul_apply]
intros
rw [submodule.comap_map_eq, sup_of_le_left h]
intros
{ ext m, apply pow_apply, }
ext m
apply pow_apply
intros
convert (of_vector_space K V).linear_independent
{ convert (of_vector_space K V).linear_independent, ext x, rw of_vector_space_apply_self }
ext x
rw of_vector_space_apply_self
intros
ext ‚ü®bi, hbi‚ü©
rw [reindex_finset_range, reindex_repr, reindex_range_repr_self]
convert finsupp.single_apply_left ((equiv.refl M).subtype_equiv _).symm.injective _ _ _
refl
intros
conv_rhs { rw [‚Üê b.total_repr x, ‚Üê b.total_repr y] }
simp_rw [finsupp.total_apply, finsupp.sum, sum_left, sum_right, smul_left, smul_right, smul_eq_mul]
intros
rw [det_mul, det_mul, mul_comm]
intros
{ classical, exact (basis.of_vector_space K V).eval_range }
classical
exact (basis.of_vector_space K V).eval_range
intros
simp only [maximal_generalized_eigenspace, ‚Üê mem_generalized_eigenspace, submodule.mem_supr_of_chain]
intros
haveI := finite_dimensional_of_dim_eq_zero h
apply eq_top_of_finrank_eq
rw [finrank_bot, finrank_eq_zero_of_dim_eq_zero h]
intros
rw finsupp.mem_supported
intros
simp [lcongr]
intros
ext
{ ext, rw [basis.to_matrix_apply, linear_map.to_matrix_apply, basis.constr_basis] }
rw [basis.to_matrix_apply, linear_map.to_matrix_apply, basis.constr_basis]
intros
apply minpoly.unique
{ apply matrix.charpoly_monic }
apply matrix.charpoly_monic
apply (left_mul_matrix _).injective_iff.mp (left_mul_matrix_injective h.basis)
{ apply (left_mul_matrix _).injective_iff.mp (left_mul_matrix_injective h.basis), rw [‚Üê polynomial.aeval_alg_hom_apply, aeval_self_charpoly] }
rw [‚Üê polynomial.aeval_alg_hom_apply, aeval_self_charpoly]
intros q q_monic root_q
{ intros q q_monic root_q, rw [matrix.charpoly_degree_eq_dim, fintype.card_fin, degree_eq_nat_degree q_monic.ne_zero], apply with_bot.some_le_some.mpr, exact h.dim_le_nat_degree_of_root q_monic.ne_zero root_q }
rw [matrix.charpoly_degree_eq_dim, fintype.card_fin, degree_eq_nat_degree q_monic.ne_zero]
apply with_bot.some_le_some.mpr
exact h.dim_le_nat_degree_of_root q_monic.ne_zero root_q
intros
{ rw ‚Üê det_transpose, exact det_eq_zero_of_row_eq_zero j h, }
rw ‚Üê det_transpose
exact det_eq_zero_of_row_eq_zero j h
intros
rw [dot_product_std_basis_eq_mul, mul_one]
intros
rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_map.to_matrix'_apply, linear_equiv.arrow_congr_apply, basis.equiv_fun_symm_apply, finset.sum_eq_single j, if_pos rfl, one_smul, basis.equiv_fun_apply]
intros j' _ hj'
{ intros j' _ hj', rw [if_neg hj', zero_smul] }
rw [if_neg hj', zero_smul]
intro hj
{ intro hj, have := finset.mem_univ j, contradiction }
have := finset.mem_univ j
contradiction
intros
cases t
ext a b
simp only [reindex_equiv, transvection, mul_boole, algebra.id.smul_eq_mul, to_matrix_mk, minor_apply, reindex_apply, dmatrix.add_apply, pi.smul_apply, reindex_alg_equiv_apply]
by_cases ha : e t_i = a; by_cases hb : e t_j = b; by_cases hab : a = b; simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases ha : e t_i = a; by_cases hb : e t_j = b; by_cases hab : a = b
by_cases ha : e t_i = a; by_cases hb : e t_j = b
by_cases ha : e t_i = a
by_cases hb : e t_j = b
by_cases hab : a = b
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases hab : a = b
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases hb : e t_j = b
by_cases hab : a = b
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases hab : a = b
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
intros
ext m x
simp only [snoc_last, multilinear_map.curry_right_apply, multilinear_map.uncurry_right_apply]
rw init_snoc
intros
rw [‚Üêis_scalar_tower.algebra_map_smul R a y, polar_smul_right, algebra.smul_def]
intros
refine le_antisymm (supr_range_std_basis_le_infi_ker_proj _ _ _ _ hd) _
have : set.univ ‚äÜ ‚ÜëhI.to_finset ‚à™ J
rwa [hI.coe_to_finset]
{ rwa [hI.coe_to_finset] }
refine le_trans (infi_ker_proj_le_supr_range_std_basis R œÜ this) (supr_le_supr $ assume i, _)
rw [set.finite.mem_to_finset]
exact le_refl _
intros
rw [or_assoc, or_assoc, or_comm b]
intros
{ ext, simp, }
ext
simp
intros
intros g‚ÇÅ g‚ÇÇ hg
refine funext (Œª x, _)
have H := congr_fun hg (f x)
simp only [hf, extend_apply] at H
exact H
intros
apply measurable_of_is_closed
intros s hs
cases eq_empty_or_nonempty s with h1 h1
simp [h1]
{ simp [h1] }
by_cases h2 : s = univ
simp [h2]
{ simp [h2] }
exact hf s hs h1 h2
intros
simp [measure.prod]
intros
set i := some s.exists_compl_positive_negative
obtain ‚ü®hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ‚ü© := some_spec s.exists_compl_positive_negative
exact ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, rfl, rfl‚ü©
intros
rw [‚Üê mk_to_germ, mk_coe_fn]
intros
have h_eq : (Œª n, f n x) = Œª n, ae_seq hf p n x
from funext (Œª n, (ae_seq_eq_fun_of_mem_ae_seq_set hf hx n).symm)
rw h_eq
exact prop_of_mem_ae_seq_set hf hx
intros
simp_rw ess_sup
{ simp_rw ess_sup, exact ennreal.limsup_liminf_le_liminf_limsup (Œª a b, f b a), }
exact ennreal.limsup_liminf_le_liminf_limsup (Œª a b, f b a)
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
{ simp [to_L1, snorm, snorm'], simp [edist_eq_coe_nnnorm] }
simp [to_L1, snorm, snorm']
simp [edist_eq_coe_nnnorm]
intros
{ rw neg_part, exact pos_part_map_norm _ }
rw neg_part
exact pos_part_map_norm _
intros
rw [‚Üê integral_sub hf.real_to_nnreal]
{ simp }
simp
{ exact hf.neg.real_to_nnreal }
exact hf.neg.real_to_nnreal
intros
simp only [interval_integral, set_integral_const, sub_smul]
intros
cases le_total a b with hab hab; simpa [hab, integral_of_le, integral_of_ge] using set_integral_congr measurable_set_Ioc (h.mono Ioc_subset_Icc_self)
cases le_total a b with hab hab
simpa [hab, integral_of_le, integral_of_ge] using set_integral_congr measurable_set_Ioc (h.mono Ioc_subset_Icc_self)
simpa [hab, integral_of_le, integral_of_ge] using set_integral_congr measurable_set_Ioc (h.mono Ioc_subset_Icc_self)
intros
refine measure.ext (Œª s hs, _)
rw [with_density_apply _ hs, measure.coe_smul, pi.smul_apply, with_density_apply _ hs, smul_eq_mul, ‚Üê lintegral_const_mul' r f hr]
refl
intros
rw [approx_apply _ hf, approx_apply _ (hf.comp hg)]
intros
by_cases hfi : integrable f Œº
have hgi : integrable g Œº := hfi.congr h
{ have hgi : integrable g Œº := hfi.congr h, rw [set_to_fun_eq hT hfi, set_to_fun_eq hT hgi, (integrable.to_L1_eq_to_L1_iff f g hfi hgi).2 h] }
rw [set_to_fun_eq hT hfi, set_to_fun_eq hT hgi, (integrable.to_L1_eq_to_L1_iff f g hfi hgi).2 h]
have hgi : ¬¨ integrable g Œº
{ have hgi : ¬¨ integrable g Œº, { rw integrable_congr h at hfi, exact hfi }, rw [set_to_fun_undef hT hfi, set_to_fun_undef hT hgi] }
rw integrable_congr h at hfi
{ rw integrable_congr h at hfi, exact hfi }
exact hfi
rw [set_to_fun_undef hT hfi, set_to_fun_undef hT hgi]
intros
{ rw sInter_eq_bInter, exact measurable_set.bInter hs h }
rw sInter_eq_bInter
exact measurable_set.bInter hs h
intros
convert Œº.inner_content_pos_of_is_mul_left_invariant h3 K hK ‚ü®U, h1U‚ü© h2U
{ convert Œº.inner_content_pos_of_is_mul_left_invariant h3 K hK ‚ü®U, h1U‚ü© h2U, exact Œº.outer_measure_opens ‚ü®U, h1U‚ü© }
exact Œº.outer_measure_opens ‚ü®U, h1U‚ü©
intros
simp [volume_val]
intros
simp [measure.trim, hs]
intros
simp only [mem_ae_iff, compl_compl]
intros
simp_rw [to_measure_of_zero_le, measure.of_measurable_apply _ hj‚ÇÅ, to_measure_of_zero_le', s.restrict_apply hi‚ÇÅ hj‚ÇÅ, set.inter_comm]
intros
{ ext, simp [mul_comm] }
ext
simp [mul_comm]
intros
simp only [finset_approx, finset.mem_erase, finset.mem_image]
split
rintros ‚ü®hx, ‚ü®i, j‚ü©, _, rfl‚ü©
{ rintros ‚ü®hx, ‚ü®i, j‚ü©, _, rfl‚ü©, refine ‚ü®i, j, _, rfl‚ü©, rintro rfl, simpa using hx }
refine ‚ü®i, j, _, rfl‚ü©
rintro rfl
simpa using hx
rintros ‚ü®i, j, hij, rfl‚ü©
{ rintros ‚ü®i, j, hij, rfl‚ü©, refine ‚ü®_, ‚ü®i, j‚ü©, finset.mem_product.mpr ‚ü®finset.mem_univ _, finset.mem_univ _‚ü©, rfl‚ü©, rw [ne.def, sub_eq_zero], exact Œª h, hij ((distinct_elems bS adm).injective h) }
refine ‚ü®_, ‚ü®i, j‚ü©, finset.mem_product.mpr ‚ü®finset.mem_univ _, finset.mem_univ _‚ü©, rfl‚ü©
rw [ne.def, sub_eq_zero]
exact Œª h, hij ((distinct_elems bS adm).injective h)
intros
rintros ‚ü®f : polynomial ‚Ñ§, f0, ef0‚ü©
replace ef0 : (f.map (algebra_map ‚Ñ§ ‚Ñù)).eval x = 0
rwa [aeval_def, ‚Üê eval_map] at ef0
{ rwa [aeval_def, ‚Üê eval_map] at ef0 }
obtain ‚ü®A, hA, h‚ü© : ‚àÉ (A : ‚Ñù), 0 < A ‚àß ‚àÄ (a : ‚Ñ§) (b : ‚Ñï), (1 : ‚Ñù) ‚â§ (b.succ) ^ f.nat_degree * (abs (x - a / (b.succ)) * A) := exists_pos_real_of_irrational_root lx.irrational f0 ef0
rcases pow_unbounded_of_one_lt A (lt_add_one 1) with ‚ü®r, hn‚ü©
obtain ‚ü®a, b, b1, -, a1‚ü© : ‚àÉ (a b : ‚Ñ§), 1 < b ‚àß x ‚â† a / b ‚àß abs (x - a / b) < 1 / b ^ (r + f.nat_degree) := lx (r + f.nat_degree)
have b0 : (0 : ‚Ñù) < b := zero_lt_one.trans (by { rw ‚Üê int.cast_one, exact int.cast_lt.mpr b1 })
refine lt_irrefl ((b : ‚Ñù) ^ f.nat_degree * abs (x - ‚Üëa / ‚Üëb)) _
rw [lt_div_iff' (pow_pos b0 _), pow_add, mul_assoc] at a1
refine ((_ : (b : ‚Ñù) ^ f.nat_degree * abs (x - a / b) < 1 / A).trans_le _)
refine (lt_div_iff' hA).mpr _
{ refine (lt_div_iff' hA).mpr _, refine lt_of_le_of_lt _ a1, refine mul_le_mul_of_nonneg_right _ (mul_nonneg (pow_nonneg b0.le _) (abs_nonneg _)), refine hn.le.trans _, refine pow_le_pow_of_le_left zero_le_two _ _, exact int.cast_two.symm.le.trans (int.cast_le.mpr (int.add_one_le_iff.mpr b1)) }
refine lt_of_le_of_lt _ a1
refine mul_le_mul_of_nonneg_right _ (mul_nonneg (pow_nonneg b0.le _) (abs_nonneg _))
refine hn.le.trans _
refine pow_le_pow_of_le_left zero_le_two _ _
exact int.cast_two.symm.le.trans (int.cast_le.mpr (int.add_one_le_iff.mpr b1))
lift b to ‚Ñï using zero_le_one.trans b1.le
{ lift b to ‚Ñï using zero_le_one.trans b1.le, specialize h a b.pred, rwa [nat.succ_pred_eq_of_pos (zero_lt_one.trans _), ‚Üê mul_assoc, ‚Üê (div_le_iff hA)] at h, exact int.coe_nat_lt.mp b1 }
specialize h a b.pred
rwa [nat.succ_pred_eq_of_pos (zero_lt_one.trans _), ‚Üê mul_assoc, ‚Üê (div_le_iff hA)] at h
exact int.coe_nat_lt.mp b1
intros
ext
ext; simp [mersenne, q, zmod.nat_coe_zmod_eq_zero_iff_dvd, -pow_pos]
simp [mersenne, q, zmod.nat_coe_zmod_eq_zero_iff_dvd, -pow_pos]
apply nat.min_fac_dvd
simp [mersenne, q, zmod.nat_coe_zmod_eq_zero_iff_dvd, -pow_pos]
intros
unfold padic_val_nat
rw int.to_nat_of_nonneg (zero_le_padic_val_rat_of_nat p n)
intros
cases nat.prime.eq_two_or_odd (fact.out p.prime) with hp2 hp_odd
{ substI p, revert a ha, exact dec_trivial }
substI p
revert a ha
exact dec_trivial
rw [‚Üê mul_self_eq_one_iff, ‚Üê pow_add, ‚Üê two_mul, two_mul_odd_div_two hp_odd]
exact pow_card_sub_one_eq_one ha
intros
simpa using congr_arg re h
intros
rw [inf_comm, inf_sdiff_right]
intros
rw [sup_comm, inf_sdiff_sup_left]
intros
simp only [is_glb, lower_bounds_empty, is_greatest_univ]
intros
rw [inf_comm, infi_inf]; simp [inf_comm]
rw [inf_comm, infi_inf]
simp [inf_comm]
intros
simpa only [(‚àò), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)
intros
simp
intros
rw [sInter_eq_bInter, bInter_mem hfin]
intros
simp only [tendsto_principal, eventually_principal]
intros
simp [filter.Coprod]
intros
rw [infi_subtype', infi_sup_left, infi_subtype']
intros
simp only [Sup_eq_supr, gc.l_supr]
intros
rw [inf_comm, @inf_comm _ _ a, inf_assoc]
intros
rw limsup_eq
congr' with b
exact eventually_congr (h.mono $ Œª x hx, by simp [hx])
intros
rw [symm_diff_eq, compl_symm_diff, symm_diff_eq]
rw [inf_sup_left, inf_sup_right, ‚Üêsup_assoc, ‚Üêinf_assoc, ‚Üêinf_assoc]
congr' 1
congr' 1
{ congr' 1, rw [inf_comm, inf_assoc], }
rw [inf_comm, inf_assoc]
apply inf_left_right_swap
{ apply inf_left_right_swap }
intros
refine le_antisymm (le_min (is_wf.min_le_min_of_subset (subset_union_left _ _)) (is_wf.min_le_min_of_subset (subset_union_right _ _))) _
rw min_le_iff
exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (or.intro_left _ hsn)))).imp (hs.min_le _) (ht.min_le _)
intros
intros t1 t2 ht1 ht2
{ intros t1 t2 ht1 ht2, rw [set.inter_comm, mul_comm], exact h t2 t1 ht2 ht1, }
rw [set.inter_comm, mul_comm]
exact h t2 t1 ht2 ht1
intros
convert inv_eq_of_aeval_div_X_ne_zero (mt (Œª h, (algebra_map K L).injective _) coeff_zero_ne)
{ rw [aeval_eq, zero_sub, div_neg] }
rw [aeval_eq, zero_sub, div_neg]
rw ring_hom.map_zero
convert aeval_eq
conv_rhs { rw ‚Üê div_X_mul_X_add p }
rw [alg_hom.map_add, alg_hom.map_mul, h, zero_mul, zero_add, aeval_C]
intros
refine ‚ü®_, Œª x y hxy, _‚ü©
rintro rfl
unfreezingI { rintro rfl }
{ unfreezingI { rintro rfl }, rw ‚Üê ideal.one_eq_top at h, exact h.not_unit is_unit_one }
rw ‚Üê ideal.one_eq_top at h
exact h.not_unit is_unit_one
simp only [‚Üê ideal.dvd_span_singleton, ‚Üê ideal.span_singleton_mul_span_singleton] at ‚ä¢ hxy
{ simp only [‚Üê ideal.dvd_span_singleton, ‚Üê ideal.span_singleton_mul_span_singleton] at ‚ä¢ hxy, exact h.dvd_or_dvd hxy }
exact h.dvd_or_dvd hxy
intros
obtain ‚ü®n, f, hf‚ü© := hfp
use [n, alg_hom.comp ‚Üëe f]
split
{ exact function.surjective.comp e.surjective hf.1 }
exact function.surjective.comp e.surjective hf.1
suffices hker : (alg_hom.comp ‚Üëe f).to_ring_hom.ker = f.to_ring_hom.ker
{ rw hker, exact hf.2 }
rw hker
exact hf.2
have hco : (alg_hom.comp ‚Üëe f).to_ring_hom = ring_hom.comp ‚Üëe.to_ring_equiv f.to_ring_hom
{ have hco : (alg_hom.comp ‚Üëe f).to_ring_hom = ring_hom.comp ‚Üëe.to_ring_equiv f.to_ring_hom, { have h : (alg_hom.comp ‚Üëe f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl, have h1 : ‚Üë(e.to_ring_equiv) = (e.to_alg_hom).to_ring_hom := rfl, rw [h, h1] }, rw [ring_hom.ker_eq_comap_bot, hco, ‚Üê ideal.comap_comap, ‚Üê ring_hom.ker_eq_comap_bot, ring_hom.ker_coe_equiv (alg_equiv.to_ring_equiv e), ring_hom.ker_eq_comap_bot] }
have h : (alg_hom.comp ‚Üëe f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl
{ have h : (alg_hom.comp ‚Üëe f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl, have h1 : ‚Üë(e.to_ring_equiv) = (e.to_alg_hom).to_ring_hom := rfl, rw [h, h1] }
have h1 : ‚Üë(e.to_ring_equiv) = (e.to_alg_hom).to_ring_hom := rfl
rw [h, h1]
rw [ring_hom.ker_eq_comap_bot, hco, ‚Üê ideal.comap_comap, ‚Üê ring_hom.ker_eq_comap_bot, ring_hom.ker_coe_equiv (alg_equiv.to_ring_equiv e), ring_hom.ker_eq_comap_bot]
intros
ext g
simp only [hsum_coeff, coe_of_finsupp, finsupp.sum, ne.def]
simp_rw [‚Üê coeff.add_monoid_hom_apply, id.def]
rw [add_monoid_hom.map_sum, finsum_eq_sum_of_support_subset]
intros x h
simp only [coeff.add_monoid_hom_apply, mem_coe, finsupp.mem_support_iff, ne.def]
contrapose! h
simp [h]
intros
induction n with n ih
rw pow_zero at H
{ rw pow_zero at H, exact (mt (eq_top_iff_one _).2 hI.1).elim H }
exact (mt (eq_top_iff_one _).2 hI.1).elim H
rw pow_succ at H
{ rw pow_succ at H, exact or.cases_on (hI.mem_or_mem H) id ih }
exact or.cases_on (hI.mem_or_mem H) id ih
intros
{ rw [mem_ker, f.map_one], exact one_ne_zero }
rw [mem_ker, f.map_one]
exact one_ne_zero
intros
rw [ring_hom.ker_eq_comap_bot, quot_quot_mk, ‚Üê comap_comap, ‚Üê ring_hom.ker, mk_ker, comap_map_of_surjective (ideal.quotient.mk I) (quotient.mk_surjective), ‚Üê ring_hom.ker, mk_ker, sup_comm]
intros
by_cases 0 ‚â§ z
{ simp [nat_abs_of_nonneg h, normalize_of_nonneg h] }
simp [nat_abs_of_nonneg h, normalize_of_nonneg h]
simp [of_nat_nat_abs_of_nonpos (le_of_not_ge h), normalize_of_neg (lt_of_not_ge h)]
{ simp [of_nat_nat_abs_of_nonpos (le_of_not_ge h), normalize_of_neg (lt_of_not_ge h)] }
intros
split
split; unfreezingI { rintros ‚ü®‚ü®x, hx‚ü©‚ü© }
unfreezingI { rintros ‚ü®‚ü®x, hx‚ü©‚ü© }
have x_mem : x ‚àà coe_submodule S I := hx.symm ‚ñ∏ submodule.mem_span_singleton_self x
{ have x_mem : x ‚àà coe_submodule S I := hx.symm ‚ñ∏ submodule.mem_span_singleton_self x, obtain ‚ü®x, x_mem, rfl‚ü© := (mem_coe_submodule _ _).mp x_mem, refine ‚ü®‚ü®x, coe_submodule_injective S h _‚ü©‚ü©, rw [ideal.submodule_span_eq, hx, coe_submodule_span_singleton] }
obtain ‚ü®x, x_mem, rfl‚ü© := (mem_coe_submodule _ _).mp x_mem
refine ‚ü®‚ü®x, coe_submodule_injective S h _‚ü©‚ü©
rw [ideal.submodule_span_eq, hx, coe_submodule_span_singleton]
unfreezingI { rintros ‚ü®‚ü®x, hx‚ü©‚ü© }
rintros ‚ü®‚ü®x, hx‚ü©‚ü©
refine ‚ü®‚ü®algebra_map R S x, _‚ü©‚ü©
{ refine ‚ü®‚ü®algebra_map R S x, _‚ü©‚ü©, rw [hx, ideal.submodule_span_eq, coe_submodule_span_singleton] }
rw [hx, ideal.submodule_span_eq, coe_submodule_span_singleton]
intros
rw [‚Üêmk'_mul, mul_comm]; exact mk'_self _ _
rw [‚Üêmk'_mul, mul_comm]
exact mk'_self _ _
intros
rw [norm_apply, ‚Üê linear_map.det_to_matrix b, to_matrix_lmul_eq]
intros
dsimp [bernstein_polynomial]
split_ifs
{ subst h, simp, }
subst h
simp
obtain w | w := (n - ŒΩ).eq_zero_or_pos
{ obtain w | w := (n - ŒΩ).eq_zero_or_pos, { simp [nat.choose_eq_zero_of_lt ((nat.le_of_sub_eq_zero w).lt_of_ne (ne.symm h))] }, { simp [zero_pow w] } }
simp [nat.choose_eq_zero_of_lt ((nat.le_of_sub_eq_zero w).lt_of_ne (ne.symm h))]
{ simp [nat.choose_eq_zero_of_lt ((nat.le_of_sub_eq_zero w).lt_of_ne (ne.symm h))] }
{ simp [zero_pow w] }
simp [zero_pow w]
intros
rw [gcd_comm (content _) _, gcd_comm (content _) _]
apply gcd_content_eq_of_dvd_sub
rw [‚Üê self_sub_C_mul_X_pow, ‚Üê self_sub_C_mul_X_pow, sub_mul, sub_sub, add_comm, sub_add, sub_sub_cancel, leading_coeff_mul, ring_hom.map_mul, mul_assoc, mul_assoc]
apply dvd_sub (dvd.intro _ rfl) (dvd.intro _ rfl)
intros
rw ‚Üêmap_cyclotomic_int
apply monic_map
exact (int_cyclotomic_spec n).2.2
intros
induction n with n ih
{ simp, }
simp
{ simp [ih, pochhammer_succ_left, map_comp], }
simp [ih, pochhammer_succ_left, map_comp]
intros
rw [polynomial.aeval_def, polynomial.aeval_def, polynomial.hom_eval‚ÇÇ, ‚Üêis_scalar_tower.algebra_map_eq]
intros
rw [‚Üê coeff_zero_eq_constant_coeff_apply, coeff_inv_of_unit, if_pos rfl]
intros
rw [‚Üê pow_one (X s : mv_power_series œÉ R), X_pow_dvd_iff]
split
split; intros h m hm
intros h m hm
{ exact h m (hm.symm ‚ñ∏ zero_lt_one) }
exact h m (hm.symm ‚ñ∏ zero_lt_one)
intros h m hm
exact h m (nat.eq_zero_of_le_zero $ nat.le_of_succ_le_succ hm)
{ exact h m (nat.eq_zero_of_le_zero $ nat.le_of_succ_le_succ hm) }
intros
{ rw [coeff, finsupp.single_zero], refl }
rw [coeff, finsupp.single_zero]
refl
intros
by_cases h : f = 0
right
{ right, exact h }
exact h
exact or.intro_left _ ‚ü®injective_of_ne_zero h, surjective_of_ne_zero h‚ü©
intros
ext
refine ‚ü®Œª hx, _, Œª hx, (subsemiring.mem_closure.mp hx) M.subsemiring_closure (Œª s sM, _)‚ü©
refine ‚ü®Œª hx, _, Œª hx, (subsemiring.mem_closure.mp hx) M.subsemiring_closure (Œª s sM, _)‚ü©; rintros - ‚ü®H1, rfl‚ü©; rintros - ‚ü®H2, rfl‚ü©
refine ‚ü®Œª hx, _, Œª hx, (subsemiring.mem_closure.mp hx) M.subsemiring_closure (Œª s sM, _)‚ü©; rintros - ‚ü®H1, rfl‚ü©
rintros - ‚ü®H1, rfl‚ü©
rintros - ‚ü®H2, rfl‚ü©
exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2
{ exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2 }
rintros - ‚ü®H1, rfl‚ü©
rintros - ‚ü®H2, rfl‚ü©
{ exact H2 sM }
exact H2 sM
intros
refl
intros
simp only [witt_vector.truncate_fun, coeff_out, mk_coeff]
intros
rw [le_mk_iff_exists_set, ‚Üêsubtype.exists_set_subtype]
apply exists_congr
intro t
rw [mk_image_eq]
apply subtype.val_injective
intros
cases h with _ _ _ h‚ÇÅ h‚ÇÇ; [refl, exact equiv.antisymm h‚ÇÇ h‚ÇÅ]
cases h with _ _ _ h‚ÇÅ h‚ÇÇ
refl
exact equiv.antisymm h‚ÇÇ h‚ÇÅ
intros
simpa [e0, NF_below_zero] using h.snd'
intros
simp only [pow_half_move_right, eq_self_iff_true]
intros
simp [h.symm, term, add_assoc]
intros
by_cases h : c; simp [h]
by_cases h : c
simp [h]
simp [h]
intros
rwa sub_neg_eq_add
intros
rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ]; simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ]
simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
intros
simp
intros
simp [nhds_infty_eq, comap_sup, comap_map coe_injective]
intros
{ rw ‚Üê sum_attach, exact has_sum_fintype _ }
rw ‚Üê sum_attach
exact has_sum_fintype _
intros
{ ext x, exact apply_symm_apply e x }
ext x
exact apply_symm_apply e x
intros
rcases eq_empty_or_nonempty (Iio x) with h|h
simp [h]
{ simp [h] }
refine tendsto_order.2 ‚ü®Œª l hl, _, Œª m hm, _‚ü©
obtain ‚ü®z, zx, lz‚ü© : ‚àÉ (a : Œ±), a < x ‚àß l < f a
{ obtain ‚ü®z, zx, lz‚ü© : ‚àÉ (a : Œ±), a < x ‚àß l < f a, by simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl, exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 ‚ü®z, zx, Œª y hy, lz.trans_le (Mf (hy.1.le))‚ü© }
simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl
simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl
exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 ‚ü®z, zx, Œª y hy, lz.trans_le (Mf (hy.1.le))‚ü©
filter_upwards [self_mem_nhds_within]
{ filter_upwards [self_mem_nhds_within], assume y hy, apply lt_of_le_of_lt _ hm, exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy) }
assume y hy
apply lt_of_le_of_lt _ hm
exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy)
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Iic _ _ _ _ (a‚Åª¬π)
intros
refine continuous_if (Œª a ha, hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _)
{ rwa [(is_closed_le hf hg).closure_eq] }
rwa [(is_closed_le hf hg).closure_eq]
{ simp only [not_le], exact closure_lt_subset_le hg hf }
simp only [not_le]
exact closure_lt_subset_le hg hf
intros
simp only [continuous_at, tendsto_congr' h, h.eq_of_nhds]
intros
rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]
intros
let E := equiv.of_bijective _ bij
have hE : continuous E.symm
rw continuous_iff_is_closed
{ rw continuous_iff_is_closed, intros S hS, rw ‚Üê E.image_eq_preimage, exact is_closed_map f S hS }
intros S hS
rw ‚Üê E.image_eq_preimage
exact is_closed_map f S hS
refine ‚ü®‚ü®‚ü®E.symm, hE‚ü©, _, _‚ü©‚ü©
ext x
{ ext x, apply E.symm_apply_apply }
apply E.symm_apply_apply
ext x
{ ext x, apply E.apply_symm_apply }
apply E.apply_symm_apply
intros
simp
intros
{ ext, simp, }
ext
simp
intros
rw ‚Üê nhds_within_univ
{ rw ‚Üê nhds_within_univ, apply nhds_within_le_of_mem, exact univ_mem }
apply nhds_within_le_of_mem
exact univ_mem
intros
simp only [continuous_on, continuous_within_at, tendsto_nhds, mem_nhds_within]
intros
simp only [continuous_on_iff_continuous_restrict, restrict_eq]
conv_rhs { rw [function.comp.assoc, ‚Üê (inducing.continuous_iff hg)] }
intros
rcases c
{ rcases c, refl }
refl
intros
rw [coord_change, e‚ÇÅ.mk_coord_change _ h‚ÇÅ h‚ÇÇ, ‚Üê e‚ÇÇ.coe_coe, e‚ÇÇ.to_local_homeomorph.left_inv, coord_change]
rwa [e‚ÇÇ.mem_source, e‚ÇÅ.proj_symm_apply' h‚ÇÅ]
intros
rw [‚Üê preimage_symm, preimage_closure]
intros
rw ‚Üê tendsto_coe
convert tendsto_sum_nat_add (Œª i, (f i : ‚Ñù))
norm_cast
intros
simp only [local_homeomorph_subtype_coe, subtype.range_coe_subtype] with mfld_simps
{ simp only [local_homeomorph_subtype_coe, subtype.range_coe_subtype] with mfld_simps, refl }
refl
intros
intros x y
have := hf (g x) (g y)
rwa [hg x, hg y] at this
intros
rw [cauchy_seq_iff_tendsto, metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff, prod.map_def]
intros
simp only [‚Üê nnreal.eq_iff, ‚Üê dist_nndist, imp_self, nnreal.coe_zero, zero_eq_dist]
intros
simpa only [hy.eq, dist_self, add_zero] using hf.dist_inequality x y
intros
rw [dimH_ball_pi x hr, fintype.card_fin]
intros
simp [inf_edist_zero_of_mem h, inf_dist]
intros
convert Œ≥.truncate_self 1; exact Œ≥.extend_one.symm
convert Œ≥.truncate_self 1
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
exact Œ≥.extend_one.symm
intros
simp [pushforward_eq]
intros
rw uniform_continuous_on_iff_restrict at h
rw continuous_on_iff_continuous_restrict
exact h.continuous
intros
rw [cauchy, map_ne_bot_iff, prod_map_map_eq, tendsto]
intros
simp [h]
intros
cases v
reflexivity
intros
rw ‚Üê bind_pure_comp_eq_map _ x.run
change x.run >>= except_t.bind_cont (pure ‚àò f) = _
apply bind_ext_congr
intro a; cases a; simp [except_t.bind_cont, except.map]
intro a; cases a
intro a
cases a
simp [except_t.bind_cont, except.map]
simp [except_t.bind_cont, except.map]
intros
cases b
cases b; exact dec_trivial
exact dec_trivial
exact dec_trivial
intros
have h := int.add_le_add_right h (-b)
rwa int.add_neg_cancel_right at h
intros
induction t; simp [*]
induction t
simp [*]
simp [*]
intros
rw [nat.mul_comm, nat.mul_div_cancel _ H]
intros
rw nat.add_comm; exact nat.lt_add_of_pos_right h
rw nat.add_comm
exact nat.lt_add_of_pos_right h
intros
induction x using nat.case_strong_induction_on with x ih
{ rw zero_mod, assumption }
rw zero_mod
assumption
by_cases h‚ÇÅ : succ x < y
{ by_cases h‚ÇÅ : succ x < y, { rwa [mod_eq_of_lt h‚ÇÅ] }, { have h‚ÇÅ : succ x % y = (succ x - y) % y := mod_eq_sub_mod (not_lt.1 h‚ÇÅ), have : succ x - y ‚â§ x := le_of_lt_succ (nat.sub_lt (succ_pos x) h), have h‚ÇÇ : (succ x - y) % y < y := ih _ this, rwa [‚Üê h‚ÇÅ] at h‚ÇÇ } }
{ rwa [mod_eq_of_lt h‚ÇÅ] }
rwa [mod_eq_of_lt h‚ÇÅ]
have h‚ÇÅ : succ x % y = (succ x - y) % y := mod_eq_sub_mod (not_lt.1 h‚ÇÅ)
{ have h‚ÇÅ : succ x % y = (succ x - y) % y := mod_eq_sub_mod (not_lt.1 h‚ÇÅ), have : succ x - y ‚â§ x := le_of_lt_succ (nat.sub_lt (succ_pos x) h), have h‚ÇÇ : (succ x - y) % y < y := ih _ this, rwa [‚Üê h‚ÇÅ] at h‚ÇÇ }
have : succ x - y ‚â§ x := le_of_lt_succ (nat.sub_lt (succ_pos x) h)
have h‚ÇÇ : (succ x - y) % y < y := ih _ this
rwa [‚Üê h‚ÇÅ] at h‚ÇÇ
intros
tactic.mk_inj_eq
intros
rw [‚Üêvadd_vsub g1, h, vadd_vsub]
intros
split
intro h
{ intro h, rw [‚Üê not_lt], intro hmn, apply h1, have : x ^ m * x ‚à£ x ^ m * 1, { rw [‚Üê pow_succ', mul_one], exact (pow_dvd_pow _ (nat.succ_le_of_lt hmn)).trans h }, rwa [mul_dvd_mul_iff_left, ‚Üê is_unit_iff_dvd_one] at this, apply pow_ne_zero m h0 }
rw [‚Üê not_lt]
intro hmn
apply h1
have : x ^ m * x ‚à£ x ^ m * 1
rw [‚Üê pow_succ', mul_one]
{ rw [‚Üê pow_succ', mul_one], exact (pow_dvd_pow _ (nat.succ_le_of_lt hmn)).trans h }
exact (pow_dvd_pow _ (nat.succ_le_of_lt hmn)).trans h
rwa [mul_dvd_mul_iff_left, ‚Üê is_unit_iff_dvd_one] at this
apply pow_ne_zero m h0
{ apply pow_dvd_pow }
apply pow_dvd_pow
intros
rw prod_ite
{ rw prod_ite, simp [filter_false_of_mem h, filter_true_of_mem h] }
simp [filter_false_of_mem h, filter_true_of_mem h]
intros
rw [‚Üê mul_support_mul_indicator] at hf hg
simp only [finprod_mem_def, mul_indicator_mul, finprod_mul_distrib hf hg]
intros
simp_rw [‚Üê finprod_eq_dif]
rw [finprod_dmem, finprod_mem_range hf, finprod_congr (Œª a, _)]
rw [dif_pos (set.mem_range_self a), hf (classical.some_spec (set.mem_range_self a))]
intros
rw [eq_sub_iff_add_eq, ‚Üê add_pow_char_of_commute _ _ _ (commute.sub_left h rfl)]
simp
apply_instance
repeat {apply_instance}
apply_instance
intros
induction n with n IH generalizing g
simp
case nat.zero { simp }
case nat.succ { let g' := squash_gcf g n, suffices : g.convergents (n + 1) = g'.convergents' n, by rwa [succ_nth_convergent'_eq_squash_gcf_nth_convergent'], cases decidable.em (terminated_at g n) with terminated_at_n not_terminated_at_n, { have g'_eq_g : g' = g, from squash_gcf_eq_self_of_terminated terminated_at_n, rw [(convergents_stable_of_terminated n.le_succ terminated_at_n), g'_eq_g, (IH _)], assume _ _ m_lt_n s_mth_eq, exact (s_pos (nat.lt.step m_lt_n) s_mth_eq) }, { suffices : g.convergents (n + 1) = g'.convergents n, by { rwa ‚Üê IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }, refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }, have : ‚àÄ ‚¶Éb‚¶Ñ, g.partial_denominators.nth n = some b ‚Üí b ‚â† 0, by { assume b nth_part_denom_eq, obtain ‚ü®gp, s_nth_eq, ‚ü®refl‚ü©‚ü© : ‚àÉ gp, g.s.nth n = some gp ‚àß gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }, exact succ_nth_convergent_eq_squash_gcf_nth_convergent this } }
let g' := squash_gcf g n
suffices : g.convergents (n + 1) = g'.convergents' n
rwa [succ_nth_convergent'_eq_squash_gcf_nth_convergent']
rwa [succ_nth_convergent'_eq_squash_gcf_nth_convergent']
cases decidable.em (terminated_at g n) with terminated_at_n not_terminated_at_n
have g'_eq_g : g' = g
{ have g'_eq_g : g' = g, from squash_gcf_eq_self_of_terminated terminated_at_n, rw [(convergents_stable_of_terminated n.le_succ terminated_at_n), g'_eq_g, (IH _)], assume _ _ m_lt_n s_mth_eq, exact (s_pos (nat.lt.step m_lt_n) s_mth_eq) }
from squash_gcf_eq_self_of_terminated terminated_at_n
rw [(convergents_stable_of_terminated n.le_succ terminated_at_n), g'_eq_g, (IH _)]
assume _ _ m_lt_n s_mth_eq
exact (s_pos (nat.lt.step m_lt_n) s_mth_eq)
suffices : g.convergents (n + 1) = g'.convergents n
{ suffices : g.convergents (n + 1) = g'.convergents n, by { rwa ‚Üê IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }, refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }, have : ‚àÄ ‚¶Éb‚¶Ñ, g.partial_denominators.nth n = some b ‚Üí b ‚â† 0, by { assume b nth_part_denom_eq, obtain ‚ü®gp, s_nth_eq, ‚ü®refl‚ü©‚ü© : ‚àÉ gp, g.s.nth n = some gp ‚àß gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }, exact succ_nth_convergent_eq_squash_gcf_nth_convergent this }
rwa ‚Üê IH
rwa ‚Üê IH
{ rwa ‚Üê IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }, refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }
{ rwa ‚Üê IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }, refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }
assume gp' m m_lt_n s_mth_eq'
assume gp' m m_lt_n s_mth_eq'
cases m_lt_n with n succ_m_lt_n
cases m_lt_n with n succ_m_lt_n
obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m
obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m
{ obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }, refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }
{ obtain ‚ü®gp_succ_m, s_succ_mth_eq‚ü© : ‚àÉ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }, refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }
from option.ne_none_iff_exists'.mp not_terminated_at_n
from option.ne_none_iff_exists'.mp not_terminated_at_n
obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m
obtain ‚ü®gp_m, mth_s_eq‚ü© : ‚àÉ gp_m, g.s.nth m = some gp_m
from g.s.ge_stable m.le_succ s_succ_mth_eq
from g.s.ge_stable m.le_succ s_succ_mth_eq
suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b
suffices : 0 < gp_m.a ‚àß 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b
have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©
have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©
have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©
{ have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }
{ have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }
{ have ot : g'.s.nth m = some ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©, by cc, rwa this }
from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq
from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq
from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq
have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©
have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©
have : gp' = ‚ü®gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b‚ü©
cc
cc
cc
cc
rwa this
rwa this
rwa this
refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©
refine ‚ü®(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _‚ü©
refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _
refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _
have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq
have : 0 < gp_succ_m.a ‚àß 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq
exact (div_pos this.left this.right)
exact (div_pos this.left this.right)
refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _
refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _
{ refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' }
{ refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' }
exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq'
exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq'
have : ‚àÄ ‚¶Éb‚¶Ñ, g.partial_denominators.nth n = some b ‚Üí b ‚â† 0
assume b nth_part_denom_eq
assume b nth_part_denom_eq
{ assume b nth_part_denom_eq, obtain ‚ü®gp, s_nth_eq, ‚ü®refl‚ü©‚ü© : ‚àÉ gp, g.s.nth n = some gp ‚àß gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }
{ assume b nth_part_denom_eq, obtain ‚ü®gp, s_nth_eq, ‚ü®refl‚ü©‚ü© : ‚àÉ gp, g.s.nth n = some gp ‚àß gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }
obtain ‚ü®gp, s_nth_eq, ‚ü®refl‚ü©‚ü© : ‚àÉ gp, g.s.nth n = some gp ‚àß gp.b = b
obtain ‚ü®gp, s_nth_eq, ‚ü®refl‚ü©‚ü© : ‚àÉ gp, g.s.nth n = some gp ‚àß gp.b = b
from exists_s_b_of_part_denom nth_part_denom_eq
from exists_s_b_of_part_denom nth_part_denom_eq
exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm
exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm
exact succ_nth_convergent_eq_squash_gcf_nth_convergent this
intros
rw is_symm_op.flip_eq
intros
letI : Œ† m : M, decidable (m ‚â† 0) := classical.dec_pred _
exact (dfinsupp.to_finsupp_single i m)
intros
simp only [mul_comm, gcd_mul_left]
intros
rw [‚Üê @inv_inj _ _ a 1, one_inv]
intros
rw add_comm; apply sub_add_sub_cancel
rw add_comm
apply sub_add_sub_cancel
intros
rw [‚Üê mul_assoc, inv_mul, one_mul]
intros
ext
ext; refl
refl
intros
split_ifs; refl
split_ifs
refl
refl
intros
rcases neg_one_pow_eq_or R n; simp [h]
rcases neg_one_pow_eq_or R n
simp [h]
simp [h]
intros
simp only [le_antisymm_iff, pow_le_one_iff hn, one_le_pow_iff hn]
intros
by_cases h : a = 0
{ rw [h, inv_zero, mul_zero] }
rw [h, inv_zero, mul_zero]
{ rw [mul_inv_cancel h, one_mul] }
rw [mul_inv_cancel h, one_mul]
intros
simpa only [one_div] using inv_ne_zero h
intros
rw div_div_eq_mul_div
exact mul_self_div_self a
intros
simp [C.d_from_eq r]
intros
{ ext, simp, }
ext
simp
intros
refine (mul_indicator_congr $ Œª x hx, _).trans mul_indicator_mul_support
have : g x = 1
from nmem_mul_support.1 (disjoint_left.1 h hx)
rw [pi.mul_apply, this, mul_one]
intros
induction n with d hd
{ simpa }
simpa
{ simp [‚Üê pow_succ, hd] }
simp [‚Üê pow_succ, hd]
intros
split
rintros ‚ü®h‚ü©
{ rintros ‚ü®h‚ü©, ext, simp only [mem_max_triv_submodule, h, forall_const, true_iff, eq_self_iff_true], }
ext
simp only [mem_max_triv_submodule, h, forall_const, true_iff, eq_self_iff_true]
intros h
{ intros h, constructor, intros x m, revert x, rw [‚Üê mem_max_triv_submodule R L M, h], exact lie_submodule.mem_top m, }
constructor
intros x m
revert x
rw [‚Üê mem_max_triv_submodule R L M, h]
exact lie_submodule.mem_top m
intros
rw lie_algebra.ad_eq_lmul_left_sub_lmul_right
have hl : is_nilpotent (algebra.lmul_left R a)
rwa algebra.is_nilpotent_lmul_left_iff
{ rwa algebra.is_nilpotent_lmul_left_iff, }
have hr : is_nilpotent (algebra.lmul_right R a)
rwa algebra.is_nilpotent_lmul_right_iff
{ rwa algebra.is_nilpotent_lmul_right_iff, }
exact (algebra.commute_lmul_left_right R a a).is_nilpotent_sub hl hr
intros
simp [skew_adjoint_lie_subalgebra_equiv]
intros
{ apply lie_submodule.subset_lie_span, use x, exact ‚ü®hx, rfl‚ü©, }
apply lie_submodule.subset_lie_span
use x
exact ‚ü®hx, rfl‚ü©
intros
{ cases p, refl, }
cases p
refl
intros
simp only [f.map_nsmul]
intros
rintro y ‚ü®x, hx, rfl‚ü©
exact smul_of_tower_mem _ a hx
intros
simp only [lift_apply', algebra.smul_def]
intros
rwa [le_inv (@zero_lt_one Œ± _ _) h‚ÇÅ, inv_one]
intros
rwa [lt_one_div (@zero_lt_one Œ± _ _) h1, one_div_one]
intros
split
intro h
{ intro h, refine or.imp (Œª h', _) (Œª h', _) (le_total a b); exact ‚ü®by simpa [h'] using h, h'‚ü© }
refine or.imp (Œª h', _) (Œª h', _) (le_total a b); exact ‚ü®by simpa [h'] using h, h'‚ü©
refine or.imp (Œª h', _) (Œª h', _) (le_total a b)
exact ‚ü®by simpa [h'] using h, h'‚ü©
exact ‚ü®by simpa [h'] using h, h'‚ü©
rintro (‚ü®rfl, h‚ü©|‚ü®rfl, h‚ü©); simp [h]
rintro (‚ü®rfl, h‚ü©|‚ü®rfl, h‚ü©)
{ rintro (‚ü®rfl, h‚ü©|‚ü®rfl, h‚ü©); simp [h] }
simp [h]
simp [h]
intros
rw [‚Üê mul_lt_mul_iff_left d, ‚Üê mul_lt_mul_iff_right b, mul_inv_cancel_left, mul_assoc, inv_mul_cancel_right]
intros
rcases le_total a 1 with h|h; simp [h]
{ rcases le_total a 1 with h|h; simp [h] }
rcases le_total a 1 with h|h
simp [h]
simp [h]
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioc]
split
rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©
{ rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©, split, exact (mul_lt_mul_left hr).mpr a_h_left_left, exact (mul_le_mul_left hr).mpr a_h_left_right, }
split
exact (mul_lt_mul_left hr).mpr a_h_left_left
exact (mul_le_mul_left hr).mpr a_h_left_right
rintro ‚ü®a_left, a_right‚ü©
{ rintro ‚ü®a_left, a_right‚ü©, use x / r, refine ‚ü®‚ü®(lt_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right‚ü©, _‚ü©, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ‚ü®‚ü®(lt_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right‚ü©, _‚ü©
rw mul_div_cancel' _ (ne_of_gt hr)
intros
cases abs_choice a with h h; simp only [h, odd_neg]
{ cases abs_choice a with h h; simp only [h, odd_neg] }
cases abs_choice a with h h
simp only [h, odd_neg]
simp only [h, odd_neg]
intros
haveI := @linear_order.decidable_le Œ± _; exact Œª x y h, decidable.mul_lt_mul (hf h) (hg h.le) (hg0 x) (hf0 y)
haveI := @linear_order.decidable_le Œ± _
exact Œª x y h, decidable.mul_lt_mul (hf h) (hg h.le) (hg0 x) (hf0 y)
intros
simpa only [sub_add_cancel] using (h (x - c)).symm
intros
{ rw mem_finset_prod, exact ‚ü®g, hg, rfl‚ü© }
rw mem_finset_prod
exact ‚ü®g, hg, rfl‚ü©
intros
rw image_eq_preimage_of_inverse; intro c; simp
rw image_eq_preimage_of_inverse; intro c
{ rw image_eq_preimage_of_inverse; intro c; simp }
rw image_eq_preimage_of_inverse
intro c
simp
intro c
simp
intros
rw [‚Üê smul_eval_smul, smul_inv_smul]
intros
{ rw norm_sq_def', apply_rules [sq_nonneg, add_nonneg] }
rw norm_sq_def'
apply_rules [sq_nonneg, add_nonneg]
intros
rintros y ‚ü®z, hz‚ü©
rw mul_assoc at hz
rcases h.is_unit_or_is_unit hz with hu | hu
{ exact hu }
exact hu
{ apply is_unit_of_mul_is_unit_left hu }
apply is_unit_of_mul_is_unit_left hu
intros
rw mul_support_subset_iff'
simp only [mem_Union, not_exists, nmem_mul_support]
intros x hx
simp only [hx, csupr_const]
intros
simp [comp_partial_sum_target, comp_partial_sum_target_set]
intros
split
rintros h
{ rintros h, rcases h.exists_nonneg with ‚ü®c, hnnc, hc‚ü©, rcases hc.exists_eq_mul hnnc with ‚ü®œÜ, hœÜ, huvœÜ‚ü©, exact ‚ü®œÜ, ‚ü®c, hœÜ‚ü©, huvœÜ‚ü© }
rcases h.exists_nonneg with ‚ü®c, hnnc, hc‚ü©
rcases hc.exists_eq_mul hnnc with ‚ü®œÜ, hœÜ, huvœÜ‚ü©
exact ‚ü®œÜ, ‚ü®c, hœÜ‚ü©, huvœÜ‚ü©
rintros ‚ü®œÜ, ‚ü®c, hœÜ‚ü©, huvœÜ‚ü©
{ rintros ‚ü®œÜ, ‚ü®c, hœÜ‚ü©, huvœÜ‚ü©, exact is_O_iff_is_O_with.2 ‚ü®c, is_O_with_of_eq_mul œÜ hœÜ huvœÜ‚ü© }
exact is_O_iff_is_O_with.2 ‚ü®c, is_O_with_of_eq_mul œÜ hœÜ huvœÜ‚ü©
intros
simp only [is_O_with, norm_norm]
intros
simp [is_O, is_O_with]
intros
simpa only [one_apply, one_smul, smul_right_apply, coe_comp', (‚àò)] using (hl.comp x hf.has_fderiv_within_at hst).has_deriv_within_at
intros
have := (hc.has_fderiv_at.clm_apply hu.has_fderiv_at).has_deriv_at
rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv, rwa filter.eventually_eq.fderiv_eq }
unfold deriv
rwa filter.eventually_eq.fderiv_eq
intros
rcases hf with ‚ü®f', hf'‚ü©
rcases hg with ‚ü®g', hg'‚ü©
exact ‚ü®continuous_linear_map.comp g' f', hg'.comp x hf' h‚ü©
intros
{ convert hc.mul' hd, ext z, apply mul_comm }
convert hc.mul' hd
ext z
apply mul_comm
intros
simp [has_fderiv_within_at, nhds_within_restrict'' s h]
intros
rw subsingleton_iff at h
have key : function.const X (f 0) = f := by ext x'; rw h x' 0
exact key ‚ñ∏ (has_fderiv_at_const (f 0) _)
intros
apply implicit_to_local_homeomorph_of_complemented_self
intros
apply lhopital_zero_nhds'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds; assumption
apply lhopital_zero_nhds'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds
apply lhopital_zero_nhds'
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
intros
rw [smooth_transition, zero_of_nonpos h, zero_div]
intros
simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ, has_ftaylor_series_up_to_on_zero_iff]
intros
simp [norm_sq_eq_abs]
intros
contrapose! h
have : cd 0 = 0
apply_fun complex.im at h
{ apply_fun complex.im at h, simpa only [z.im_ne_zero, complex.add_im, add_zero, coe_im, zero_mul, or_false, complex.of_real_im, complex.zero_im, complex.mul_im, mul_eq_zero] using h, }
simpa only [z.im_ne_zero, complex.add_im, add_zero, coe_im, zero_mul, or_false, complex.of_real_im, complex.zero_im, complex.mul_im, mul_eq_zero] using h
simp only [this, zero_mul, complex.of_real_zero, zero_add, complex.of_real_eq_zero] at h
ext i
fin_cases i; assumption
fin_cases i
assumption
assumption
intros
rw convex_iff_segment_subset
exact forall‚ÇÇ_congr (Œª x y, forall‚ÇÇ_congr $ Œª hx hy, (open_segment_subset_iff_segment_subset hx hy).symm)
intros
{ convert hs.add_smul_sub_mem_interior hx hy ht, abel }
convert hs.add_smul_sub_mem_interior hx hy ht
abel
intros
rw [‚Üêzero_smul ùïú (0 : F), inner_smul_left]; simp only [zero_mul, ring_hom.map_zero]
rw [‚Üêzero_smul ùïú (0 : F), inner_smul_left]
simp only [zero_mul, ring_hom.map_zero]
intros
rw set.sUnion_eq_Union; exact orthonormal_Union_of_directed hs.directed_coe (by simpa using h)
rw set.sUnion_eq_Union
exact orthonormal_Union_of_directed hs.directed_coe (by simpa using h)
intros
rw [dist_eq_norm, vsub_sub_vsub_cancel_left, dist_comm, dist_eq_norm_vsub V]
intros
rw [real.norm_eq_abs, x.abs_eq]
intros
rw [mem_ball, dist_zero_right]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
have := x.norm_def
{ have := x.norm_def, simp only [‚Üê coe_nnnorm] at this, exact_mod_cast this }
simp only [‚Üê coe_nnnorm] at this
exact_mod_cast this
intros
rw exp_series_radius_eq_top
exact with_top.zero_lt_top
intros
simp
intros
{ ext, exact f.map_zero }
ext
exact f.map_zero
intros
convert inverse_add_norm_diff_nth_order x 1; simp
{ convert inverse_add_norm_diff_nth_order x 1; simp }
convert inverse_add_norm_diff_nth_order x 1
simp
simp
intros
simp [absorbs, absorbent]
intros
refine (continuous_const.div _ (Œª x, _)).interval_integrable a b
{ continuity }
continuity
{ nlinarith }
nlinarith
intros
simpa using integral_sin_pow_odd_mul_cos_pow 1 0
intros
simp [*, mul_rpow_eq_ite]
intros
convert (@has_strict_fderiv_at_cpow ((Œª x, (f x, g x)) x) h0).comp x (hf.prod hg)
intros
simp only [sub_eq_add_neg, rpow_add hx, rpow_neg (le_of_lt hx), div_eq_mul_inv]
intros
rw [rpow_def_of_pos hx, one_lt_exp_iff, mul_pos_iff, log_pos_iff hx, log_neg_iff hx]
intros
rw [‚Üê tan_div_sqrt_one_add_tan_sq (cos_arctan_pos x), tan_arctan]
intros
simp [sub_eq_add_neg, sin_add]
intros
rw [sin_sq, cos_pi_over_two_pow]
intros
cases le_total x (-1) with hx‚ÇÅ hx‚ÇÅ
simp [arcsin_of_le_neg_one hx‚ÇÅ, hy.1, hx‚ÇÅ.trans (neg_one_le_sin _)]
{ simp [arcsin_of_le_neg_one hx‚ÇÅ, hy.1, hx‚ÇÅ.trans (neg_one_le_sin _)] }
cases lt_or_le 1 x with hx‚ÇÇ hx‚ÇÇ
simp [arcsin_of_one_le hx‚ÇÇ.le, hy.2.not_le, (sin_le_one y).trans_lt hx‚ÇÇ]
{ simp [arcsin_of_one_le hx‚ÇÇ.le, hy.2.not_le, (sin_le_one y).trans_lt hx‚ÇÇ] }
exact arcsin_le_iff_le_sin ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© (mem_Icc_of_Ico hy)
intros
subst y
exact inj_on_sin (arcsin_mem_Icc _) h‚ÇÇ (sin_arcsin' (sin_mem_Icc x))
intros
rcases exists_between hr with ‚ü®r', hrr', h‚ü©
exact summable_of_is_O_nat (summable_geometric_of_lt_1 ((norm_nonneg _).trans hrr'.le) h) (is_o_pow_const_mul_const_pow_const_pow_of_norm_lt _ hrr').is_O.norm_left
intros
convert finset.card_fin n
apply fintype.of_equiv_card
intros
dsimp [transfer_nat_trans_self]
rw [id_comp, comp_id]
have := transfer_nat_trans_counit adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.left_unitor.hom ‚â´ f ‚â´ L‚ÇÅ.right_unitor.inv) X
dsimp at this
rw this
simp
intros
erw [iso.inv_eq_inv (e.functor.map_iso (e.unit_iso.app X) ‚â™‚â´ e.counit_iso.app (e.functor.obj X)) (iso.refl _)]
exact e.functor_unit_comp X
intros
apply zigzag_is_connected
intros j‚ÇÅ j‚ÇÇ
rcases h j‚ÇÅ j‚ÇÇ with ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü©
apply list.relation_refl_trans_gen_of_exists_chain l hl‚ÇÅ hl‚ÇÇ
intros
simp only [cancel_mono]
intros
apply (cancel_epi (colimit_obj_iso_colimit_comp_evaluation H k).inv).1
ext
simpa using w j
intros
ext j
rw [‚Üêassoc, colimit.Œπ_pre, colimit.Œπ_pre]
letI : has_colimit ((D ‚ãô E) ‚ãô F) := show has_colimit (D ‚ãô E ‚ãô F), by apply_instance
exact (colimit.Œπ_pre F (D ‚ãô E) j).symm
intros
simp
intros
ext
ext; simp [add_comp]
simp [add_comp]
simp [add_comp]
intros
ext j j'
simp [comp_sum, sum_comp, biproduct.Œπ_œÄ, comp_dite, dite_comp]
intros
simp
intros
{ ext, simp [‚Üê G.map_comp] }
ext
simp [‚Üê G.map_comp]
intros
ext
intros
rw [‚Üêcancel_mono (Œª_ Y).hom, left_unitor_naturality, left_unitor_naturality]
{ rw [‚Üêcancel_mono (Œª_ Y).hom, left_unitor_naturality, left_unitor_naturality], simp }
simp
intros
{ simp [tensor_left_tensor], }
simp [tensor_left_tensor]
intros
simp only [right_adjoint_mate, monoidal_category.tensor_id, category.id_comp, coevaluation_evaluation_assoc, category.comp_id, iso.inv_hom_id]
intros
fsplit
introsI E X f e e_epi
obtain ‚ü®f', hf'‚ü© := projective.factors (i.hom ‚â´ f) e
exact ‚ü®i.inv ‚â´ f', by simp [hf']‚ü©
intros
rw [‚Üêfunctor.map_comp,prod_comp,category.comp_id]
intros
intros s hs
let y : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), presieve.family_of_elements P (B hf) := Œª Y f hf Z g hg, s _ (presieve.bind_comp _ _ hg)
have hy : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), (y hf).compatible
intros Y f H Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm
{ intros Y f H Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm, apply hs, apply reassoc_of comm }
apply hs
apply reassoc_of comm
let t : presieve.family_of_elements P U := Œª Y f hf, (hB hf).amalgamate (y hf) (hy hf)
have ht : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), (y hf).is_amalgamation (t f hf) := Œª Y f hf, (hB hf).is_amalgamation _
have hT : t.compatible
rw presieve.compatible_iff_sieve_compatible
{ rw presieve.compatible_iff_sieve_compatible, intros Z W f h hf, apply (hB (U.downward_closed hf h)).is_separated_for.ext, intros Y l hl, apply (hB' hf (l ‚â´ h)).ext, intros M m hm, have : bind U B (m ‚â´ l ‚â´ h ‚â´ f), { have : bind U B _ := presieve.bind_comp f hf hm, simpa using this }, transitivity s (m ‚â´ l ‚â´ h ‚â´ f) this, { have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m), rw [op_comp, functor_to_types.map_comp_apply] at this, rw this, change s _ _ = s _ _, simp }, { have : s _ _ = _ := (ht hf _ hm).symm, simp only [assoc] at this, rw this, simp } }
intros Z W f h hf
apply (hB (U.downward_closed hf h)).is_separated_for.ext
intros Y l hl
apply (hB' hf (l ‚â´ h)).ext
intros M m hm
have : bind U B (m ‚â´ l ‚â´ h ‚â´ f)
have : bind U B _ := presieve.bind_comp f hf hm
{ have : bind U B _ := presieve.bind_comp f hf hm, simpa using this }
simpa using this
transitivity s (m ‚â´ l ‚â´ h ‚â´ f) this
have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m)
{ have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m), rw [op_comp, functor_to_types.map_comp_apply] at this, rw this, change s _ _ = s _ _, simp }
rw [op_comp, functor_to_types.map_comp_apply] at this
rw this
change s _ _ = s _ _
simp
have : s _ _ = _ := (ht hf _ hm).symm
{ have : s _ _ = _ := (ht hf _ hm).symm, simp only [assoc] at this, rw this, simp }
simp only [assoc] at this
rw this
simp
refine ‚ü®hU.amalgamate t hT, _, _‚ü©
rintro Z _ ‚ü®Y, f, g, hg, hf, rfl‚ü©
{ rintro Z _ ‚ü®Y, f, g, hg, hf, rfl‚ü©, rw [op_comp, functor_to_types.map_comp_apply, presieve.is_sheaf_for.valid_glue _ _ _ hg], apply ht hg _ hf }
rw [op_comp, functor_to_types.map_comp_apply, presieve.is_sheaf_for.valid_glue _ _ _ hg]
apply ht hg _ hf
intros y hy
{ intros y hy, apply hU.is_separated_for.ext, intros Y f hf, apply (hB hf).is_separated_for.ext, intros Z g hg, rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, hy _ (presieve.bind_comp _ _ hg), hU.valid_glue _ _ hf, ht hf _ hg] }
apply hU.is_separated_for.ext
intros Y f hf
apply (hB hf).is_separated_for.ext
intros Z g hg
rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, hy _ (presieve.bind_comp _ _ hg), hU.valid_glue _ _ hf, ht hf _ hg]
intros
{ ext, simp, }
ext
simp
intros
simp [image_subobject_iso]
intros
rw [colex.lt_def]
refine ‚ü®max' _ hA, _, by simp, max'_mem _ _‚ü©
simp only [false_iff, not_mem_empty]
intros x hx t
apply not_le_of_lt hx (le_max' _ _ t)
intros
simp_rw [coe_inv_embedding, index_embedding, coe_embedding, nat.add_sub_cancel_left]
intros
have : c.blocks.take c.length = c.blocks := take_all_of_le (by simp [blocks])
rw [‚Üê this, c.blocks_partial_sum c.length_lt_card_boundaries, c.boundary_length]
refl
intros
haveI := classical.dec_eq Œπ
convert ht (s'.image coe) using 1
{ rw card_image_of_injective _ subtype.coe_injective, }
rw card_image_of_injective _ subtype.coe_injective
apply congr_arg
{ apply congr_arg, ext y, simp, }
ext y
simp
intros
simp [neighbor_finset_eq_filter, dot_product, sum_filter, finset.sum_apply]
intros
induction hf
exact zero
case nat.primrec.zero { exact zero }
exact succ
case nat.primrec.succ { exact succ }
exact left
case nat.primrec.left { exact left }
exact right
case nat.primrec.right { exact right }
case nat.primrec.pair : f g hf hg pf pg { refine (pf.pair pg).of_eq_tot (Œª n, _), simp [has_seq.seq] }
case nat.primrec.comp : f g hf hg pf pg { refine (pf.comp pg).of_eq_tot (Œª n, _), simp }
case nat.primrec.prec : f g hf hg pf pg { refine (pf.prec pg).of_eq_tot (Œª n, _), simp, induction n.unpair.2 with m IH, {simp}, simp, exact ‚ü®_, IH, rfl‚ü© }
intros
rw [‚Üê proj_map_nth, hL, ‚Üê list.map_reverse, list_blank.nth_mk, list.inth, list.nth_map]
cases S.reverse.nth n; refl
cases S.reverse.nth n
refl
refl
intros
rw [‚Üê bind_pure_comp_eq_map,bind_assoc]; simp [bind_pure_comp_eq_map]
rw [‚Üê bind_pure_comp_eq_map,bind_assoc]
simp [bind_pure_comp_eq_map]
intros
simp [sequence, traverse_map, id_traverse]; refl
simp [sequence, traverse_map, id_traverse]
refl
intros
simp [nth_le_to_list]
intros
{ introI, exact hne (of_fail h) }
introI
exact hne (of_fail h)
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, ‚Üêorelse_eq_orelse, parser.orelse]
by_cases h : np = n
{ by_cases h : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse] }, { have : n ‚â§ nq := mono.of_fail hq, rcases eq_or_lt_of_le this with rfl|H, { simp [hp, hq, h, hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, hn, H, ‚Üêorelse_eq_orelse, parser.orelse] } } }, { simp [hp, h, ‚Üêorelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse] }, { have : n ‚â§ nq := mono.of_fail hq, rcases eq_or_lt_of_le this with rfl|H, { simp [hp, hq, h, hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, hn, H, ‚Üêorelse_eq_orelse, parser.orelse] } } }
{ simp [hp, h, hn, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, h, hn, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse]
have : n ‚â§ nq := mono.of_fail hq
{ have : n ‚â§ nq := mono.of_fail hq, rcases eq_or_lt_of_le this with rfl|H, { simp [hp, hq, h, hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, hn, H, ‚Üêorelse_eq_orelse, parser.orelse] } }
rcases eq_or_lt_of_le this with rfl|H
simp [hp, hq, h, hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, hn, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hq, h, hn, H, ‚Üêorelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, hn, H, ‚Üêorelse_eq_orelse, parser.orelse] }
{ simp [hp, h, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, h, ‚Üêorelse_eq_orelse, parser.orelse]
intros
simp only [char_buf, decorate_error_eq_done, ne.def, ‚Üêbuffer.length_to_list]
induction cb'.to_list with hd tl hl generalizing cb n n'
simp [pure_eq_done, mmap'_eq_done, -buffer.length_to_list, list.nil_prefix]
{ simp [pure_eq_done, mmap'_eq_done, -buffer.length_to_list, list.nil_prefix] }
simp only [ch_eq_done, and.comm, and.assoc, and.left_comm, hl, mmap', and_then_eq_bind, bind_eq_done, list.length, exists_and_distrib_left, exists_const]
{ simp only [ch_eq_done, and.comm, and.assoc, and.left_comm, hl, mmap', and_then_eq_bind, bind_eq_done, list.length, exists_and_distrib_left, exists_const], split, { rintro ‚ü®np, h, rfl, rfl, hn, rfl‚ü©, simp only [add_comm, add_left_comm, h, true_and, eq_self_iff_true, and_true], have : n < cb.to_list.length := by simpa using hn, rwa [‚Üêbuffer.nth_le_to_list _ this, ‚Üêlist.cons_nth_le_drop_succ this, list.prefix_cons_inj] }, { rintro ‚ü®h, rfl‚ü©, by_cases hn : n < cb.size, { have : n < cb.to_list.length := by simpa using hn, rw [‚Üêlist.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h, use [n + 1, h.right], simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm }, { have : cb.to_list.length ‚â§ n := by simpa using hn, rw list.drop_eq_nil_of_le this at h, simpa using h } } }
split
rintro ‚ü®np, h, rfl, rfl, hn, rfl‚ü©
{ rintro ‚ü®np, h, rfl, rfl, hn, rfl‚ü©, simp only [add_comm, add_left_comm, h, true_and, eq_self_iff_true, and_true], have : n < cb.to_list.length := by simpa using hn, rwa [‚Üêbuffer.nth_le_to_list _ this, ‚Üêlist.cons_nth_le_drop_succ this, list.prefix_cons_inj] }
simp only [add_comm, add_left_comm, h, true_and, eq_self_iff_true, and_true]
have : n < cb.to_list.length := by simpa using hn
rwa [‚Üêbuffer.nth_le_to_list _ this, ‚Üêlist.cons_nth_le_drop_succ this, list.prefix_cons_inj]
rintro ‚ü®h, rfl‚ü©
{ rintro ‚ü®h, rfl‚ü©, by_cases hn : n < cb.size, { have : n < cb.to_list.length := by simpa using hn, rw [‚Üêlist.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h, use [n + 1, h.right], simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm }, { have : cb.to_list.length ‚â§ n := by simpa using hn, rw list.drop_eq_nil_of_le this at h, simpa using h } }
by_cases hn : n < cb.size
have : n < cb.to_list.length := by simpa using hn
{ have : n < cb.to_list.length := by simpa using hn, rw [‚Üêlist.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h, use [n + 1, h.right], simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm }
rw [‚Üêlist.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h
use [n + 1, h.right]
simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm
have : cb.to_list.length ‚â§ n := by simpa using hn
{ have : cb.to_list.length ‚â§ n := by simpa using hn, rw list.drop_eq_nil_of_le this at h, simpa using h }
rw list.drop_eq_nil_of_le this at h
simpa using h
intros
simp [sep_by1, seq_eq_done]
simp [inv_eq_one_div]
intros
subst er; exact exp_approx_succ _ e‚ÇÅ _ _ (by simpa using e) (exp_approx_end _ _ _ e‚ÇÅ h)
subst er
exact exp_approx_succ _ e‚ÇÅ _ _ (by simpa using e) (exp_approx_end _ _ _ e‚ÇÅ h)
intros
rw [‚Üê mul_right_inj' (@two_ne_zero' ‚ÑÇ _ _ _), two_cosh, two_cos, neg_mul_eq_neg_mul]
intros
rw [add_comm, sin_sq_add_cos_sq]
intros
simp [ext_iff]
intros
rw [‚Üê of_real_int_cast, of_real_re]
intros
{ ext, simp only [map_range_apply, coe_zero, pi.zero_apply, hf] }
ext
simp only [map_range_apply, coe_zero, pi.zero_apply, hf]
intros
classical
exact quotient.induction_on f (Œª x, x.2.to_finset.finite_to_set.subset (Œª i H, multiset.mem_to_finset.2 ((x.3 i).resolve_right H)))
intros
{ ext ‚ü®a, b‚ü© : 1, simp }
ext ‚ü®a, b‚ü© : 1
simp
intros
ext x
cases x
{ simp [sum.map, swap_apply_of_ne_of_ne] }
simp [sum.map, swap_apply_of_ne_of_ne]
simp [sum.map, swap_apply_def]
{ simp [sum.map, swap_apply_def], split_ifs; refl}
split_ifs; refl
split_ifs
refl
refl
refl
intros
{ ext, simp }
ext
simp
intros
rw [‚Üê fin.succ_above_above _ _ h, fin_succ_equiv'_succ_above]
intros
{ substs f g s t, cases e, refl }
substs f g s t
cases e
refl
intros
ext j
by_cases h : j.val < n
have : j ‚â† last n := ne_of_lt h
{ have : j ‚â† last n := ne_of_lt h, simp [h, update_noteq, this, snoc] }
simp [h, update_noteq, this, snoc]
rw eq_last_of_not_lt h
{ rw eq_last_of_not_lt h, simp }
simp
intros
{ subst h, ext, simp }
subst h
ext
simp
intros
classical
{ classical, ext x, simp, split_ifs with h; by_cases h' : x = a; simp [h, h'] }
ext x
simp
split_ifs with h
split_ifs with h; by_cases h' : x = a; simp [h, h']
split_ifs with h; by_cases h' : x = a
by_cases h' : x = a
simp [h, h']
simp [h, h']
by_cases h' : x = a
simp [h, h']
simp [h, h']
intros
rw [coe_singleton, set.singleton_subset_iff]
intros
rw [comp_sup_eq_sup_comp coe]; intros; refl
rw [comp_sup_eq_sup_comp coe]; intros
{ rw [comp_sup_eq_sup_comp coe]; intros; refl }
rw [comp_sup_eq_sup_comp coe]
intros
refl
intros
refl
intros
simp [min']
intros
rw [noncomm_prod]
simp only [noncomm_fold_coe]
induction l with hd tl hl
{ simp }
simp
rw [list.prod_cons, list.foldr, hl]
{ rw [list.prod_cons, list.foldr, hl], intros x hx y hy, exact comm x (list.mem_cons_of_mem _ hx) y (list.mem_cons_of_mem _ hy) }
intros x hx y hy
exact comm x (list.mem_cons_of_mem _ hx) y (list.mem_cons_of_mem _ hy)
intros
{ ext x, simp }
ext x
simp
intros
simp [to_finset]
intros
classical
rw [‚Üêfinset.card_univ, univ_sum_type, finset.card_union_eq]
{ simp [finset.card_univ] }
simp [finset.card_univ]
intros x hx
{ intros x hx, suffices : (‚àÉ (a : Œ±), sum.inl a = x) ‚àß ‚àÉ (b : Œ≤), sum.inr b = x, { obtain ‚ü®‚ü®a, rfl‚ü©, ‚ü®b, hb‚ü©‚ü© := this, simpa using hb }, simpa using hx }
suffices : (‚àÉ (a : Œ±), sum.inl a = x) ‚àß ‚àÉ (b : Œ≤), sum.inr b = x
obtain ‚ü®‚ü®a, rfl‚ü©, ‚ü®b, hb‚ü©‚ü© := this
{ obtain ‚ü®‚ü®a, rfl‚ü©, ‚ü®b, hb‚ü©‚ü© := this, simpa using hb }
simpa using hb
simpa using hx
intros
simp
intros
{ simp only [not_le, iff_false], exact int.neg_succ_lt_zero n, }
simp only [not_le, iff_false]
exact int.neg_succ_lt_zero n
intros
rw [‚Üêint.nat_abs_eq_nat_abs_iff, int.nat_abs_of_nat]
intros
simp [sub_eq_add_neg]
intros
simp [gcd]
intros
{ unfold gcd_a, rw [xgcd, xgcd_zero_left] }
unfold gcd_a
rw [xgcd, xgcd_zero_left]
intros
simp [p‚ÇÅ‚ÇÇ.kunion s‚ÇÉ.nodupkeys p‚ÇÉ‚ÇÑ]
intros
rw last_eq_nth_le
congr
simp [h]
intros
induction l with hd tl IH
{ simp }
simp
{ simpa using IH }
simpa using IH
intros
rw [‚Üê filter_map_eq_filter, filter_map_filter_map]
congr
funext x
show (option.guard p x).bind f = ite (p x) (f x) none
by_cases h : p x
{ simp only [option.guard, if_pos h, option.some_bind'] }
simp only [option.guard, if_pos h, option.some_bind']
{ simp only [option.guard, if_neg h, option.none_bind'] }
simp only [option.guard, if_neg h, option.none_bind']
intros
simp only [countp_eq_length_filter, filter_append, length_append]
intros
simp only [erase_cons, if_pos rfl]
intros
simp only [disjoint_left, imp_not_comm, forall_eq']
intros
simp only [reverse_core_eq, map_append, map_reverse]
intros
cases l with hd tl
{ simpa using h }
simpa using h
induction tl with hd' tl hl generalizing hd
{ simp }
simp
by_cases hx : x = hd
{ by_cases hx : x = hd, { simp only [hx, prev_cons_cons_eq], exact mem_cons_of_mem _ (last_mem _) }, { rw [prev, dif_neg hx], split_ifs with hm, { exact mem_cons_self _ _ }, { exact mem_cons_of_mem _ (hl _ _) } } }
simp only [hx, prev_cons_cons_eq]
{ simp only [hx, prev_cons_cons_eq], exact mem_cons_of_mem _ (last_mem _) }
exact mem_cons_of_mem _ (last_mem _)
rw [prev, dif_neg hx]
{ rw [prev, dif_neg hx], split_ifs with hm, { exact mem_cons_self _ _ }, { exact mem_cons_of_mem _ (hl _ _) } }
split_ifs with hm
{ exact mem_cons_self _ _ }
exact mem_cons_self _ _
{ exact mem_cons_of_mem _ (hl _ _) }
exact mem_cons_of_mem _ (hl _ _)
intros
induction l with hd tl hl generalizing f
simp [map_with_index, map_with_index_core, list.enum_eq_zip_range]
{ simp [map_with_index, map_with_index_core, list.enum_eq_zip_range] }
rw [map_with_index, map_with_index_core, map_with_index_core_eq, hl]
{ rw [map_with_index, map_with_index_core, map_with_index_core_eq, hl], simp [enum_eq_zip_range, range_succ_eq_map, zip_with_map_left, map_uncurry_zip_eq_zip_with] }
simp [enum_eq_zip_range, range_succ_eq_map, zip_with_map_left, map_uncurry_zip_eq_zip_with]
intros
simp only [nodup, pairwise_join, disjoint_left.symm, forall_mem_ne]
intros
induction l‚ÇÅ with x l‚ÇÅ IH; [simp only [list.pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_true_iff, and_true, true_and, nil_append], simp only [cons_append, pairwise_cons, forall_mem_append, IH, forall_mem_cons, forall_and_distrib, and_assoc, and.left_comm]]
induction l‚ÇÅ with x l‚ÇÅ IH
simp only [list.pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_true_iff, and_true, true_and, nil_append]
simp only [cons_append, pairwise_cons, forall_mem_append, IH, forall_mem_cons, forall_and_distrib, and_assoc, and.left_comm]
intros
induction l with a l IH; simp
induction l with a l IH
simp
simp
refine (perm.trans _ (IH.append_left _)).append_left _
rw [‚Üê append_assoc, ‚Üê append_assoc]
exact perm_append_comm.append_right _
intros
rw [pmap_eq_map_attach]; from ext_le (by simp) (Œª i hi1 hi2, by { simp at hi1, simp [nth_le_of_fn f ‚ü®i, hi1‚ü©, -subtype.val_eq_coe] })
rw [pmap_eq_map_attach]
from ext_le (by simp) (Œª i hi1 hi2, by { simp at hi1, simp [nth_le_of_fn f ‚ü®i, hi1‚ü©, -subtype.val_eq_coe] })
intros
simp [rotate]
intros
obtain ‚ü®k, rfl‚ü© := h
exact ‚ü®k, by simp‚ü©
intros
induction l
cases h
case list.nil { cases h }
case list.cons : hd tl ih { by_cases e : a = hd.1, { subst e, exact ‚ü®hd.2, [], tl, by simp, by cases hd; refl, by simp‚ü© }, { simp at h, cases h, case or.inl : h { exact absurd h e }, case or.inr : h { rcases ih h with ‚ü®b, tl‚ÇÅ, tl‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©, exact ‚ü®b, hd :: tl‚ÇÅ, tl‚ÇÇ, not_mem_cons_of_ne_of_not_mem e h‚ÇÅ, by rw h‚ÇÇ; refl, by simp [e, h‚ÇÉ]‚ü© } } }
intros
rw [‚Üê @prod.mk.eta _ _ (unzip (zip l‚ÇÅ l‚ÇÇ)), unzip_zip_left (le_of_eq h), unzip_zip_right (ge_of_eq h)]
intros
{ ext, apply dot_product_assoc }
ext
apply dot_product_assoc
intros
ext
{ ext, refl }
refl
intros
ext i j
by_cases h : i = j
{ simp [h, transpose] }
simp [h, transpose]
{ simp [h, transpose, diagonal_apply_ne' h] }
simp [h, transpose, diagonal_apply_ne' h]
intros
ext i j
{ ext i j, apply add_dot_product }
apply add_dot_product
intros
simp [hj]
intros
ext ‚ü®i, k‚ü© ‚ü®j, k'‚ü©
simp only [block_diagonal_apply, mul_apply, ‚Üê finset.univ_product_univ, finset.sum_product]
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
{ ext i, refine fin.cases _ _ i; simp }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp
simp
simp
intros
rw [multiset.sigma, list.sigma, ‚Üê coe_bind]; simp
rw [multiset.sigma, list.sigma, ‚Üê coe_bind]
simp
intros
induction hst
exact rel.zero
case rel.zero { exact rel.zero }
case rel.cons : a b s t hab hst ih { apply rel.cons (h a (mem_cons_self _ _) b (mem_cons_self _ _) hab), exact ih (Œª a' ha' b' hb' h', h a' (mem_cons_of_mem ha') b' (mem_cons_of_mem hb') h') }
intros
by_cases h : a ‚àà s
{ rwa [card_erase_of_mem h, if_pos] }
rwa [card_erase_of_mem h, if_pos]
{ rwa [erase_of_not_mem h, if_neg] }
rwa [erase_of_not_mem h, if_neg]
intros
by_cases a ‚àà s; simp [h]
by_cases a ‚àà s
simp [h]
simp [h]
intros
apply finset.sum_congr rfl
intros c hc
dsimp
congr' 1
apply finset.prod_congr rfl
intros i hi
dsimp
congr' 1
apply h hi
rwa finsupp.mem_support_iff at hc
intros
{ ext1, apply bind‚ÇÅ_bind‚ÇÅ }
ext1
apply bind‚ÇÅ_bind‚ÇÅ
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
rw [X, vars_monomial (@one_ne_zero R _ _), finsupp.support_single_ne_zero (one_ne_zero : 1 ‚â† 0)]
intros
intros i hi
simp only [vars, exists_prop, multiset.mem_to_finset, finset.mem_image] at hi ‚ä¢
simpa only [multiset.mem_map] using degrees_rename _ _ hi
intros
simp only [exists_prop, ‚Üê lt_succ_iff, find_lt_iff]
intros
induction n using nat.binary_rec with b n hn generalizing m
simp only [zero_test_bit] at h
{ simp only [zero_test_bit] at h, exact (zero_of_test_bit_eq_ff (Œª i, (h i).symm)).symm }
exact (zero_of_test_bit_eq_ff (Œª i, (h i).symm)).symm
induction m using nat.binary_rec with b' m hm
simp only [zero_test_bit] at h
{ simp only [zero_test_bit] at h, exact zero_of_test_bit_eq_ff h }
exact zero_of_test_bit_eq_ff h
suffices h' : n = m
{ rw [h', show b = b', by simpa using h 0] }
rw [h', show b = b', by simpa using h 0]
exact hn (Œª i, by convert h (i + 1) using 1; rw test_bit_succ)
intros
rw digits_aux
intros
convert to_with_top_top
intros
rw [desc_factorial_succ, nat.zero_sub, zero_mul]
intros
rw [nat.coprime_comm, coprime_pow_left_iff hn, nat.coprime_comm]
intros
rw [add_div hc0, if_pos hc]
intros
simpa [H] using mkpair_unpair n
intros
rw [odd_iff, mod_two_ne_one]
intros
{ rw ‚Üêone_pow n, exact nat.pow_le_pow_of_le_left h n }
rw ‚Üêone_pow n
exact nat.pow_le_pow_of_le_left h n
intros
rw [‚Üê with_bot.coe_zero, with_bot.coe_le_coe]; exact nat.zero_le _
rw [‚Üê with_bot.coe_zero, with_bot.coe_le_coe]
exact nat.zero_le _
intros
rw [‚Üê dvd_to_int, int.dvd_iff_mod_eq_zero, ‚Üê to_int_inj, mod_to_int]
rw [‚Üê dvd_to_int, int.dvd_iff_mod_eq_zero, ‚Üê to_int_inj, mod_to_int]; refl
refl
intros
cases x; simp only [pbind, map_none']
{ cases x; simp only [pbind, map_none'] }
cases x
simp only [pbind, map_none']
simp only [pbind, map_none']
intros
rw [valid'.dual_iff, dual_balance_r]
have := hr.dual.balance_l_aux hl.dual
rw [size_dual, size_dual] at this
exact this H‚ÇÅ H‚ÇÇ H‚ÇÉ
intros
cases m; [exact (hl.node' hm).node' hr, exact (hl.node' hm.2.1).node' (hm.2.2.node' hr)]
cases m
exact (hl.node' hm).node' hr
exact (hl.node' hm.2.1).node' (hm.2.2.node' hr)
intros
cases t
cases t; refl
refl
refl
intros
cases x with a‚ÇÅ f‚ÇÅ
cases y with a‚ÇÇ f‚ÇÇ
dsimp [Mp] at *
have : a‚ÇÅ = a‚ÇÇ
refine pfunctor.M.bisim (Œª a‚ÇÅ a‚ÇÇ, ‚àÉ x y, R x y ‚àß x.1 = a‚ÇÅ ‚àß y.1 = a‚ÇÇ) _ _ _ ‚ü®‚ü®a‚ÇÅ, f‚ÇÅ‚ü©, ‚ü®a‚ÇÇ, f‚ÇÇ‚ü©, r, rfl, rfl‚ü©
{ refine pfunctor.M.bisim (Œª a‚ÇÅ a‚ÇÇ, ‚àÉ x y, R x y ‚àß x.1 = a‚ÇÅ ‚àß y.1 = a‚ÇÇ) _ _ _ ‚ü®‚ü®a‚ÇÅ, f‚ÇÅ‚ü©, ‚ü®a‚ÇÇ, f‚ÇÇ‚ü©, r, rfl, rfl‚ü©, rintro _ _ ‚ü®‚ü®a‚ÇÅ, f‚ÇÅ‚ü©, ‚ü®a‚ÇÇ, f‚ÇÇ‚ü©, r, rfl, rfl‚ü©, rcases h _ _ r with ‚ü®a', f', f‚ÇÅ', f‚ÇÇ', e‚ÇÅ, e‚ÇÇ, h'‚ü©, rcases M.bisim_lemma P e‚ÇÅ with ‚ü®g‚ÇÅ', e‚ÇÅ', rfl, rfl‚ü©, rcases M.bisim_lemma P e‚ÇÇ with ‚ü®g‚ÇÇ', e‚ÇÇ', _, rfl‚ü©, rw [e‚ÇÅ', e‚ÇÇ'], exact ‚ü®_, _, _, rfl, rfl, Œª b, ‚ü®_, _, h' b, rfl, rfl‚ü©‚ü© }
rintro _ _ ‚ü®‚ü®a‚ÇÅ, f‚ÇÅ‚ü©, ‚ü®a‚ÇÇ, f‚ÇÇ‚ü©, r, rfl, rfl‚ü©
rcases h _ _ r with ‚ü®a', f', f‚ÇÅ', f‚ÇÇ', e‚ÇÅ, e‚ÇÇ, h'‚ü©
rcases M.bisim_lemma P e‚ÇÅ with ‚ü®g‚ÇÅ', e‚ÇÅ', rfl, rfl‚ü©
rcases M.bisim_lemma P e‚ÇÇ with ‚ü®g‚ÇÇ', e‚ÇÇ', _, rfl‚ü©
rw [e‚ÇÅ', e‚ÇÇ']
exact ‚ü®_, _, _, rfl, rfl, Œª b, ‚ü®_, _, h' b, rfl, rfl‚ü©‚ü©
subst this
congr' with i p
induction p with x a f h' i c x a f h' i c p IH generalizing f‚ÇÅ f‚ÇÇ
induction p with x a f h' i c x a f h' i c p IH generalizing f‚ÇÅ f‚ÇÇ; try { rcases h _ _ r with ‚ü®a', f', f‚ÇÅ', f‚ÇÇ', e‚ÇÅ, e‚ÇÇ, h''‚ü©, rcases M.bisim_lemma P e‚ÇÅ with ‚ü®g‚ÇÅ', e‚ÇÅ', rfl, rfl‚ü©, rcases M.bisim_lemma P e‚ÇÇ with ‚ü®g‚ÇÇ', e‚ÇÇ', e‚ÇÉ, rfl‚ü©, cases h'.symm.trans e‚ÇÅ', cases h'.symm.trans e‚ÇÇ' }
try { rcases h _ _ r with ‚ü®a', f', f‚ÇÅ', f‚ÇÇ', e‚ÇÅ, e‚ÇÇ, h''‚ü©, rcases M.bisim_lemma P e‚ÇÅ with ‚ü®g‚ÇÅ', e‚ÇÅ', rfl, rfl‚ü©, rcases M.bisim_lemma P e‚ÇÇ with ‚ü®g‚ÇÇ', e‚ÇÇ', e‚ÇÉ, rfl‚ü©, cases h'.symm.trans e‚ÇÅ', cases h'.symm.trans e‚ÇÇ' }
{ exact (congr_fun (congr_fun e‚ÇÉ i) c : _) }
exact (congr_fun (congr_fun e‚ÇÉ i) c : _)
try { rcases h _ _ r with ‚ü®a', f', f‚ÇÅ', f‚ÇÇ', e‚ÇÅ, e‚ÇÇ, h''‚ü©, rcases M.bisim_lemma P e‚ÇÅ with ‚ü®g‚ÇÅ', e‚ÇÅ', rfl, rfl‚ü©, rcases M.bisim_lemma P e‚ÇÇ with ‚ü®g‚ÇÇ', e‚ÇÇ', e‚ÇÉ, rfl‚ü©, cases h'.symm.trans e‚ÇÅ', cases h'.symm.trans e‚ÇÇ' }
rcases h _ _ r with ‚ü®a', f', f‚ÇÅ', f‚ÇÇ', e‚ÇÅ, e‚ÇÇ, h''‚ü©
rcases M.bisim_lemma P e‚ÇÅ with ‚ü®g‚ÇÅ', e‚ÇÅ', rfl, rfl‚ü©
rcases M.bisim_lemma P e‚ÇÇ with ‚ü®g‚ÇÇ', e‚ÇÇ', e‚ÇÉ, rfl‚ü©
cases h'.symm.trans e‚ÇÅ'
cases h'.symm.trans e‚ÇÇ'
{ exact IH _ _ (h'' _) }
exact IH _ _ (h'' _)
intros
{ cases x, cases y, congr' with n, apply H }
cases x
cases y
congr' with n
apply H
intros
simp only [obj.iget, fst_map, *, dif_pos, eq_self_iff_true]
{ simp only [obj.iget, fst_map, *, dif_pos, eq_self_iff_true], cases x, refl }
cases x
refl
intros
let n := u.prod
let m := v.prod
change (u ‚äî v).prod = pnat.lcm n m
have : u = n.factor_multiset := u.factor_multiset_prod.symm
rw [this]
have : v = m.factor_multiset := v.factor_multiset_prod.symm
rw [this]
rw[‚Üê pnat.factor_multiset_lcm n m, pnat.prod_factor_multiset]
intros
simp_rw algebra.smul_def
{ simp_rw algebra.smul_def, exact eval‚ÇÇ_eq_sum_range (algebra_map R S) x }
exact eval‚ÇÇ_eq_sum_range (algebra_map R S) x
intros
simpa only [pow_one] using coeff_mul_X_pow p 1 n
intros
rw [‚Üê monomial_eq_C_mul_X, degree_monomial n ha]
intros
haveI := nontrivial.of_polynomial_ne hp; exact have leading_coeff p * leading_coeff X ‚â† 0, by simpa, by erw [degree_mul' this, degree_eq_nat_degree hp, degree_X, ‚Üê with_bot.coe_one, ‚Üê with_bot.coe_add, with_bot.coe_lt_coe]; exact nat.lt_succ_self _
haveI := nontrivial.of_polynomial_ne hp
exact have leading_coeff p * leading_coeff X ‚â† 0, by simpa, by erw [degree_mul' this, degree_eq_nat_degree hp, degree_X, ‚Üê with_bot.coe_one, ‚Üê with_bot.coe_add, with_bot.coe_lt_coe]; exact nat.lt_succ_self _
intros
rw degree_le_iff_coeff_zero
intros i hi
rw erase_lead_coeff
split_ifs with h
refl
{ refl }
apply coeff_eq_zero_of_degree_lt hi
intros
convert eval‚ÇÇ_at_apply f n
simp
intros
simp [eval‚ÇÇ_eq_sum]
intros
let p := span (polynomial R) {g : polynomial R | ‚àÉ i : ‚Ñï, g = (C (coeff f i))}
nth_rewrite 0 (sum_C_mul_X_eq f).symm
refine submodule.sum_mem _ (Œª n hn, _)
dsimp
have : C (coeff f n) ‚àà p
apply subset_span
apply subset_span
{ apply subset_span, simp }
{ apply subset_span, simp }
simp
simp
have : (monomial n (1 : R)) ‚Ä¢ C (coeff f n) ‚àà p := p.smul_mem _ this
convert this using 1
simp only [monomial_mul_C, one_mul, smul_eq_mul]
rw monomial_eq_C_mul_X
intros
simp only [iterated_deriv_zero_right]
intros
by_cases hp : p = 0
{ rw [hp, mirror_zero] }
rw [hp, mirror_zero]
rw [mirror, nat_trailing_degree_mul_X_pow ((mt reverse_eq_zero.mp) hp), reverse_nat_trailing_degree, zero_add]
{ rw [mirror, nat_trailing_degree_mul_X_pow ((mt reverse_eq_zero.mp) hp), reverse_nat_trailing_degree, zero_add] }
intros
by_cases hp : p = 0
{ simp [hp] }
simp [hp]
rw [‚Üêwith_bot.coe_eq_coe, ‚Üêdegree_eq_nat_degree hp, ‚Üêdegree_eq_nat_degree, degree_smul_of_smul_regular p h]
contrapose! hp
rw ‚Üêsmul_zero k at hp
exact h.polynomial hp
intros
unfold reverse
rw [nat_degree_mul' fg, reflect_mul f g rfl.le rfl.le]
intros
rw [supp]
dsimp
split
intros h a f haf
{ intros h a f haf, have : liftp (Œª u, u ‚àà f '' univ) x, { rw liftp_iff, refine ‚ü®a, f, haf.symm, Œª i, mem_image_of_mem _ (mem_univ _)‚ü© }, exact h this }
have : liftp (Œª u, u ‚àà f '' univ) x
rw liftp_iff
{ rw liftp_iff, refine ‚ü®a, f, haf.symm, Œª i, mem_image_of_mem _ (mem_univ _)‚ü© }
refine ‚ü®a, f, haf.symm, Œª i, mem_image_of_mem _ (mem_univ _)‚ü©
exact h this
intros h p
rw liftp_iff
rintros ‚ü®a, f, xeq, h'‚ü©
rcases h a f xeq.symm with ‚ü®i, _, hi‚ü©
rw ‚Üêhi
apply h'
intros
rw [‚Üê int.cast_coe_nat, coe_int_num]
intros
by_cases b ‚â§ a; simp [h, max_def]
by_cases b ‚â§ a
simp [h, max_def]
simp [h, max_def]
intros
rw [‚Üê(@num_denom q), ‚Üê(@num_denom p)]
conv_rhs { simp only [num_denom] }
exact rat.le_def (by exact_mod_cast p.pos) (by exact_mod_cast q.pos)
intros
simpa only [sub_eq_add_neg] using add_lim_zero hf (neg_lim_zero hg)
intros
simp [div_eq_mul_inv, top_mul]
intros
rw [div_eq_mul_inv, to_nnreal_mul, to_nnreal_inv, div_eq_mul_inv]
intros
split_ifs
simp [h]
{ simp [h] }
exact with_top.top_mul h
{ exact with_top.top_mul h }
intros
rw [add_comm, add_comm c, add_right_inj h]
rw [golden_conj, ‚Üêsub_eq_zero]
ring_exp
rw real.sq_sqrt; norm_num
rw real.sq_sqrt
norm_num
norm_num
intros
simp [le_antisymm_iff, hx, hy]
intros
{ unfold comp, ext y, simp }
unfold comp
ext y
simp
intros
revert s
induction n with n IH; intro s; apply cases_on s (Œª a', _) (Œª s, _); intro h
induction n with n IH; intro s; apply cases_on s (Œª a', _) (Œª s, _)
induction n with n IH; intro s
induction n with n IH
intro s
apply cases_on s (Œª a', _) (Œª s, _)
intro h
{ rw ‚Üêeq_of_ret_mem h.mem, refl }
rw ‚Üêeq_of_ret_mem h.mem
refl
intro h
cases of_results_think h with n h
{ cases of_results_think h with n h, cases h, contradiction }
cases h
contradiction
intro s
apply cases_on s (Œª a', _) (Œª s, _)
intro h
{ have := h.len_unique (results_ret _), contradiction }
have := h.len_unique (results_ret _)
contradiction
intro h
{ rw IH (results_think_iff.1 h), refl }
rw IH (results_think_iff.1 h)
refl
intros
rw [‚Üêlift_rel.swap R, ‚Üêlift_rel.swap R]; apply lift_rel_think_left
rw [‚Üêlift_rel.swap R, ‚Üêlift_rel.swap R]
apply lift_rel_think_left
intros
simp [set.insert_inter, h]
intros
rw [‚Üê image_comp, compl_comp_compl, image_id]
intros
split
{ intros h x hx, rcases hs hx with ‚ü®y, rfl‚ü©, exact h hx }
intros h x hx
rcases hs hx with ‚ü®y, rfl‚ü©
exact h hx
intros h x
apply h
intros
{ rw ‚Üê set.image_univ, simp [-set.image_univ, coe_image] }
rw ‚Üê set.image_univ
simp [-set.image_univ, coe_image]
intros
simp only [not_nonempty_iff_eq_empty.symm, prod_nonempty_iff, not_and_distrib]
intros
refine ‚ü®Œª h x x' hx, _, injective.image_injective‚ü©
rw [‚Üê singleton_eq_singleton_iff]
apply h
rw [image_singleton, image_singleton, hx]
intros
rw [inter_comm, singleton_inter_eq_empty]
intros
ext
ext; simp
simp
intros
{ ext y, by_cases hy : y = x, { subst y, simp }, { simp [hy] } }
ext y
by_cases hy : y = x
subst y
{ subst y, simp }
simp
simp [hy]
{ simp [hy] }
intros
{ ext x, simp [Ioi] }
ext x
simp [Ioi]
intros
rw [‚Üênot_nonempty_iff_eq_empty, not_iff_not, nonempty_Icc]
intros
rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iic]
intros
simp [lt_irrefl]
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
refine ‚ü®Œª _ h, ‚ü®add_le_add_right h.1 _, add_lt_add_right h.2 _‚ü©, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
obtain ‚ü®c, rfl‚ü© := exists_add_of_le h.1
rw [mem_Ico, add_right_comm, add_le_add_iff_right, add_lt_add_iff_right] at h
exact ‚ü®a + c, h, by rw add_right_comm‚ü©
intros
rw [bdd_below_bdd_above_iff_subset_Icc]
split
rintro ‚ü®a, b, h‚ü©
{ rintro ‚ü®a, b, h‚ü©, exact ‚ü®a, b, Œª x hx, Icc_subset_interval (h hx)‚ü© }
exact ‚ü®a, b, Œª x hx, Icc_subset_interval (h hx)‚ü©
{ rintro ‚ü®a, b, h‚ü©, exact ‚ü®min a b, max a b, h‚ü© }
rintro ‚ü®a, b, h‚ü©
exact ‚ü®min a b, max a b, h‚ü©
intros
intros x hx y hy hxy
rcases mem_Union.1 hx with ‚ü®i, hx‚ü©
rcases mem_Union.1 hy with ‚ü®j, hy‚ü©
rcases hs i j with ‚ü®k, hi, hj‚ü©
exact hf k (hi hx) (hj hy) hxy
intros
{ ext, simp }
ext
simp
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
{ rw val_one_eq_one_mod, exact nat.mod_eq_of_lt (fact.out _) }
rw val_one_eq_one_mod
exact nat.mod_eq_of_lt (fact.out _)
intros
rw ‚Üê set.image_univ
{ rw ‚Üê set.image_univ, apply image.is_subfield _ univ.is_subfield }
apply image.is_subfield _ univ.is_subfield
intros
{ rw coe_pow, exact hf.iterate n }
rw coe_pow
exact hf.iterate n
intros
rw omega_limit_eq_Inter
intros _ hx
rw mem_Inter at hx
exact hx ‚ü®u, hu‚ü©
intros
apply bot_eq_top_of_finrank_adjoin_eq_one
exact Œª x, by linarith [h x, show 0 < finrank F F‚üÆx‚üØ, from finrank_pos]
intros
classical
obtain ‚ü®s, h‚ü© := exists_multiset_of_splits i sp
use s.to_finset
rw [h, finset.prod_eq_multiset_prod, ‚Üêmultiset.to_finset_eq]
apply nodup_of_separable_prod
apply separable.of_mul_right
rw ‚Üêh
exact sep.map
intros
convert eq_prod_roots_of_splits_id hsplit
simp [m]
intros
{ rw div_eq_mul_inv, exact s.mul_mem hx (s.inv_mem hy) }
rw div_eq_mul_inv
exact s.mul_mem hx (s.inv_mem hy)
intros
unfold angle
rw [inner_neg_neg, norm_neg, norm_neg]
intros
rw monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub h
simp_rw [pi.sub_apply, sum_sub_distrib, sum_monge_point_weights_with_circumcenter]
rw [sum_centroid_weights_with_circumcenter, sub_self]
simp [‚Üêcard_pos, card_compl, h]
intros
rw [coe_def, support_indicator, (‚àò), support_comp_eq_preimage, ‚Üê ext_chart_at_source I, ‚Üê (ext_chart_at I c).symm_image_target_inter_eq', ‚Üê (ext_chart_at I c).symm_image_target_inter_eq', f.to_times_cont_diff_bump.support_eq]
intros
simpa using chart_mem_atlas H x
intros
rw ‚Üê lift_prop_on_univ at h
exact lift_prop_on_mono mono h (subset_univ _)
intros
split
{ exact continuous_within_at.union hs.1 ht.1 }
exact continuous_within_at.union hs.1 ht.1
convert has_fderiv_within_at.union hs.2 ht.2
{ convert has_fderiv_within_at.union hs.2 ht.2, simp only [union_inter_distrib_right, preimage_union] }
simp only [union_inter_distrib_right, preimage_union]
intros
simp only [tangent_map_within] with mfld_simps
rw mfderiv_within_comp p.1 hg hf h hps
refl
intros
have : e.symm.trans e ‚âà local_homeomorph.of_set e.target e.open_target := local_homeomorph.trans_symm_self _
exact structure_groupoid.eq_on_source _ (of_set_mem_times_cont_diff_groupoid n I e.open_target) this
intros
rw ‚Üê times_cont_mdiff_on_univ at hf ‚ä¢
convert hf.times_cont_mdiff_on_tangent_map_within hmn unique_mdiff_on_univ
rw tangent_map_within_univ
intros
simp only [pi.one_def, smooth_const]
intros
ext
rw [to_free_abelian_group, to_finsupp, add_monoid_hom.comp_apply, lift.of, lift_add_hom_apply_single, add_monoid_hom.flip_apply, smul_add_hom_apply, one_smul, add_monoid_hom.id_apply]
intros
{ rw eq_bot_iff, exact general_commutator_le_right H ‚ä• }
rw eq_bot_iff
exact general_commutator_le_right H ‚ä•
intros
rw [mk', monoid_hom.map_one]; exact mul_one _
rw [mk', monoid_hom.map_one]
exact mul_one _
intros
rw ‚Üêf.map_comp_map hy j hl; refl
rw ‚Üêf.map_comp_map hy j hl
refl
intros
obtain ‚ü®n, hn‚ü© := iff_card.mp (hG.to_quotient H.normal_core)
obtain ‚ü®k, hk1, hk2‚ü© := (nat.dvd_prime_pow hp.out).mp ((congr_arg _ (H.normal_core.index_eq_card.trans hn)).mp (subgroup.index_dvd_of_le H.normal_core_le))
exact ‚ü®k, hk2‚ü©
intros
induction s using quot.induction_on
refine support_form_perm_of_nodup s h _
rintro _ rfl
simpa [nat.succ_le_succ_iff] using length_nontrivial hn
intros
classical
split
intro h
{ intro h, have hr : support (f ^ n) = support f, { rw hf.support_pow_eq_iff, rintro ‚ü®k, rfl‚ü©, refine h.ne_one _, simp [pow_mul, pow_order_of_eq_one] }, have : order_of (f ^ n) = order_of f, { rw [order_of_is_cycle h, hr, order_of_is_cycle hf] }, rw [order_of_pow, nat.div_eq_self] at this, cases this, { exact absurd this (order_of_pos _).ne' }, { rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm] } }
have hr : support (f ^ n) = support f
rw hf.support_pow_eq_iff
{ rw hf.support_pow_eq_iff, rintro ‚ü®k, rfl‚ü©, refine h.ne_one _, simp [pow_mul, pow_order_of_eq_one] }
rintro ‚ü®k, rfl‚ü©
refine h.ne_one _
simp [pow_mul, pow_order_of_eq_one]
have : order_of (f ^ n) = order_of f
{ rw [order_of_is_cycle h, hr, order_of_is_cycle hf] }
rw [order_of_is_cycle h, hr, order_of_is_cycle hf]
rw [order_of_pow, nat.div_eq_self] at this
cases this
{ exact absurd this (order_of_pos _).ne' }
exact absurd this (order_of_pos _).ne'
{ rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm] }
rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm]
intro h
{ intro h, obtain ‚ü®m, hm‚ü© := exists_pow_eq_self_of_coprime h, have hf' : is_cycle ((f ^ n) ^ m) := by rwa hm, refine is_cycle_of_is_cycle_pow hf' _, intros x hx, rw [hm], exact support_pow_le _ n hx }
obtain ‚ü®m, hm‚ü© := exists_pow_eq_self_of_coprime h
have hf' : is_cycle ((f ^ n) ^ m) := by rwa hm
refine is_cycle_of_is_cycle_pow hf' _
intros x hx
rw [hm]
exact support_pow_le _ n hx
intros
by_cases h : p = q
{ exact h ‚ñ∏ commute.refl _ }
exact h ‚ñ∏ commute.refl _
exact (cycle_factors_finset_pairwise_disjoint _ _ hp _ hq h).commute
{ exact (cycle_factors_finset_pairwise_disjoint _ _ hp _ hq h).commute }
intros
refine fin.cases _ _ p; simp [equiv.perm.decompose_fin, fin.succ_ne_zero]
refine fin.cases _ _ p
{ refine fin.cases _ _ p; simp [equiv.perm.decompose_fin, fin.succ_ne_zero] }
simp [equiv.perm.decompose_fin, fin.succ_ne_zero]
simp [equiv.perm.decompose_fin, fin.succ_ne_zero]
intros
simp [equiv_functor.map]
intros
simp
intros
refine ‚ü®Œª h, _, disjoint.inv_left‚ü©
convert h.inv_left
exact (inv_inv _).symm
intros
ext
ext; simp
simp
intros
obtain ‚ü®c, g', rfl, hd, hc, h3‚ü© := mem_cycle_type_iff.1 h
simp only [mul_assoc]
rw [hd.commute.eq, ‚Üê mul_assoc g']
suffices hg' : order_of g' ‚à£ 2
rw [‚Üê pow_two, order_of_dvd_iff_pow_eq_one.1 hg', one_mul]
{ rw [‚Üê pow_two, order_of_dvd_iff_pow_eq_one.1 hg', one_mul], exact (card_support_eq_three_iff.1 h3).is_three_cycle_sq }
exact (card_support_eq_three_iff.1 h3).is_three_cycle_sq
rw [‚Üê lcm_cycle_type, multiset.lcm_dvd]
intros n hn
rw le_antisymm (two_le_of_mem_cycle_type hn) (le_trans (le_card_support_of_mem_cycle_type hn) _)
apply le_of_add_le_add_left
rw [‚Üê hd.card_support_mul, h3]
exact (c * g').support.card_le_univ
intros
cases n
{ rw pow_zero }
rw pow_zero
rw [r_one_pow, one_def]
{ rw [r_one_pow, one_def], congr' 1, exact zmod.nat_cast_self _, }
congr' 1
exact zmod.nat_cast_self _
intros
have := (normal_subgroup_of_iff hK).mp hN (a * b) b h hb
rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at this
intros
ext x
calc f x = f.linear x +·µ• f 0 : by simp [‚Üê f.map_vadd] ... = (f.linear.to_fun + Œª (z : V1), f 0) x : by simp
intros
simp [‚Üêmem_coe]
intros
simp [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw 0]
intros
simp only [‚Üêspan_Union, set.bUnion_of_singleton s]
intros
rw [map_le_iff_le_comap, submodule.comap_map_eq]
intros
simp
intros
rw [pow_succ', mul_eq_comp]
intros
let B := basis.of_vector_space_index K V
let hB := basis.of_vector_space K V
have hB‚ÇÄ : _ := hB.linear_independent.to_subtype_range
have : linear_independent K (Œª x, x : f '' B ‚Üí V')
have h‚ÇÅ : linear_independent K (Œª (x : ‚Ü•(‚áëf '' range (basis.of_vector_space _ _))), ‚Üëx) := @linear_independent.image_subtype _ _ _ _ _ _ _ _ _ f hB‚ÇÄ (show disjoint _ _, by simp [hf_inj])
{ have h‚ÇÅ : linear_independent K (Œª (x : ‚Ü•(‚áëf '' range (basis.of_vector_space _ _))), ‚Üëx) := @linear_independent.image_subtype _ _ _ _ _ _ _ _ _ f hB‚ÇÄ (show disjoint _ _, by simp [hf_inj]), rwa [basis.range_of_vector_space K V] at h‚ÇÅ }
rwa [basis.range_of_vector_space K V] at h‚ÇÅ
let C := this.extend (subset_univ _)
have BC := this.subset_extend (subset_univ _)
let hC := basis.extend this
haveI : inhabited V := ‚ü®0‚ü©
refine ‚ü®hC.constr K (C.restrict (inv_fun f)), hB.ext (Œª b, _)‚ü©
rw image_subset_iff at BC
have fb_eq : f b = hC ‚ü®f b, BC b.2‚ü©
change f b = basis.extend this _
{ change f b = basis.extend this _, rw [basis.extend_apply_self, subtype.coe_mk] }
rw [basis.extend_apply_self, subtype.coe_mk]
dsimp [hB]
rw [basis.of_vector_space_apply_self, fb_eq, hC.constr_basis]
exact left_inverse_inv_fun (linear_map.ker_eq_bot.1 hf_inj) _
intros
simp [reindex_finset_range]
intros
induction c using clifford_algebra.induction
case h_grade0 : r { simp only [reverse.commutes, alg_hom.commutes, quaternion_algebra.coe_algebra_map, quaternion_algebra.conj_coe], }
case h_grade1 : x { rw [reverse_Œπ, involute_Œπ, to_quaternion_Œπ, alg_hom.map_neg, to_quaternion_Œπ, quaternion_algebra.neg_mk, conj_mk, neg_zero], }
case h_mul : x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ { simp only [reverse.map_mul, alg_hom.map_mul, hx‚ÇÅ, hx‚ÇÇ, quaternion_algebra.conj_mul] }
case h_add : x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ { simp only [reverse.map_add, alg_hom.map_add, hx‚ÇÅ, hx‚ÇÇ, quaternion_algebra.conj_add] }
intros
apply le_bot_iff.mp
apply cardinal.sup_le.mpr
rintro ‚ü®s, li‚ü©
apply le_bot_iff.mpr
apply cardinal.mk_emptyc_iff.mpr
simp only [subtype.coe_mk]
by_contradiction h
have ne : s.nonempty := ne_empty_iff_nonempty.mp h
simpa using linear_independent.ne_zero (‚ü®_, ne.some_mem‚ü© : s) li
intros
rw is_noetherian_iff_well_founded at h
exact (well_founded.supr_eq_monotonic_sequence_limit h (f.generalized_eigenspace Œº) : _)
intros
refine (span_eq_of_le _ _ (set_like.le_def.2 $ Œª l hl, _)).symm
rintro _ ‚ü®_, hp, rfl ‚ü©
{ rintro _ ‚ü®_, hp, rfl ‚ü© , exact single_mem_supported R 1 hp }
exact single_mem_supported R 1 hp
rw ‚Üê l.sum_single
{ rw ‚Üê l.sum_single, refine sum_mem _ (Œª i il, _), convert @smul_mem R (Œ± ‚Üí‚ÇÄ R) _ _ _ _ (single i 1) (l i) _, { simp }, apply subset_span, apply set.mem_image_of_mem _ (hl il) }
refine sum_mem _ (Œª i il, _)
convert @smul_mem R (Œ± ‚Üí‚ÇÄ R) _ _ _ _ (single i 1) (l i) _
{ simp }
simp
apply subset_span
apply set.mem_image_of_mem _ (hl il)
intros
apply_fun lcongr e‚ÇÅ e‚ÇÇ using (lcongr e‚ÇÅ e‚ÇÇ).injective
simp
intros
obtain ‚ü®a, ha‚ü© := submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr hI)
have : linear_independent R (Œª i, b i ‚Ä¢ a)
have hb := b.linear_independent
{ have hb := b.linear_independent, rw fintype.linear_independent_iff at ‚ä¢ hb, intros g hg, apply hb g, simp only [‚Üê smul_assoc, ‚Üê finset.sum_smul, smul_eq_zero] at hg, exact hg.resolve_right ha }
rw fintype.linear_independent_iff at ‚ä¢ hb
intros g hg
apply hb g
simp only [‚Üê smul_assoc, ‚Üê finset.sum_smul, smul_eq_zero] at hg
exact hg.resolve_right ha
exact le_antisymm (b.card_le_card_of_linear_independent (c.linear_independent.map' (submodule.subtype I) (linear_map.ker_eq_bot.mpr subtype.coe_injective))) (c.card_le_card_of_linear_independent this)
intros
have := eq_of_linear_independent_of_span_subtype (hl.mono (set.union_subset hsu htu)) (set.subset_union_right _ _) (set.union_subset (set.subset.trans subset_span hst) subset_span)
rw ‚Üê this
apply set.subset_union_left
intros
simp only [linear_independent_iff, (‚àò), finsupp.mem_supported, finsupp.total_apply, set.subset_def, finset.mem_coe]
split
intros h l hl‚ÇÅ hl‚ÇÇ
{ intros h l hl‚ÇÅ hl‚ÇÇ, have := h (l.subtype_domain s) ((finsupp.sum_subtype_domain_index hl‚ÇÅ).trans hl‚ÇÇ), exact (finsupp.subtype_domain_eq_zero_iff hl‚ÇÅ).1 this }
have := h (l.subtype_domain s) ((finsupp.sum_subtype_domain_index hl‚ÇÅ).trans hl‚ÇÇ)
exact (finsupp.subtype_domain_eq_zero_iff hl‚ÇÅ).1 this
intros h l hl
{ intros h l hl, refine finsupp.emb_domain_eq_zero.1 (h (l.emb_domain $ function.embedding.subtype s) _ _), { suffices : ‚àÄ i hi, ¬¨l ‚ü®i, hi‚ü© = 0 ‚Üí i ‚àà s, by simpa, intros, assumption }, { rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index], exacts [Œª _, zero_smul _ _, Œª _ _ _, add_smul _ _ _] } }
refine finsupp.emb_domain_eq_zero.1 (h (l.emb_domain $ function.embedding.subtype s) _ _)
suffices : ‚àÄ i hi, ¬¨l ‚ü®i, hi‚ü© = 0 ‚Üí i ‚àà s
{ suffices : ‚àÄ i hi, ¬¨l ‚ü®i, hi‚ü© = 0 ‚Üí i ‚àà s, by simpa, intros, assumption }
simpa
simpa
intros
assumption
rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index]
{ rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index], exacts [Œª _, zero_smul _ _, Œª _ _ _, add_smul _ _ _] }
exacts [Œª _, zero_smul _ _, Œª _ _ _, add_smul _ _ _]
intros
intros i
let repr : (span R (range (v ‚àò f)) : Type*) ‚Üí Œπ' ‚Üí‚ÇÄ R := (hv.comp f f.injective).repr
let l := (repr ‚ü®v i, hss (mem_range_self i)‚ü©).map_domain f
have h_total_l : finsupp.total Œπ M R v l = v i
dsimp only [l]
{ dsimp only [l], rw finsupp.total_map_domain, rw (hv.comp f f.injective).total_repr, { refl }, { exact f.injective } }
rw finsupp.total_map_domain
rw (hv.comp f f.injective).total_repr
{ refl }
refl
{ exact f.injective }
exact f.injective
have h_total_eq : (finsupp.total Œπ M R v) l = (finsupp.total Œπ M R v) (finsupp.single i 1)
rw [h_total_l, finsupp.total_single, one_smul]
rw [h_total_l, finsupp.total_single, one_smul]
have l_eq : l = _ := linear_map.ker_eq_bot.1 hv h_total_eq
dsimp only [l] at l_eq
rw ‚Üêfinsupp.emb_domain_eq_map_domain at l_eq
rcases finsupp.single_of_emb_domain_single (repr ‚ü®v i, _‚ü©) f i (1 : R) zero_ne_one.symm l_eq with ‚ü®i', hi'‚ü©
use i'
exact hi'.2
intros
ext i' k
rw [basis.to_matrix, matrix.update_column_apply, e.to_matrix_apply]
split_ifs
{ rw [h, update_same j x v] }
rw [h, update_same j x v]
{ rw update_noteq h }
rw update_noteq h
intros
by_cases i = j; simp [h, ‚Üê degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]
by_cases i = j
{ by_cases i = j; simp [h, ‚Üê degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)], }
simp [h, ‚Üê degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]
simp [h, ‚Üê degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]
intros
rw [‚Üê det_transpose, det_zero_of_row_eq i_ne_j]
{ rw [‚Üê det_transpose, det_zero_of_row_eq i_ne_j], exact funext hij }
exact funext hij
intros
funext x
classical
rw [‚Üê dot_product_std_basis_one v x, ‚Üê dot_product_std_basis_one w x, h]
intros
induction k with k IH
{ simp }
simp
rw [pow_succ', mul_eq_mul, adjugate_mul_distrib, IH, ‚Üêmul_eq_mul, pow_succ]
{ rw [pow_succ', mul_eq_mul, adjugate_mul_distrib, IH, ‚Üêmul_eq_mul, pow_succ] }
intros
apply nat.decreasing_induction' _ hk
simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, list.drop_eq_nil_of_le, list.prod_nil]
{ simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, list.drop_eq_nil_of_le, list.prod_nil], }
assume n hn hk IH
{ assume n hn hk IH, have hn' : n < (list_transvec_col M).length, by simpa [list_transvec_col] using hn, rw ‚Üê list.cons_nth_le_drop_succ hn', simpa [list_transvec_col, matrix.mul_assoc] }
have hn' : n < (list_transvec_col M).length
simpa [list_transvec_col] using hn
simpa [list_transvec_col] using hn
rw ‚Üê list.cons_nth_le_drop_succ hn'
simpa [list_transvec_col, matrix.mul_assoc]
intros
{ ext m, simp }
ext m
simp
intros
ext ‚ü®x, y‚ü©
{ ext ‚ü®x, y‚ü©, simp only [and.left_comm, eq_comm, mem_map, prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left', mem_prod] }
simp only [and.left_comm, eq_comm, mem_map, prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left', mem_prod]
intros
{ simp only [polar, pi.neg_apply, sub_eq_add_neg, neg_add] }
simp only [polar, pi.neg_apply, sub_eq_add_neg, neg_add]
intros
simp only [ltensor, rtensor, ‚Üê map_comp, id_comp, comp_id]
intros
simp
intros
rw [or_comm, or_iff_left_iff_imp]
intros
{ ext, simp, }
ext
simp
intros
rw [apply_ite f, h, ite_not]
intros
simp [hs]
intros
rw [‚Üê hC, ‚Üê hD, generate_from_prod_eq h2C h2D]
intros
obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hŒº, hŒΩ‚ü© := s.to_jordan_decomposition_spec
simp only [jordan_decomposition.to_signed_measure, hŒº, hŒΩ]
ext k hk
rw [to_signed_measure_sub_apply hk, to_measure_of_zero_le_apply _ hi‚ÇÇ hi‚ÇÅ hk, to_measure_of_le_zero_apply _ hi‚ÇÉ hi‚ÇÅ.compl hk]
simp only [ennreal.coe_to_real, subtype.coe_mk, ennreal.some_eq_coe, sub_neg_eq_add]
rw [‚Üê of_union _ (measurable_set.inter hi‚ÇÅ hk) (measurable_set.inter hi‚ÇÅ.compl hk), set.inter_comm i, set.inter_comm i·∂ú, set.inter_union_compl _ _]
{ apply_instance }
apply_instance
rintro x ‚ü®‚ü®hx‚ÇÅ, _‚ü©, hx‚ÇÇ, _‚ü©
{ rintro x ‚ü®‚ü®hx‚ÇÅ, _‚ü©, hx‚ÇÇ, _‚ü©, exact false.elim (hx‚ÇÇ hx‚ÇÅ) }
exact false.elim (hx‚ÇÇ hx‚ÇÅ)
intros
set f' := hfi.1.mk f
have hadd' : s = t + Œº.with_density·µ• f'
convert hadd using 2
{ convert hadd using 2, exact with_density·µ•_eq.congr_ae hfi.1.ae_eq_mk.symm }
exact with_density·µ•_eq.congr_ae hfi.1.ae_eq_mk.symm
haveI := have_lebesgue_decomposition_mk Œº hfi.1.measurable_mk htŒº hadd'
refine (integrable.ae_eq_of_with_density·µ•_eq (integrable_rn_deriv _ _) hfi _).symm
rw [‚Üê add_right_inj t, ‚Üê hadd, eq_singular_part _ f htŒº hadd, singular_part_add_with_density_rn_deriv_eq]
intros
refine integrable.sub _ _; { split, measurability, exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ Œº).ne }
refine integrable.sub _ _
{ split, measurability, exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ Œº).ne }
split
{ split, measurability, exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ Œº).ne }
measurability
exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ Œº).ne
intros
rw ‚Üê complete_space_coe_iff_is_complete
haveI : fact (m ‚â§ m0) := ‚ü®hm‚ü©
change complete_space (Lp_meas_subgroup F m p Œº)
apply_instance
intros
simp_rw [integrable, and_iff_right hf, and_iff_right hf.norm, has_finite_integral_norm_iff]
intros
{ rw [norm_to_L1, lintegral_norm_eq_lintegral_edist] }
rw [norm_to_L1, lintegral_norm_eq_lintegral_edist]
intros
simp [mem_Lp_iff_snorm_lt_top, mem_‚Ñíp, f.measurable.ae_measurable]
intros
simp [mem_‚Ñíp, ae_measurable_indicator_iff hs, snorm_indicator_eq_snorm_restrict hs]
intros
simp [mem_‚Ñíp, snorm_exponent_zero]
intros
rw support_eq
refine (measure_bUnion_finset_le _ _).trans_lt (ennreal.sum_lt_top_iff.mpr (Œª y hy, _))
rw finset.mem_filter at hy
exact hf y hy.2
intros
by_cases hfm : ae_measurable f Œº
rw integral_eq_lintegral_of_nonneg_ae hf hfm
{ rw integral_eq_lintegral_of_nonneg_ae hf hfm, exact to_real_nonneg }
exact to_real_nonneg
{ rw integral_non_ae_measurable hfm }
rw integral_non_ae_measurable hfm
intros
simp only [integral_const', real.volume_Ioc, ennreal.to_real_of_real', ‚Üê neg_sub b, max_zero_sub_eq_self]
intros
have hac := hab.trans hbc
simp only [interval_integral, ‚Üê add_sub_comm, sub_eq_zero]
rw ‚Üê integral_union
iterate 4 { rw ‚Üê integral_union }
rw ‚Üê integral_union
rw ‚Üê integral_union
rw ‚Üê integral_union
suffices : Ioc a b ‚à™ Ioc b c ‚à™ Ioc c a = Ioc b a ‚à™ Ioc c b ‚à™ Ioc a c
{ suffices : Ioc a b ‚à™ Ioc b c ‚à™ Ioc c a = Ioc b a ‚à™ Ioc c b ‚à™ Ioc a c, by rw this, rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle, min_left_comm, max_left_comm] }
rw this
rw this
rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle, min_left_comm, max_left_comm]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
all_goals { simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2] }
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
intros
refine absolutely_continuous.mk (Œª s hs‚ÇÅ hs‚ÇÇ, _)
rw with_density_apply _ hs‚ÇÅ
exact set_lintegral_measure_zero _ _ hs‚ÇÇ
intros
refine lintegral_mono _
intro a
rw ennreal.coe_le_coe
exact h a
intros
rw [measure.restrict_map hg hs, integral_map hg (hf.mono_measure _)]
exact measure.map_mono g measure.restrict_le_self
intros
simp [set_to_simple_func]
intros
rw set_to_fun_congr_ae hT (@indicator_const_Lp_coe_fn _ _ _ 1 _ _ _ _ hs hŒºs x _ _).symm
rw L1.set_to_fun_eq_set_to_L1 hT
exact L1.set_to_L1_indicator_const_Lp hT hs hŒºs x
intros
simp_rw [measurable_iff_comap_le, measurable_space.pi, measurable_space.comap_supr, measurable_space.comap_comp, function.comp, supr_le_iff]
intros
by_cases p; simp [h, hf, measurable_set.univ]
{ by_cases p; simp [h, hf, measurable_set.univ] }
by_cases p
simp [h, hf, measurable_set.univ]
simp [h, hf, measurable_set.univ]
intros
unfold index
rw [nat.Inf_def, nat.find_pos, mem_image]
rintro ‚ü®t, h1t, h2t‚ü©
{ rintro ‚ü®t, h1t, h2t‚ü©, rw [finset.card_eq_zero] at h2t, subst h2t, cases K.2.2 with g hg, show g ‚àà (‚àÖ : set G), convert h1t (interior_subset hg), symmetry, apply bUnion_empty }
rw [finset.card_eq_zero] at h2t
subst h2t
cases K.2.2 with g hg
show g ‚àà (‚àÖ : set G)
convert h1t (interior_subset hg)
symmetry
apply bUnion_empty
{ exact index_defined K.2.1 hV }
exact index_defined K.2.1 hV
intros
refine le_antisymm (le_pre.2 $ Œª s hs, _) (le_trim _)
rw trim_eq_infi
refine (infi_le_of_le (closure s) $ infi_le_of_le subset_closure $ infi_le_of_le measurable_set_closure ((pre_le _).trans_eq (hcl _)))
rwa diam_closure
intros
rw [‚Üê pi_univ_Icc, volume_pi_pi]
{ simp only [real.volume_Icc] }
simp only [real.volume_Icc]
intros
simp [volume_val]
intros
by_cases hs : s.finite
{ simp [set.infinite, hs, count_apply_finite] }
simp [set.infinite, hs, count_apply_finite]
change s.infinite at hs
{ change s.infinite at hs, simp [hs, count_apply_infinite] }
simp [hs, count_apply_infinite]
intros
simp_rw [measure.trim]
{ simp_rw [measure.trim], exact (@le_to_measure_apply _ m _ _ _), }
exact (@le_to_measure_apply _ m _ _ _)
intros
rw [‚Üê Œº‚ÇÇ.trimmed, outer_measure.le_trim_iff]; refl
rw [‚Üê Œº‚ÇÇ.trimmed, outer_measure.le_trim_iff]
refl
intros
rw [add_comm, restrict_add_restrict_compl hs]
intros
{ convert m.union _ _, rw inter_union_diff t s }
convert m.union _ _
rw inter_union_diff t s
intros
rcases t.eq_empty_or_nonempty with rfl|ht
rcases h with ‚ü®Œº, hŒº‚ü©
{ rcases h with ‚ü®Œº, hŒº‚ü©, rw [eq_false_intro empty_not_nonempty, supr_false, eq_comm], simp_rw [empty'], apply bot_unique, refine infi_le_of_le Œº (infi_le _ hŒº) }
rw [eq_false_intro empty_not_nonempty, supr_false, eq_comm]
simp_rw [empty']
apply bot_unique
refine infi_le_of_le Œº (infi_le _ hŒº)
{ simp [ht, Inf_gen_def] }
simp [ht, Inf_gen_def]
intros
erw [to_measure_of_zero_le_apply]
{ simp }
simp
{ assumption }
assumption
intros
have hfi := integrable_to_real_of_lintegral_ne_top hfm hf
ext i hi
rw [with_density·µ•_apply hfi hi, to_signed_measure_apply_measurable hi, with_density_apply _ hi, integral_to_real hfm.restrict]
refine ae_lt_top' hfm.restrict (ne_top_of_le_ne_top hf _)
conv_rhs { rw ‚Üê set_lintegral_univ }
exact lintegral_mono_set (set.subset_univ _)
intros
simp only [pmf.bind_pure, pmf.bind_on_support_eq_bind]
intros
ext x
cases x; simp [nat.succ_ne_zero]
cases x
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
intros
simp [h.proper_divisors]
intros
rintros ‚ü®‚ü®a, b, bN0, cop‚ü©, rfl‚ü©
change (liouville (a / b)) at h
rcases h (b + 1) with ‚ü®p, q, q1, a0, a1‚ü©
have qR0 : (0 : ‚Ñù) < q := int.cast_pos.mpr (zero_lt_one.trans q1)
have b0 : (b : ‚Ñù) ‚â† 0 := ne_of_gt (nat.cast_pos.mpr bN0)
have bq0 : (0 : ‚Ñù) < b * q := mul_pos (nat.cast_pos.mpr bN0) qR0
replace a1 : abs (a * q - b * p) * q ^ (b + 1) < b * q
rwa [div_sub_div _ _ b0 (ne_of_gt qR0), abs_div, div_lt_div_iff (abs_pos.mpr (ne_of_gt bq0)) (pow_pos qR0 _), abs_of_pos bq0, one_mul, ‚Üê int.cast_pow, ‚Üê int.cast_mul, ‚Üê int.cast_coe_nat, ‚Üê int.cast_mul, ‚Üê int.cast_mul, ‚Üê int.cast_sub, ‚Üê int.cast_abs, ‚Üê int.cast_mul, int.cast_lt] at a1
rwa [div_sub_div _ _ b0 (ne_of_gt qR0), abs_div, div_lt_div_iff (abs_pos.mpr (ne_of_gt bq0)) (pow_pos qR0 _), abs_of_pos bq0, one_mul, ‚Üê int.cast_pow, ‚Üê int.cast_mul, ‚Üê int.cast_coe_nat, ‚Üê int.cast_mul, ‚Üê int.cast_mul, ‚Üê int.cast_sub, ‚Üê int.cast_abs, ‚Üê int.cast_mul, int.cast_lt] at a1
replace a0 : ¬¨a * q - ‚Üëb * p = 0
rwa [ne.def, div_eq_div_iff b0 (ne_of_gt qR0), mul_comm ‚Üëp, ‚Üê sub_eq_zero, ‚Üê int.cast_coe_nat, ‚Üê int.cast_mul, ‚Üê int.cast_mul, ‚Üê int.cast_sub, int.cast_eq_zero] at a0
rwa [ne.def, div_eq_div_iff b0 (ne_of_gt qR0), mul_comm ‚Üëp, ‚Üê sub_eq_zero, ‚Üê int.cast_coe_nat, ‚Üê int.cast_mul, ‚Üê int.cast_mul, ‚Üê int.cast_sub, int.cast_eq_zero] at a0
lift q to ‚Ñï using (zero_lt_one.trans q1).le
have ap : 0 < abs (a * ‚Üëq - ‚Üëb * p) := abs_pos.mpr a0
lift (abs (a * ‚Üëq - ‚Üëb * p)) to ‚Ñï using (abs_nonneg (a * ‚Üëq - ‚Üëb * p))
rw [‚Üê int.coe_nat_mul, ‚Üê int.coe_nat_pow, ‚Üê int.coe_nat_mul, int.coe_nat_lt] at a1
exact not_le.mpr a1 (nat.mul_lt_mul_pow_succ (int.coe_nat_pos.mp ap) (int.coe_nat_lt.mp q1)).le
intros
cases œâ_pow_formula p' h with k w
rw [mersenne_coe_X] at w
simpa using w
intros
convert padic.norm_eq_pow_val _
contrapose! hx
exact subtype.val_injective hx
intros
have n_nonzero : (n : ‚Ñö) ‚â† 0
simpa only [cast_eq_zero, ne.def]
simpa only [cast_eq_zero, ne.def]
simpa only [ int.coe_nat_multiplicity p n, rat.coe_nat_denom n, (padic_val_rat_of_nat p n).symm, int.coe_nat_zero, int.coe_nat_inj', sub_zero, get_one_right, int.coe_nat_succ, zero_add, rat.coe_nat_num ] using padic_val_rat_def p n_nonzero
intros
by_cases hz : 0 < z
exact h.is_primitive_classified_of_coprime_of_pos hc hz
{ exact h.is_primitive_classified_of_coprime_of_pos hc hz }
have h' : pythagorean_triple x y (-z)
{ simpa [pythagorean_triple, neg_mul_neg] using h.eq, }
simpa [pythagorean_triple, neg_mul_neg] using h.eq
apply h'.is_primitive_classified_of_coprime_of_pos hc
apply lt_of_le_of_ne _ (h'.ne_zero_of_coprime hc).symm
exact le_neg.mp (not_lt.mp hz)
intros
split
rintro ‚ü®x, rfl‚ü©
{ rintro ‚ü®x, rfl‚ü©, simp only [add_zero, coe_int_re, zero_mul, mul_im, dvd_mul_right, and_self, mul_re, mul_zero, coe_int_im] }
simp only [add_zero, coe_int_re, zero_mul, mul_im, dvd_mul_right, and_self, mul_re, mul_zero, coe_int_im]
rintro ‚ü®‚ü®r, hr‚ü©, ‚ü®i, hi‚ü©‚ü©
{ rintro ‚ü®‚ü®r, hr‚ü©, ‚ü®i, hi‚ü©‚ü©, use ‚ü®r, i‚ü©, rw [smul_val, ext], exact ‚ü®hr, hi‚ü© }
use ‚ü®r, i‚ü©
rw [smul_val, ext]
exact ‚ü®hr, hi‚ü©
intros
rw [‚Üêinf_inf_sdiff, inf_idem, inf_of_le_right (@sdiff_le _ x x _)]
intros
rw [disjoint_iff, h.eq_bot_of_le (inf_le_left.trans hle)]
intros
casesI is_empty_or_nonempty Œπ
{ rw [supr_of_empty', supr_of_empty'] }
rw [supr_of_empty', supr_of_empty']
{ exact csupr_le (Œª x, le_csupr_of_le B x (H x)) }
exact csupr_le (Œª x, le_csupr_of_le B x (H x))
intros
apply h.tendsto_at_top_at_top
intro b
rcases not_bdd_above_iff.1 H b with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©
exact ‚ü®N, le_of_lt hN‚ü©
intros
simpa only [mul_comm] using hf.const_mul_at_bot hr
intros
{ ext U, simp [h.mem_iff, is_basis.mem_filter_iff] }
ext U
simp [h.mem_iff, is_basis.mem_filter_iff]
intros
simp
intros
rw [filter.map_map, H, ‚Üê filter.map_map]
intros
simp only [filter.Coprod, supr_ne_bot, ‚Üê exists_and_distrib_left, ‚Üê comap_eval_ne_bot_iff']
intros
simp only [filter.lift', filter.lift, (‚àò), ‚Üê inf_principal, infi_subtype', ‚Üê infi_inf]
intros
intros a b; rw [gc2, gc1]
intros a b
rw [gc2, gc1]
intros
refine ‚ü®x ‚äì i, I.mem_of_le inf_le_right hi, x ‚äì j, J.mem_of_le inf_le_right hj, _‚ü©
calc x = x ‚äì (i ‚äî j) : left_eq_inf.mpr hx ... = (x ‚äì i) ‚äî (x ‚äì j) : inf_sup_left
intros
simpa only [limsup_eq, eventually_const] using cInf_Ici
intros
simp only [supr, hf.map_Sup', ‚Üê range_comp]
intros
simp only [(Œî), sup_comm]
intros
rw ‚Üê image_mul_prod
exact (is_pwo.prod hs ht).image_of_monotone (Œª _ _ h, mul_le_mul' h.1 h.2)
intros
intros t1 t2 ht1 ht2
cases (set.mem_union _ _ _).mp ht1 with ht1‚ÇÅ ht1‚ÇÇ
{ exact h‚ÇÅ t1 t2 ht1‚ÇÅ ht2, }
exact h‚ÇÅ t1 t2 ht1‚ÇÅ ht2
{ exact h‚ÇÇ t1 t2 ht1‚ÇÇ ht2, }
exact h‚ÇÇ t1 t2 ht1‚ÇÇ ht2
intros
have : (x‚Åª¬π : L) = aeval x (div_X p) / (aeval x p - algebra_map _ _ (p.coeff 0))
rw [aeval_eq, subalgebra.coe_zero, zero_sub, div_neg]
{ rw [aeval_eq, subalgebra.coe_zero, zero_sub, div_neg], convert inv_eq_of_root_of_coeff_zero_ne_zero _ coeff_zero_ne, { rw subalgebra.aeval_coe }, { simpa using aeval_eq } }
convert inv_eq_of_root_of_coeff_zero_ne_zero _ coeff_zero_ne
{ rw subalgebra.aeval_coe }
rw subalgebra.aeval_coe
{ simpa using aeval_eq }
simpa using aeval_eq
rw [this, div_eq_mul_inv, aeval_eq, subalgebra.coe_zero, zero_sub, ‚Üê ring_hom.map_neg, ‚Üê ring_hom.map_inv]
exact A.mul_mem (aeval x p.div_X).2 (A.algebra_map_mem _)
intros
{ rw mul_comm at H, exact H.of_mul_left_left }
rw mul_comm at H
exact H.of_mul_left_left
intros
refine ‚ü®hP, mt ideal.is_unit_iff.mp h.ne_top, Œª I J hIJ, _‚ü©
simpa only [ideal.dvd_iff_le] using (h.mul_le.mp (ideal.le_of_dvd hIJ))
intros
obtain ‚ü®equiv‚ü© := @fintype.trunc_equiv_fin Œπ (classical.dec_eq Œπ) _
replace equiv := mv_polynomial.rename_equiv R equiv
refine ‚ü®_, alg_equiv.to_alg_hom equiv.symm, _‚ü©
split
{ exact (alg_equiv.symm equiv).surjective }
exact (alg_equiv.symm equiv).surjective
suffices hinj : function.injective equiv.symm.to_alg_hom.to_ring_hom
rw [(ring_hom.injective_iff_ker_eq_bot _).1 hinj]
{ rw [(ring_hom.injective_iff_ker_eq_bot _).1 hinj], exact submodule.fg_bot }
exact submodule.fg_bot
exact (alg_equiv.symm equiv).injective
intros
convert mul_left_mono I hI
exact (mul_one I).symm
intros
simpa only [‚Üêinjective_iff_ker_eq_bot] using f.injective
intros
cases (nat_abs_eq a) with h
{ use [1, is_unit_one], rw [‚Üê h, one_mul], }
use [1, is_unit_one]
rw [‚Üê h, one_mul]
use [-1, is_unit_one.neg]
{ use [-1, is_unit_one.neg], rw [ ‚Üê neg_eq_iff_neg_eq.mp (eq.symm h)], simp only [neg_mul_eq_neg_mul_symm, one_mul] }
rw [ ‚Üê neg_eq_iff_neg_eq.mp (eq.symm h)]
simp only [neg_mul_eq_neg_mul_symm, one_mul]
intros
{ rw [pow_dvd_iff_le_multiplicity, not_le] }
rw [pow_dvd_iff_le_multiplicity, not_le]
intros
split
split; assume h
unfreezingI { split; assume h }
assume h
exact is_noetherian_of_linear_equiv (linear_equiv.of_top (‚ä§ : submodule R M) rfl)
{ exact is_noetherian_of_linear_equiv (linear_equiv.of_top (‚ä§ : submodule R M) rfl) }
assume h
exact is_noetherian_of_linear_equiv (linear_equiv.of_top (‚ä§ : submodule R M) rfl).symm
{ exact is_noetherian_of_linear_equiv (linear_equiv.of_top (‚ä§ : submodule R M) rfl).symm }
intros
{ simp only [U], ring, }
simp only [U]
ring
intros
classical
suffices h : ‚àÄ (n : ‚Ñï) (p q : polynomial R), ((p * q).degree < n) ‚Üí (p * q).content = p.content * q.content
apply h
{ apply h, apply (lt_of_le_of_lt degree_le_nat_degree (with_bot.coe_lt_coe.2 (nat.lt_succ_self _))) }
apply (lt_of_le_of_lt degree_le_nat_degree (with_bot.coe_lt_coe.2 (nat.lt_succ_self _)))
intro n
induction n with n ih
intros p q hpq
{ intros p q hpq, rw [with_bot.coe_zero, nat.with_bot.lt_zero_iff, degree_eq_bot, mul_eq_zero] at hpq, rcases hpq with rfl | rfl; simp }
rw [with_bot.coe_zero, nat.with_bot.lt_zero_iff, degree_eq_bot, mul_eq_zero] at hpq
rcases hpq with rfl | rfl; simp
rcases hpq with rfl | rfl
simp
simp
intros p q hpq
by_cases p0 : p = 0
simp [p0]
{ simp [p0] }
by_cases q0 : q = 0
simp [q0]
{ simp [q0] }
rw [degree_eq_nat_degree (mul_ne_zero p0 q0), with_bot.coe_lt_coe, nat.lt_succ_iff_lt_or_eq, ‚Üê with_bot.coe_lt_coe, ‚Üê degree_eq_nat_degree (mul_ne_zero p0 q0), nat_degree_mul p0 q0] at hpq
rcases hpq with hlt | heq
apply ih _ _ hlt
{ apply ih _ _ hlt }
rw [‚Üê p.nat_degree_prim_part, ‚Üê q.nat_degree_prim_part, ‚Üê with_bot.coe_eq_coe, with_bot.coe_add, ‚Üê degree_eq_nat_degree p.prim_part_ne_zero, ‚Üê degree_eq_nat_degree q.prim_part_ne_zero] at heq
rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]
suffices h : (q.prim_part * p.prim_part).content = 1
rw [mul_assoc, content_C_mul, content_C_mul, mul_comm p.prim_part, mul_assoc, content_C_mul, content_C_mul, h, mul_one, content_prim_part, content_prim_part, mul_one, mul_one]
{ rw [mul_assoc, content_C_mul, content_C_mul, mul_comm p.prim_part, mul_assoc, content_C_mul, content_C_mul, h, mul_one, content_prim_part, content_prim_part, mul_one, mul_one] }
rw [‚Üê normalize_content, normalize_eq_one, is_unit_iff_dvd_one, content_eq_gcd_leading_coeff_content_erase_lead, leading_coeff_mul, gcd_comm]
apply (gcd_mul_dvd_mul_gcd _ _ _).trans
rw [content_mul_aux, ih, content_prim_part, mul_one, gcd_comm, ‚Üê content_eq_gcd_leading_coeff_content_erase_lead, content_prim_part, one_mul, mul_comm q.prim_part, content_mul_aux, ih, content_prim_part, mul_one, gcd_comm, ‚Üê content_eq_gcd_leading_coeff_content_erase_lead, content_prim_part]
rw [‚Üê heq, degree_mul, with_bot.add_lt_add_iff_right]
{ rw [‚Üê heq, degree_mul, with_bot.add_lt_add_iff_right], { apply degree_erase_lt p.prim_part_ne_zero }, { rw [ne.def, degree_eq_bot], apply q.prim_part_ne_zero } }
{ apply degree_erase_lt p.prim_part_ne_zero }
apply degree_erase_lt p.prim_part_ne_zero
rw [ne.def, degree_eq_bot]
{ rw [ne.def, degree_eq_bot], apply q.prim_part_ne_zero }
apply q.prim_part_ne_zero
rw [mul_comm, ‚Üê heq, degree_mul, with_bot.add_lt_add_iff_left]
{ rw [mul_comm, ‚Üê heq, degree_mul, with_bot.add_lt_add_iff_left], { apply degree_erase_lt q.prim_part_ne_zero }, { rw [ne.def, degree_eq_bot], apply p.prim_part_ne_zero } }
{ apply degree_erase_lt q.prim_part_ne_zero }
apply degree_erase_lt q.prim_part_ne_zero
rw [ne.def, degree_eq_bot]
{ rw [ne.def, degree_eq_bot], apply p.prim_part_ne_zero }
apply p.prim_part_ne_zero
intros
rw ‚Üêmap_cyclotomic_int
rw degree_map_eq_of_leading_coeff_ne_zero (int.cast_ring_hom R) _
cases n with k
{ cases n with k, { simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]}, rw [‚Üêdegree_cyclotomic' (complex.is_primitive_root_exp k.succ (nat.succ_ne_zero k))], exact (int_cyclotomic_spec k.succ).2.1 }
simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]
{ simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]}
rw [‚Üêdegree_cyclotomic' (complex.is_primitive_root_exp k.succ (nat.succ_ne_zero k))]
exact (int_cyclotomic_spec k.succ).2.1
simp only [(int_cyclotomic_spec n).right.right, ring_hom.eq_int_cast, monic.leading_coeff, int.cast_one, ne.def, not_false_iff, one_ne_zero]
intros
rw [‚Üê algebra_map_aeval, ‚Üê (algebra_map A B).map_zero] at hp
exact h hp
intros
convert pb.constr_pow_aeval hy X; rw aeval_X
{ convert pb.constr_pow_aeval hy X; rw aeval_X }
convert pb.constr_pow_aeval hy X
rw aeval_X
rw aeval_X
intros
convert rfl
intros
rw [coeff_zero_eq_constant_coeff]; refl
rw [coeff_zero_eq_constant_coeff]
intros
rw [‚Üê finset.val_eq_zero, ‚Üê multiset.subset_zero, ‚Üê nth_roots_zero (1 : R), primitive_roots]
simp only [finset.not_mem_empty, forall_const, forall_prop_of_false, multiset.to_finset_zero, finset.filter_true_of_mem, finset.empty_val, not_false_iff, multiset.zero_subset, nth_roots_zero]
intros
simp [‚Üê submonoid.subsemiring_closure_to_add_submonoid, submonoid.subsemiring_closure_eq_closure]
intros
haveI : finite_dimensional L F := finite_dimensional.right K L F
haveI : is_separable L F := is_separable_tower_top_of_is_separable K L F
letI : fintype (L ‚Üí‚Çê[K] E) := power_basis.alg_hom.fintype pb
letI : ‚àÄ (f : L ‚Üí‚Çê[K] E), fintype (@@alg_hom L F E _ _ _ _ f.to_ring_hom.to_algebra) := _
rw [fintype.sum_equiv alg_hom_equiv_sigma (Œª (œÉ : F ‚Üí‚Çê[K] E), _) (Œª œÉ, œÉ.1 pb.gen), ‚Üê finset.univ_sigma_univ, finset.sum_sigma, ‚Üê finset.sum_nsmul]
refine finset.sum_congr rfl (Œª œÉ _, _)
letI : algebra L E := œÉ.to_ring_hom.to_algebra
{ letI : algebra L E := œÉ.to_ring_hom.to_algebra, simp only [finset.sum_const, finset.card_univ], rw alg_hom.card L F E }
simp only [finset.sum_const, finset.card_univ]
rw alg_hom.card L F E
intros œÉ
{ intros œÉ, simp only [alg_hom_equiv_sigma, equiv.coe_fn_mk, alg_hom.restrict_domain, alg_hom.comp_apply, is_scalar_tower.coe_to_alg_hom'] }
simp only [alg_hom_equiv_sigma, equiv.coe_fn_mk, alg_hom.restrict_domain, alg_hom.comp_apply, is_scalar_tower.coe_to_alg_hom']
intros
haveI := classical.dec_eq Œ±
refine multiset.induction_on f (Œª h, (ha.not_unit (associated_one_iff_is_unit.1 (associated.symm h))).elim) _ pfa.2 pfa.1
rintros p s _ ‚ü®u, hu‚ü© hs
use p
have hs0 : s = 0
by_contra hs0
{ by_contra hs0, obtain ‚ü®q, hq‚ü© := multiset.exists_mem_of_ne_zero hs0, apply (hs q (by simp [hq])).2.1, refine (ha.is_unit_or_is_unit (_ : _ = ((p * ‚Üëu) * (s.erase q).prod) * _)).resolve_left _, { rw [mul_right_comm _ _ q, mul_assoc, ‚Üê multiset.prod_cons, multiset.cons_erase hq, ‚Üê hu, mul_comm, mul_comm p _, mul_assoc], simp, }, apply mt is_unit_of_mul_is_unit_left (mt is_unit_of_mul_is_unit_left _), apply (hs p (multiset.mem_cons_self _ _)).2.1 }
obtain ‚ü®q, hq‚ü© := multiset.exists_mem_of_ne_zero hs0
apply (hs q (by simp [hq])).2.1
refine (ha.is_unit_or_is_unit (_ : _ = ((p * ‚Üëu) * (s.erase q).prod) * _)).resolve_left _
rw [mul_right_comm _ _ q, mul_assoc, ‚Üê multiset.prod_cons, multiset.cons_erase hq, ‚Üê hu, mul_comm, mul_comm p _, mul_assoc]
{ rw [mul_right_comm _ _ q, mul_assoc, ‚Üê multiset.prod_cons, multiset.cons_erase hq, ‚Üê hu, mul_comm, mul_comm p _, mul_assoc], simp, }
simp
apply mt is_unit_of_mul_is_unit_left (mt is_unit_of_mul_is_unit_left _)
apply (hs p (multiset.mem_cons_self _ _)).2.1
simp only [mul_one, multiset.prod_cons, multiset.prod_zero, hs0] at *
exact ‚ü®associated.symm ‚ü®u, hu‚ü©, rfl‚ü©
intros
simp [factors', multiset.map_pmap, multiset.pmap_eq_map]
intros
{ rw [comap_supp, ‚Üê ideal.map_le_iff_le_comap], simp }
rw [comap_supp, ‚Üê ideal.map_le_iff_le_comap]
simp
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [witt_zero, witt_structure_rat, bind‚ÇÅ, aeval_zero', constant_coeff_X_in_terms_of_W, ring_hom.map_zero, alg_hom.map_zero, map_witt_structure_int]
intros
delta frobenius_poly_rat
rw [‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_X_in_terms_of_W_witt_polynomial, bind‚ÇÅ_X_right]
intros
obtain ‚ü®œÜ, hf‚ü© := hf
unfreezingI {obtain ‚ü®œÜ, hf‚ü© := hf}
ext n
simp only [map_coeff, hf, map_aeval]
apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl
simp only [map_coeff]
intros
show coeff i (truncate_fun _ 0 : truncated_witt_vector p n R) = 0
rw [coeff_truncate_fun, witt_vector.zero_coeff]
intros
rw [‚Üê map_witt_polynomial p (int.cast_ring_hom R), ‚Üê witt_polynomial_vars p ‚Ñ§]
apply vars_map
intros
rw [‚Üê typein_lt_typein r, typein_enum, typein_enum]
intros
induction h with _ e n a eb b h‚ÇÅ h‚ÇÇ h‚ÇÉ _ IH
induction h with _ e n a eb b h‚ÇÅ h‚ÇÇ h‚ÇÉ _ IH; constructor
constructor
constructor
exacts [h‚ÇÅ, h‚ÇÇ, lt_of_lt_of_le h‚ÇÉ bb]
intros
induction n with n hn
{ exact numeric_one }
exact numeric_one
split
{ split, { rintro ‚ü® ‚ü© ‚ü® ‚ü©, dsimp only [pi.zero_apply], rw ‚Üê pow_half_move_left' n, apply hn.move_left_lt }, { exact ‚ü®Œª _, numeric_zero, Œª _, hn‚ü© } }
rintro ‚ü® ‚ü© ‚ü® ‚ü©
{ rintro ‚ü® ‚ü© ‚ü® ‚ü©, dsimp only [pi.zero_apply], rw ‚Üê pow_half_move_left' n, apply hn.move_left_lt }
dsimp only [pi.zero_apply]
rw ‚Üê pow_half_move_left' n
apply hn.move_left_lt
{ exact ‚ü®Œª _, numeric_zero, Œª _, hn‚ü© }
exact ‚ü®Œª _, numeric_zero, Œª _, hn‚ü©
intros
simp [h.symm, termg, add_assoc]
intros
by_cases h : c; simp [h]
by_cases h : c
simp [h]
simp [h]
intros
rw [mul_symdiv_eq, sub_sub_cancel]
intros
simp [h‚ÇÅ.symm, h‚ÇÇ.symm, horner, mul_pow, pow_mul]
intros
simp
intros
simp only [has_basis_nhds_infty.ge_iff, and_imp]
intros
ext x
apply completion.induction_on x
apply is_closed_eq ((0 : Œ± ‚Üí+ Œ≤).continuous_completion continuous_const)
{ apply is_closed_eq ((0 : Œ± ‚Üí+ Œ≤).continuous_completion continuous_const), simp [continuous_const] }
simp [continuous_const]
intro a
{ intro a, simp [(0 : Œ± ‚Üí+ Œ≤).completion_coe continuous_const, coe_zero] }
simp [(0 : Œ± ‚Üí+ Œ≤).completion_coe continuous_const, coe_zero]
intros
simp_rw ‚Üê nat.sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l)
exact summable_sum_mul_antidiagonal_of_summable_mul h
intros
rw [e.symm.image_eq_preimage, e.symm_symm]
intros
induction n with n ihn
{ ext, simp }
ext
simp
rw [pow_succ, ihn, mul_def, smul_right_comp, smul_eq_mul, pow_succ']
{ rw [pow_succ, ihn, mul_def, smul_right_comp, smul_eq_mul, pow_succ'] }
intros
{ conv in (_ + _) { rw add_comm }, exact hg.add_at_top hf }
conv in (_ + _) { rw add_comm }
exact hg.add_at_top hf
intros
apply subset.antisymm
exact closure_minimal Ioc_subset_Icc_self is_closed_Icc
{ exact closure_minimal Ioc_subset_Icc_self is_closed_Icc }
apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
{ apply subset.trans _ (closure_mono Ioo_subset_Ioc_self), rw closure_Ioo hab }
rw closure_Ioo hab
intros
simp [lt_iff_not_ge, -not_le]; exact (is_closed_le hg hf).is_open_compl
simp [lt_iff_not_ge, -not_le]
exact (is_closed_le hg hf).is_open_compl
intros
rw [‚Üê nhds_within_union, Iic_union_Ici, nhds_within_univ]
intros
{ simp only [min_def], exact hf.if_le hg hf hg (Œª x, id) }
simp only [min_def]
exact hf.if_le hg hf hg (Œª x, id)
intros
{ ext, rw h }
ext
rw h
intros
simp only [‚Üê ne_empty_iff_nonempty, ne.def, closure_empty_iff]
intros
simp only [cluster_pt_principal_iff, frequently_iff, set.nonempty, exists_prop, mem_inter_iff]
intros
simpa only [dense_range, prod_range_range_eq] using hf.prod hg
intros
{ rw ‚Üêset.image_univ, exact is_open_map_sigma_mk _ is_open_univ }
rw ‚Üêset.image_univ
exact is_open_map_sigma_mk _ is_open_univ
intros
rw [nhds_within_restrict' t hs, nhds_within_restrict' u hs, h‚ÇÇ]
intros
rw [continuous_on, continuous_iff_continuous_at]
split
rintros h ‚ü®x, xs‚ü©
{ rintros h ‚ü®x, xs‚ü©, exact (continuous_within_at_iff_continuous_at_restrict f xs).mp (h x xs) }
exact (continuous_within_at_iff_continuous_at_restrict f xs).mp (h x xs)
intros h x xs
exact (continuous_within_at_iff_continuous_at_restrict f xs).mpr (h ‚ü®x, xs‚ü©)
intros
rw [nhds_within, map_inf hf.inj, hf.map_nhds_eq, map_principal, ‚Üê nhds_within_inter', inter_eq_self_of_subset_right (image_subset_range _ _)]
intros
refine continuous_snd.comp (e‚ÇÇ.to_local_homeomorph.continuous_on.comp_continuous (e‚ÇÅ.to_local_homeomorph.continuous_on_symm.comp_continuous _ _) _)
{ exact continuous_const.prod_mk continuous_id }
exact continuous_const.prod_mk continuous_id
{ exact Œª x, e‚ÇÅ.mem_target.2 h‚ÇÅ }
exact Œª x, e‚ÇÅ.mem_target.2 h‚ÇÅ
intro x
{ intro x, rwa [e‚ÇÇ.mem_source, e‚ÇÅ.proj_symm_apply' h‚ÇÅ] }
rwa [e‚ÇÇ.mem_source, e‚ÇÅ.proj_symm_apply' h‚ÇÅ]
intros
rw [tendsto_nhds_top_iff_nnreal, at_top_basis_Ioi.tendsto_right_iff]
rw [tendsto_nhds_top_iff_nnreal, at_top_basis_Ioi.tendsto_right_iff]; [simp, apply_instance, apply_instance]
simp
apply_instance
apply_instance
intros
have A : ‚àÄ (a : Œ±), (f a : ‚Ñù) ‚â§ g a := Œª a, nnreal.coe_le_coe.2 (h a)
have : (sf : ‚Ñù) < sg := has_sum_lt A (nnreal.coe_lt_coe.2 hi) (has_sum_coe.2 hf) (has_sum_coe.2 hg)
exact nnreal.coe_lt_coe.1 this
intros
simpa only [continuous_at, e.left_inv hx] using e.continuous_at_symm (e.map_source hx)
intros
rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.right, coinduced_compose]
intros
refine ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).2 (Œª Œµ h‚ÇÄ, _)
refine ‚ü®K‚Åª¬π * Œµ, ennreal.mul_pos (ennreal.inv_ne_zero.2 ennreal.coe_ne_top) h‚ÇÄ.ne', _‚ü©
refine Œª x hx, (hf x.1 x.2).trans_lt _
rw [mul_comm, ‚Üê div_eq_mul_inv] at hx
rw mul_comm
exact ennreal.mul_lt_of_lt_div hx
intros
simp [real.dist_eq]
intros
simp only [‚Üê metric.Union_ball_nat_succ (0 : Œπ ‚Üí ‚Ñù), dimH_Union, dimH_ball_pi _ (nat.cast_add_one_pos _), supr_const]
intros
simp [inf_dist, inf_edist, dist_edist]
intros
simpa only [real.to_nnreal_coe] using lipschitz_with.of_le_add_mul' K h
intros
ext x
rw cast_coe
have : ‚Üëx ‚àà (Icc 0 1 : set ‚Ñù) := x.2
rw [truncate, coe_mk, max_eq_left this.1, min_eq_left this.2, extend_extends']
intros
simp_rw [‚Üê lower_semicontinuous_within_at_univ_iff] at *
{ simp_rw [‚Üê lower_semicontinuous_within_at_univ_iff] at *, exact hf.add' hg hcont }
exact hf.add' hg hcont
intros
apply singletons_open_iff_discrete.mp
intros x
rw [‚Üê is_closed_compl_iff]
exact finite.is_closed (finite.of_fintype _)
intros
dsimp [pushforward_eq]
simp
intros
rw [uniformity_eq_uniformity_interior]; exact mem_lift' hs
rw [uniformity_eq_uniformity_interior]
exact mem_lift' hs
intros
assume p hp
refine (set_seq_aux hf U_mem N).2.snd ‚ü®_, _‚ü©
refine (set_seq_aux hf U_mem N).2.snd ‚ü®_, _‚ü©; apply set_seq_sub_aux
apply set_seq_sub_aux
exact set_seq_mono hf U_mem hm hp.1
apply set_seq_sub_aux
exact set_seq_mono hf U_mem hn hp.2
intros
assume u hu x hx
rcases h u hu x (h' hx) with ‚ü®t, ht, H‚ü©
exact ‚ü®t, nhds_within_mono x h' ht, H.mono (Œª n, id)‚ü©
intros
rw [local_triv_at, mem_local_triv_source]
{ rw [local_triv_at, mem_local_triv_source], exact Z.mem_base_set_at b }
exact Z.mem_base_set_at b
intros
unfold even
rw corec_eq
refl
intros
cases v
reflexivity
intros
have h := int.add_le_add_left h b
rwa int.add_neg_cancel_left at h
intros
by_cases hba : b ‚â§ a
simp [le_antisymm hba h‚ÇÅ]
{ simp [le_antisymm hba h‚ÇÅ] }
by_cases hc0 : c ‚â§ 0
simp [le_antisymm hc0 h‚ÇÇ, int.zero_mul]
{ simp [le_antisymm hc0 h‚ÇÇ, int.zero_mul] }
exact (le_not_le_of_lt (int.mul_lt_mul_of_pos_left (lt_of_le_not_le h‚ÇÅ hba) (lt_of_le_not_le h‚ÇÇ hc0))).left
intros
induction s; simp [*]
induction s
simp [*]
simp [*]
intros
{ cases b, apply bit0_val, apply bit1_val }
cases b
apply bit0_val
apply bit1_val
intros
rw [H2, nat.mul_div_cancel _ H1]
intros
rw [mod_eq_sub_mod (le_refl _), nat.sub_self, zero_mod]
intros
tactic.mk_inj_eq
intros
{ ext, refl }
ext
refl
intros
{ intros œÜ‚ÇÅ œÜ‚ÇÇ H, cases œÜ‚ÇÅ, cases œÜ‚ÇÇ, congr, exact H }
intros œÜ‚ÇÅ œÜ‚ÇÇ H
cases œÜ‚ÇÅ
cases œÜ‚ÇÇ
congr
exact H
intros
apply prod_congr rfl (Œª j hj, _)
have : j ‚â† i
assume eq
assume eq
{ assume eq, rw eq at hj, exact h hj }
{ assume eq, rw eq at hj, exact h hj }
rw eq at hj
rw eq at hj
exact h hj
exact h hj
simp [this]
intros
{ simp_rw ‚Üê(ite_not (p _)), apply prod_ite_of_false, simpa }
simp_rw ‚Üê(ite_not (p _))
apply prod_ite_of_false
simpa
intros
rw [univ_filter_zero_lt, finset.prod_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
simp
intros
ext x
change (F'.e ‚â´ F'.m) _ = _
rw [F'.fac, (classical.indefinite_description _ x.2).2]
refl
intros
induction n
simp
{ simp, }
rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]
apply sub_pow_char_of_commute
apply commute.pow_pow h
intros
obtain ‚ü®ifp_n', stream_nth_eq', ifp_n_fract_ne_zero, int_fract_pair.of_eq_ifp_succ_n‚ü© : ‚àÉ ifp_n', int_fract_pair.stream q n = some ifp_n' ‚àß ifp_n'.fr ‚â† 0 ‚àß int_fract_pair.of ifp_n'.fr‚Åª¬π = ifp_succ_n
from succ_nth_stream_eq_some_iff.elim_left stream_succ_nth_eq
have : ifp_n = ifp_n'
injection (eq.trans stream_nth_eq.symm stream_nth_eq')
injection (eq.trans stream_nth_eq.symm stream_nth_eq')
cases this
rw [‚Üêint_fract_pair.of_eq_ifp_succ_n]
cases (nth_stream_fr_nonneg_lt_one stream_nth_eq) with zero_le_ifp_n_fract ifp_n_fract_lt_one
have : 0 < ifp_n.fr
from (lt_of_le_of_ne zero_le_ifp_n_fract $ ifp_n_fract_ne_zero.symm)
exact (of_inv_fr_num_lt_num_of_pos this)
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
simpa only [gcd_comm a b] using gcd_eq_left_iff b a h
intros
{ subst hs, exact finset.fold_congr hfg }
subst hs
exact finset.fold_congr hfg
intros
simp only [sum_Ico_eq_sub _ hmn, (geom_sum_def _ _).symm, geom_sum_eq hx, div_sub_div_same, sub_sub_sub_cancel_right]
intros
rw [eq_comm, inv_eq_one]
intros
rw [sub_eq_add_neg, add_right_eq_self, neg_eq_zero]
intros
rw [‚Üê sub_add, add_sub_cancel']
intros
split_ifs; refl
split_ifs
refl
refl
intros
rcases neg_one_pow_eq_or R n; simp [h]
rcases neg_one_pow_eq_or R n
simp [h]
simp [h]
intros
haveI := invertible_of_pow_eq_one x n hx hn
exact is_unit_of_invertible x
intros
by_cases h : a = 0
{ rw [h, inv_zero, mul_zero] }
rw [h, inv_zero, mul_zero]
{ rw [inv_mul_cancel h, one_mul] }
rw [inv_mul_cancel h, one_mul]
intros
simpa only [one_div] using eq_inv_of_mul_right_eq_one h
intros
{ dsimp [augment], rcases i with _|i, refl, refl, }
dsimp [augment]
rcases i with _|i
refl
refl
intros
simp [h]
intros
dsimp [d_next, from_next]
rcases c.next i with ‚ü®‚ü©|‚ü®‚ü®i', w‚ü©‚ü©; { dsimp [d_next, from_next], simp }
rcases c.next i with ‚ü®‚ü©|‚ü®‚ü®i', w‚ü©‚ü©
{ dsimp [d_next, from_next], simp }
{ dsimp [d_next, from_next], simp }
dsimp [d_next, from_next]
simp
intros
refine (mul_indicator_congr $ Œª x hx, _).trans mul_indicator_mul_support
have : f x = 1
from nmem_mul_support.1 (disjoint_right.1 h hx)
rw [pi.mul_apply, this, one_mul]
intros
simp [mul_right_iterate]
intros
ext x y
rcases x
rcases x; rcases y
rcases y
by_cases h : x = y; simp [Pso, indefinite_diagonal, h]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h], }
simp [Pso, indefinite_diagonal, h]
simp [Pso, indefinite_diagonal, h]
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
rcases y
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi], }
simp [Pso, indefinite_diagonal, h, hi]
simp [Pso, indefinite_diagonal, h, hi]
intros
obtain ‚ü®n, hn‚ü© := h
use n
exact linear_map.submodule_pow_eq_zero_of_pow_eq_zero (K.ad_comp_incl_eq x) hn
intros
simp [skew_adjoint_lie_subalgebra_equiv]
intros
rw [‚Üêneg_neg a, smul_neg, neg_neg_iff_pos, neg_neg_iff_pos]
exact smul_pos_iff_of_pos hc
intros
cases le_or_lt a 0 with ha ha
{ simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one] }
simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one]
simp only [ha.not_le, false_or, inv_lt_one_iff_of_pos ha]
{ simp only [ha.not_le, false_or, inv_lt_one_iff_of_pos ha] }
intros
rwa [le_one_div (@zero_lt_one Œ± _ _) h1, one_div_one]
intros
rw [‚Üê mul_le_mul_iff_left b, mul_one, mul_inv_cancel_left]
intros
simp [div_eq_mul_inv]
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioi]
split
rintro ‚ü®a_w, a_h_left, rfl‚ü©
{ rintro ‚ü®a_w, a_h_left, rfl‚ü©, exact (mul_lt_mul_left hr).mpr a_h_left, }
exact (mul_lt_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (lt_div_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (lt_div_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
haveI := @linear_order.decidable_le Œ± _
rcases lt_trichotomy 0 a with (ha|rfl|ha)
refine or.inl ‚ü®ha, lt_imp_lt_of_le_imp_le (Œª hb, _) hab‚ü©
{ refine or.inl ‚ü®ha, lt_imp_lt_of_le_imp_le (Œª hb, _) hab‚ü©, exact decidable.mul_nonpos_of_nonneg_of_nonpos ha.le hb }
exact decidable.mul_nonpos_of_nonneg_of_nonpos ha.le hb
{ rw [zero_mul] at hab, exact hab.false.elim }
rw [zero_mul] at hab
exact hab.false.elim
refine or.inr ‚ü®ha, lt_imp_lt_of_le_imp_le (Œª hb, _) hab‚ü©
{ refine or.inr ‚ü®ha, lt_imp_lt_of_le_imp_le (Œª hb, _) hab‚ü©, exact decidable.mul_nonpos_of_nonpos_of_nonneg ha.le hb }
exact decidable.mul_nonpos_of_nonpos_of_nonneg ha.le hb
intros
haveI := @linear_order.decidable_le Œ± _; exact Œª x y h, decidable.mul_lt_mul' (hf h.le) (hg h) (hg0 x) (hf0 y)
haveI := @linear_order.decidable_le Œ± _
exact Œª x y h, decidable.mul_lt_mul' (hf h.le) (hg h) (hg0 x) (hf0 y)
intros
simpa only [sub_eq_neg_add] using h (-x)
intros
simp [*, ‚Üê add_assoc] at *
intros
intro a
rw [mem_finset_prod, mem_finset_prod]
rintro ‚ü®g, hg, rfl‚ü©
exact ‚ü®g, Œª i hi, hf hi $ hg hi, rfl‚ü©
intros
induction l with hd tl IH
{ simp }
simp
{ have hl' : ‚àÄ (p ‚àà tl), nat_degree p ‚â§ n := Œª p hp, hl p (list.mem_cons_of_mem _ hp), simp only [list.prod_cons, list.map, list.length], rw [add_mul, one_mul, add_comm, ‚ÜêIH hl', mul_comm tl.length], have h : nat_degree tl.prod ‚â§ n * tl.length, { refine (nat_degree_list_prod_le _).trans _, rw [‚Üêtl.length_map nat_degree, mul_comm], refine list.sum_le_of_forall_le _ _ _, simpa using hl' }, have hdn : nat_degree hd ‚â§ n := hl _ (list.mem_cons_self _ _), rcases hdn.eq_or_lt with rfl|hdn', { cases h.eq_or_lt with h' h', { rw [‚Üêh', coeff_mul_degree_add_degree, leading_coeff, leading_coeff] }, { rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero], exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _) } }, { rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, zero_mul], exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h) } }
have hl' : ‚àÄ (p ‚àà tl), nat_degree p ‚â§ n := Œª p hp, hl p (list.mem_cons_of_mem _ hp)
simp only [list.prod_cons, list.map, list.length]
rw [add_mul, one_mul, add_comm, ‚ÜêIH hl', mul_comm tl.length]
have h : nat_degree tl.prod ‚â§ n * tl.length
refine (nat_degree_list_prod_le _).trans _
{ refine (nat_degree_list_prod_le _).trans _, rw [‚Üêtl.length_map nat_degree, mul_comm], refine list.sum_le_of_forall_le _ _ _, simpa using hl' }
rw [‚Üêtl.length_map nat_degree, mul_comm]
refine list.sum_le_of_forall_le _ _ _
simpa using hl'
have hdn : nat_degree hd ‚â§ n := hl _ (list.mem_cons_self _ _)
rcases hdn.eq_or_lt with rfl|hdn'
cases h.eq_or_lt with h' h'
{ cases h.eq_or_lt with h' h', { rw [‚Üêh', coeff_mul_degree_add_degree, leading_coeff, leading_coeff] }, { rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero], exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _) } }
{ rw [‚Üêh', coeff_mul_degree_add_degree, leading_coeff, leading_coeff] }
rw [‚Üêh', coeff_mul_degree_add_degree, leading_coeff, leading_coeff]
rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero]
{ rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero], exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _) }
exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _)
rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, zero_mul]
{ rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, zero_mul], exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h) }
exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h)
intros
rw [‚Üê smul_eval_smul, smul_inv_smul]
intros
rw [nontrivial_iff, not_iff_comm, zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
split
intro h'
{ intro h', convert dvd_sub h' h, exact eq.symm (sub_sub_self b c) }
convert dvd_sub h' h
exact eq.symm (sub_sub_self b c)
intro h'
{ intro h', convert dvd_add h h', exact eq_add_of_sub_eq rfl }
convert dvd_add h h'
exact eq_add_of_sub_eq rfl
intros
induction h
{ exact rel.of (hr _ _ h_h) }
exact rel.of (hr _ _ h_h)
{ rw [star_add, star_add], exact rel.add_left h_ih, }
rw [star_add, star_add]
exact rel.add_left h_ih
{ rw [star_mul, star_mul], exact rel.mul_right h_ih, }
rw [star_mul, star_mul]
exact rel.mul_right h_ih
{ rw [star_mul, star_mul], exact rel.mul_left h_ih, }
rw [star_mul, star_mul]
exact rel.mul_left h_ih
intros
erw [comap_id_eq_map U V (eq_to_hom hUV.symm), eq_to_hom_op, eq_to_hom_map]
intros
simp [radius]
intros
{ unfold is_O, exact exists_congr (Œª _, is_O_with_norm_left) }
unfold is_O
exact exists_congr (Œª _, is_O_with_norm_left)
intros
unfold is_O_with at *
filter_upwards [h‚ÇÅ, h‚ÇÇ]
intros x hx‚ÇÅ hx‚ÇÇ
apply le_trans (norm_mul_le _ _)
convert mul_le_mul hx‚ÇÅ hx‚ÇÇ (norm_nonneg _) (le_trans (norm_nonneg _) hx‚ÇÅ) using 1
rw normed_field.norm_mul
ac_refl
intros
simpa only [one_apply, one_smul, smul_right_apply, coe_comp', (‚àò)] using (hl.comp x hf.has_strict_fderiv_at).has_strict_deriv_at
intros
simpa using (hf.add hg).has_deriv_at_filter
intros
simp only [‚Üê fderiv_within_univ, fderiv_within_neg unique_diff_within_at_univ]
intros
{ convert hc.mul_const' d, ext z, apply mul_comm }
convert hc.mul_const' d
ext z
apply mul_comm
intros
simp only [has_fderiv_within_at, nhds_within_union]
exact hs.join ht
intros
apply mem_implicit_to_local_homeomorph_of_complemented_target
intros
rw [iterated_deriv_eq_iterated_fderiv, ‚Üê continuous_multilinear_map.map_smul_univ]
{ rw [iterated_deriv_eq_iterated_fderiv, ‚Üê continuous_multilinear_map.map_smul_univ], simp }
simp
intros
have hdg : ‚àÄ·∂† x in at_top, differentiable_at ‚Ñù g x
from hg'.mp (eventually_of_forall $ Œª _ hg', classical.by_contradiction (Œª h, hg' (deriv_zero_of_not_differentiable_at h)))
have hdf' : ‚àÄ·∂† x in at_top, has_deriv_at f (deriv f x) x
from hdf.mp (eventually_of_forall $ Œª _, differentiable_at.has_deriv_at)
have hdg' : ‚àÄ·∂† x in at_top, has_deriv_at g (deriv g x) x
from hdg.mp (eventually_of_forall $ Œª _, differentiable_at.has_deriv_at)
exact has_deriv_at.lhopital_zero_at_top hdf' hdg' hg' hftop hgtop hdiv
intros
rcases em (x = c) with rfl|hx
refine times_cont_diff_at.congr_of_eventually_eq _ f.eventually_eq_one
{ refine times_cont_diff_at.congr_of_eventually_eq _ f.eventually_eq_one, rw pi.one_def, exact times_cont_diff_at_const }
rw pi.one_def
exact times_cont_diff_at_const
exact real.smooth_transition.times_cont_diff_at.comp x (times_cont_diff_at.div_const $ times_cont_diff_at_const.sub $ times_cont_diff_at_id.dist times_cont_diff_at_const hx)
{ exact real.smooth_transition.times_cont_diff_at.comp x (times_cont_diff_at.div_const $ times_cont_diff_at_const.sub $ times_cont_diff_at_id.dist times_cont_diff_at_const hx) }
intros
rw [‚Üê has_fderiv_within_at_univ]
exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)
intros
split
assume H
{ assume H, have A : f = (f ‚àò e) ‚àò e.symm, by { ext y, simp only [function.comp_app], rw e.apply_symm_apply y }, have B : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s, by { rw [‚Üê preimage_comp, e.self_comp_symm], refl }, rw [A, ‚Üê B], exact H.comp_continuous_linear_map _}
have A : f = (f ‚àò e) ‚àò e.symm
ext y
ext y
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
simp only [function.comp_app]
simp only [function.comp_app]
rw e.apply_symm_apply y
rw e.apply_symm_apply y
have B : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s
rw [‚Üê preimage_comp, e.self_comp_symm]
rw [‚Üê preimage_comp, e.self_comp_symm]
{ rw [‚Üê preimage_comp, e.self_comp_symm], refl }
{ rw [‚Üê preimage_comp, e.self_comp_symm], refl }
refl
refl
rw [A, ‚Üê B]
exact H.comp_continuous_linear_map _
assume H
{ assume H, have : x = e (e.symm x), by simp, rw this at H, exact H.comp_continuous_linear_map _ }
have : x = e (e.symm x)
simp
simp
rw this at H
exact H.comp_continuous_linear_map _
intros
rw [‚Üê times_cont_diff_within_at_univ] at *; exact hf.smul hg
rw [‚Üê times_cont_diff_within_at_univ] at *
exact hf.smul hg
intros
refine ‚ü®Œª H n, H n, _‚ü©
rintro H (_|n)
exacts [times_cont_diff_on_top.2 H, H n]
intros
obtain ‚ü®a, b, ha, hb, hab, hz‚ü© := hz
by_cases ha' : a = 0
{ rw [ha', zero_add] at hab, rw [ha', hab, zero_smul, one_smul, zero_add] at hz, exact (hy hz).elim }
rw [ha', zero_add] at hab
rw [ha', hab, zero_smul, one_smul, zero_add] at hz
exact (hy hz).elim
by_cases hb' : b = 0
rw [hb', add_zero] at hab
{ rw [hb', add_zero] at hab, rw [hb', hab, zero_smul, one_smul, add_zero] at hz, exact (hx hz).elim }
rw [hb', hab, zero_smul, one_smul, add_zero] at hz
exact (hx hz).elim
exact ‚ü®a, b, ha.lt_of_ne (ne.symm ha'), hb.lt_of_ne (ne.symm hb'), hab, hz‚ü©
intros
split
intro h
{ intro h, rw [‚Üêset.subset_empty_iff, ‚Üêh], exact subset_convex_hull ùïú _ }
rw [‚Üêset.subset_empty_iff, ‚Üêh]
exact subset_convex_hull ùïú _
rintro rfl
{ rintro rfl, exact convex_hull_empty }
exact convex_hull_empty
intros
intros y hy
let I := { z | ‚àÉ (u : ‚Ñù), u ‚àà Ioc (0 : ‚Ñù) 1 ‚àß z = y + u ‚Ä¢ (x - y) }
have hI : I ‚äÜ interior s
rintros z ‚ü®u, hu, rfl‚ü©
{ rintros z ‚ü®u, hu, rfl‚ü©, exact hs.add_smul_sub_mem_interior hy hx hu, }
exact hs.add_smul_sub_mem_interior hy hx hu
let z := homothety x t‚Åª¬π y
have hz‚ÇÅ : z ‚àà interior s
suffices : z ‚àà I
{ suffices : z ‚àà I, { exact hI this, }, use 1 - t‚Åª¬π, split, { simp only [mem_Ioc, sub_le_self_iff, inv_nonneg, sub_pos, inv_lt_one ht, true_and], linarith, }, { simp only [z, homothety_apply, sub_smul, smul_sub, vsub_eq_sub, vadd_eq_add, one_smul], abel, }, }
exact hI this
{ exact hI this, }
use 1 - t‚Åª¬π
split
simp only [mem_Ioc, sub_le_self_iff, inv_nonneg, sub_pos, inv_lt_one ht, true_and]
{ simp only [mem_Ioc, sub_le_self_iff, inv_nonneg, sub_pos, inv_lt_one ht, true_and], linarith, }
linarith
simp only [z, homothety_apply, sub_smul, smul_sub, vsub_eq_sub, vadd_eq_add, one_smul]
{ simp only [z, homothety_apply, sub_smul, smul_sub, vsub_eq_sub, vadd_eq_add, one_smul], abel, }
abel
have ht' : t ‚â† 0
linarith
{ linarith, }
have hz‚ÇÇ : y = homothety x t z
simp [z, ht', homothety_apply, smul_smul]
{ simp [z, ht', homothety_apply, smul_smul], }
rw hz‚ÇÇ
rw mem_interior at hz‚ÇÅ ‚ä¢
obtain ‚ü®U, hU‚ÇÅ, hU‚ÇÇ, hU‚ÇÉ‚ü© := hz‚ÇÅ
exact ‚ü®image (homothety x t) U, image_subset ‚áë(homothety x t) hU‚ÇÅ, homothety_is_open_map x t ht' U hU‚ÇÇ, mem_image_of_mem ‚áë(homothety x t) hU‚ÇÉ‚ü©
intros
have := @abs_inner_div_norm_mul_norm_eq_one_iff ‚Ñù F _ _ x y
simpa [coe_real_eq_id] using this
intros
rcases zorn.zorn_subset_nonempty {b | orthonormal ùïú (coe : b ‚Üí E)} _ _ hs with ‚ü®b, bi, sb, h‚ü©
refine ‚ü®b, sb, bi, _‚ü©
{ refine ‚ü®b, sb, bi, _‚ü©, exact Œª u hus hu, h u hu hus }
exact Œª u hus hu, h u hu hus
refine Œª c hc cc c0, ‚ü®‚ãÉ‚ÇÄ c, _, _‚ü©
{ refine Œª c hc cc c0, ‚ü®‚ãÉ‚ÇÄ c, _, _‚ü©, { exact orthonormal_sUnion_of_directed cc.directed_on (Œª x xc, hc xc) }, { exact Œª _, set.subset_sUnion_of_mem } }
{ exact orthonormal_sUnion_of_directed cc.directed_on (Œª x xc, hc xc) }
exact orthonormal_sUnion_of_directed cc.directed_on (Œª x xc, hc xc)
{ exact Œª _, set.subset_sUnion_of_mem }
exact Œª _, set.subset_sUnion_of_mem
intros
change orthogonal_projection_fn K u = orthogonal_projection_fn K' u
congr
exact h
intros
rw [dist_eq_norm, vsub_sub_vsub_cancel_right, dist_eq_norm_vsub V]
intros
rw [dist_comm, dist_eq_norm]
intros
simpa only [sub_eq_add_neg] using dist_add_right _ _ _
intros
rw [mem_closed_ball, dist_eq_norm]
intros
refine (linear_map.fst ùïú E F).is_linear.with_bound 1 (Œª x, _)
rw one_mul
exact le_max_left _ _
intros
rw [continuous_iff_continuous_on_univ, ‚Üê metric.eball_top_eq_univ (0 : ùî∏), ‚Üê exp_series_radius_eq_top ùïÇ ùî∏]
exact continuous_on_exp
intros
{ ext, refl }
ext
refl
intros
simpa only [one_div] using interval_integrable_one_div_one_add_sq
intros
field_simp [pow_mul, sin_sq, cos_sq, ‚Üê sub_sub, (by ring : (2:‚Ñù) - 1 = 1)]
intros
simp [hz.not_lt, mul_rpow_eq_ite]
intros
convert (@complex.has_fderiv_at_cpow ((Œª x, (f x, g x)) x) h0).comp x (hf.prod hg)
intros
simp only [sub_eq_add_neg] at h ‚ä¢
{ simp only [sub_eq_add_neg] at h ‚ä¢, simp only [rpow_add' hx h, rpow_neg hx, div_eq_mul_inv] }
simp only [rpow_add' hx h, rpow_neg hx, div_eq_mul_inv]
intros
rcases hx.eq_or_lt with (rfl|hx)
rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, (@zero_lt_one ‚Ñù _ _).not_lt]
rcases em (y = 0) with (rfl|hy)
{ rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, (@zero_lt_one ‚Ñù _ _).not_lt] }
simp [*, lt_irrefl, (@zero_lt_one ‚Ñù _ _).not_lt]
simp [*, lt_irrefl, (@zero_lt_one ‚Ñù _ _).not_lt]
{ simp [one_lt_rpow_iff_of_pos hx, hx] }
simp [one_lt_rpow_iff_of_pos hx, hx]
intros
rw [one_div, ‚Üê inv_sqrt_one_add_tan_sq (cos_arctan_pos x), tan_arctan]
intros
simp [cos_add]
intros
rw [sin_sq_pi_over_two_pow, sqrt_two_add_series, div_pow, sq_sqrt, add_div, ‚Üêsub_sub]
congr
norm_num
norm_num
apply add_nonneg
norm_num
apply sqrt_two_add_series_zero_nonneg
convert tendsto_cos_pi_div_two.inv_tendsto_zero.at_top_mul zero_lt_one tendsto_sin_pi_div_two
simp only [pi.inv_apply, ‚Üê div_eq_inv_mul, ‚Üê tan_eq_sin_div_cos]
intros
rw [‚Üê neg_le_neg_iff, ‚Üê arcsin_neg, arcsin_le_iff_le_sin ‚ü®neg_le_neg hy.2, neg_le.2 hy.1‚ü© ‚ü®neg_le_neg hx.2, neg_le.2 hx.1‚ü©, sin_neg, neg_le_neg_iff]
intros
rw [‚Üê arcsin_proj_Icc, proj_Icc_of_right_le _ hx, subtype.coe_mk, arcsin_one]
intros
simpa using tendsto_const_nhds.mul nnreal.tendsto_inverse_at_top_nhds_0_nat
intros
dsimp [transfer_nat_trans_self]
rw [id_comp, comp_id]
have := unit_transfer_nat_trans adj‚ÇÅ adj‚ÇÇ (L‚ÇÇ.left_unitor.hom ‚â´ f ‚â´ L‚ÇÅ.right_unitor.inv) X
dsimp at this
rw this
simp
intros
symmetry
{ symmetry, erw [‚Üêiso.comp_hom_eq_id (e.counit_iso.app _), functor_unit_comp], refl }
erw [‚Üêiso.comp_hom_eq_id (e.counit_iso.app _), functor_unit_comp]
refl
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
tidy
intros
simp
intros
simp [biprod.lift_eq, biprod.desc_eq]
intros
ext j
simp [sum_comp, biproduct.Œπ_œÄ, comp_dite]
intros
simp
intros
{ ext, simp [cokernel_zero_iso_target], }
ext
simp [cokernel_zero_iso_target]
intros
rw [‚Üêcancel_mono (œÅ_ Y).hom, right_unitor_naturality, right_unitor_naturality]
{ rw [‚Üêcancel_mono (œÅ_ Y).hom, right_unitor_naturality, right_unitor_naturality], simp }
simp
intros
dunfold right_adjoint_mate
rw [category.assoc, category.assoc, associator_inv_naturality_assoc, associator_inv_naturality_assoc, ‚Üêtensor_id_comp_id_tensor g, category.assoc, category.assoc, category.assoc, category.assoc, id_tensor_comp_tensor_id_assoc, ‚Üêleft_unitor_naturality, tensor_id_comp_id_tensor_assoc]
intros
{ ext, rw [‚Üê op_comp, is_iso.inv_hom_id, op_id] }
ext
rw [‚Üê op_comp, is_iso.inv_hom_id, op_id]
intros
rw [‚Üêfunctor.map_comp,prod_comp,category.comp_id]
intros
apply limit.hom_ext
rintro ‚ü®‚ü®Y, f, hf‚ü©, ‚ü®Z, g, hg‚ü©‚ü©
simp only [first_map, second_map, fork_map]
simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, assoc, fan.mk_œÄ_app, subtype.coe_mk, subtype.val_eq_coe]
rw [‚Üê P.map_comp, ‚Üê op_comp, pullback.condition]
simp
intros
apply le_antisymm
rintro X S ‚ü®R, hR, RS‚ü© x hx
{ rintro X S ‚ü®R, hR, RS‚ü© x hx, rcases hR x hx with ‚ü®U, f, hf, hU‚ü©, exact ‚ü®_, f, RS _ hf, hU‚ü© }
rcases hR x hx with ‚ü®U, f, hf, hU‚ü©
exact ‚ü®_, f, RS _ hf, hU‚ü©
intros X S hS
{ intros X S hS, exact ‚ü®S, hS, le_refl _‚ü© }
exact ‚ü®S, hS, le_refl _‚ü©
intros
{ rw eq_mk f, simp, }
rw eq_mk f
simp
intros
{ ext, simp, }
ext
simp
intros
classical
apply finset.induction_on s
{ simp [top_factors] }
simp [top_factors]
{ intros i s nm ih, simp [ih] }
intros i s nm ih
simp [ih]
intros
simp [image_subobject_iso]
intros
rw [‚Üêsdiff_lt_sdiff_iff_lt, sdiff_eq_empty_iff_subset.2 h.1]
exact empty_to_colex_lt (by simpa [finset.nonempty] using exists_of_ssubset h)
intros
rw [mul_vec, adj_matrix_dot_product]
intros
simp only [degree, card_pos, finset.nonempty, mem_neighbor_finset]
intros
letI : ‚àÄ a, decidable (a ‚àà set.range (encode : Œ± ‚Üí ‚Ñï)) := decidable_range_encode _
letI : ‚àÄ a, decidable (a ‚àà set.range (encode : Œ± ‚Üí ‚Ñï)) := decidable_range_encode _; exact option_get (primrec.decode‚ÇÇ.comp subtype_val)
exact option_get (primrec.decode‚ÇÇ.comp subtype_val)
intros
simp only [add_bottom, list_blank.map_cons]
simp only [add_bottom, list_blank.map_cons]; convert list_blank.cons_head_tail _
convert list_blank.cons_head_tail _
generalize : list_blank.tail L = L'
refine L'.induction_on _
intro l
simp
intros
rw [‚Üê bind_pure_comp_eq_map, bind_assoc]; simp [pure_bind]
rw [‚Üê bind_pure_comp_eq_map, bind_assoc]
simp [pure_bind]
intros
rw [fix_eq_œâSup f,hc]
apply le_antisymm
apply œâSup_le_œâSup_of_le _
{ apply œâSup_le_œâSup_of_le _, intros i, existsi [i], intro x, apply le_f_of_mem_approx _ ‚ü®i, rfl‚ü©, }
intros i
existsi [i]
intro x
apply le_f_of_mem_approx _ ‚ü®i, rfl‚ü©
apply œâSup_le_œâSup_of_le _
{ apply œâSup_le_œâSup_of_le _, intros i, existsi i.succ, refl', }
intros i
existsi i.succ
refl'
intros
simp [equiv.traverse,comp_traverse] with functor_norm
simp [equiv.traverse,comp_traverse] with functor_norm; congr; ext; simp
simp [equiv.traverse,comp_traverse] with functor_norm; congr; ext
simp [equiv.traverse,comp_traverse] with functor_norm; congr
congr
ext
simp
intros
simp [sequence, traverse_map]; rw ‚Üê comp_traverse; simp [map_id]
simp [sequence, traverse_map]; rw ‚Üê comp_traverse
simp [sequence, traverse_map]
rw ‚Üê comp_traverse
simp [map_id]
intros
dsimp [of_fin]; rw [to_fin_val, of_nat_to_nat]
dsimp [of_fin]
rw [to_fin_val, of_nat_to_nat]
intros
simp
intros
simp
intros
simp [one_of, sat_eq_done]
intros
simp [sep_by, pure_eq_done]
intros
rw [‚Üê of_real_nat_cast, of_real_re]
intros
subst er
refine exp_approx_succ _ en _ _ _ h
field_simp [show (m : ‚Ñù) ‚â† 0, by norm_cast; linarith]
intros
rw [two_mul, cos_add, ‚Üê sq, ‚Üê sq]
intros
rw [‚Üê of_real_int_cast, of_real_im]
intros
intros x y H
ext i
have h1 : (mk s x : Œ† i, Œ≤ i) i = (mk s y : Œ† i, Œ≤ i) i
rw H
{rw H}
cases i with i hi
change i ‚àà s at hi
dsimp only [mk_apply, subtype.coe_mk] at h1
simpa only [dif_pos hi] using h1
intros
{ ext ‚ü®a, b‚ü© : 1, simp }
ext ‚ü®a, b‚ü© : 1
simp
intros
cases x with x hx; exact set.sum_compl_symm_apply_of_mem hx
cases x with x hx
exact set.sum_compl_symm_apply_of_mem hx
intros
{ dsimp [set_value], simp [swap_apply_left] }
dsimp [set_value]
simp [swap_apply_left]
intros
rw [set.image_subset_iff, e.image_eq_preimage]
intros
cases a; refl
cases a
refl
intros
dunfold extend_subtype
{ dunfold extend_subtype, simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply], rw [sum_compl_apply_symm_of_pos _ _ hx, sum.map_inl, sum_compl_apply_inl] }
simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply]
rw [sum_compl_apply_symm_of_pos _ _ hx, sum.map_inl, sum_compl_apply_inl]
intros
cases e
{ cases e, refl }
refl
intros
ext x
ext x; simp [prod_coe_symm]
simp [prod_coe_symm]
simp [prod_coe_symm]
simp [prod_coe_symm]
simp [prod_coe_symm]
intros
{ induction h, simp [heq_iff_eq, function.funext_iff] }
induction h
simp [heq_iff_eq, function.funext_iff]
intros
induction s using quotient.induction_on
simp
intros
simp [ext_iff]
intros
suffices : (bkts.to_list.map (list.map sigma.fst)).pairwise list.disjoint
suffices : ‚àÄ l, array.mem l bkts ‚Üí (l.map sigma.fst).nodup
{ suffices : ‚àÄ l, array.mem l bkts ‚Üí (l.map sigma.fst).nodup, by simpa [bucket_array.as_list, list.nodup_join, *], rintros l ‚ü®i, rfl‚ü©, apply v.nodup }
simpa [bucket_array.as_list, list.nodup_join, *]
simpa [bucket_array.as_list, list.nodup_join, *]
rintros l ‚ü®i, rfl‚ü©
apply v.nodup
rw [‚Üê list.enum_map_snd bkts.to_list, list.pairwise_map, list.pairwise_map]
have : (bkts.to_list.enum.map prod.fst).nodup := by simp [list.nodup_range]
refine list.pairwise.imp_of_mem _ ((list.pairwise_map _).1 this)
rw prod.forall
intros i l‚ÇÅ
rw prod.forall
intros j l‚ÇÇ me‚ÇÅ me‚ÇÇ ij
simp [list.disjoint]
intros a b ml‚ÇÅ b' ml‚ÇÇ
apply ij
rwa [‚Üê v.idx_enum_1 _ me‚ÇÅ ml‚ÇÅ, ‚Üê v.idx_enum_1 _ me‚ÇÇ ml‚ÇÇ]
intros
rw [‚Üê abs_eq_iff_mul_self_eq, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_inj'.symm
intros
simp [gcd]
intros
{ unfold gcd_b, rw [xgcd, xgcd_zero_left] }
unfold gcd_b
rw [xgcd, xgcd_zero_left]
intros
ext
ext; simp
simp
intros
cases le_or_lt n l.length with hn hn
{ rw length_insert_nth _ _ hn }
rw length_insert_nth _ _ hn
rw insert_nth_of_length_lt _ _ _ hn
{ rw insert_nth_of_length_lt _ _ _ hn, exact (nat.lt_succ_self _).le }
exact (nat.lt_succ_self _).le
intros
simp [any_iff_exists]
intros
rw filter_map_eq_map; apply map_id
rw filter_map_eq_map
apply map_id
intros
simp only [countp_eq_length_filter, length_pos_iff_exists_mem, mem_filter, exists_prop]
intros
induction ys generalizing f; simp *
induction ys generalizing f
simp *
simp *
intros
simp only [erase_cons, if_neg h]; split; refl
simp only [erase_cons, if_neg h]; split
simp only [erase_cons, if_neg h]
split
refl
refl
intros
simp only [zip_right, zip_right', map‚ÇÇ_right_eq_map‚ÇÇ_right']
intros
induction l; [refl, simp only [*, reverse_cons, mem_append, mem_singleton, mem_cons_iff, not_mem_nil, false_or, or_false, or_comm]]
induction l
refl
simp only [*, reverse_cons, mem_append, mem_singleton, mem_cons_iff, not_mem_nil, false_or, or_false, or_comm]
intros
induction h with _ _ _ _ ih _ _ a _ ih
refl
{refl}
rw reverse_cons
{ rw reverse_cons, exact sublist_append_of_sublist_left ih }
exact sublist_append_of_sublist_left ih
rw [reverse_cons, reverse_cons]
{ rw [reverse_cons, reverse_cons], exact ih.append_right [a] }
exact ih.append_right [a]
intros
cases l with x l
{ simpa using hn }
simpa using hn
induction l with y l hl generalizing x n
{ simp }
simp
cases n
{ cases n, { simp }, { have hn' : n.succ ‚â§ l.length.succ, { refine nat.succ_le_of_lt _, simpa [nat.succ_lt_succ_iff] using hn }, have hx': (x :: y :: l).nth_le n.succ hn ‚â† x, { intro H, suffices : n.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, rcases hn'.eq_or_lt with hn''|hn'', { rw [next_last_cons], { simp [hn''] }, { exact hx' }, { simp [last_eq_nth_le, hn''] }, { exact nodup_of_nodup_cons h } }, { have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn'' , rw [next_ne_head_ne_last _ _ _ _ hx'], { simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }, { rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } } } } }
{ simp }
simp
have hn' : n.succ ‚â§ l.length.succ
{ have hn' : n.succ ‚â§ l.length.succ, { refine nat.succ_le_of_lt _, simpa [nat.succ_lt_succ_iff] using hn }, have hx': (x :: y :: l).nth_le n.succ hn ‚â† x, { intro H, suffices : n.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, rcases hn'.eq_or_lt with hn''|hn'', { rw [next_last_cons], { simp [hn''] }, { exact hx' }, { simp [last_eq_nth_le, hn''] }, { exact nodup_of_nodup_cons h } }, { have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn'' , rw [next_ne_head_ne_last _ _ _ _ hx'], { simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }, { rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } } } }
refine nat.succ_le_of_lt _
{ refine nat.succ_le_of_lt _, simpa [nat.succ_lt_succ_iff] using hn }
simpa [nat.succ_lt_succ_iff] using hn
have hx': (x :: y :: l).nth_le n.succ hn ‚â† x
intro H
{ intro H, suffices : n.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }
suffices : n.succ = 0
simpa
{ simpa }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn nat.succ_pos' _
simpa using H
rcases hn'.eq_or_lt with hn''|hn''
rw [next_last_cons]
{ rw [next_last_cons], { simp [hn''] }, { exact hx' }, { simp [last_eq_nth_le, hn''] }, { exact nodup_of_nodup_cons h } }
simp [hn'']
{ simp [hn''] }
exact hx'
{ exact hx' }
simp [last_eq_nth_le, hn'']
{ simp [last_eq_nth_le, hn''] }
exact nodup_of_nodup_cons h
{ exact nodup_of_nodup_cons h }
have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn''
{ have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn'' , rw [next_ne_head_ne_last _ _ _ _ hx'], { simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }, { rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } } }
rw [next_ne_head_ne_last _ _ _ _ hx']
simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)]
{ simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }
rw last_eq_nth_le
{ rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } }
intro H
suffices : n.succ = l.length.succ
exact absurd hn'' this.ge.not_lt
{ exact absurd hn'' this.ge.not_lt }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn _ _
simp
{ simp }
simpa using H
{ simpa using H }
intros
induction as generalizing start
{ refl }
refl
simp only [foldr_with_index_aux, foldr_with_index_aux_spec_cons, *]
{ simp only [foldr_with_index_aux, foldr_with_index_aux_spec_cons, *] }
intros
simp only [list.bind, nodup_join, pairwise_map, and_comm, and.left_comm, mem_map, exists_imp_distrib, and_imp]
simp only [list.bind, nodup_join, pairwise_map, and_comm, and.left_comm, mem_map, exists_imp_distrib, and_imp]; rw [show (‚àÄ (l : list Œ≤) (x : Œ±), f x = l ‚Üí x ‚àà l‚ÇÅ ‚Üí nodup l) ‚Üî (‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí nodup (f x)), from forall_swap.trans $ forall_congr $ Œª_, forall_eq']
rw [show (‚àÄ (l : list Œ≤) (x : Œ±), f x = l ‚Üí x ‚àà l‚ÇÅ ‚Üí nodup l) ‚Üî (‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí nodup (f x)), from forall_swap.trans $ forall_congr $ Œª_, forall_eq']
intros
simp only [sublists, sublists_aux_cons_cons, cons_append, perm_cons]
refine (perm.cons _ _).trans perm_middle.symm
induction sublists_aux l cons with b l IH
induction sublists_aux l cons with b l IH; simp
simp
simp
exact (IH.cons _).trans perm_middle.symm
intros
rw [‚Üê of_fn_id, map_of_fn, function.right_id]
intros
have hi : i % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hn)
have hj : j % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hn)
refine (nodup_iff_nth_le_inj.mp hl) _ _ hi hj _
rw [‚Üênth_le_rotate' l i, ‚Üênth_le_rotate' l j]
simp [nat.sub_add_cancel, hi.le, hj.le, h]
intros
by_cases hl : l = []
{ simp [hl, eq_comm] }
simp [hl, eq_comm]
have hl' : l.cyclic_permutations.length = l.length := length_cyclic_permutations_of_ne_nil _ hl
refine ‚ü®Œª h, _, is_rotated.cyclic_permutations‚ü©
obtain ‚ü®k, hk‚ü© := h
refine ‚ü®k % l.length, _‚ü©
have hk' : k % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hl)
rw [‚Üênth_le_cyclic_permutations _ _ (hk'.trans_le hl'.ge), ‚Üênth_le_rotate' _ k]
simp [hk, hl', nat.sub_add_cancel hk'.le]
intros
rw [split, h]; refl
rw [split, h]
refl
intros
induction n with n IHn generalizing l‚ÇÅ l‚ÇÇ
simp
{simp}
induction h with l‚ÇÅ l‚ÇÇ a s IH l‚ÇÅ l‚ÇÇ a s IH
refl
{refl}
refine IH.trans _
{ refine IH.trans _, rw sublists_len_succ_cons, apply sublist_append_left }
rw sublists_len_succ_cons
apply sublist_append_left
simp [sublists_len_succ_cons]
{ simp [sublists_len_succ_cons], exact IH.append ((IHn s).map _) }
exact IH.append ((IHn s).map _)
intros
rw [‚Üêhl, ‚Üêhr, ‚Üêzip_unzip lp, ‚Üêunzip_left, ‚Üêunzip_right, zip_unzip, zip_unzip]
intros
{ ext, symmetry, apply dot_product_assoc }
ext
symmetry
apply dot_product_assoc
intros
{ ext, refl }
ext
refl
intros
ext i j; by_cases h : i = j; simp [h]
ext i j; by_cases h : i = j
ext i j
by_cases h : i = j
simp [h]
simp [h]
intros
simp [h]
intros
{ cases ik, cases jk, refl }
cases ik
cases jk
refl
intros
{ ext, simp [fin.append] }
ext
simp [fin.append]
intros
{ ext i j, refine fin.cases _ _ i; simp [minor] }
ext i j
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [minor]
simp [minor]
simp [minor]
intros
simp [multiset.sigma]
intros
simp [(‚à™), union]
intros
induction hst
simpa using huv
case rel.zero { simpa using huv }
case rel.cons : a b s t hab hst ih { simpa using ih.cons hab }
intros
convert add_monoid_algebra.support_mul p q; ext; convert iff.rfl
convert add_monoid_algebra.support_mul p q; ext
convert add_monoid_algebra.support_mul p q
ext
convert iff.rfl
intros
show _ = eval‚ÇÇ_hom f g (eval‚ÇÇ C q p)
rw eval‚ÇÇ_comp_left (eval‚ÇÇ_hom f g)
congr' with a
simp
intros
ext : 2; simp
{ ext : 2; simp }
ext : 2
simp
simp
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
simpa only [exists_prop, finset.mem_image] using vars_rename f œÜ h
intros
simp_rw [‚Üê not_lt, find_lt_iff, not_exists]
intros
rw [mul_comm, nat.mul_right_eq_self_iff hb]
intros
rw [‚Üê H2, nat.mul_div_cancel' H1]
intros
rw nat.bin_cast
apply binary_rec _ _ n
{ rw [binary_rec_zero, cast_zero] }
rw [binary_rec_zero, cast_zero]
{ intros b k h, rw [binary_rec_eq, h], { cases b; simp [bit, bit0, bit1] }, { simp } }
intros b k h
rw [binary_rec_eq, h]
cases b; simp [bit, bit0, bit1]
{ cases b; simp [bit, bit0, bit1] }
cases b
simp [bit, bit0, bit1]
simp [bit, bit0, bit1]
{ simp }
simp
intros
rw [‚Üê choose_mul_factorial_mul_factorial hk, mul_assoc]
exact (mul_div_left _ (mul_pos (factorial_pos _) (factorial_pos _))).symm
intros
rw [‚Üêlist.init_append_last hl]
simp only [list.length_append, list.length, zero_add, list.length_init, of_digits_append, list.length_init, of_digits_singleton, add_comm (l.length - 1), pow_add, pow_one]
apply nat.mul_le_mul_left
refine le_trans _ (nat.le_add_left _ _)
have : 0 < l.last hl
rwa [pos_iff_ne_zero]
{ rwa [pos_iff_ne_zero] }
convert nat.mul_le_mul_left _ this
rw [mul_one]
intros
convert to_with_top_zero
intros
rw [desc_factorial_succ, desc_factorial_zero, mul_one, nat.sub_zero]
intros
rw [gcd_comm, gcd_eq_left H]
intros
rw [‚Üê H.gcd_eq_one, gcd_eq_left d]
intros
rw [not_odd_iff, even_iff]
intros
{ rw ‚Üêone_pow n, exact pow_lt_pow_of_lt_left h‚ÇÅ h‚ÇÄ }
rw ‚Üêone_pow n
exact pow_lt_pow_of_lt_left h‚ÇÅ h‚ÇÄ
intros
{ rw mem_def at ha ‚ä¢, subst ha, refl }
rw mem_def at ha ‚ä¢
subst ha
refl
intros
rw [valid'.dual_iff, dual_balance_r]; exact hr.dual.balance_l hl.dual (balance_sz_dual H)
rw [valid'.dual_iff, dual_balance_r]
exact hr.dual.balance_l hl.dual (balance_sz_dual H)
intros
dsimp [node3_l, node', size]; rw add_right_comm _ 1
dsimp [node3_l, node', size]
rw add_right_comm _ 1
intros
split
rintros ‚ü®y, hy‚ü©
{ rintros ‚ü®y, hy‚ü©, cases h : y with a f, refine ‚ü®a, Œª i, (f i).val, _, Œª i, (f i).property‚ü©, rw [‚Üêhy, h, pfunctor.map_eq] }
cases h : y with a f
refine ‚ü®a, Œª i, (f i).val, _, Œª i, (f i).property‚ü©
rw [‚Üêhy, h, pfunctor.map_eq]
rintros ‚ü®a, f, xeq, pf‚ü©
use ‚ü®a, Œª i, ‚ü®f i, pf i‚ü©‚ü©
rw [xeq]
reflexivity
intros
simp_rw algebra.smul_def
{ simp_rw algebra.smul_def, exact eval‚ÇÇ_eq_sum_range' (algebra_map R S) hn x }
exact eval‚ÇÇ_eq_sum_range' (algebra_map R S) hn x
intros
simp
intros
rw [‚Üê pow_one X, support_X_pow H 1]
intros
ext1
{ ext1, rw [monomial_eq_smul_X, coeff_smul, coeff_C_mul, smul_eq_mul] }
rw [monomial_eq_smul_X, coeff_smul, coeff_C_mul, smul_eq_mul]
intros
rw [add_comm, degree_add_eq_left_of_degree_lt h]
intros
rw [subsingleton.elim p 0, degree_zero]
intros
refine ‚ü®r * a ^ n * b ^ (N - n), bi, bu, _‚ü©
rw [C_mul_X_pow_eq_monomial, map_monomial, ‚Üê C_mul_X_pow_eq_monomial, eval_mul, eval_pow, eval_C]
rw [ring_hom.map_mul, ring_hom.map_mul, ring_hom.map_pow, ring_hom.map_pow, eval_X, mul_comm]
rw [‚Üê nat.sub_add_cancel nN] {occs := occurrences.pos [2]}
rw [pow_add, mul_assoc, mul_comm (i b ^ n), mul_pow, mul_assoc, mul_assoc (i a ^ n), ‚Üê mul_pow]
rw [bu, one_pow, mul_one]
intros
by_cases h : f.support.card ‚â§ 1
right
{ right, rw ‚Üê C_mul_X_pow_eq_self h, simp }
rw ‚Üê C_mul_X_pow_eq_self h
simp
left
{ left, apply erase_lead_nat_degree_lt (lt_of_not_ge h) }
apply erase_lead_nat_degree_lt (lt_of_not_ge h)
intros
simp only [‚ÜêC_eq_nat_cast, eval_C]
intros
simp only [monomial_eq_C_mul_X, sum_C_mul_X_eq]
intros
induction n with n ih
{ exfalso, exact nat.lt_asymm h h }
exfalso
exact nat.lt_asymm h h
by_cases H : n = 0
{ by_cases H : n = 0, { rw [iterated_deriv_succ, H], simp only [iterated_deriv_C_zero, derivative_C] }, { replace h : 0 < n := nat.pos_of_ne_zero H, rw [iterated_deriv_succ, ih h], simp only [derivative_zero] } }
rw [iterated_deriv_succ, H]
{ rw [iterated_deriv_succ, H], simp only [iterated_deriv_C_zero, derivative_C] }
simp only [iterated_deriv_C_zero, derivative_C]
replace h : 0 < n := nat.pos_of_ne_zero H
{ replace h : 0 < n := nat.pos_of_ne_zero H, rw [iterated_deriv_succ, ih h], simp only [derivative_zero] }
rw [iterated_deriv_succ, ih h]
simp only [derivative_zero]
intros
rw [leading_coeff, leading_coeff, coeff_smul, nat_degree_smul_of_smul_regular p h]
intros
by_cases f0 : f=0
{ simp only [f0, zero_mul, reverse_zero], }
simp only [f0, zero_mul, reverse_zero]
by_cases g0 : g=0
{ rw [g0, mul_zero, reverse_zero, mul_zero], }
rw [g0, mul_zero, reverse_zero, mul_zero]
simp [reverse_mul, *]
intros
simp only [taylor_apply, X_comp]
intros
ext
ext; apply mem_supp
apply mem_supp
intros
rw [‚Üê int.cast_coe_nat, coe_int_denom]
intros
simp [abs_eq_max_neg]
intros
rw [lt_iff_le_and_ne, rat.le_def']
suffices : p ‚â† q ‚Üî p.num * q.denom ‚â† q.num * p.denom
split; intro h
split; intro h
split
split
{ split; intro h, { exact lt_iff_le_and_ne.elim_right ‚ü®h.left, (this.elim_left h.right)‚ü© }, { have tmp := lt_iff_le_and_ne.elim_left h, exact ‚ü®tmp.left, this.elim_right tmp.right‚ü© }}
{ split; intro h, { exact lt_iff_le_and_ne.elim_right ‚ü®h.left, (this.elim_left h.right)‚ü© }, { have tmp := lt_iff_le_and_ne.elim_left h, exact ‚ü®tmp.left, this.elim_right tmp.right‚ü© }}
intro h
intro h
{ exact lt_iff_le_and_ne.elim_right ‚ü®h.left, (this.elim_left h.right)‚ü© }
{ exact lt_iff_le_and_ne.elim_right ‚ü®h.left, (this.elim_left h.right)‚ü© }
exact lt_iff_le_and_ne.elim_right ‚ü®h.left, (this.elim_left h.right)‚ü©
exact lt_iff_le_and_ne.elim_right ‚ü®h.left, (this.elim_left h.right)‚ü©
intro h
intro h
have tmp := lt_iff_le_and_ne.elim_left h
have tmp := lt_iff_le_and_ne.elim_left h
{ have tmp := lt_iff_le_and_ne.elim_left h, exact ‚ü®tmp.left, this.elim_right tmp.right‚ü© }
{ have tmp := lt_iff_le_and_ne.elim_left h, exact ‚ü®tmp.left, this.elim_right tmp.right‚ü© }
exact ‚ü®tmp.left, this.elim_right tmp.right‚ü©
exact ‚ü®tmp.left, this.elim_right tmp.right‚ü©
exact (not_iff_not.elim_right eq_iff_mul_eq_mul)
rw ‚Üê zero_cauchy
rw ‚Üê zero_cauchy; refl
refl
intros
simpa using neg_lim_zero hfg
intros
{ simp_rw ennreal.to_real, norm_cast, exact to_nnreal_inv a, }
simp_rw ennreal.to_real
norm_cast
exact to_nnreal_inv a
intros
simp [div_eq_mul_inv, h]
refine lt_of_mul_lt_mul_left _ (le_of_lt gold_pos)
simp [‚Üê sq, gold_pos, zero_lt_one]
intros
rw not_infinite_iff_exist_lt_gt
rw not_infinite_iff_exist_lt_gt; exact ‚ü® r - 1, r + 1, coe_lt_coe.2 $ sub_one_lt r, coe_lt_coe.2 $ lt_add_one r‚ü©
exact ‚ü® r - 1, r + 1, coe_lt_coe.2 $ sub_one_lt r, coe_lt_coe.2 $ lt_add_one r‚ü©
intros
simpa using sqrt_inj h (le_refl _)
intros
{ unfold comp, ext x, simp }
unfold comp
ext x
simp
intros
rw [‚Üêbind_ret, ‚Üêbind_ret]; apply lift_rel_bind _ _ h1; simp; exact @h2
rw [‚Üêbind_ret, ‚Üêbind_ret]; apply lift_rel_bind _ _ h1; simp
rw [‚Üêbind_ret, ‚Üêbind_ret]; apply lift_rel_bind _ _ h1
rw [‚Üêbind_ret, ‚Üêbind_ret]
apply lift_rel_bind _ _ h1
simp
exact @h2
intros
ext x
simp only [mem_inter_iff, mem_insert_iff, mem_inter_eq, and.congr_left_iff, or_iff_right_iff_imp]
cc
intros
ext
{ ext, simp [and_or_distrib_left, exists_or_distrib, eq_comm, or_comm, and_comm] }
simp [and_or_distrib_left, exists_or_distrib, eq_comm, or_comm, and_comm]
intros
split
intro h
{ intro h, apply subset.antisymm, rw [‚Üêpreimage_subset_preimage_iff hs, h], rw [‚Üêpreimage_subset_preimage_iff ht, h] }
apply subset.antisymm
rw [‚Üêpreimage_subset_preimage_iff hs, h]
rw [‚Üêpreimage_subset_preimage_iff ht, h]
rintro rfl
refl
intros
rw [‚Üê preimage_range (coe : s ‚Üí Œ±), range_coe]
intros
simp [subset_def]
intros
rw [‚Üê image_eq_image hf.1, hf.2.image_preimage]
intros
{ ext, simp }
ext
simp
intros
ext
ext; simp
simp
intros
rw [‚Üê Ioi_inter_Iic, inter_assoc, inter_comm, inter_assoc, Ioi_inter_Ioi, inter_comm, Ioi_inter_Iic, sup_comm]
intros
rw [‚Üênot_nonempty_iff_eq_empty, not_iff_not, nonempty_Ico]
intros
rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iio]
intros
simp [add_comm]
intros
refine ‚ü®Œª x h, add_le_add_right (mem_Iic.mp h) _, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
simpa [add_comm a] using h
intros
refine ‚ü®Œª x h, add_le_add_right (mem_Ici.mp h) _, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
obtain ‚ü®c, rfl‚ü© := exists_add_of_le (mem_Ici.mp h)
rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
exact ‚ü®a + c, h, by rw add_right_comm‚ü©
intros
simp [interval_oc, h]
intros
intros y hy
rw [Hinj.image_Inter_eq, mem_Inter]
exact Œª i, H i hy
intros
rw [‚Üê sUnion_image, image_id']
intros
{ ext x, simp [hs.exists_mem x] }
ext x
simp [hs.exists_mem x]
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
{ apply fin.val_add }
apply fin.val_add
intros
rw [zmod.val_min_abs_def_pos]
{ rw [zmod.val_min_abs_def_pos], split_ifs; simp only [add_zero, sub_add_cancel] }
split_ifs
split_ifs; simp only [add_zero, sub_add_cancel]
simp only [add_zero, sub_add_cancel]
simp only [add_zero, sub_add_cancel]
intros
simpa only [add_comm _ (n:‚Ñù)] using f.commute_add_int n
intros
revert Œ±
suffices : ‚àÄ (Œ± : E), is_solvable_by_rad F Œ± ‚Üí (‚àÉ Œ≤ : solvable_by_rad F E, ‚ÜëŒ≤ = Œ± ‚àß P Œ≤)
intro Œ±
{ intro Œ±, obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := this Œ± (subtype.mem Œ±), convert PŒ±, exact subtype.ext hŒ±‚ÇÄ.symm }
obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := this Œ± (subtype.mem Œ±)
convert PŒ±
exact subtype.ext hŒ±‚ÇÄ.symm
apply is_solvable_by_rad.rec
exact Œª Œ±, ‚ü®algebra_map F (solvable_by_rad F E) Œ±, rfl, base Œ±‚ü©
{ exact Œª Œ±, ‚ü®algebra_map F (solvable_by_rad F E) Œ±, rfl, base Œ±‚ü© }
intros Œ± Œ≤ hŒ± hŒ≤ PŒ± PŒ≤
{ intros Œ± Œ≤ hŒ± hŒ≤ PŒ± PŒ≤, obtain ‚ü®‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü©, Œ≤‚ÇÄ, hŒ≤‚ÇÄ, PŒ≤‚ü© := ‚ü®PŒ±, PŒ≤‚ü©, exact ‚ü®Œ±‚ÇÄ + Œ≤‚ÇÄ, by {rw [‚ÜêhŒ±‚ÇÄ, ‚ÜêhŒ≤‚ÇÄ], refl }, add Œ±‚ÇÄ Œ≤‚ÇÄ PŒ± PŒ≤‚ü© }
obtain ‚ü®‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü©, Œ≤‚ÇÄ, hŒ≤‚ÇÄ, PŒ≤‚ü© := ‚ü®PŒ±, PŒ≤‚ü©
exact ‚ü®Œ±‚ÇÄ + Œ≤‚ÇÄ, by {rw [‚ÜêhŒ±‚ÇÄ, ‚ÜêhŒ≤‚ÇÄ], refl }, add Œ±‚ÇÄ Œ≤‚ÇÄ PŒ± PŒ≤‚ü©
intros Œ± hŒ± PŒ±
{ intros Œ± hŒ± PŒ±, obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := PŒ±, exact ‚ü®-Œ±‚ÇÄ, by {rw ‚ÜêhŒ±‚ÇÄ, refl }, neg Œ±‚ÇÄ PŒ±‚ü© }
obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := PŒ±
exact ‚ü®-Œ±‚ÇÄ, by {rw ‚ÜêhŒ±‚ÇÄ, refl }, neg Œ±‚ÇÄ PŒ±‚ü©
intros Œ± Œ≤ hŒ± hŒ≤ PŒ± PŒ≤
{ intros Œ± Œ≤ hŒ± hŒ≤ PŒ± PŒ≤, obtain ‚ü®‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü©, Œ≤‚ÇÄ, hŒ≤‚ÇÄ, PŒ≤‚ü© := ‚ü®PŒ±, PŒ≤‚ü©, exact ‚ü®Œ±‚ÇÄ * Œ≤‚ÇÄ, by {rw [‚ÜêhŒ±‚ÇÄ, ‚ÜêhŒ≤‚ÇÄ], refl }, mul Œ±‚ÇÄ Œ≤‚ÇÄ PŒ± PŒ≤‚ü© }
obtain ‚ü®‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü©, Œ≤‚ÇÄ, hŒ≤‚ÇÄ, PŒ≤‚ü© := ‚ü®PŒ±, PŒ≤‚ü©
exact ‚ü®Œ±‚ÇÄ * Œ≤‚ÇÄ, by {rw [‚ÜêhŒ±‚ÇÄ, ‚ÜêhŒ≤‚ÇÄ], refl }, mul Œ±‚ÇÄ Œ≤‚ÇÄ PŒ± PŒ≤‚ü©
intros Œ± hŒ± PŒ±
{ intros Œ± hŒ± PŒ±, obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := PŒ±, exact ‚ü®Œ±‚ÇÄ‚Åª¬π, by {rw ‚ÜêhŒ±‚ÇÄ, refl }, inv Œ±‚ÇÄ PŒ±‚ü© }
obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := PŒ±
exact ‚ü®Œ±‚ÇÄ‚Åª¬π, by {rw ‚ÜêhŒ±‚ÇÄ, refl }, inv Œ±‚ÇÄ PŒ±‚ü©
intros Œ± n hn hŒ± PŒ±
{ intros Œ± n hn hŒ± PŒ±, obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := PŒ±, refine ‚ü®‚ü®Œ±, is_solvable_by_rad.rad Œ± n hn hŒ±‚ü©, rfl, rad _ n hn _‚ü©, convert PŒ±, exact subtype.ext (eq.trans ((solvable_by_rad F E).coe_pow _ n) hŒ±‚ÇÄ.symm) }
obtain ‚ü®Œ±‚ÇÄ, hŒ±‚ÇÄ, PŒ±‚ü© := PŒ±
refine ‚ü®‚ü®Œ±, is_solvable_by_rad.rad Œ± n hn hŒ±‚ü©, rfl, rad _ n hn _‚ü©
convert PŒ±
exact subtype.ext (eq.trans ((solvable_by_rad F E).coe_pow _ n) hŒ±‚ÇÄ.symm)
intros
rw ‚Üê adjoin_simple.algebra_map_gen F Œ± at h
have inj := (algebra_map F‚üÆŒ±‚üØ E).injective
exact minpoly.eq_of_algebra_map_eq inj ((is_integral_algebra_map_iff inj).mp h) (adjoin_simple.algebra_map_gen _ _).symm
intros
rw [coe_expand, derivative_eval‚ÇÇ_C, derivative_pow, derivative_X, mul_one]
intros
rw [separable_iff_derivative_ne_zero hf, ne, ‚Üê degree_eq_bot, degree_derivative_eq]
rintro ‚ü®‚ü©
rw [pos_iff_ne_zero, ne, nat_degree_eq_zero_iff_degree_le_zero, degree_le_zero_iff]
refine Œª hf1, hf.not_unit _
rw [hf1, is_unit_C, is_unit_iff_ne_zero]
intro hf2
rw [hf2, C_0] at hf1
exact absurd hf1 hf.ne_zero
intros
apply polynomial.map_injective _ i.injective
rw [eq_prod_roots_of_splits h_splits, h_roots]
simp
intros
use p
simp
intros
simp_rw [monge_point_eq_affine_combination_of_points_with_circumcenter, centroid_eq_affine_combination_of_points_with_circumcenter, affine_combination_vsub, monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub h]
intros
{ simp only [‚Üê finset.prod_apply], exact smooth_finset_prod' h }
simp only [‚Üê finset.prod_apply]
exact smooth_finset_prod' h
intros
rw support_eq_inter_preimage
{ rw support_eq_inter_preimage, exact ext_chart_preimage_open_of_open I c is_open_ball }
exact ext_chart_preimage_open_of_open I c is_open_ball
intros
suffices h : Q (e ‚àò e.symm) e.target (e x)
rw [lift_prop_at, hG.lift_prop_within_at_indep_chart he hx G.id_mem_maximal_atlas (mem_univ _)]
{ rw [lift_prop_at, hG.lift_prop_within_at_indep_chart he hx G.id_mem_maximal_atlas (mem_univ _)], refine ‚ü®(e.continuous_at hx).continuous_within_at, _‚ü©, simpa only with mfld_simps }
refine ‚ü®(e.continuous_at hx).continuous_within_at, _‚ü©
simpa only with mfld_simps
have A : Q id e.target (e x)
have : e x ‚àà e.target
{ have : e x ‚àà e.target, by simp only [hx] with mfld_simps, simpa only with mfld_simps using (hG.is_local e.open_target this).1 (hQ (e x)) }
simp only [hx] with mfld_simps
simp only [hx] with mfld_simps
simpa only with mfld_simps using (hG.is_local e.open_target this).1 (hQ (e x))
apply hG.congr _ _ A; simp only [hx] with mfld_simps {contextual := tt}
apply hG.congr _ _ A
simp only [hx] with mfld_simps {contextual := tt}
simp only [hx] with mfld_simps {contextual := tt}
intros
rwa [‚Üê univ_inter s, has_mfderiv_within_at_inter hs, has_mfderiv_within_at_univ] at h
intros
simp only [tangent_map] with mfld_simps
rw mfderiv_comp p.1 hg hf
refl
intros
cases he with he he_symm
cases he' with he' he'_symm
simp only at he he_symm he' he'_symm
split
split; simp only [local_equiv.prod_source, local_homeomorph.prod_to_local_equiv]
simp only [local_equiv.prod_source, local_homeomorph.prod_to_local_equiv]
have h3 := times_cont_diff_on.prod_map he he'
{ have h3 := times_cont_diff_on.prod_map he he', rw [‚Üê I.image_eq, ‚Üê I'.image_eq, set.prod_image_image_eq] at h3, rw ‚Üê (I.prod I').image_eq, exact h3, }
rw [‚Üê I.image_eq, ‚Üê I'.image_eq, set.prod_image_image_eq] at h3
rw ‚Üê (I.prod I').image_eq
exact h3
simp only [local_equiv.prod_source, local_homeomorph.prod_to_local_equiv]
have h3 := times_cont_diff_on.prod_map he_symm he'_symm
{ have h3 := times_cont_diff_on.prod_map he_symm he'_symm, rw [‚Üê I.image_eq, ‚Üê I'.image_eq, set.prod_image_image_eq] at h3, rw ‚Üê (I.prod I').image_eq, exact h3, }
rw [‚Üê I.image_eq, ‚Üê I'.image_eq, set.prod_image_image_eq] at h3
rw ‚Üê (I.prod I').image_eq
exact h3
intros
rw ‚Üê times_cont_mdiff_on_univ at hf
rw continuous_iff_continuous_on_univ
convert hf.continuous_on_tangent_map_within hmn unique_mdiff_on_univ
rw tangent_map_within_univ
intros
intro x
by_cases hx : x ‚àà closure (support f)
{ exact hf x hx }
exact hf x hx
refine times_cont_mdiff_at.congr_of_eventually_eq _ (eventually_eq_zero_nhds.2 hx)
{ refine times_cont_mdiff_at.congr_of_eventually_eq _ (eventually_eq_zero_nhds.2 hx), exact times_cont_mdiff_at_const }
exact times_cont_mdiff_at_const
intros
{ ext, simp only [Inf_image, infi_apply, infi_Prop_eq], refl }
ext
simp only [Inf_image, infi_apply, infi_Prop_eq]
refl
intros
rw [‚Üêset_like.mem_coe, ‚Üêha]; exact mem_own_left_coset s a
rw [‚Üêset_like.mem_coe, ‚Üêha]
exact mem_own_left_coset s a
intros
rw [‚Üê add_monoid_hom.comp_apply, finsupp.to_free_abelian_group_comp_to_finsupp, add_monoid_hom.id_apply]
intros
simp only [general_commutator_le_left, general_commutator_le_right, le_inf_iff, and_self]
intros
rw [order_of, is_fixed_point_iff_minimal_period_eq_one, is_fixed_pt, mul_one]
intros
let œï := orbit_equiv_quotient_stabilizer G a
haveI := fintype.of_equiv (orbit G a) œï
rw [card_congr œï, ‚Üêsubgroup.index_eq_card]
exact hG.index (stabilizer G a)
intros
induction s using quot.induction_on
simpa using list.form_perm_apply_mem_eq_next h _ _
intros
classical
exact top_le_iff.mp (le_trans (ge_of_eq closure_is_swap) (closure_mono (Œª _, is_swap.is_cycle)))
intros
split
intro h
{ intro h, obtain ‚ü®x, hx, -‚ü© := id hf, exact ‚ü®x, mem_support.mpr hx, by simp [h]‚ü© }
obtain ‚ü®x, hx, -‚ü© := id hf
exact ‚ü®x, mem_support.mpr hx, by simp [h]‚ü©
rintro ‚ü®x, hx, hx'‚ü©
{ rintro ‚ü®x, hx, hx'‚ü©, by_cases h : support (f ^ n) = support f, { rw [‚Üêh, mem_support] at hx, contradiction }, { rw [hf.support_pow_eq_iff, not_not] at h, obtain ‚ü®k, rfl‚ü© := h, rw [pow_mul, pow_order_of_eq_one, one_pow] } }
by_cases h : support (f ^ n) = support f
rw [‚Üêh, mem_support] at hx
{ rw [‚Üêh, mem_support] at hx, contradiction }
contradiction
rw [hf.support_pow_eq_iff, not_not] at h
{ rw [hf.support_pow_eq_iff, not_not] at h, obtain ‚ü®k, rfl‚ü© := h, rw [pow_mul, pow_order_of_eq_one, one_pow] }
obtain ‚ü®k, rfl‚ü© := h
rw [pow_mul, pow_order_of_eq_one, one_pow]
intros
have : f.cycle_factors_finset = f.cycle_factors_finset := rfl
obtain ‚ü®-, hd, hp‚ü© := cycle_factors_finset_eq_finset.mp this
exact hp
intros
ext i
cases n
simp
{ simp }
refine fin.cases _ (Œª i, _) i
{ simp }
simp
rw [coe_fin_rotate, decompose_fin_symm_apply_succ, if_congr (i.succ_eq_last_succ) rfl rfl]
split_ifs with h
{ simp [h] }
simp [h]
rw [fin.coe_succ, function.injective.map_swap fin.coe_injective, fin.coe_succ, coe_fin_rotate, if_neg h, fin.coe_zero, fin.coe_one, swap_apply_of_ne_of_ne (nat.succ_ne_zero _) (nat.succ_succ_ne_one _)]
{ rw [fin.coe_succ, function.injective.map_swap fin.coe_injective, fin.coe_succ, coe_fin_rotate, if_neg h, fin.coe_zero, fin.coe_one, swap_apply_of_ne_of_ne (nat.succ_ne_zero _) (nat.succ_succ_ne_one _)] }
intros
ext
{ext, simp [equiv_functor.map_equiv, equiv_functor.map] }
simp [equiv_functor.map_equiv, equiv_functor.map]
intros
{ ext, simp }
ext
simp
intros
rw [disjoint_comm, disjoint_inv_left_iff, disjoint_comm]
intros
haveI := fintype.one_lt_card_iff_nontrivial.1 (lt_trans dec_trivial h3)
rw ‚Üê fintype.one_lt_card_iff_nontrivial
refine lt_of_mul_lt_mul_left _ (le_of_lt nat.prime_two.pos)
rw [two_mul_card_alternating_group, card_perm, ‚Üê nat.succ_le_iff]
exact le_trans h3 (card Œ±).self_le_factorial
intros
rw [sr_mul_sr, sub_self, one_def]
intros
rwa [comap_map_eq, sup_eq_left]
intros
rw [‚Üê mem_to_submonoid, closure_to_submonoid k] at h
refine submonoid.closure_induction h (Œª x hx, _) H1 (Œª x y hx hy, Hmul x y hx hy)
rw [mem_union, mem_inv] at hx
{ rw [mem_union, mem_inv] at hx, cases hx with mem invmem, { exact Hk x mem }, { rw [‚Üê inv_inv x], exact Hk_inv _ invmem } }
cases hx with mem invmem
{ exact Hk x mem }
exact Hk x mem
rw [‚Üê inv_inv x]
{ rw [‚Üê inv_inv x], exact Hk_inv _ invmem }
exact Hk_inv _ invmem
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
ext
change (‚ü®f x, _‚ü© : mrange f) = ‚ü®1, _‚ü© ‚Üî f x = 1
simp only []
intros
rw decomp ; simp only [linear_map.map_zero, pi.add_apply, add_sub_cancel, zero_add]
rw decomp
simp only [linear_map.map_zero, pi.add_apply, add_sub_cancel, zero_add]
intros
refine subset.antisymm _ (Union_subset $ le_supr S)
suffices : (span R (‚ãÉ i, (S i : set M)) : set M) ‚äÜ ‚ãÉ (i : Œπ), ‚Üë(S i)
simpa only [span_Union, span_eq] using this
simpa only [span_Union, span_eq] using this
refine (Œª x hx, span_induction hx (Œª _, id) _ _ _)
refine (Œª x hx, span_induction hx (Œª _, id) _ _ _); simp only [mem_Union, exists_imp_distrib]
simp only [mem_Union, exists_imp_distrib]
{ exact hŒπ.elim (Œª i, ‚ü®i, (S i).zero_mem‚ü©) }
exact hŒπ.elim (Œª i, ‚ü®i, (S i).zero_mem‚ü©)
simp only [mem_Union, exists_imp_distrib]
intros x y i hi j hj
{ intros x y i hi j hj, rcases H i j with ‚ü®k, ik, jk‚ü©, exact ‚ü®k, add_mem _ (ik hi) (jk hj)‚ü© }
rcases H i j with ‚ü®k, ik, jk‚ü©
exact ‚ü®k, add_mem _ (ik hi) (jk hj)‚ü©
simp only [mem_Union, exists_imp_distrib]
{ exact Œª a x i hi, ‚ü®i, smul_mem _ a hi‚ü© }
exact Œª a x i hi, ‚ü®i, smul_mem _ a hi‚ü©
intros
classical; by_cases a = 0; simp [h, comap_smul]
classical; by_cases a = 0
classical
by_cases a = 0
simp [h, comap_smul]
simp [h, comap_smul]
intros
rw [map_le_map_iff, hf, sup_bot_eq]
intros
let C := basis.of_vector_space_index K V'
let hC := basis.of_vector_space K V'
haveI : inhabited V := ‚ü®0‚ü©
use hC.constr K (C.restrict (inv_fun f))
refine hC.ext (Œª c, _)
rw [linear_map.comp_apply, hC.constr_basis]
simp [right_inverse_inv_fun (linear_map.range_eq_top.1 hf_surj) c]
intros
rw eq_top_iff
intros j hj
rw ‚Üê hv at hj
rw submodule.mem_span at hj ‚ä¢
refine Œª p hp, hj p (Œª u hu, _)
obtain ‚ü®i, rfl‚ü© := hu
have : ((w i)‚Åª¬π ‚Ä¢ 1 : R) ‚Ä¢ w i ‚Ä¢ v i ‚àà p := p.smul_mem ((w i)‚Åª¬π ‚Ä¢ 1 : R) (hp ‚ü®i, rfl‚ü©)
rwa [smul_one_smul, inv_smul_smul] at this
intros
ext x
split
split; rw [mem_orthogonal_iff]; intro hx
split; rw [mem_orthogonal_iff]
rw [mem_orthogonal_iff]
intro hx
intros y hy
{ intros y hy, rw submodule.mem_dual_annihilator_comap_iff at hx, refine hx (B.to_lin.dom_restrict W ‚ü®y, hy‚ü©) ‚ü®‚ü®y, hy‚ü©, rfl‚ü© }
rw submodule.mem_dual_annihilator_comap_iff at hx
refine hx (B.to_lin.dom_restrict W ‚ü®y, hy‚ü©) ‚ü®‚ü®y, hy‚ü©, rfl‚ü©
rw [mem_orthogonal_iff]
intro hx
rw submodule.mem_dual_annihilator_comap_iff
{ rw submodule.mem_dual_annihilator_comap_iff, rintro _ ‚ü®‚ü®w, hw‚ü©, rfl‚ü©, exact hx w hw }
rintro _ ‚ü®‚ü®w, hw‚ü©, rfl‚ü©
exact hx w hw
intros
rw [matrix.to_bilin'_aux, coe_fn_mk, sum_eq_single i, sum_eq_single j]
simp only [std_basis_same, std_basis_same, one_mul, mul_one]
{ simp only [std_basis_same, std_basis_same, one_mul, mul_one] }
rintros j' - hj'
{ rintros j' - hj', apply mul_eq_zero_of_right, exact std_basis_ne R‚ÇÇ (Œª _, R‚ÇÇ) _ _ hj' 1 }
apply mul_eq_zero_of_right
exact std_basis_ne R‚ÇÇ (Œª _, R‚ÇÇ) _ _ hj' 1
intros
{ intros, have := finset.mem_univ j, contradiction }
have := finset.mem_univ j
contradiction
rintros i' - hi'
{ rintros i' - hi', refine finset.sum_eq_zero (Œª j _, _), apply mul_eq_zero_of_left, apply mul_eq_zero_of_left, exact std_basis_ne R‚ÇÇ (Œª _, R‚ÇÇ) _ _ hi' 1 }
refine finset.sum_eq_zero (Œª j _, _)
apply mul_eq_zero_of_left
apply mul_eq_zero_of_left
exact std_basis_ne R‚ÇÇ (Œª _, R‚ÇÇ) _ _ hi' 1
intros
{ intros, have := finset.mem_univ i, contradiction }
have := finset.mem_univ i
contradiction
intros
ext : 1
dsimp
ext
all_goals { dsimp, rw to_quaternion_Œπ, dsimp, simp only [to_quaternion_Œπ, zero_smul, one_smul, zero_add, add_zero, ring_hom.map_zero], }
dsimp
rw to_quaternion_Œπ
dsimp
simp only [to_quaternion_Œπ, zero_smul, one_smul, zero_add, add_zero, ring_hom.map_zero]
dsimp
rw to_quaternion_Œπ
dsimp
simp only [to_quaternion_Œπ, zero_smul, one_smul, zero_add, add_zero, ring_hom.map_zero]
intros
rw [‚Üê det_comm' hM'M hMM', ‚Üê matrix.mul_assoc, hM'M, matrix.one_mul]
intros
have : (‚ä• : submodule R M) ‚âÉ‚Çó[R] punit := bot_equiv_punit
rw [this.dim_eq, dim_punit]
intros
rw [dim_fun_eq_lift_mul, dim_self, cardinal.lift_one, mul_one, cardinal.nat_cast_inj]
intros
unfold has_generalized_eigenvalue at *
contrapose! hk
rw [‚Üêle_bot_iff, ‚Üêhk]
exact (f.generalized_eigenspace Œº).monotone hm
intros
haveI : finite_dimensional K V := of_fintype_basis h
have := dim_eq_card_basis h
rw ‚Üê finrank_eq_dim at this
exact_mod_cast this
intros
rw [‚Üê dim_eq_zero, ‚Üê finrank_eq_dim, ‚Üê @nat.cast_zero cardinal, cardinal.nat_cast_inj]
intros
ext l a
by_cases a ‚àà s; simp [h]
by_cases a ‚àà s
simp [h]
simp [h]
exact ((mem_supported' R l.1).1 l.2 a h).symm
intros
simp [linear_independent_comp_subtype]
intros
split_ifs; simp [h, nat_degree_X_sub_C_le]
split_ifs
simp [h, nat_degree_X_sub_C_le]
simp [h, nat_degree_X_sub_C_le]
intros
rw [‚Üê det_transpose, ‚Üê update_row_transpose, det_update_row_add]
simp [update_row_transpose, det_transpose]
intros
ext i j
simp only [linear_map.to_matrix_apply, module.dual.transpose_apply, B‚ÇÅ.dual_basis_repr, B‚ÇÇ.dual_basis_apply, matrix.transpose_apply, linear_map.comp_apply]
intros
rw [matrix.to_lin_apply, finset.sum_congr rfl (Œª j hj, _)]
rw [basis.repr_self, matrix.mul_vec, dot_product, finset.sum_eq_single i, finsupp.single_eq_same, mul_one]
intros i' _ i'_ne
{ intros i' _ i'_ne, rw [finsupp.single_eq_of_ne i'_ne.symm, mul_zero] }
rw [finsupp.single_eq_of_ne i'_ne.symm, mul_zero]
intros
{ intros, have := finset.mem_univ i, contradiction }
have := finset.mem_univ i
contradiction
intros
simpa using list_transvec_col_mul_last_row_drop M i (zero_le _)
intros
rw [‚Üê update_cons_zero x m (x+y), f.map_add, update_cons_zero, update_cons_zero]
intros
{ ext, simp, }
ext
simp
intros
ext ‚ü®x, y‚ü©; simp [and.left_comm, eq_comm]
ext ‚ü®x, y‚ü©
simp [and.left_comm, eq_comm]
intros
{ simp only [polar, pi.smul_apply, smul_sub] }
simp only [polar, pi.smul_apply, smul_sub]
intros
refine disjoint.mono (supr_range_std_basis_le_infi_ker_proj _ _ _ _ $ disjoint_compl_right) (supr_range_std_basis_le_infi_ker_proj _ _ _ _ $ disjoint_compl_right) _
simp only [disjoint, set_like.le_def, mem_infi, mem_inf, mem_ker, mem_bot, proj_apply, funext_iff]
rintros b ‚ü®hI, hJ‚ü© i
classical
by_cases hiI : i ‚àà I
by_cases hiJ : i ‚àà J
{ by_cases hiJ : i ‚àà J, { exact (h ‚ü®hiI, hiJ‚ü©).elim }, { exact hJ i hiJ } }
{ exact (h ‚ü®hiI, hiJ‚ü©).elim }
exact (h ‚ü®hiI, hiJ‚ü©).elim
{ exact hJ i hiJ }
exact hJ i hiJ
{ exact hI i hiI }
exact hI i hiI
intros
simp only [ltensor, rtensor, ‚Üê map_comp, id_comp, comp_id]
intros
simp [set_value]
intros
rwa sometimes_eq
intros
haveI := hs.principal_is_measurably_generated; exact filter.inf_is_measurably_generated _ _
haveI := hs.principal_is_measurably_generated
exact filter.inf_is_measurably_generated _ _
intros
{ rw ‚Üê prod_swap at hf, exact hf.comp_measurable measurable_swap }
rw ‚Üê prod_swap at hf
exact hf.comp_measurable measurable_swap
intros
refine integrable.ae_eq_of_with_density·µ•_eq (integrable_rn_deriv _ _) (integrable_rn_deriv _ _).neg _
rw [with_density·µ•_neg, ‚Üê add_right_inj ((-s).singular_part Œº), singular_part_add_with_density_rn_deriv_eq, singular_part_neg, ‚Üê neg_add, singular_part_add_with_density_rn_deriv_eq]
intros
have h : ae_measurable' m (condexp_L2 ‚Ñù hm (indicator_const_Lp 2 hs hŒºs (1 : ‚Ñù))) Œº
from ae_measurable'_condexp_L2 _ _
rw condexp_ind_smul
suffices : ae_measurable' m ((to_span_singleton ‚Ñù x) ‚àò (condexp_L2 ‚Ñù hm (indicator_const_Lp 2 hs hŒºs (1 : ‚Ñù)))) Œº
refine ae_measurable'.congr this _
{ refine ae_measurable'.congr this _, refine eventually_eq.trans _ (coe_fn_comp_LpL _ _).symm, rw Lp_meas_coe, }
refine eventually_eq.trans _ (coe_fn_comp_LpL _ _).symm
rw Lp_meas_coe
exact ae_measurable'.measurable_comp (to_span_singleton ‚Ñù x).measurable h
intros
ext1
change Lp_trim_to_Lp_meas F ‚Ñù 1 Œº hm (indicator_const_Lp 1 hs hŒºs c) =·µê[Œº] (indicator_const_Lp 1 _ _ c : Œ± ‚Üí F)
refine (Lp_trim_to_Lp_meas_ae_eq hm _).trans _
exact (ae_eq_of_ae_eq_trim indicator_const_Lp_coe_fn).trans indicator_const_Lp_coe_fn.symm
intros
obtain ‚ü®g, hg_sm, hfg‚ü© := Lp_meas.ae_fin_strongly_measurable' hm f hp_ne_zero hp_ne_top
refine hfg.trans _
refine ae_eq_zero_of_forall_set_integral_eq_of_fin_strongly_measurable_trim hm _ _ hg_sm
intros s hs hŒºs
{ intros s hs hŒºs, have hfg_restrict : f =·µê[Œº.restrict s] g, from ae_restrict_of_ae hfg, rw [integrable_on, integrable_congr hfg_restrict.symm], exact hf_int_finite s hs hŒºs, }
have hfg_restrict : f =·µê[Œº.restrict s] g
from ae_restrict_of_ae hfg
from ae_restrict_of_ae hfg
rw [integrable_on, integrable_congr hfg_restrict.symm]
exact hf_int_finite s hs hŒºs
intros s hs hŒºs
{ intros s hs hŒºs, have hfg_restrict : f =·µê[Œº.restrict s] g, from ae_restrict_of_ae hfg, rw integral_congr_ae hfg_restrict.symm, exact hf_zero s hs hŒºs, }
have hfg_restrict : f =·µê[Œº.restrict s] g
from ae_restrict_of_ae hfg
from ae_restrict_of_ae hfg
rw integral_congr_ae hfg_restrict.symm
exact hf_zero s hs hŒºs
intros
haveI hŒº_ne_bot : Œº.ae.ne_bot
rwa [ne_bot_iff, ne.def, ae_eq_bot]
{ rwa [ne_bot_iff, ne.def, ae_eq_bot] }
exact limsup_const c
intros
have : ‚àÄ·µê a ‚àÇŒº, ‚à•f‚ÇÅ a‚à• ‚â§ ‚à•f‚ÇÄ a‚à• + g a
apply h.mono
{ apply h.mono, intros a ha, calc ‚à•f‚ÇÅ a‚à• ‚â§ ‚à•f‚ÇÄ a‚à• + ‚à•f‚ÇÄ a - f‚ÇÅ a‚à• : norm_le_insert _ _ ... ‚â§ ‚à•f‚ÇÄ a‚à• + g a : add_le_add_left ha _ }
intros a ha
calc ‚à•f‚ÇÅ a‚à• ‚â§ ‚à•f‚ÇÄ a‚à• + ‚à•f‚ÇÄ a - f‚ÇÅ a‚à• : norm_le_insert _ _ ... ‚â§ ‚à•f‚ÇÄ a‚à• + g a : add_le_add_left ha _
exact integrable.mono' (hf‚ÇÄ_i.norm.add hg_i) hf‚ÇÅ_m this
intros
simp [integrable.to_L1, snorm, snorm']
{ simp [integrable.to_L1, snorm, snorm'], simp [edist_eq_coe_nnnorm_sub] }
simp [edist_eq_coe_nnnorm_sub]
intros
{ cases f, simp [mem_‚Ñíp.to_Lp] }
cases f
simp [mem_‚Ñíp.to_Lp]
intros
rw tendsto_iff_dist_tendsto_zero
simp_rw dist_def
rw [‚Üê ennreal.zero_to_real, ennreal.tendsto_to_real_iff (Œª n, _) ennreal.zero_ne_top]
rw snorm_congr_ae (Lp.coe_fn_sub _ _).symm
exact Lp.snorm_ne_top _
intros
suffices h_set_eq : {x : Œ± | f x = g x} = {x | (f-g) x = (0 : E)}
rw h_set_eq
{ rw h_set_eq, exact (hf.sub hg) measurable_set_eq, }
exact (hf.sub hg) measurable_set_eq
ext
simp_rw [set.mem_set_of_eq, pi.sub_apply, sub_eq_zero]
intros
rw [‚Üê f.integral_eq_integral hfi, simple_func.integral, ‚Üê simple_func.integral_eq]
{ rw [‚Üê f.integral_eq_integral hfi, simple_func.integral, ‚Üê simple_func.integral_eq], refl, }
refl
intros
simp [integral, set_to_simple_func, weighted_smul_apply]
intros
rw [integrable_on, measure.restrict_restrict hs]
{ rw [integrable_on, measure.restrict_restrict hs], exact h.mono_set (inter_subset_left _ _) }
exact h.mono_set (inter_subset_left _ _)
intros
cases le_total a b with hab hab
simp only [interval_of_le, min_eq_left, max_eq_right, hab] at hcont hderiv hint
{ simp only [interval_of_le, min_eq_left, max_eq_right, hab] at hcont hderiv hint, apply integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint }
apply integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint
simp only [interval_of_ge, min_eq_right, max_eq_left, hab] at hcont hderiv
{ simp only [interval_of_ge, min_eq_right, max_eq_left, hab] at hcont hderiv, rw [integral_symm, integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint.symm, neg_sub] }
rw [integral_symm, integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint.symm, neg_sub]
intros
simp only [interval_integral, measure.restrict_smul, integral_smul_measure, smul_sub]
intros
rw [‚Üê add_neg_eq_zero, ‚Üê integral_symm, integral_add_adjacent_intervals_cancel hab hbc]
intros
simp
intros
rw [ne.def, ‚Üê measure.measure_univ_eq_zero] at hŒº
refine lintegral_strict_mono_of_ae_le_of_ae_lt_on hf hg hfi (ae_le_of_ae_lt h) hŒº _
simpa using h
intros
ext1 s hs
simp [with_density_apply _ hs]
intros
rw [ennreal_rat_embed, encodable.encodek]; refl
rw [ennreal_rat_embed, encodable.encodek]
refl
intros
let npf := (‚à´‚Åª (c : Œ±), (f c) ^ p ‚àÇŒº) ^ (1/p)
let nqg := (‚à´‚Åª (c : Œ±), (g c) ^ q ‚àÇŒº) ^ (1/q)
calc ‚à´‚Åª (a : Œ±), (f * g) a ‚àÇŒº = ‚à´‚Åª (a : Œ±), ((fun_mul_inv_snorm f p Œº * fun_mul_inv_snorm g q Œº) a) * (npf * nqg) ‚àÇŒº : begin refine lintegral_congr (Œª a, _), rw [pi.mul_apply, fun_eq_fun_mul_inv_snorm_mul_snorm f hf_nonzero hf_nontop, fun_eq_fun_mul_inv_snorm_mul_snorm g hg_nonzero hg_nontop, pi.mul_apply], ring, end ... ‚â§ npf * nqg : begin rw lintegral_mul_const' (npf * nqg) _ (by simp [hf_nontop, hg_nontop, hf_nonzero, hg_nonzero]), nth_rewrite 1 ‚Üêone_mul (npf * nqg), refine mul_le_mul _ (le_refl (npf * nqg)), have hf1 := lintegral_rpow_fun_mul_inv_snorm_eq_one hpq.pos hf hf_nonzero hf_nontop, have hg1 := lintegral_rpow_fun_mul_inv_snorm_eq_one hpq.symm.pos hg hg_nonzero hg_nontop, exact lintegral_mul_le_one_of_lintegral_rpow_eq_one hpq (hf.mul_const _) (hg.mul_const _) hf1 hg1, end
intros
casesI is_empty_or_nonempty Œ±; simp [set_to_simple_func]
casesI is_empty_or_nonempty Œ±
simp [set_to_simple_func]
simp [set_to_simple_func]
intros
rw union_eq_Union
{ rw union_eq_Union, exact measurable_set.Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©) }
exact measurable_set.Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)
intros
rcases index_elim hK' hV with ‚ü®s, h1s, h2s‚ü©
apply nat.Inf_le
rw [mem_image]
refine ‚ü®s, subset.trans h h1s, h2s‚ü©
intros
rintros s t ‚ü®r, r0, hr‚ü©
refine tendsto_nhds_unique_of_eventually_eq (mk_metric'.tendsto_pre _ _) ((mk_metric'.tendsto_pre _ _).add (mk_metric'.tendsto_pre _ _)) _
rw [‚Üê pos_iff_ne_zero] at r0
filter_upwards [Ioo_mem_nhds_within_Ioi ‚ü®le_rfl, r0‚ü©]
rintro Œµ ‚ü®Œµ0, Œµr‚ü©
refine bounded_by_union_of_top_of_nonempty_inter _
rintro u ‚ü®x, hxs, hxu‚ü© ‚ü®y, hyt, hyu‚ü©
have : Œµ < diam u
from Œµr.trans_le ((hr x hxs y hyt).trans $ edist_le_diam_of_mem hxu hyu)
exact infi_eq_top.2 (Œª h, (this.not_le h).elim)
intros
simp only [volume_Icc_pi, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
intros s hs
rcases exists_measurable_superset_of_null hs with ‚ü®t, h1t, h2t, h3t‚ü©
exact measure_mono_null h1t (h h2t h3t)
intros
ext1 t ht
rw [@measure.restrict_apply Œ± m _ _ _ ht, trim_measurable_set_eq hm ht, measure.restrict_apply (hm t ht), trim_measurable_set_eq hm (@measurable_set.inter Œ± m t s ht hs)]
intros
intros t ht
suffices : Œº (t ‚à© s ‚à™ t ‚à© s') ‚â§ Œº (t ‚à© s) + Œº (t ‚à© s')
simpa [ht, inter_union_distrib_left]
simpa [ht, inter_union_distrib_left]
apply measure_union_le
intros
rw [filter.eventually_le, ae_iff]
rw ae_iff at h
refine measure_mono_null (Œª x hx, _) h
exact not_lt.2 (le_of_lt (not_le.1 hx))
intros
simp_rw [Inf_eq_bounded_by_Inf_gen, bounded_by_apply, supr_Inf_gen_nonempty h]
intros
ext i hi
rw [with_density·µ•_apply hfi hi, integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi.integrable_on, vector_measure.sub_apply, to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, with_density_apply _ hi, with_density_apply _ hi]
intros
ext x
cases x; simp [nat.succ_ne_zero]
cases x
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
{ rw bernoulli'_def, norm_num [sum_range_succ] }
rw bernoulli'_def
norm_num [sum_range_succ]
intros
have inj : function.injective (algebra_map R L)
rw is_scalar_tower.algebra_map_eq R S L
{ rw is_scalar_tower.algebra_map_eq R S L, exact (is_integral_closure.algebra_map_injective S R L).comp bS.algebra_map_injective }
exact (is_integral_closure.algebra_map_injective S R L).comp bS.algebra_map_injective
obtain ‚ü®a', b', hb', h‚ü© := is_integral_closure.exists_smul_eq_mul h inj a hb
obtain ‚ü®q, r, hr, hqr‚ü© := exists_mem_finset_approx bS adm a' hb'
refine ‚ü®q, r, hr, _‚ü©
refine lt_of_mul_lt_mul_left _ (show 0 ‚â§ abv (algebra.norm R (algebra_map R S b')), from abv.nonneg _)
refine lt_of_le_of_lt (le_of_eq _) (mul_lt_mul hqr (le_refl _) (abv.pos ((algebra.norm_ne_zero_iff_of_basis bS).mpr hb)) (abv.nonneg _))
rw [‚Üê abv.map_mul, ‚Üê monoid_hom.map_mul, ‚Üê abv.map_mul, ‚Üê monoid_hom.map_mul, ‚Üê algebra.smul_def, smul_sub b', sub_mul, smul_comm, h, mul_comm b a', algebra.smul_mul_assoc r a' b, algebra.smul_mul_assoc b' q b]
intros
rw [divisors_eq_proper_divisors_insert_self_of_pos h.pos, sum_insert proper_divisors.not_self_mem, h.sum_proper_divisors]
intros
rw @padic_val_nat_def _ prime _ nonzero
let one_le_mul : _ ‚â§ multiplicity p n := @multiplicity.le_multiplicity_of_pow_dvd _ _ _ p n 1 (begin norm_num, exact div end)
simp only [nat.cast_one] at one_le_mul
rcases one_le_mul with ‚ü®_, q‚ü©
dsimp at q
solve_by_elim
intros
{ delta pythagorean_triple, rw add_comm }
delta pythagorean_triple
rw add_comm
intros
simpa using zsqrtd.add_le_add_left _ _ h (-c)
intros
rw [disjoint_iff, h.eq_bot_of_le (inf_le_right.trans hle)]
intros
simp only [insert_eq, bdd_above_union, bdd_above_singleton, true_and]
intros
simpa only [inf_comm] using binfi_inf h
intros
rw [supr, range_const, cSup_singleton]
intros
rintros ‚ü®M, hM‚ü©
cases mem_at_top_sets.mp (h $ Ioi_mem_at_top M) with a ha
apply lt_irrefl M
calc M < f a : ha a (le_refl _) ... ‚â§ M : hM (set.mem_range_self a)
intros
simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)
intros
rw [‚Üê h.is_basis.filter_eq_generate, h.filter_eq]
intros
simp only [imp_iff_not_or, eventually_or_distrib_right, not_frequently]
intros
rw [filter.comap_comap, H, ‚Üê filter.comap_comap]
intros
apply le_antisymm
calc map f (F ‚äì comap f G) ‚â§ map f F ‚äì (map f $ comap f G) : map_inf_le ... ‚â§ map f F ‚äì G : inf_le_inf_left (map f F) map_comap_le
{ calc map f (F ‚äì comap f G) ‚â§ map f F ‚äì (map f $ comap f G) : map_inf_le ... ‚â§ map f F ‚äì G : inf_le_inf_left (map f F) map_comap_le }
rintro U ‚ü®V, V_in, W, ‚ü®Z, Z_in, hZ‚ü©, h‚ü©
{ rintro U ‚ü®V, V_in, W, ‚ü®Z, Z_in, hZ‚ü©, h‚ü©, apply mem_inf_of_inter (image_mem_map V_in) Z_in, calc f '' V ‚à© Z = f '' (V ‚à© f ‚Åª¬π' Z) : by rw image_inter_preimage ... ‚äÜ f '' (V ‚à© W) : image_subset _ (inter_subset_inter_right _ ‚Äπ_‚Ä∫) ... = f '' (f ‚Åª¬π' U) : by rw h ... ‚äÜ U : image_preimage_subset f U }
apply mem_inf_of_inter (image_mem_map V_in) Z_in
calc f '' V ‚à© Z = f '' (V ‚à© f ‚Åª¬π' Z) : by rw image_inter_preimage ... ‚äÜ f '' (V ‚à© W) : image_subset _ (inter_subset_inter_right _ ‚Äπ_‚Ä∫) ... = f '' (f ‚Åª¬π' U) : by rw h ... ‚äÜ U : image_preimage_subset f U
intros
simp [Coprod_ne_bot_iff', *]
intros
rw [‚Üê e.bdd_above_image, e.image_preimage]
intros
have := partial_order.ext H
have ss := funext (Œª x, funext $ semilattice_inf.ext_inf H x)
casesI A
casesI B
injection this; congr'
injection this
congr'
intros
intro
intro; rw c.map_id; refl
intro; rw c.map_id
rw c.map_id
refl
intros
simp only [supr, hf.map_cSup (range_nonempty _) hg, ‚Üê range_comp]
intros
rw [(Œî), sup_idem, sdiff_self]
intros
refine le_antisymm (is_wf.min_le _ _ (mem_mul.2 ‚ü®_, _, hs.min_mem _, ht.min_mem _, rfl‚ü©)) _
rw is_wf.le_min_iff
rintros _ ‚ü®x, y, hx, hy, rfl‚ü©
exact mul_le_mul' (hs.min_le _ hx) (ht.min_le _ hy)
intros
intros t1 t2 ht1 ht2
rw set.mem_Union at ht1
cases ht1 with n ht1
exact hyp n t1 t2 ht1 ht2
intros
obtain ‚ü®p, ne_zero, aeval_eq‚ü© := hx
rw [subalgebra.aeval_coe, subalgebra.coe_eq_zero] at aeval_eq
revert ne_zero aeval_eq
refine p.rec_on_horner _ _ _
intro h
{ intro h, contradiction }
contradiction
intros p a hp ha ih ne_zero aeval_eq
{ intros p a hp ha ih ne_zero aeval_eq, refine A.inv_mem_of_root_of_coeff_zero_ne_zero aeval_eq _, rwa [coeff_add, hp, zero_add, coeff_C, if_pos rfl] }
refine A.inv_mem_of_root_of_coeff_zero_ne_zero aeval_eq _
rwa [coeff_add, hp, zero_add, coeff_C, if_pos rfl]
intros p hp ih ne_zero aeval_eq
{ intros p hp ih ne_zero aeval_eq, rw [alg_hom.map_mul, aeval_X, mul_eq_zero] at aeval_eq, cases aeval_eq with aeval_eq x_eq, { exact ih hp aeval_eq }, { rw [x_eq, subalgebra.coe_zero, inv_zero], exact A.zero_mem } }
rw [alg_hom.map_mul, aeval_X, mul_eq_zero] at aeval_eq
cases aeval_eq with aeval_eq x_eq
{ exact ih hp aeval_eq }
exact ih hp aeval_eq
rw [x_eq, subalgebra.coe_zero, inv_zero]
{ rw [x_eq, subalgebra.coe_zero, inv_zero], exact A.zero_mem }
exact A.zero_mem
intros
{ rw is_coprime_comm at H ‚ä¢, exact H.of_mul_left_left }
rw is_coprime_comm at H ‚ä¢
exact H.of_mul_left_left
intros
have : wf_dvd_monoid R := is_noetherian_ring.wf_dvd_monoid
cases wf_dvd_monoid.exists_factors x hx with fx hfx
use fx.card
unfreezingI { use fx.card }
have H := hfx.2
rw ‚Üê associates.mk_eq_mk_iff_associated at H ‚ä¢
rw [‚Üê H, ‚Üê associates.prod_mk, associates.mk_pow, ‚Üê multiset.prod_repeat]
congr' 1
rw multiset.eq_repeat
simp only [true_and, and_imp, multiset.card_map, eq_self_iff_true, multiset.mem_map, exists_imp_distrib]
rintros _ _ _ rfl
rw associates.mk_eq_mk_iff_associated
refine associated_of_irreducible _ _ hirr
apply hfx.1
assumption
intros
convert mul_left_mono I hI
exact (mul_one I).symm
intros
rw [emb_domain_apply, dif_pos (set.mem_range_self a)]
exact congr rfl (f.injective (classical.some_spec (set.mem_range_self a)))
intros
split
intro hg
{ intro hg, obtain ‚ü®ua, hua, ha‚ü© := exists_unit_of_abs a, obtain ‚ü®ub, hub, hb‚ü© := exists_unit_of_abs b, use [(nat.gcd_a (int.nat_abs a) (int.nat_abs b)) * ua, (nat.gcd_b (int.nat_abs a) (int.nat_abs b)) * ub], rw [mul_assoc, ‚Üê ha, mul_assoc, ‚Üê hb, mul_comm, mul_comm _ (int.nat_abs b : ‚Ñ§), ‚Üê nat.gcd_eq_gcd_ab, ‚Üêgcd_eq_nat_abs, hg, int.coe_nat_one] }
obtain ‚ü®ua, hua, ha‚ü© := exists_unit_of_abs a
obtain ‚ü®ub, hub, hb‚ü© := exists_unit_of_abs b
use [(nat.gcd_a (int.nat_abs a) (int.nat_abs b)) * ua, (nat.gcd_b (int.nat_abs a) (int.nat_abs b)) * ub]
rw [mul_assoc, ‚Üê ha, mul_assoc, ‚Üê hb, mul_comm, mul_comm _ (int.nat_abs b : ‚Ñ§), ‚Üê nat.gcd_eq_gcd_ab, ‚Üêgcd_eq_nat_abs, hg, int.coe_nat_one]
rintro ‚ü®r, s, h‚ü©
{ rintro ‚ü®r, s, h‚ü©, by_contradiction hg, obtain ‚ü®p, ‚ü®hp, ha, hb‚ü©‚ü© := nat.prime.not_coprime_iff_dvd.mp hg, apply nat.prime.not_dvd_one hp, rw [‚Üêcoe_nat_dvd, int.coe_nat_one, ‚Üê h], exact dvd_add ((coe_nat_dvd_left.mpr ha).mul_left _) ((coe_nat_dvd_left.mpr hb).mul_left _) }
by_contradiction hg
obtain ‚ü®p, ‚ü®hp, ha, hb‚ü©‚ü© := nat.prime.not_coprime_iff_dvd.mp hg
apply nat.prime.not_dvd_one hp
rw [‚Üêcoe_nat_dvd, int.coe_nat_one, ‚Üê h]
exact dvd_add ((coe_nat_dvd_left.mpr ha).mul_left _) ((coe_nat_dvd_left.mpr hb).mul_left _)
intros
rw ‚Üêmap_comp_map hy hl; refl
rw ‚Üêmap_comp_map hy hl
refl
intros
by_cases H : ‚àÉ (s : finset L), nonempty (basis s K L)
rw [norm_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]
{ rw [norm_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some] }
rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero]
{ rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero], rintros ‚ü®s, ‚ü®b‚ü©‚ü©, exact H ‚ü®s, ‚ü®b‚ü©‚ü© }
rintros ‚ü®s, ‚ü®b‚ü©‚ü©
exact H ‚ü®s, ‚ü®b‚ü©‚ü©
intros
rw U
intros
rw [is_primitive_iff_content_eq_one, content_mul, hp.content_eq_one, hq.content_eq_one, mul_one]
intros
have hdeg := degree_cyclotomic n R
rw degree_eq_nat_degree (cyclotomic_ne_zero n R) at hdeg
exact_mod_cast hdeg
intros
cases n
{ simp, }
simp
{ simp [X_mul, nat.succ_ne_zero, pochhammer_succ_left], }
simp [X_mul, nat.succ_ne_zero, pochhammer_succ_left]
intros
convert pb.constr_pow_aeval hy (C x); rw aeval_C
{ convert pb.constr_pow_aeval hy (C x); rw aeval_C }
convert pb.constr_pow_aeval hy (C x)
rw aeval_C
rw aeval_C
intros
ext
simp only [linear_map.map_neg, coeff_rescale, coeff_X]
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
rw [monomial, finsupp.single_zero, mv_power_series.monomial_zero_eq_C, C]
intros
rcases ((factors_spec a ha).2) with ‚ü®c, hc‚ü©
rw [‚Üê hc]
exact submonoid.mul_mem _ (submonoid.multiset_prod_mem _ _ hfac) (hunit _)
intros
ext x
refine ‚ü®Œª hx, _, Œª hx, closure_mono add_submonoid.subset_closure hx‚ü©
rintros - ‚ü®H, rfl‚ü©
rintros - ‚ü®J, rfl‚ü©
refine (add_submonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.to_add_submonoid (Œª y hy, _)
refine (submonoid.mem_closure.mp hy) H.to_submonoid (Œª z hz, _)
exact (add_submonoid.mem_closure.mp hz) H.to_add_submonoid (Œª w hw, J hw)
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [witt_one, witt_structure_rat, X_in_terms_of_W_zero, alg_hom.map_one, ring_hom.map_one, bind‚ÇÅ_X_right, map_witt_structure_int]
intros
{ ghost_calc x, ghost_simp [mul_comm] }
ghost_calc x
ghost_simp [mul_comm]
intros
witt_truncate_fun_tac
intros
{ rw [X_in_terms_of_W, ‚Üê fin.sum_univ_eq_sum_range] }
rw [X_in_terms_of_W, ‚Üê fin.sum_univ_eq_sum_range]
intros
{ rcases powerlt_aux h with ‚ü®s, rfl‚ü©, apply le_sup _ s }
rcases powerlt_aux h with ‚ü®s, rfl‚ü©
apply le_sup _ s
intros
rw [add_comm, ‚Üê card_ord c, ‚Üê card_one, ‚Üê card_add, one_add_of_omega_le]
rw [add_comm, ‚Üê card_ord c, ‚Üê card_one, ‚Üê card_add, one_add_of_omega_le]; rwa [‚Üê ord_omega, ord_le_ord]
rwa [‚Üê ord_omega, ord_le_ord]
intros
cases n; rw lt_def_le; use ‚ü®punit.star, pgame.le_refl 0‚ü©
cases n; rw lt_def_le
cases n
rw lt_def_le
use ‚ü®punit.star, pgame.le_refl 0‚ü©
rw lt_def_le
use ‚ü®punit.star, pgame.le_refl 0‚ü©
intros
simp [h‚ÇÅ.symm, h‚ÇÇ.symm, term, add_nsmul]; ac_refl
simp [h‚ÇÅ.symm, h‚ÇÇ.symm, term, add_nsmul]
ac_refl
intros
simpa [normalize_fin_lt, ‚Üê e, ‚Üê hm] using h
intros
constructor; intro h1
constructor
intro h1
cases h1 with v h1
{ cases h1 with v h1, cases h1 with h1 h1; [left,right]; refine ‚ü®v,_‚ü©; assumption }
cases h1 with h1 h1
cases h1 with h1 h1; [left,right]; refine ‚ü®v,_‚ü©; assumption
cases h1 with h1 h1; [left,right]; refine ‚ü®v,_‚ü©
cases h1 with h1 h1; [left,right]
left
refine ‚ü®v,_‚ü©
assumption
assumption
right
refine ‚ü®v,_‚ü©
assumption
assumption
intro h1
cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©; [left,right]; assumption
cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©; [left,right]
cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©
cases h1 with h1 h1; cases h1 with v h1
cases h1 with h1 h1
{ cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©; [left,right]; assumption }
cases h1 with v h1
refine ‚ü®v,_‚ü©
left
assumption
assumption
cases h1 with v h1
refine ‚ü®v,_‚ü©
right
assumption
assumption
intros
rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, pow_succ']
intros
simp only [list.apply_id, list.lookup, eq_rec_constant, prod.to_sigma, list.map]
simp only [list.apply_id, list.lookup, eq_rec_constant, prod.to_sigma, list.map]; split_ifs; refl
simp only [list.apply_id, list.lookup, eq_rec_constant, prod.to_sigma, list.map]; split_ifs
split_ifs
refl
refl
intros
simp only [le_nhds_infty, ‚Üê compl_image_coe, ultrafilter.mem_coe, ultrafilter.compl_mem_iff_not_mem]
intros
convert is_closed_closure
intros
have hfg := hf.add hg
ext x
apply completion.induction_on x
exact is_closed_eq ((f+g).continuous_completion hfg) ((f.continuous_completion hf).add (g.continuous_completion hg))
{ exact is_closed_eq ((f+g).continuous_completion hfg) ((f.continuous_completion hf).add (g.continuous_completion hg)) }
intro a
{ intro a, simp [(f+g).completion_coe hfg, coe_add, f.completion_coe hf, g.completion_coe hg] }
simp [(f+g).completion_coe hfg, coe_add, f.completion_coe hf, g.completion_coe hg]
intros
simp_rw ‚Üê nat.sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l)
exact tsum_mul_tsum_eq_tsum_sum_antidiagonal hf hg hfg
intros
rw (has_sum_ite_eq_extract hf.has_sum b).tsum_eq
exact (add_sub_cancel'_right _ _).symm
intros
{ conv in (_ + _) { rw add_comm }, exact hg.add_at_bot hf }
conv in (_ + _) { rw add_comm }
exact hg.add_at_bot hf
intros
apply subset.antisymm
exact closure_minimal Ico_subset_Icc_self is_closed_Icc
{ exact closure_minimal Ico_subset_Icc_self is_closed_Icc }
apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
{ apply subset.trans _ (closure_mono Ioo_subset_Ico_self), rw closure_Ioo hab }
rw closure_Ioo hab
intros
have sne : s.nonempty := @nonempty_of_not_bdd_above Œ± _ s ‚ü®Inf ‚àÖ‚ü© ha
intros x hx
obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := (is_glb_lt_iff (is_glb_cInf sne hb)).1 hx
obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bdd_above_iff.1 ha x
exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
intros
rw [‚Üê nhds_within_union, Iio_union_Ici, nhds_within_univ]
intros
rw [‚Üê mem_compl_eq, ‚Üê interior_compl, mem_interior_iff_mem_nhds, function.compl_support]
rw [‚Üê mem_compl_eq, ‚Üê interior_compl, mem_interior_iff_mem_nhds, function.compl_support]; refl
refl
intros
rw [interior, closure, compl_sUnion, compl_image_set_of]
simp only [compl_subset_compl, is_open_compl_iff]
intros
rwa [cluster_pt, inf_eq_right.mpr H]
intros
{ ext, refl }
ext
refl
intros
intros s hs
rw is_closed_sigma_iff
intro j
classical
by_cases h : i = j
subst j
{ subst j, convert hs, exact set.preimage_image_eq _ sigma_mk_injective }
convert hs
exact set.preimage_image_eq _ sigma_mk_injective
convert is_closed_empty
{ convert is_closed_empty, apply set.eq_empty_of_subset_empty, rintro x ‚ü®y, _, hy‚ü©, have : i = j, by cc, contradiction }
apply set.eq_empty_of_subset_empty
rintro x ‚ü®y, _, hy‚ü©
have : i = j
cc
cc
contradiction
intros
apply polynomial.induction_on' g
{ intros p q hp hq, simp [hp, hq], }
intros p q hp hq
simp [hp, hq]
{ intros n a, simp [pi.pow_apply f x n], }
intros n a
simp [pi.pow_apply f x n]
intros
rw [nhds_within_restrict t h‚ÇÄ h‚ÇÅ, nhds_within_restrict u h‚ÇÄ h‚ÇÅ, h‚ÇÇ]
intros
refine ‚ü®Œª h, _, Œª h, (eventually_nhds_nhds_within.2 h).filter_mono inf_le_left‚ü©
simp only [eventually_nhds_within_iff] at h ‚ä¢
exact h.mono (Œª x hx hxs, (hx hxs).self_of_nhds hxs)
intros
induction a
erw [fiber_eq, fiber_eq]
tidy
intros
rw [h.symm.map_nhds_eq, h.symm_apply_apply]
intros
{ rw ‚Üê tsum_zero, exact tsum_lt_tsum (Œª a, zero_le _) hi hg }
rw ‚Üê tsum_zero
exact tsum_lt_tsum (Œª a, zero_le _) hi hg
intros
cases lt_or_gt_of_ne hc with hneg hpos
exacts [hp.neg.compact_of_continuous' (neg_pos.mpr hneg) hf, hp.compact_of_continuous' hpos hf]
intros
rcases metric.cauchy_seq_iff'.1 hu 1 zero_lt_one with ‚ü®N, hN‚ü©
suffices : ‚àÉ R > 0, ‚àÄ n, dist (u n) (u N) < R
rcases this with ‚ü®R, R0, H‚ü©
{ rcases this with ‚ü®R, R0, H‚ü©, exact ‚ü®_, add_pos R0 R0, Œª m n, lt_of_le_of_lt (dist_triangle_right _ _ _) (add_lt_add (H m) (H n))‚ü© }
exact ‚ü®_, add_pos R0 R0, Œª m n, lt_of_le_of_lt (dist_triangle_right _ _ _) (add_lt_add (H m) (H n))‚ü©
let R := finset.sup (finset.range N) (Œª n, nndist (u n) (u N))
refine ‚ü®‚ÜëR + 1, add_pos_of_nonneg_of_pos R.2 zero_lt_one, Œª n, _‚ü©
cases le_or_lt N n
exact lt_of_lt_of_le (hN _ h) (le_add_of_nonneg_left R.2)
{ exact lt_of_lt_of_le (hN _ h) (le_add_of_nonneg_left R.2) }
have : _ ‚â§ R := finset.le_sup (finset.mem_range.2 h)
{ have : _ ‚â§ R := finset.le_sup (finset.mem_range.2 h), exact lt_of_le_of_lt this (lt_add_of_pos_right _ zero_lt_one) }
exact lt_of_le_of_lt this (lt_add_of_pos_right _ zero_lt_one)
intros
rw sUnion_eq_Union at hc‚ÇÇ; simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc‚ÇÇ
rw sUnion_eq_Union at hc‚ÇÇ
simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc‚ÇÇ
intros
simpa only [dist_comm x] using abs_sub_left_of_mem_interval h
intros
{ rw [iterate_succ'], apply hf.dist_fixed_point_le }
rw [iterate_succ']
apply hf.dist_fixed_point_le
intros
rw [dimH_univ_pi, fintype.card_fin]
intros
rw [‚Üê ennreal.coe_le_coe, ‚Üê edist_nndist, ennreal.coe_mul, ‚Üê ennreal.coe_rpow_of_nonneg _ r.coe_nonneg]
apply hf.edist_le_of_le
rwa [edist_nndist, ennreal.coe_le_coe]
intros
refl
intros
rcases h with ‚ü®Œ≥, Œ≥_in‚ü©
have : Œ≥ 0 ‚àà F ‚àß Œ≥ 1 ‚àà F
split
split
split; apply Œ≥_in
split; apply Œ≥_in
{ split; apply Œ≥_in }
{ split; apply Œ≥_in }
apply Œ≥_in
apply Œ≥_in
apply Œ≥_in
apply Œ≥_in
simpa using this
intros
rw is_open_iff_ball_subset
split
split; intros h x hx
intros h x hx
obtain ‚ü®V, hV, hV'‚ü© := h x hx
{ obtain ‚ü®V, hV, hV'‚ü© := h x hx, exact ‚ü®interior V, interior_mem_uniformity hV, is_open_interior, (ball_mono interior_subset x).trans hV'‚ü©, }
exact ‚ü®interior V, interior_mem_uniformity hV, is_open_interior, (ball_mono interior_subset x).trans hV'‚ü©
intros h x hx
obtain ‚ü®V, hV, -, hV'‚ü© := h x hx
{ obtain ‚ü®V, hV, -, hV'‚ü© := h x hx, exact ‚ü®V, hV, hV'‚ü©, }
exact ‚ü®V, hV, hV'‚ü©
intros
simp [separated_space_iff, id_rel_subset.2 separated_equiv.1, subset.antisymm_iff]
simp [separated_space_iff, id_rel_subset.2 separated_equiv.1, subset.antisymm_iff]; simp [subset_def, separation_rel]
simp [subset_def, separation_rel]
intros
simp [tendsto_locally_uniformly_on, tendsto_locally_uniformly, nhds_within_univ]
intros
rw [mem_Icc, mem_Icc]
split
split ; intro ; split ; linarith
split ; intro ; split
split ; intro
intro
split
linarith
linarith
intro
split
linarith
linarith
intros
cases x; cases x'; simp [show x = x', from funext h]
cases x; cases x'
cases x
cases x'
simp [show x = x', from funext h]
intros
cases a; cases b; exact dec_trivial
cases a; cases b
cases a
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw int.mul_comm
simp [of_nat_mul_neg_of_nat, nat.mul_comm]
intros
have h := int.add_le_add_left h (-b)
rwa int.neg_add_cancel_left at h
intros
by_cases hba : b ‚â§ a
simp [le_antisymm hba h‚ÇÅ]
{ simp [le_antisymm hba h‚ÇÅ] }
by_cases hc0 : c ‚â§ 0
simp [le_antisymm hc0 h‚ÇÇ, int.mul_zero]
{ simp [le_antisymm hc0 h‚ÇÇ, int.mul_zero] }
exact (le_not_le_of_lt (int.mul_lt_mul_of_pos_right (lt_of_le_not_le h‚ÇÅ hba) (lt_of_le_not_le h‚ÇÇ hc0))).left
intros
induction s
{ show length t = 0 + length t, by rw nat.zero_add }
show length t = 0 + length t
rw nat.zero_add
rw nat.zero_add
{ simp [*, nat.add_comm, nat.add_left_comm] }
simp [*, nat.add_comm, nat.add_left_comm]
intros
rw [H2, nat.mul_div_cancel_left _ H1]
intros
{ rw [update_eq_piecewise, prod_piecewise], simp [h] }
rw [update_eq_piecewise, prod_piecewise]
simp [h]
intros
by_cases hm : a ‚àà s
{ simp_rw insert_eq_of_mem hm }
simp_rw insert_eq_of_mem hm
{ rw [prod_insert hm, h hm, one_mul] }
rw [prod_insert hm, h hm, one_mul]
intros
{ simp_rw apply_ite k, exact prod_ite_of_false _ _ h }
simp_rw apply_ite k
exact prod_ite_of_false _ _ h
intros
rw [univ_filter_succ_lt, finset.sum_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
{ rw ‚Üê finprod_mem_one s, exact finprod_mem_congr rfl hf }
rw ‚Üê finprod_mem_one s
exact finprod_mem_congr rfl hf
intros
simp only [finsupp.sum, finset.sum_mul]
intros
convert ‚Üê prod_le_prod h0 h1
exact finset.prod_const_one
intros
{ rw ‚Üêcocone_naturality F f, refl }
rw ‚Üêcocone_naturality F f
refl
intros
rw [eq_comm, ‚Üêsub_eq_zero, ‚Üêint.cast_sub, char_p.int_cast_eq_zero_iff R p, int.modeq_iff_dvd]
intros
simp only [convergents', (convergents'_aux_stable_of_terminated n_le_m terminated_at_n)]
intros
rw [submodule.supr_eq_range_dfinsupp_lsum, linear_map.range_eq_top]
exact function.bijective.surjective h
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
split
intro hxy
{ intro hxy, rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy, apply or_of_or_of_imp_right hxy, intro hy, by_cases hgxy : gcd x y = 0, { rw euclidean_domain.gcd_eq_zero_iff at hgxy, exact hgxy.2 }, { rcases gcd_dvd x y with ‚ü®‚ü®r, hr‚ü©, ‚ü®s, hs‚ü©‚ü©, generalize_hyp : gcd x y = g at hr hs hy hgxy ‚ä¢, subst hs, rw [mul_div_cancel_left _ hgxy] at hy, rw [hy, mul_zero] } }
rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy
apply or_of_or_of_imp_right hxy
intro hy
by_cases hgxy : gcd x y = 0
{ rw euclidean_domain.gcd_eq_zero_iff at hgxy, exact hgxy.2 }
rw euclidean_domain.gcd_eq_zero_iff at hgxy
exact hgxy.2
rcases gcd_dvd x y with ‚ü®‚ü®r, hr‚ü©, ‚ü®s, hs‚ü©‚ü©
{ rcases gcd_dvd x y with ‚ü®‚ü®r, hr‚ü©, ‚ü®s, hs‚ü©‚ü©, generalize_hyp : gcd x y = g at hr hs hy hgxy ‚ä¢, subst hs, rw [mul_div_cancel_left _ hgxy] at hy, rw [hy, mul_zero] }
generalize_hyp : gcd x y = g at hr hs hy hgxy ‚ä¢
subst hs
rw [mul_div_cancel_left _ hgxy] at hy
rw [hy, mul_zero]
rintro (hx | hy)
{ rw [hx, lcm_zero_left] }
rw [hx, lcm_zero_left]
{ rw [hy, lcm_zero_right] }
rw [hy, lcm_zero_right]
intros
{ rw mul_comm at H ‚ä¢, exact dvd_gcd_mul_of_dvd_mul H }
rw mul_comm at H ‚ä¢
exact dvd_gcd_mul_of_dvd_mul H
intros
rw [sub_eq_add_neg, eq_add_neg_iff_add_eq]
intros
rw [‚Üê neg_sub b c, sub_neg_eq_add, add_comm, sub_add_sub_cancel]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
replace h := div_inv_monoid.mk.inj h
dsimp at h
rcases h with ‚ü®rfl, rfl, rfl, rfl, rfl, rfl‚ü©
refl
intros
rw [mul_assoc, inv_mul, mul_one]
intros
rw [units.mul_inv_eq_iff_eq_mul, one_mul, coe_lift_right]
intros
simp
intros
rw [‚Üê mul_one (m : R)]
{ rw [‚Üê mul_one (m : R)], exact (one_right a).cast_int_mul_right m }
exact (one_right a).cast_int_mul_right m
intros
rw [div_eq_mul_inv, mul_self_mul_inv a]
intros
simpa only [one_div] using eq_inv_of_mul_left_eq_one h
intros
rw [div_mul_eq_mul_div, one_mul, div_mul_right _ h]
intros
rcases h‚ÇÅ : c.next j with _ | ‚ü®k,w‚ÇÅ‚ü©
{ rw [d_from_eq_zero _ h‚ÇÅ], simp }
rw [d_from_eq_zero _ h‚ÇÅ]
simp
rw [d_from_eq _ w‚ÇÅ]
{ rw [d_from_eq _ w‚ÇÅ], rcases h‚ÇÇ : c.prev j with _ | ‚ü®i,w‚ÇÇ‚ü©, { rw [d_to_eq_zero _ h‚ÇÇ], simp }, { rw [d_to_eq _ w‚ÇÇ], simp } }
rcases h‚ÇÇ : c.prev j with _ | ‚ü®i,w‚ÇÇ‚ü©
{ rw [d_to_eq_zero _ h‚ÇÇ], simp }
rw [d_to_eq_zero _ h‚ÇÇ]
simp
{ rw [d_to_eq _ w‚ÇÇ], simp }
rw [d_to_eq _ w‚ÇÇ]
simp
intros
dsimp [d_next]
rw c.next_eq_some w
refl
intros
{ dunfold indicator, split_ifs, exacts [rfl, (smul_zero r).symm] }
dunfold indicator
split_ifs
exacts [rfl, (smul_zero r).symm]
intros
split
split; intros h
intros h
erw [eq_bot_iff, lie_submodule.lie_span_le]
{ erw [eq_bot_iff, lie_submodule.lie_span_le], rintros m ‚ü®x, n, hn‚ü©, rw [‚Üê hn, h.trivial], simp,}
rintros m ‚ü®x, n, hn‚ü©
rw [‚Üê hn, h.trivial]
simp
intros h
rw lie_submodule.eq_bot_iff at h
{ rw lie_submodule.eq_bot_iff at h, apply is_trivial.mk, intros x m, apply h, apply lie_submodule.subset_lie_span, use [x, m], refl, }
apply is_trivial.mk
intros x m
apply h
apply lie_submodule.subset_lie_span
use [x, m]
refl
intros
{ rw map_le, exact set.image_subset_iff, }
rw map_le
exact set.image_subset_iff
intros
{ cases N, cases N', simp only [], ext m, exact h m, }
cases N
cases N'
simp only []
ext m
exact h m
intros
simp [pre_weight_space, -linear_map.pow_apply]
intros
simp only [‚Üênsmul_eq_smul_cast, f.map_nsmul]
intros
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_le_neg_iff]
exact smul_le_smul_of_nonneg h (neg_nonneg_of_nonpos hc)
intros
rw [lift_def, lift_nc_single, algebra.smul_def, ring_hom.coe_add_monoid_hom]
intros
rw [mul_comm, div_le_iff hb]
intros
rw [inv_mul_le_iff_le_mul, mul_comm]
intros
simpa only [div_eq_mul_inv] using min_mul_mul_right a b (c‚Åª¬π)
intros
cases le_total a b with hb hb
{ simp [hb, le_mul_right] }
simp [hb, le_mul_right]
cases le_total a c with hc hc
{ cases le_total a c with hc hc, { simp [hc, le_mul_left] }, { simp [hb, hc] } }
{ simp [hc, le_mul_left] }
simp [hc, le_mul_left]
{ simp [hb, hc] }
simp [hb, hc]
intros
haveI := @linear_order.decidable_le Œ± _
refine decidable.or_iff_not_and_not.2 _
simp only [not_and, not_le]
intros ab nab
apply not_lt_of_le hab _
rcases lt_trichotomy 0 a with (ha|rfl|ha)
exacts [mul_neg_of_pos_of_neg ha (ab ha.le), ((ab le_rfl).asymm (nab le_rfl)).elim, mul_neg_of_neg_of_pos ha (nab ha.le)]
intros
haveI := @linear_order.decidable_le Œ± _; exact Œª x y h, decidable.mul_lt_mul'' (hf h) (hg h) (hf0 x) (hg0 x)
haveI := @linear_order.decidable_le Œ± _
exact Œª x y h, decidable.mul_lt_mul'' (hf h) (hg h) (hf0 x) (hg0 x)
intros
simpa only [sub_eq_add_neg, periodic] using h.sub_eq
intros
simp only [mem_inv, inv_inv]
intros
simp [bit1]
intros
simp [bit0]
intros
intros r
rw [submodule.mem_sup, mem_vanishing_ideal]
rintro ‚ü®f, hf, g, hg, rfl‚ü© x ‚ü®hxt, hxt'‚ü©
rw mem_vanishing_ideal at hf hg
apply submodule.add_mem; solve_by_elim
apply submodule.add_mem
solve_by_elim
solve_by_elim
intros
rcases hf with ‚ü®r, s, h‚ü©
refine ‚ü®r, s, Œª x, ‚ü®(h x).1, (is_localization.mk'_eq_iff_eq_mul.mpr _).symm‚ü©‚ü©
exact (h x).2.symm
intros
{ rw comap_id U U rfl, refl }
rw comap_id U U rfl
refl
intros
continuity
intros
obtain ‚ü®c, hc‚ü© := is_O_iff.mp h
refine ‚ü®max c 0, eventually_map.2 (filter.mem_of_superset hc (Œª x hx, _))‚ü©
simp only [mem_set_of_eq, normed_field.norm_div] at ‚ä¢ hx
by_cases hgx : g x = 0
rw [hgx, norm_zero, div_zero, le_max_iff]
{ rw [hgx, norm_zero, div_zero, le_max_iff], exact or.inr le_rfl }
exact or.inr le_rfl
exact le_max_iff.2 (or.inl ((div_le_iff (norm_pos_iff.2 hgx)).2 hx))
{ exact le_max_iff.2 (or.inl ((div_le_iff (norm_pos_iff.2 hgx)).2 hx)) }
intros
unfold is_o
{ unfold is_o, exact forall_congr (Œª _, forall_congr $ Œª _, is_O_with_norm_left) }
exact forall_congr (Œª _, forall_congr $ Œª _, is_O_with_norm_left)
intros
unfold is_o at *
intros c cpos
rcases h‚ÇÅ.exists_pos with ‚ü®c', c'pos, hc'‚ü©
exact (hc'.mul (h‚ÇÇ (div_pos cpos c'pos))).congr_const (mul_div_cancel' _ (ne_of_gt c'pos))
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hc.mul hd
intros
intro hg
have := (hf.comp a hg.has_deriv_within_at hst).congr_of_eventually_eq_of_mem hfg.symm ha
simpa using hsu.eq_deriv _ this (has_deriv_within_at_id _ _)
intros
simpa using (hf.add hg).has_strict_deriv_at
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact has_fderiv_within_at.comp x (hg.has_fderiv_within_at) (hf.has_fderiv_within_at) h
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
{ convert hc.mul_const' d, ext z, apply mul_comm }
convert hc.mul_const' d
ext z
apply mul_comm
intros
rwa [‚Üê univ_inter s, has_fderiv_within_at_inter hs, has_fderiv_within_at_univ] at h
intros
refine ((hf.implicit_to_local_homeomorph f f' hf').tendsto_symm (hf.mem_implicit_to_local_homeomorph_source hf')).comp _
rw [implicit_to_local_homeomorph_self]
exact h‚ÇÅ.prod_mk_nhds h‚ÇÇ
intros
{ ext x, simp [iterated_deriv] }
ext x
simp [iterated_deriv]
intros
have hdg : ‚àÄ·∂† x in at_bot, differentiable_at ‚Ñù g x
from hg'.mp (eventually_of_forall $ Œª _ hg', classical.by_contradiction (Œª h, hg' (deriv_zero_of_not_differentiable_at h)))
have hdf' : ‚àÄ·∂† x in at_bot, has_deriv_at f (deriv f x) x
from hdf.mp (eventually_of_forall $ Œª _, differentiable_at.has_deriv_at)
have hdg' : ‚àÄ·∂† x in at_bot, has_deriv_at g (deriv g x) x
from hdg.mp (eventually_of_forall $ Œª _, differentiable_at.has_deriv_at)
exact has_deriv_at.lhopital_zero_at_bot hdf' hdg' hg' hfbot hgbot hdiv
intros
rw [euclidean.ball_eq_preimage, ‚Üê f.to_times_cont_diff_bump_of_inner.support_eq, ‚Üê support_comp_eq_preimage, coe_eq_comp]
intros
simp [‚Üê times_cont_diff_within_at_univ, times_cont_diff_within_at_top]
intros
refine ‚ü®Œª H, _, Œª H, H.comp_continuous_linear_map _‚ü©
have A : f = (f ‚àò e) ‚àò e.symm
ext y
ext y
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
simp only [function.comp_app]
simp only [function.comp_app]
rw e.apply_symm_apply y
rw e.apply_symm_apply y
have B : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s
rw [‚Üê preimage_comp, e.self_comp_symm]
rw [‚Üê preimage_comp, e.self_comp_symm]
{ rw [‚Üê preimage_comp, e.self_comp_symm], refl }
{ rw [‚Üê preimage_comp, e.self_comp_symm], refl }
refl
refl
rw [A, ‚Üê B]
exact H.comp_continuous_linear_map _
intros
rcases p
exact times_cont_diff_at.prod_map hf hg
intros
assume x xs
rcases h x xs with ‚ü®u, u_open, xu, hu‚ü©
apply (times_cont_diff_within_at_inter _).1 (hu x ‚ü®xs, xu‚ü©)
exact is_open.mem_nhds u_open xu
intros
apply set.subset.antisymm
rw set.image_subset_iff
{ rw set.image_subset_iff, refine convex_hull_min _ ((convex_convex_hull ùïú (‚áëf '' s)).affine_preimage f), rw ‚Üê set.image_subset_iff, exact subset_convex_hull ùïú (f '' s) }
refine convex_hull_min _ ((convex_convex_hull ùïú (‚áëf '' s)).affine_preimage f)
rw ‚Üê set.image_subset_iff
exact subset_convex_hull ùïú (f '' s)
exact convex_hull_min (set.image_subset _ (subset_convex_hull ùïú s)) ((convex_convex_hull ùïú s).affine_image f)
{ exact convex_hull_min (set.image_subset _ (subset_convex_hull ùïú s)) ((convex_convex_hull ùïú s).affine_image f) }
intros
finish
intros
rw [‚Üêne_empty_iff_nonempty, ‚Üêne_empty_iff_nonempty, ne.def, ne.def]
exact not_congr convex_hull_empty_iff
intros
rintro x hx
obtain ‚ü®_, rfl‚ü© := hAB ‚ü®x, hx‚ü©
exact hx.1
intros
refine Œª i j hij, hc {j} i _
rw [hij, set.image_singleton, convex_hull_singleton]
exact set.mem_singleton _
intros
conv_rhs { rw [‚Üêinner_self_re_to_K] }
symmetry
exact is_R_or_C.abs_of_nonneg inner_self_nonneg
intros
have : ‚à•v i‚à• ‚â† 0
rw hv.1 i
{ rw hv.1 i, norm_num }
norm_num
simpa using this
intros
ext
{ ext, apply eq_orthogonal_projection_of_mem_of_inner_eq_zero; simp }
apply eq_orthogonal_projection_of_mem_of_inner_eq_zero
apply eq_orthogonal_projection_of_mem_of_inner_eq_zero; simp
simp
simp
intros
obtain ‚ü®u, hus, hu, hu_max‚ü© := exists_maximal_orthonormal hv
obtain ‚ü®b, hb‚ü© := (maximal_orthonormal_iff_basis_of_finite_dimensional hu).mp hu_max
exact ‚ü®u, hus, b, by rwa hb, hb‚ü©
intros
rw [dist_eq_norm_vsub V‚ÇÇ, dist_eq_norm_vsub V, ‚Üê map_vsub, f.linear_isometry.norm_map]
intros
rcases s with ‚ü®‚ü®l‚ü©, hl‚ü©
have : l.map f ‚â† []
simpa using hs
simpa using hs
simpa using list.norm_prod_le' this
intros
simpa [real.nnnorm_of_nonneg (norm_nonneg a)]
intros
rw [mem_closed_ball_iff_norm, add_sub_cancel']
intros
simpa only [pi.sub_apply, add_sub_cancel'_right] using hf.add_lipschitz_with hg hK
intros
refine (linear_map.snd ùïú E F).is_linear.with_bound 1 (Œª x, _)
rw one_mul
exact le_max_right _ _
intros
rw subsingleton_iff at h
have minor : (f' : M ‚Üí N) = function.const M 0 := by ext x'; rw h x' 0; exact f'.map_zero
have key : ‚àÄ (x' : M), ‚à•(0 : M ‚Üí‚Çó[R] N) x'‚à• = ‚à•x'‚à• := Œª x', by { rw [linear_map.zero_apply, h x' 0], repeat { rw norm_zero }, }
exact ‚ü®(1 : R), one_ne_zero, ‚ü®0, key‚ü©, by { rw pi.smul_def, ext p, rw [one_smul, minor], refl, }‚ü©
intros
rcases exists_extension_of_le_sublinear ‚ü®p, f‚ü© (Œª x, ‚à•f‚à• * ‚à•x‚à•) (Œª c hc x, by simp only [norm_smul c x, real.norm_eq_abs, abs_of_pos hc, mul_left_comm]) (Œª x y, _) (Œª x, le_trans (le_abs_self _) (f.le_op_norm _)) with ‚ü®g, g_eq, g_le‚ü©
set g' := g.mk_continuous (‚à•f‚à•) (Œª x, abs_le.2 ‚ü®neg_le.1 $ g.map_neg x ‚ñ∏ norm_neg x ‚ñ∏ g_le (-x), g_le x‚ü©)
refine ‚ü®g', g_eq, _‚ü©
{ refine ‚ü®g', g_eq, _‚ü©, { apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _), refine f.op_norm_le_bound (norm_nonneg _) (Œª x, _), dsimp at g_eq, rw ‚Üê g_eq, apply g'.le_op_norm } }
apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _)
{ apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _), refine f.op_norm_le_bound (norm_nonneg _) (Œª x, _), dsimp at g_eq, rw ‚Üê g_eq, apply g'.le_op_norm }
refine f.op_norm_le_bound (norm_nonneg _) (Œª x, _)
dsimp at g_eq
rw ‚Üê g_eq
apply g'.le_op_norm
simp only [‚Üê mul_add]
{ simp only [‚Üê mul_add], exact mul_le_mul_of_nonneg_left (norm_add_le x y) (norm_nonneg f) }
exact mul_le_mul_of_nonneg_left (norm_add_le x y) (norm_nonneg f)
intros
{ ext, refl }
ext
refl
intros
use 0
rintro _ ‚ü®x, hx, rfl‚ü©
apply norm_nonneg
intros
simp only [mul_comm, integral_const_mul]
intros
convert h.smul c
intros
refine nnreal.eq _
push_cast
exact real.sqrt_eq_rpow x.1
intros
convert (@complex.has_fderiv_at_cpow ((Œª x, (f x, g x)) x) h0).comp_has_fderiv_within_at x (hf.prod hg)
intros
rw [‚Üêreal.log_le_log hx (real.rpow_pos_of_pos hy z), real.log_rpow hy]
intros
rw [arctan_eq_arcsin, div_pow, sq_sqrt, one_add_div, div_div_eq_div_mul, ‚Üê sqrt_mul, mul_div_cancel', sub_add_cancel, sqrt_one, div_one]
rw [arctan_eq_arcsin, div_pow, sq_sqrt, one_add_div, div_div_eq_div_mul, ‚Üê sqrt_mul, mul_div_cancel', sub_add_cancel, sqrt_one, div_one]; nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
intros
simp [sub_eq_add_neg, cos_add]
{ convert continuous_sin.continuous_within_at, simp }
convert continuous_sin.continuous_within_at
simp
linarith [pi_pos]
intros
rw [‚Üê neg_le_neg_iff, ‚Üê arcsin_neg, arcsin_le_iff_le_sin' ‚ü®neg_le_neg hx.2, neg_lt.2 hx.1‚ü©, sin_neg, neg_le_neg_iff]
intros
have A : summable (Œª n, n * r ^ n : ‚Ñï ‚Üí ùïú)
simpa using summable_pow_mul_geometric_of_norm_lt_1 1 hr
simpa using summable_pow_mul_geometric_of_norm_lt_1 1 hr
have B : has_sum (pow r : ‚Ñï ‚Üí ùïú) (1 - r)‚Åª¬π
from has_sum_geometric_of_norm_lt_1 hr
refine A.has_sum_iff.2 _
have hr' : r ‚â† 1
rintro rfl
rintro rfl
{ rintro rfl, simpa [lt_irrefl] using hr }
{ rintro rfl, simpa [lt_irrefl] using hr }
simpa [lt_irrefl] using hr
simpa [lt_irrefl] using hr
set s : ùïú := ‚àë' n : ‚Ñï, n * r ^ n
calc s = (1 - r) * s / (1 - r) : (mul_div_cancel_left _ (sub_ne_zero.2 hr'.symm)).symm ... = (s - r * s) / (1 - r) : by rw [sub_mul, one_mul] ... = ((0 : ‚Ñï) * r ^ 0 + (‚àë' n : ‚Ñï, (n + 1) * r ^ (n + 1)) - r * s) / (1 - r) : by { congr, exact tsum_eq_zero_add A } ... = (r * (‚àë' n : ‚Ñï, (n + 1) * r ^ n) - r * s) / (1 - r) : by simp [pow_succ, mul_left_comm _ r, tsum_mul_left] ... = r / (1 - r) ^ 2 : by simp [add_mul, tsum_add A B.summable, mul_add, B.tsum_eq, ‚Üê div_eq_mul_inv, sq, div_div_eq_div_mul]
intros
{ rw exact_iff, tidy }
rw exact_iff
tidy
intros
{ ext, dsimp [transfer_nat_trans_self, transfer_nat_trans], simp }
ext
dsimp [transfer_nat_trans_self, transfer_nat_trans]
simp
intros
erw [‚Üêiso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp]
{ erw [‚Üêiso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp], refl }
refl
intros
simp [essentially_small_iff, category_theory.locally_small_of_thin]
intros
tidy
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
have := pullback_cone.is_limit_mk_id_id (F.map f)
simp_rw [‚ÜêF.map_id] at this
apply pullback_cone.mono_of_is_limit_mk_id_id _ (is_limit_of_is_limit_pullback_cone_map F _ this)
intros
{ erw is_colimit.fac, refl, }
erw is_colimit.fac
refl
intros
rw ‚Üêcocone_of_hom_of_cocone h s
conv_lhs { simp only [hom_of_cocone_of_hom] }
apply (cocone_of_hom_fac _ _).symm
intros
simp
intros
apply biprod.hom_ext; apply biprod.hom_ext'; simp
apply biprod.hom_ext; apply biprod.hom_ext'
apply biprod.hom_ext
apply biprod.hom_ext'
simp
simp
apply biprod.hom_ext'
simp
simp
intros
ext j
simp [comp_sum, biproduct.Œπ_œÄ_assoc, dite_comp]
intros
apply limit.w (wide_pullback_shape.wide_cospan _ _ _) (wide_pullback_shape.hom.term j)
intros
ext x
change (F'.e ‚â´ F'.m) _ = _
rw [F'.fac, (classical.indefinite_description _ x.2).2]
refl
intros
simp
intros
rw [‚Üêtensor_left_iff, id_tensor_comp, ‚Üêcancel_epi (Œ±_ (ùüô_ C) (ùüô_ C ‚äó X) Y).hom, ‚Üêcancel_epi ((Œ±_ (ùüô_ C) (ùüô_ C) X).hom ‚äó ùüô Y), pentagon_assoc, triangle, ‚Üêassociator_naturality, ‚Üêcomp_tensor_id_assoc, triangle, associator_naturality, tensor_id]
intros
dunfold left_adjoint_mate
rw [category.assoc, category.assoc, associator_naturality_assoc, associator_naturality_assoc, ‚Üêid_tensor_comp_tensor_id _ g, category.assoc, category.assoc, category.assoc, category.assoc, tensor_id_comp_id_tensor_assoc, ‚Üêright_unitor_naturality, id_tensor_comp_tensor_id_assoc]
intros
apply zero_of_target_iso_zero
dsimp
refl
intros
rw [‚Üêfunctor.map_comp, prod_comp, category.id_comp, category.comp_id]
intros
split
intros hP
{ intros hP, refine presieve.is_sheaf_iso J _ (hP punit), exact iso_whisker_left _ coyoneda.punit_iso ‚â™‚â´ P.right_unitor }
refine presieve.is_sheaf_iso J _ (hP punit)
exact iso_whisker_left _ coyoneda.punit_iso ‚â™‚â´ P.right_unitor
{ intros hP X Y S hS z hz, refine ‚ü®Œª x, (hP S hS).amalgamate (Œª Z f hf, z f hf x) _, _, _‚ü©, { intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ h, exact congr_fun (hz g‚ÇÅ g‚ÇÇ hf‚ÇÅ hf‚ÇÇ h) x }, { intros Z f hf, ext x, apply presieve.is_sheaf_for.valid_glue }, { intros y hy, ext x, apply (hP S hS).is_separated_for.ext, intros Y' f hf, rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ‚Üê hy _ hf], refl } }
intros hP X Y S hS z hz
refine ‚ü®Œª x, (hP S hS).amalgamate (Œª Z f hf, z f hf x) _, _, _‚ü©
intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ h
{ intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ h, exact congr_fun (hz g‚ÇÅ g‚ÇÇ hf‚ÇÅ hf‚ÇÇ h) x }
exact congr_fun (hz g‚ÇÅ g‚ÇÇ hf‚ÇÅ hf‚ÇÇ h) x
intros Z f hf
{ intros Z f hf, ext x, apply presieve.is_sheaf_for.valid_glue }
ext x
apply presieve.is_sheaf_for.valid_glue
{ intros y hy, ext x, apply (hP S hS).is_separated_for.ext, intros Y' f hf, rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ‚Üê hy _ hf], refl }
intros y hy
ext x
apply (hP S hS).is_separated_for.ext
intros Y' f hf
rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ‚Üê hy _ hf]
refl
intros
rw presieve.pullback_compatible_iff
split
intro t
{ intro t, ext ‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©, simpa [first_map, second_map] using t hf hg }
ext ‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©
simpa [first_map, second_map] using t hf hg
intros t Y Z f g hf hg
{ intros t Y Z f g hf hg, rw types.limit_ext_iff at t, simpa [first_map, second_map] using t ‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü© }
rw types.limit_ext_iff at t
simpa [first_map, second_map] using t ‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©
intros
simp_rw [eval, ‚Üê functor_to_types.map_comp_apply, ‚Üê op_comp]
{ simp_rw [eval, ‚Üê functor_to_types.map_comp_apply, ‚Üê op_comp], refl }
refl
intros
{ rw eq_mk h, simp, }
rw eq_mk h
simp
intros
fsplit
intro w
{ intro w, replace w := w =‚â´ P.arrow, simpa using w, }
replace w := w =‚â´ P.arrow
simpa using w
rintro rfl
{ rintro rfl, ext, simp, }
ext
simp
intros
rcases A.eq_empty_or_nonempty with rfl | hA
{ simp }
simp
{ apply (empty_to_colex_lt hA).le }
apply (empty_to_colex_lt hA).le
intros
cases hn
{ cases hn, rw ‚Üê composition.ext_iff at hc, cases hc, congr, rwa fin.ext_iff }
rw ‚Üê composition.ext_iff at hc
cases hc
congr
rwa fin.ext_iff
intros
simp [composition.to_composition_as_set, composition_as_set.length, c.card_boundaries_eq_succ_length]
intros
rw [‚Üê dot_product_adj_matrix, vec_mul]
refine congr rfl _
ext
rw [‚Üê transpose_apply (adj_matrix Œ± G) x v, transpose_adj_matrix]
intros
rw fintype.card_congr (G.incidence_set_equiv_neighbor_set v)
{ rw fintype.card_congr (G.incidence_set_equiv_neighbor_set v), simp }
simp
intros
induction pf
case nat.partrec'.prim : n f hf { exact hf.to_prim.to_comp }
case nat.partrec'.comp : m n f g _ _ hf hg { exact (vector_m_of_fn (Œª i, hg i)).bind (hf.comp snd) }
case nat.partrec'.rfind : n f _ hf { have := ((primrec.eq.comp primrec.id (primrec.const 0)).to_comp.comp (hf.comp (vector_cons.comp snd fst))).to‚ÇÇ.partrec‚ÇÇ, exact this.rfind }
intros
let : primcodable {a//id a<n}
swap
exactI (iff.trans (by refl) subtype_val_iff).trans (of_equiv_iff _)
intros
rcases h‚ÇÅ with ‚ü®f, c, hf‚ü©
rw [show p = Œª a, q (f a), from set.ext hf]
rcases computable_iff.1 h‚ÇÇ with ‚ü®g, hg, rfl‚ü©
exact ‚ü®by apply_instance, by simpa using hg.comp c‚ü©
intros
cases n; simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]
cases n
simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]
simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]
congr
symmetry
apply list_blank.map_modify_nth
intro
refl
intros
cases T; simp [tape.move]
cases T
simp [tape.move]
intros
simp only [equiv.traverse] with functor_norm
intros
simp [sequence, naturality, traverse_map]
intros
cases F
cases F; refl
refl
intros
simp [seq_eq_bind_map]
intros
simp only [one_of', one_of_eq_done, eps_eq_done, and.comm, and_then_eq_bind, bind_eq_done, exists_eq_left, exists_and_distrib_left]
split
rintro ‚ü®c, hc, rfl, hn, rfl‚ü©
{ rintro ‚ü®c, hc, rfl, hn, rfl‚ü©, exact ‚ü®rfl, hn, hc‚ü© }
exact ‚ü®rfl, hn, hc‚ü©
rintro ‚ü®rfl, hn, hc‚ü©
{ rintro ‚ü®rfl, hn, hc‚ü©, exact ‚ü®cb.read ‚ü®n, hn‚ü©, hc, rfl, hn, rfl‚ü© }
exact ‚ü®cb.read ‚ü®n, hn‚ü©, hc, rfl, hn, rfl‚ü©
intros
simp [fix_core]
intros
rw [‚Üê of_real_nat_cast, of_real_im]
intros
rw [lim_eq_lim_im_add_lim_re]; simp
rw [lim_eq_lim_im_add_lim_re]
simp
intros
simpa using h
intros
rw ‚Üê cosh_mul_I; ring_nf; simp
rw ‚Üê cosh_mul_I; ring_nf
rw ‚Üê cosh_mul_I
ring_nf
simp
intros
rw [two_mul, sin_add, two_mul, add_mul, mul_comm]
intros
rw [‚Üê of_real_rat_cast, of_real_im]
intros
classical
rw dfinsupp.sum_add_hom_apply
convert S.dfinsupp_sum_mem _ _ _
exact h
intros
dsimp only [single]
by_cases h : i = i'
have h1 : i' ‚àà ({i} : finset Œπ) := finset.mem_singleton.2 h.symm
{ have h1 : i' ‚àà ({i} : finset Œπ) := finset.mem_singleton.2 h.symm, simp only [mk_apply, dif_pos h, dif_pos h1], refl }
simp only [mk_apply, dif_pos h, dif_pos h1]
refl
have h1 : i' ‚àâ ({i} : finset Œπ) := finset.not_mem_singleton.2 (ne.symm h)
{ have h1 : i' ‚àâ ({i} : finset Œπ) := finset.not_mem_singleton.2 (ne.symm h), simp only [mk_apply, dif_neg h, dif_neg h1] }
simp only [mk_apply, dif_neg h, dif_neg h1]
intros
{ ext ‚ü®a, b‚ü© : 1, simp }
ext ‚ü®a, b‚ü© : 1
simp
intros
cases x with x hx; exact set.sum_compl_symm_apply_of_not_mem hx
cases x with x hx
exact set.sum_compl_symm_apply_of_not_mem hx
intros
conv_rhs { rw equiv.swap_apply_def }
split_ifs with h‚ÇÅ h‚ÇÇ
{ rw [hf h‚ÇÅ, equiv.swap_apply_left] }
rw [hf h‚ÇÅ, equiv.swap_apply_left]
{ rw [hf h‚ÇÇ, equiv.swap_apply_right] }
rw [hf h‚ÇÇ, equiv.swap_apply_right]
rw [equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h‚ÇÅ) (mt (congr_arg f) h‚ÇÇ)]
{ rw [equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h‚ÇÅ) (mt (congr_arg f) h‚ÇÇ)] }
intros
{ ext1 x, cases x, refl }
ext1 x
cases x
refl
intros
convert (e ‚ü®x, hx‚ü©).2
{ convert (e ‚ü®x, hx‚ü©).2, rw [e.extend_subtype_apply_of_mem _ hx, subtype.val_eq_coe] }
rw [e.extend_subtype_apply_of_mem _ hx, subtype.val_eq_coe]
intros
cases a; refl
cases a
refl
intros
simpa [lt_iff_coe_lt_coe, le_iff_coe_le_coe] using nat.succ_le_succ_iff.symm
intros
rw [‚Üêcoe_ssubset, coe_singleton, set.ssubset_singleton_iff, coe_eq_empty]
intros
simp [max']
intros
induction s using quotient.induction_on with s
simp only [quot_mk_to_coe, cons_coe, noncomm_prod_coe, list.prod_cons]
induction s with hd tl IH
{ simp }
simp
rw [list.prod_cons, mul_assoc, ‚ÜêIH, ‚Üêmul_assoc, ‚Üêmul_assoc]
{ rw [list.prod_cons, mul_assoc, ‚ÜêIH, ‚Üêmul_assoc, ‚Üêmul_assoc], { congr' 1, apply comm; simp }, { intros x hx y hy, simp only [quot_mk_to_coe, list.mem_cons_iff, mem_coe, cons_coe] at hx hy, apply comm, { cases hx; simp [hx] }, { cases hy; simp [hy] } } }
congr' 1
{ congr' 1, apply comm; simp }
apply comm; simp
apply comm
simp
simp
intros x hx y hy
{ intros x hx y hy, simp only [quot_mk_to_coe, list.mem_cons_iff, mem_coe, cons_coe] at hx hy, apply comm, { cases hx; simp [hx] }, { cases hy; simp [hy] } }
simp only [quot_mk_to_coe, list.mem_cons_iff, mem_coe, cons_coe] at hx hy
apply comm
cases hx; simp [hx]
cases hx
{ cases hx; simp [hx] }
simp [hx]
simp [hx]
cases hy; simp [hy]
cases hy
{ cases hy; simp [hy] }
simp [hy]
simp [hy]
intros
have : i ‚àà (single i b).support := by simpa using h
intro H
simpa [H]
intros
simp [finset.subset_iff, set.subset_def]
intros
convert prod_take_of_fn f n
{ rw [take_all_of_le (le_of_eq (length_of_fn f))] }
rw [take_all_of_le (le_of_eq (length_of_fn f))]
have : ‚àÄ (j : fin n), (j : ‚Ñï) < n := Œª j, j.is_lt
{ have : ‚àÄ (j : fin n), (j : ‚Ñï) < n := Œª j, j.is_lt, simp [this] }
simp [this]
intros
rw [‚Üê abs_lt_iff_mul_self_lt, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_lt.symm
intros
rw [add_comm, add_comm i, mod_add_cancel_right]
intros
unfold bit0
{unfold bit0, simp}
simp
intros
simp [gcd]
intros
unfold gcd_a xgcd
induction s
{ exact absurd rfl h, }
exact absurd rfl h
{ simp [xgcd_aux], }
simp [xgcd_aux]
intros
convert dif_pos _ using 1
convert coe_least_of_bdd_eq _ (classical.some_spec (‚ü®b, Hb‚ü© : bdd_below s)) _
{ convert coe_least_of_bdd_eq _ (classical.some_spec (‚ü®b, Hb‚ü© : bdd_below s)) _ }
{ exact ‚ü®Hinh, b, Hb‚ü©, }
exact ‚ü®Hinh, b, Hb‚ü©
rw even_iff; norm_num
rw even_iff
norm_num
intros
induction n with n IH generalizing k l
{ simpa using hn }
simpa using hn
cases l with hd tl
{ cases l with hd tl, { simp }, { cases k, { simp }, { rw nat.succ_lt_succ_iff at hn, simpa using IH _ _ hn _ } } }
{ simp }
simp
cases k
{ cases k, { simp }, { rw nat.succ_lt_succ_iff at hn, simpa using IH _ _ hn _ } }
{ simp }
simp
rw nat.succ_lt_succ_iff at hn
{ rw nat.succ_lt_succ_iff at hn, simpa using IH _ _ hn _ }
simpa using IH _ _ hn _
intros
induction l with hd tl hl generalizing n
{ simp only [option.to_list, nth, take_nil, append_nil]}
simp only [option.to_list, nth, take_nil, append_nil]
cases n
{ cases n, { simp only [option.to_list, nth, eq_self_iff_true, and_self, take, nil_append] }, { simp only [hl, cons_append, nth, eq_self_iff_true, and_self, take] } }
simp only [option.to_list, nth, eq_self_iff_true, and_self, take, nil_append]
{ simp only [option.to_list, nth, eq_self_iff_true, and_self, take, nil_append] }
{ simp only [hl, cons_append, nth, eq_self_iff_true, and_self, take] }
simp only [hl, cons_append, nth, eq_self_iff_true, and_self, take]
intros
induction l; [refl, simp only [*, reverse_cons, foldl_append, foldl_cons, foldl_nil, foldr]]
induction l
refl
simp only [*, reverse_cons, foldl_append, foldl_cons, foldl_nil, foldr]
intros
induction n; [refl, simp only [*, repeat_succ, sum_cons, nat.mul_succ, add_comm]]
induction n
refl
simp only [*, repeat_succ, sum_cons, nat.mul_succ, add_comm]
intros
induction l with h t ih; cases hx
induction l with h t ih
cases hx
cases hx
rw hx
{ rw hx, exact lt_add_of_lt_of_nonneg (lt_one_add _) (nat.zero_le _) }
exact lt_add_of_lt_of_nonneg (lt_one_add _) (nat.zero_le _)
exact lt_add_of_pos_of_le (zero_lt_one_add _) (le_of_lt (ih hx))
{ exact lt_add_of_pos_of_le (zero_lt_one_add _) (le_of_lt (ih hx)) }
intros
simp only [map_filter_map, H, filter_map_some]
intros
simp only [prefix_iff_eq_take, length_take]
induction m with m IH generalizing L n
simp only [min_eq_left, eq_self_iff_true, nat.zero_le, take]
{ simp only [min_eq_left, eq_self_iff_true, nat.zero_le, take] }
cases n
{ cases n, { simp only [nat.nat_zero_eq_zero, nonpos_iff_eq_zero, take, take_nil], split, { cases L, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [forall_prop_of_false, not_false_iff, take] } }, { intro h, contradiction } }, { cases L with l ls, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [length] at hm, specialize @IH ls n (nat.lt_of_succ_lt_succ hm), simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH, simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take], exact ‚ü®nat.succ_le_succ, nat.le_of_succ_le_succ‚ü© } } }
simp only [nat.nat_zero_eq_zero, nonpos_iff_eq_zero, take, take_nil]
{ simp only [nat.nat_zero_eq_zero, nonpos_iff_eq_zero, take, take_nil], split, { cases L, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [forall_prop_of_false, not_false_iff, take] } }, { intro h, contradiction } }
split
cases L
{ cases L, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [forall_prop_of_false, not_false_iff, take] } }
exact absurd hm (not_lt_of_le m.succ.zero_le)
{ exact absurd hm (not_lt_of_le m.succ.zero_le) }
simp only [forall_prop_of_false, not_false_iff, take]
{ simp only [forall_prop_of_false, not_false_iff, take] }
intro h
{ intro h, contradiction }
contradiction
cases L with l ls
{ cases L with l ls, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [length] at hm, specialize @IH ls n (nat.lt_of_succ_lt_succ hm), simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH, simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take], exact ‚ü®nat.succ_le_succ, nat.le_of_succ_le_succ‚ü© } }
{ exact absurd hm (not_lt_of_le m.succ.zero_le) }
exact absurd hm (not_lt_of_le m.succ.zero_le)
simp only [length] at hm
{ simp only [length] at hm, specialize @IH ls n (nat.lt_of_succ_lt_succ hm), simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH, simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take], exact ‚ü®nat.succ_le_succ, nat.le_of_succ_le_succ‚ü© }
specialize @IH ls n (nat.lt_of_succ_lt_succ hm)
simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH
simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take]
exact ‚ü®nat.succ_le_succ, nat.le_of_succ_le_succ‚ü©
intros
induction L with l L ih; [refl, {simp [ih], rw ‚Üê permutations_aux2_append}]
induction L with l L ih
refl
simp [ih]
rw ‚Üê permutations_aux2_append
intros
induction l with b l
{ induction l with b l, {refl}, by_cases a = b; [simp [h], simp [h, ne.symm h, *]] }
refl
{refl}
by_cases a = b; [simp [h], simp [h, ne.symm h, *]]
by_cases a = b
simp [h]
simp [h, ne.symm h, *]
intros
rw disjoint_comm; exact disjoint_nil_left _
rw disjoint_comm
exact disjoint_nil_left _
intros
cases n
cases n; refl
refl
refl
intros
cases l with x l
{ simpa using hn }
simpa using hn
induction l with y l hl generalizing n x
{ simp }
simp
rcases n with _|_|n
{ rcases n with _|_|n, { simpa [last_eq_nth_le, nat.mod_eq_of_lt (nat.succ_lt_succ l.length.lt_succ_self)] }, { simp only [mem_cons_iff, nodup_cons] at h, push_neg at h, simp [add_comm, prev_cons_cons_of_ne, h.left.left.symm] }, { rw [prev_ne_cons_cons], { convert hl _ _ (nodup_of_nodup_cons h) _ using 1, have : ‚àÄ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk), { intros, simpa }, rw [this], congr, simp only [nat.add_succ_sub_one, add_zero, length], simp only [length, nat.succ_lt_succ_iff] at hn, set k := l.length, rw [nat.succ_add, ‚Üênat.add_succ, nat.add_mod_right, nat.succ_add, ‚Üênat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt], { exact nat.lt_succ_of_lt hn }, { exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) } }, { intro H, suffices : n.succ.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, { intro H, suffices : n.succ.succ = 1, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _, simpa using H } } }
simpa [last_eq_nth_le, nat.mod_eq_of_lt (nat.succ_lt_succ l.length.lt_succ_self)]
{ simpa [last_eq_nth_le, nat.mod_eq_of_lt (nat.succ_lt_succ l.length.lt_succ_self)] }
simp only [mem_cons_iff, nodup_cons] at h
{ simp only [mem_cons_iff, nodup_cons] at h, push_neg at h, simp [add_comm, prev_cons_cons_of_ne, h.left.left.symm] }
push_neg at h
simp [add_comm, prev_cons_cons_of_ne, h.left.left.symm]
rw [prev_ne_cons_cons]
{ rw [prev_ne_cons_cons], { convert hl _ _ (nodup_of_nodup_cons h) _ using 1, have : ‚àÄ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk), { intros, simpa }, rw [this], congr, simp only [nat.add_succ_sub_one, add_zero, length], simp only [length, nat.succ_lt_succ_iff] at hn, set k := l.length, rw [nat.succ_add, ‚Üênat.add_succ, nat.add_mod_right, nat.succ_add, ‚Üênat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt], { exact nat.lt_succ_of_lt hn }, { exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) } }, { intro H, suffices : n.succ.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, { intro H, suffices : n.succ.succ = 1, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _, simpa using H } }
convert hl _ _ (nodup_of_nodup_cons h) _ using 1
{ convert hl _ _ (nodup_of_nodup_cons h) _ using 1, have : ‚àÄ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk), { intros, simpa }, rw [this], congr, simp only [nat.add_succ_sub_one, add_zero, length], simp only [length, nat.succ_lt_succ_iff] at hn, set k := l.length, rw [nat.succ_add, ‚Üênat.add_succ, nat.add_mod_right, nat.succ_add, ‚Üênat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt], { exact nat.lt_succ_of_lt hn }, { exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) } }
have : ‚àÄ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk)
intros
{ intros, simpa }
simpa
rw [this]
congr
simp only [nat.add_succ_sub_one, add_zero, length]
simp only [length, nat.succ_lt_succ_iff] at hn
set k := l.length
rw [nat.succ_add, ‚Üênat.add_succ, nat.add_mod_right, nat.succ_add, ‚Üênat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt]
exact nat.lt_succ_of_lt hn
{ exact nat.lt_succ_of_lt hn }
exact nat.succ_lt_succ (nat.lt_succ_of_lt hn)
{ exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) }
intro H
{ intro H, suffices : n.succ.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }
suffices : n.succ.succ = 0
simpa
{ simpa }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn nat.succ_pos' _
simpa using H
intro H
{ intro H, suffices : n.succ.succ = 1, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _, simpa using H }
suffices : n.succ.succ = 1
simpa
{ simpa }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _
simpa using H
intros
simp only [foldr_with_index, foldr_with_index_aux_spec, foldr_with_index_aux_eq_foldr_with_index_aux_spec, enum]
intros
simp
intros
rcases s with ‚ü®l, p, s‚ü©
induction s generalizing l‚ÇÅ
cases h‚ÇÇ
case list.sublist.slnil { cases h‚ÇÇ }
case list.sublist.cons : r‚ÇÅ r‚ÇÇ b s' ih { simp at h‚ÇÇ, cases h‚ÇÇ with e m, { subst b, exact ‚ü®a::r‚ÇÅ, p.cons a, s'.cons2 _ _ _‚ü© }, { rcases ih m d‚ÇÅ h‚ÇÅ p with ‚ü®t, p', s'‚ü©, exact ‚ü®t, p', s'.cons _ _ _‚ü© } }
case list.sublist.cons2 : r‚ÇÅ r‚ÇÇ b s' ih { have bm : b ‚àà l‚ÇÅ := (p.subset $ mem_cons_self _ _), have am : a ‚àà r‚ÇÇ := h‚ÇÇ.resolve_left (Œª e, h‚ÇÅ $ e.symm ‚ñ∏ bm), rcases mem_split bm with ‚ü®t‚ÇÅ, t‚ÇÇ, rfl‚ü©, have st : t‚ÇÅ ++ t‚ÇÇ <+ t‚ÇÅ ++ b :: t‚ÇÇ := by simp, rcases ih am (nodup_of_sublist st d‚ÇÅ) (mt (Œª x, st.subset x) h‚ÇÅ) (perm.cons_inv $ p.trans perm_middle) with ‚ü®t, p', s'‚ü©, exact ‚ü®b::t, (p'.cons b).trans $ (swap _ _ _).trans (perm_middle.symm.cons a), s'.cons2 _ _ _‚ü© }
intros
rw of_fn_eq_pmap; from nodup_pmap (Œª _ _ _ _ H, fin.veq_of_eq $ hf H) (nodup_range n)
rw of_fn_eq_pmap
from nodup_pmap (Œª _ _ _ _ H, fin.veq_of_eq $ hf H) (nodup_range n)
intros
cases n
cases n; simp [rotate]
simp [rotate]
simp [rotate]
intros
by_cases a = a'
{ subst a' }
subst a'
induction l with x xs
refl
{ refl }
by_cases a' = x.1
{ by_cases a' = x.1, { subst a', simp [kerase_cons_ne h,kerase_cons_eq rfl] }, by_cases h' : a = x.1, { subst a, simp [kerase_cons_eq rfl,kerase_cons_ne (ne.symm h)] }, { simp [kerase_cons_ne,*] } }
{ subst a', simp [kerase_cons_ne h,kerase_cons_eq rfl] }
subst a'
simp [kerase_cons_ne h,kerase_cons_eq rfl]
by_cases h' : a = x.1
{ subst a, simp [kerase_cons_eq rfl,kerase_cons_ne (ne.symm h)] }
subst a
simp [kerase_cons_eq rfl,kerase_cons_ne (ne.symm h)]
{ simp [kerase_cons_ne,*] }
simp [kerase_cons_ne,*]
intros
cases e : split l with l‚ÇÅ' l‚ÇÇ'
injection (split_cons_of_eq _ (split_cons_of_eq _ e)).symm.trans h
substs l‚ÇÅ l‚ÇÇ
cases length_split_le e with h‚ÇÅ h‚ÇÇ
exact ‚ü®nat.succ_le_succ (nat.succ_le_succ h‚ÇÅ), nat.succ_le_succ (nat.succ_le_succ h‚ÇÇ)‚ü©
intros
{ rw ‚Üêzip_map', congr, exact map_id _ }
rw ‚Üêzip_map'
congr
exact map_id _
intros
{ ext, rw [‚Üêdiagonal_one, mul_vec_diagonal, one_mul] }
ext
rw [‚Üêdiagonal_one, mul_vec_diagonal, one_mul]
intros
ext
{ ext, refl }
refl
intros
ext i j; by_cases h : i = j; simp [h]
ext i j; by_cases h : i = j
ext i j
by_cases h : i = j
simp [h]
simp [h]
intros
{ rw ‚Üê diagonal_transpose, apply dot_product_diagonal }
rw ‚Üê diagonal_transpose
apply dot_product_diagonal
intros
simp [mul_apply, std_basis_matrix]
intros
ext
simp only [map_apply, block_diagonal'_apply, eq_comm]
rw [apply_dite f, hf]
intros
ext i
simp_rw [fin.append]
split_ifs with h
rcases i with ‚ü®‚ü®‚ü© | i, hi‚ü©
{ rcases i with ‚ü®‚ü®‚ü© | i, hi‚ü©, { simp }, { simp only [nat.succ_eq_add_one, add_lt_add_iff_right, fin.coe_mk] at h, simp [h] } }
{ simp }
simp
simp only [nat.succ_eq_add_one, add_lt_add_iff_right, fin.coe_mk] at h
{ simp only [nat.succ_eq_add_one, add_lt_add_iff_right, fin.coe_mk] at h, simp [h] }
simp [h]
rcases i with ‚ü®‚ü®‚ü© | i, hi‚ü©
{ rcases i with ‚ü®‚ü®‚ü© | i, hi‚ü©, { simpa using h }, { rw [not_lt, fin.coe_mk, nat.succ_eq_add_one, add_le_add_iff_right] at h, simp [h] } }
{ simpa using h }
simpa using h
rw [not_lt, fin.coe_mk, nat.succ_eq_add_one, add_le_add_iff_right] at h
{ rw [not_lt, fin.coe_mk, nat.succ_eq_add_one, add_le_add_iff_right] at h, simp [h] }
simp [h]
intros
simp [multiset.sigma]
intros
rw [antidiagonal, mem_coe, list.nat.mem_antidiagonal]
intros
simp [powerset_aux, sublists]; rw [‚Üê show @sublists_aux‚ÇÅ Œ± (multiset Œ±) l (Œª x, [‚Üëx]) = sublists_aux l (Œª x, list.cons ‚Üëx), from sublists_aux‚ÇÅ_eq_sublists_aux _ _, sublists_aux_cons_eq_sublists_aux‚ÇÅ, ‚Üê bind_ret_eq_map, sublists_aux‚ÇÅ_bind]; refl
simp [powerset_aux, sublists]; rw [‚Üê show @sublists_aux‚ÇÅ Œ± (multiset Œ±) l (Œª x, [‚Üëx]) = sublists_aux l (Œª x, list.cons ‚Üëx), from sublists_aux‚ÇÅ_eq_sublists_aux _ _, sublists_aux_cons_eq_sublists_aux‚ÇÅ, ‚Üê bind_ret_eq_map, sublists_aux‚ÇÅ_bind]
simp [powerset_aux, sublists]
rw [‚Üê show @sublists_aux‚ÇÅ Œ± (multiset Œ±) l (Œª x, [‚Üëx]) = sublists_aux l (Œª x, list.cons ‚Üëx), from sublists_aux‚ÇÅ_eq_sublists_aux _ _, sublists_aux_cons_eq_sublists_aux‚ÇÅ, ‚Üê bind_ret_eq_map, sublists_aux‚ÇÅ_bind]
refl
intros
simpa only [sub_eq_add_neg] using le_trans (degrees_add p (-q)) (by rw degrees_neg)
intros
{ ext1 i, simp }
ext1 i
simp
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
simp only [‚Üê succ_le_iff, le_find_iff, succ_le_succ_iff]
intros
cases n; unfold le_rec_on or.by_cases; rw [dif_neg n.not_succ_le_self, dif_pos rfl]
cases n; unfold le_rec_on or.by_cases
cases n
unfold le_rec_on or.by_cases
unfold le_rec_on or.by_cases
rw [dif_neg n.not_succ_le_self, dif_pos rfl]
intros
rw mul_comm; exact nat.div_eq_iff_eq_mul_right H H'
rw mul_comm
exact nat.div_eq_iff_eq_mul_right H H'
intros
rw [bit1, cast_add_one, cast_bit0]; refl
rw [bit1, cast_add_one, cast_bit0]
refl
intros
rw [choose_eq_factorial_div_factorial (nat.le_add_left j i), nat.add_sub_cancel, mul_comm]
intros
cases n
simp
{ simp }
have h := add_pow (-1 : ‚Ñ§) 1 n.succ
simp only [one_pow, mul_one, add_left_neg, int.nat_cast_eq_coe_nat] at h
rw [‚Üê h, zero_pow (nat.succ_pos n), if_neg (nat.succ_ne_zero n)]
intros
have : digits (b + 2) m ‚â† []
from digits_ne_nil_iff_ne_zero.mpr hm
convert pow_length_le_mul_of_digits this (last_digit_ne_zero _ hm)
rwa of_digits_digits
intros
rw [‚Üê some_eq_coe]
{ rw [‚Üê some_eq_coe], exact part.ext' (iff_of_true trivial h) (Œª _ _, rfl) }
exact part.ext' (iff_of_true trivial h) (Œª _ _, rfl)
intros
{ simp only [‚Üê some_eq_coe, ‚Üê to_with_top_some], congr }
simp only [‚Üê some_eq_coe, ‚Üê to_with_top_some]
intros
rw [gcd_comm, gcd_mul_left_left]
intros
simp [coprime]
intros
rw [‚Üênot_le, le_pow_iff_clog_le hb, not_le]
exact pred_lt (clog_pos hb hx).ne'
intros
rw [not_even_iff, odd_iff]
intros
cases n
cases k; simp [zero_pow_eq]
{ cases k; simp [zero_pow_eq] }
cases k
simp [zero_pow_eq]
simp [zero_pow_eq]
cases n
{ rw one_pow }
rw one_pow
refine ‚ü®Œª _, one_lt_succ_succ n, Œª _, _‚ü©
induction k with k hk
{ exact absurd rfl h }
exact absurd rfl h
cases k
{ simp }
simp
exact one_lt_mul (one_lt_succ_succ _).le (hk (succ_ne_zero k).symm)
intros
rw [pp.dvd_iff_not_coprime]; apply em
rw [pp.dvd_iff_not_coprime]
apply em
intros
refine ‚ü®Œª h, lt_of_lt_of_le (with_bot.coe_lt_coe.mpr zero_lt_one) h, Œª h, _‚ü©
induction x using with_bot.rec_bot_coe
{ exact (not_lt_bot h).elim }
exact (not_lt_bot h).elim
exact with_bot.coe_le_coe.mpr (nat.succ_le_iff.mpr (with_bot.coe_lt_coe.mp h))
{ exact with_bot.coe_le_coe.mpr (nat.succ_le_iff.mpr (with_bot.coe_lt_coe.mp h)) }
intros
rw ‚Üê not_lt; exact not_congr lt_to_nat
rw ‚Üê not_lt
exact not_congr lt_to_nat
intros
cases x; simp only [map_none', map_some', pmap]
{ cases x; simp only [map_none', map_some', pmap] }
cases x
simp only [map_none', map_some', pmap]
simp only [map_none', map_some', pmap]
intros
have := H.2.eq_node'
rw this at H
clear this
induction r with rs rl rx rr IHrl IHrr generalizing l x o‚ÇÅ
{ exact ‚ü®H.left, rfl‚ü© }
exact ‚ü®H.left, rfl‚ü©
have := H.2.2.2.eq_node'
rw this at H ‚ä¢
rcases IHrr H.right with ‚ü®h, e‚ü©
refine ‚ü®valid'.balance_l H.left h (or.inr ‚ü®_, or.inr e, H.3.1‚ü©), _‚ü©
rw [erase_max, size_balance_l H.3.2.1 h.3 H.2.2.1 h.2 (or.inr ‚ü®_, or.inr e, H.3.1‚ü©)]
rw [size, e]
refl
intros
dsimp [node3_r, node', size]; rw [‚Üê add_assoc, ‚Üê add_assoc]
dsimp [node3_r, node', size]
rw [‚Üê add_assoc, ‚Üê add_assoc]
intros
simp only [liftp_iff, sigma.mk.inj_iff]
simp only [liftp_iff, sigma.mk.inj_iff]; split; intro
simp only [liftp_iff, sigma.mk.inj_iff]; split
split
intro
{ casesm* [Exists _, _ ‚àß _], subst_vars, assumption }
casesm* [Exists _, _ ‚àß _]
subst_vars
assumption
intro
constructor
repeat { constructor <|> assumption }
constructor
constructor
constructor
constructor
constructor
constructor
assumption
intros
simp [bit1, C_bit0]
intros
simp [monomial, monomial_fun, finsupp.single_left_inj ha]
intros
rw [C_mul_X_pow_eq_monomial, support_monomial n c H]
intros
{ rw C_mul_X_pow_eq_monomial, apply degree_monomial_le }
rw C_mul_X_pow_eq_monomial
apply degree_monomial_le
intros
rw ‚Üê degree_nonneg_iff_ne_zero; exact trans (by exact_mod_cast n.zero_le) hdeg
rw ‚Üê degree_nonneg_iff_ne_zero
exact trans (by exact_mod_cast n.zero_le) hdeg
intros
obtain ‚ü®ev, bi, bu, hF‚ü© := @denoms_clearable_nat_degree _ _ _ _ b _ (algebra_map ‚Ñ§ K) f a (by { rw [eq_int_cast, one_div_mul_cancel], rw [int.cast_ne_zero], exact (b0.ne.symm) })
obtain Fa := congr_arg abs hF
rw [eq_one_div_of_mul_eq_one_left bu, eq_int_cast, eq_int_cast, abs_mul] at Fa
rw [abs_of_pos (pow_pos (int.cast_pos.mpr b0) _ : 0 < (b : K) ^ _), one_div, eq_int_cast] at Fa
rw [div_eq_mul_inv, ‚Üê Fa, ‚Üê int.cast_abs, ‚Üê int.cast_one, int.cast_le]
refine int.le_of_lt_add_one ((lt_add_iff_pos_left 1).mpr (abs_pos.mpr (Œª F0, fab _)))
rw [eq_one_div_of_mul_eq_one_left bu, F0, one_div, eq_int_cast, int.cast_zero, zero_eq_mul] at hF
cases hF with hF hF
exact (not_le.mpr b0 (le_of_eq (int.cast_eq_zero.mp (pow_eq_zero hF)))).elim
{ exact (not_le.mpr b0 (le_of_eq (int.cast_eq_zero.mp (pow_eq_zero hF)))).elim }
{ rwa div_eq_mul_inv }
rwa div_eq_mul_inv
intros
apply polynomial.induction_on' p
intros p q ph qh
{ intros p q ph qh, simp only [mul_add, eval_add, ph, qh], }
simp only [mul_add, eval_add, ph, qh]
intros n b
{ intros n b, simp only [mul_assoc, C_mul_monomial, eval_monomial], }
simp only [mul_assoc, C_mul_monomial, eval_monomial]
intros
refine or.resolve_left (dvd_or_coprime (X - C a) (f /‚Çò (X - C a)) (irreducible_of_degree_eq_one (polynomial.degree_X_sub_C a))) _
contrapose! hf' with h
have key : (X - C a) * (f /‚Çò (X - C a)) = f - (f %‚Çò (X - C a))
rw [eq_sub_iff_add_eq, ‚Üê eq_sub_iff_add_eq', mod_by_monic_eq_sub_mul_div]
{ rw [eq_sub_iff_add_eq, ‚Üê eq_sub_iff_add_eq', mod_by_monic_eq_sub_mul_div], exact monic_X_sub_C a }
exact monic_X_sub_C a
replace key := congr_arg derivative key
simp only [derivative_X, derivative_mul, one_mul, sub_zero, derivative_sub, mod_by_monic_X_sub_C_eq_C_eval, derivative_C] at key
have : (X - C a) ‚à£ derivative f := key ‚ñ∏ (dvd_add h (dvd_mul_right _ _))
rw [‚Üê dvd_iff_mod_by_monic_eq_zero (monic_X_sub_C _), mod_by_monic_X_sub_C_eq_C_eval] at this
rw [‚Üê C_inj, this, C_0]
intros
have A : ‚àÄ{n:‚Ñï} {a}, M (C a * X^n)
assume n a
{ assume n a, induction n with n ih, { simp only [pow_zero, mul_one, h_C] }, { exact h_monomial _ _ ih } }
induction n with n ih
{ simp only [pow_zero, mul_one, h_C] }
simp only [pow_zero, mul_one, h_C]
{ exact h_monomial _ _ ih }
exact h_monomial _ _ ih
have B : ‚àÄ (s : finset ‚Ñï), M (s.sum (Œª (n : ‚Ñï), C (p.coeff n) * X ^ n))
apply finset.induction
{ apply finset.induction, { convert h_C 0, exact C_0.symm }, { assume n s ns ih, rw sum_insert ns, exact h_add _ _ A ih, } }
{ convert h_C 0, exact C_0.symm }
convert h_C 0
exact C_0.symm
{ assume n s ns ih, rw sum_insert ns, exact h_add _ _ A ih, }
assume n s ns ih
rw sum_insert ns
exact h_add _ _ A ih
rw [‚Üê sum_C_mul_X_eq p, polynomial.sum]
exact B _
intros
simp only [iterated_deriv_zero_right]
intros
rwa [monic, add_comm, leading_coeff_add_of_degree_lt hpq]
intros
rw [monic.def, leading_coeff_smul_of_smul_regular _ (is_smul_regular_of_group _), units.smul_def]
obtain ‚ü®k, hk‚ü© := h
simp only [‚Üêhk, smul_eq_mul, ‚Üêunits.coe_mul, units.coe_eq_one, inv_mul_eq_iff_eq_mul]
simp [units.ext_iff, is_unit.unit_spec]
intros
rw [‚Üêreverse_leading_coeff, reverse_mul_of_domain, leading_coeff_mul, reverse_leading_coeff, reverse_leading_coeff]
intros
simp only [taylor_apply, C_comp]
intros
split
intro h
{ intro h, have : liftp (supp x) x, by rw h; intro u; exact id, rw liftp_iff at this, rcases this with ‚ü®a, f, xeq, h'‚ü©, refine ‚ü®a, f, xeq.symm, _‚ü©, intros a' f' h'', rintros u ‚ü®i, _, hfi‚ü©, have : u ‚àà supp x, by rw ‚Üêhfi; apply h', exact (mem_supp x u).mp this _ _ h'' }
have : liftp (supp x) x
rw h
rw h
rw h; intro u; exact id
rw h; intro u; exact id
rw h; intro u
rw h; intro u
intro u
intro u
exact id
exact id
rw liftp_iff at this
rcases this with ‚ü®a, f, xeq, h'‚ü©
refine ‚ü®a, f, xeq.symm, _‚ü©
intros a' f' h''
rintros u ‚ü®i, _, hfi‚ü©
have : u ‚àà supp x
rw ‚Üêhfi
rw ‚Üêhfi
rw ‚Üêhfi; apply h'
rw ‚Üêhfi; apply h'
apply h'
apply h'
exact (mem_supp x u).mp this _ _ h''
rintros ‚ü®a, f, xeq, h‚ü© p
rw liftp_iff
split
rintros ‚ü®a', f', xeq', h'‚ü© u usuppx
{ rintros ‚ü®a', f', xeq', h'‚ü© u usuppx, rcases (mem_supp x u).mp usuppx a' f' xeq'.symm with ‚ü®i, _, f'ieq‚ü©, rw ‚Üêf'ieq, apply h' }
rcases (mem_supp x u).mp usuppx a' f' xeq'.symm with ‚ü®i, _, f'ieq‚ü©
rw ‚Üêf'ieq
apply h'
intro h'
refine ‚ü®a, f, xeq.symm, _‚ü©
intro i
apply h'
rw mem_supp
intros a' f' xeq'
apply h a' f' xeq'
apply mem_image_of_mem _ (mem_univ _)
rw ‚Üê one_cauchy
rw ‚Üê one_cauchy; refl
refl
intros
rw [div_eq_mul_inv, to_real_mul, to_real_inv, div_eq_mul_inv]
simpa only [coe_inv one_ne_zero, coe_one] using coe_eq_coe.2 inv_one
linarith [one_sub_gold_conj, one_lt_gold]
intros
{ refine le_trans _ h, simp }
refine le_trans _ h
simp
intros
refine (lt_div_iff $ Œª hr, false.elim _).1 h
subst r
simpa using h
intros
rw [sqrt, nnreal.coe_eq_zero, nnreal.sqrt_eq_zero, real.to_nnreal_eq_zero]
intros
{ ext x y, split; apply eq.symm }
ext x y
split
split; apply eq.symm
apply eq.symm
apply eq.symm
intros
rw [‚Üêlift_eq_iff_equiv]; exact lift_rel_map eq _ ((lift_eq_iff_equiv _ _).2 h1) (Œª a b, congr_arg _)
rw [‚Üêlift_eq_iff_equiv]
exact lift_rel_map eq _ ((lift_eq_iff_equiv _ _).2 h1) (Œª a b, congr_arg _)
intros
simp [singleton_inter_eq_empty.2 h]
intros
simp only [image_insert_eq, image_singleton]
intros
rw [inter_comm, preimage_inter_range]
intros
{ ext x, by_cases h‚ÇÅ : x.1 ‚àà s‚ÇÅ; by_cases h‚ÇÇ : x.2 ‚àà t‚ÇÅ; simp * }
ext x
by_cases h‚ÇÅ : x.1 ‚àà s‚ÇÅ
by_cases h‚ÇÅ : x.1 ‚àà s‚ÇÅ; by_cases h‚ÇÇ : x.2 ‚àà t‚ÇÅ; simp *
by_cases h‚ÇÅ : x.1 ‚àà s‚ÇÅ; by_cases h‚ÇÇ : x.2 ‚àà t‚ÇÅ
by_cases h‚ÇÇ : x.2 ‚àà t‚ÇÅ
simp *
simp *
by_cases h‚ÇÇ : x.2 ‚àà t‚ÇÅ
simp *
simp *
intros
rw [‚Üê image_eq_image hf.1, hf.2.image_preimage]
intros
{ ext, simp }
ext
simp
intros
ext
ext; simp
simp
intros
apply piecewise_le; intros; simp *
apply piecewise_le; intros
apply piecewise_le
intros
simp *
intros
simp *
intros
simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]
simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]; ac_refl
ac_refl
intros
rw [‚Üênot_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioc]
intros
rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iic]
intros
simp [lt_irrefl]
intros
simp
intros
refine ‚ü®Œª x h, add_lt_add_right (mem_Iio.mp h) _, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
simpa [add_comm a] using h
intros
refine ‚ü®Œª x h, add_lt_add_right (mem_Ioi.mp h) _, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
obtain ‚ü®c, rfl‚ü© := exists_add_of_le (mem_Ioi.mp h).le
rw [mem_Ioi, add_right_comm, add_lt_add_iff_right] at h
exact ‚ü®a + c, h, by rw add_right_comm‚ü©
intros
simp [interval_oc, le_of_lt h]
intros
ext1 x
simp [image, ‚Üê exists_and_distrib_right, @exists_swap Œ±]
intros
{ ext, simp }
ext
simp
intros
rw [‚Üê sInter_image, image_id']
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
cases n
{ rw nat.mod_zero, apply int.nat_abs_mul }
rw nat.mod_zero
apply int.nat_abs_mul
{ apply fin.val_mul }
apply fin.val_mul
intros
rwa [‚Üê nat.cast_zero, ne.def, eq_iff_modeq_nat, nat.modeq_zero_iff_dvd, ‚Üê hp.1.coprime_iff_not_dvd, nat.coprime_primes hp.1 hq.1]
intros
simpa only [sub_eq_add_neg] using (f.commute_add_int n).inverses_right (equiv.add_right _).right_inv (equiv.add_right _).left_inv
intros
rcases eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset f œï s hc‚ÇÅ hc‚ÇÇ hn‚ÇÅ hn‚ÇÇ with ‚ü®u, hu_mem, hu‚ü©
refine mem_of_superset hu_mem (Œª t ht x hx, _)
exact hu (subset_closure $ mem_image2_of_mem ht hx)
intros
ext
convert minpoly.aeval F Œ±
conv in (aeval Œ±) { rw [‚Üê adjoin_simple.algebra_map_gen F Œ±] }
exact is_scalar_tower.algebra_map_aeval F F‚üÆŒ±‚üØ E _ _
intros
conv { to_rhs, rw [‚Üêfixed_field_fixing_subgroup K, intermediate_field.finrank_fixed_field_eq_card] }
intros
rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero]
{ rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero], exact is_coprime_one_right }
exact is_coprime_one_right
intros
use [(2‚Åª¬π : ‚Ñù) ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) +·µ• p‚ÇÅ, (2‚Åª¬π : ‚Ñù) * (dist p‚ÇÇ p‚ÇÅ)]
intro p
rw [set.mem_insert_iff, set.mem_singleton_iff]
rintro ‚ü®_|_‚ü©
rw [dist_eq_norm_vsub V p‚ÇÅ, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, norm_neg, norm_smul, dist_eq_norm_vsub V p‚ÇÇ]
{ rw [dist_eq_norm_vsub V p‚ÇÅ, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, norm_neg, norm_smul, dist_eq_norm_vsub V p‚ÇÇ], simp }
simp
rw [H, dist_eq_norm_vsub V p‚ÇÇ, vsub_vadd_eq_vsub_sub, dist_eq_norm_vsub V p‚ÇÇ]
{ rw [H, dist_eq_norm_vsub V p‚ÇÇ, vsub_vadd_eq_vsub_sub, dist_eq_norm_vsub V p‚ÇÇ], conv_lhs { congr, congr, rw ‚Üêone_smul ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ : V) }, rw [‚Üêsub_smul, norm_smul], norm_num }
conv_lhs { congr, congr, rw ‚Üêone_smul ‚Ñù (p‚ÇÇ -·µ• p‚ÇÅ : V) }
rw [‚Üêsub_smul, norm_smul]
norm_num
intros
have h := s.circumcenter_circumradius_unique_dist_eq.2 (p, r)
simp only [hp, hr, forall_const, eq_self_iff_true, and_self, prod.ext_iff] at h
exact h.1
intros
rw [add_assoc, real.cos_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy, sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy, ‚Üêneg_mul_eq_mul_neg, ‚Üêneg_add', add_comm, ‚Üêsq, ‚Üêsq, real.sin_sq_add_cos_sq]
intros
rw [f.support_eq_inter_preimage, ‚Üê ext_chart_at_source I, ‚Üê (ext_chart_at I c).symm_image_target_inter_eq', inter_comm]
congr' 1 with y
exact and.congr_right_iff.2 (Œª hy, ‚ü®Œª h, ext_chart_at_target_subset_range _ _ h, Œª h, f.ball_subset ‚ü®hy, h‚ü©‚ü©)
intros
haveI : ‚àÄ x : M, second_countable_topology (chart_at H x).source := Œª x, (chart_at H x).second_countable_topology_source
haveI := hsc.to_encodable
rw bUnion_eq_Union at hs
exact second_countable_topology_of_countable_cover (Œª x : s, (chart_at H (x : M)).open_source) hs
intros
assume x hx
apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_of_mem_maximal_atlas hQ he hx)
apply is_open.mem_nhds e.open_source hx
intros
refine ‚ü®h.1, _‚ü©
simp only [mfderiv_within, h, dif_pos] with mfld_simps
exact differentiable_within_at.has_fderiv_within_at h.2
intros
{ ext p : 1, exact tangent_map_comp_at _ (hg _) (hf _) }
ext p : 1
exact tangent_map_comp_at _ (hg _) (hf _)
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
rw [‚Üêset_like.mem_coe, ‚Üêha]; exact mem_own_right_coset s a
rw [‚Üêset_like.mem_coe, ‚Üêha]
exact mem_own_right_coset s a
intros
rw [subgroup.fg_iff_submonoid_fg, add_subgroup.fg_iff_add_submonoid.fg]
exact (subgroup.to_submonoid P).fg_iff_add_fg
intros
simp only [to_finsupp, lift.of]
intros
exact {smul_comm := Œª _ n, @smul_comm _ _ _ _ _ _ _ (g n) }
intros
rw [mul_comm, mk'_spec]
intros
rw [is_periodic_pt, is_fixed_pt, mul_left_iterate, mul_one]
intros
induction s using quot.induction_on
simpa using form_perm_reverse _ h
intros
let H := closure ({œÉ, swap x (œÉ x)} : set (perm Œ±))
have h3 : œÉ ‚àà H := subset_closure (set.mem_insert œÉ _)
have h4 : swap x (œÉ x) ‚àà H := subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _))
have step1 : ‚àÄ (n : ‚Ñï), swap ((œÉ ^ n) x) ((œÉ^(n+1)) x) ‚àà H
intro n
{ intro n, induction n with n ih, { exact subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)) }, { convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3), rw [mul_swap_eq_swap_mul, mul_inv_cancel_right], refl } }
induction n with n ih
{ exact subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)) }
exact subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _))
convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3)
{ convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3), rw [mul_swap_eq_swap_mul, mul_inv_cancel_right], refl }
rw [mul_swap_eq_swap_mul, mul_inv_cancel_right]
refl
have step2 : ‚àÄ (n : ‚Ñï), swap x ((œÉ ^ n) x) ‚àà H
intro n
{ intro n, induction n with n ih, { convert H.one_mem, exact swap_self x }, { by_cases h5 : x = (œÉ ^ n) x, { rw [pow_succ, mul_apply, ‚Üêh5], exact h4 }, by_cases h6 : x = (œÉ^(n+1)) x, { rw [‚Üêh6, swap_self], exact H.one_mem }, rw [swap_comm, ‚Üêswap_mul_swap_mul_swap h5 h6], exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n) } }
induction n with n ih
convert H.one_mem
{ convert H.one_mem, exact swap_self x }
exact swap_self x
by_cases h5 : x = (œÉ ^ n) x
{ by_cases h5 : x = (œÉ ^ n) x, { rw [pow_succ, mul_apply, ‚Üêh5], exact h4 }, by_cases h6 : x = (œÉ^(n+1)) x, { rw [‚Üêh6, swap_self], exact H.one_mem }, rw [swap_comm, ‚Üêswap_mul_swap_mul_swap h5 h6], exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n) }
{ rw [pow_succ, mul_apply, ‚Üêh5], exact h4 }
rw [pow_succ, mul_apply, ‚Üêh5]
exact h4
by_cases h6 : x = (œÉ^(n+1)) x
{ rw [‚Üêh6, swap_self], exact H.one_mem }
rw [‚Üêh6, swap_self]
exact H.one_mem
rw [swap_comm, ‚Üêswap_mul_swap_mul_swap h5 h6]
exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n)
have step3 : ‚àÄ (y : Œ±), swap x y ‚àà H
intro y
{ intro y, have hx : x ‚àà (‚ä§ : finset Œ±) := finset.mem_univ x, rw [‚Üêh2, mem_support] at hx, have hy : y ‚àà (‚ä§ : finset Œ±) := finset.mem_univ y, rw [‚Üêh2, mem_support] at hy, cases is_cycle.exists_pow_eq h1 hx hy with n hn, rw ‚Üê hn, exact step2 n }
have hx : x ‚àà (‚ä§ : finset Œ±) := finset.mem_univ x
rw [‚Üêh2, mem_support] at hx
have hy : y ‚àà (‚ä§ : finset Œ±) := finset.mem_univ y
rw [‚Üêh2, mem_support] at hy
cases is_cycle.exists_pow_eq h1 hx hy with n hn
rw ‚Üê hn
exact step2 n
have step4 : ‚àÄ (y z : Œ±), swap y z ‚àà H
intros y z
{ intros y z, by_cases h5 : z = x, { rw [h5, swap_comm], exact step3 y }, by_cases h6 : z = y, { rw [h6, swap_self], exact H.one_mem }, rw [‚Üêswap_mul_swap_mul_swap h5 h6, swap_comm z x], exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y) }
by_cases h5 : z = x
{ rw [h5, swap_comm], exact step3 y }
rw [h5, swap_comm]
exact step3 y
by_cases h6 : z = y
{ rw [h6, swap_self], exact H.one_mem }
rw [h6, swap_self]
exact H.one_mem
rw [‚Üêswap_mul_swap_mul_swap h5 h6, swap_comm z x]
exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y)
rw [eq_top_iff, ‚Üêclosure_is_swap, closure_le]
rintros œÑ ‚ü®y, z, h5, h6‚ü©
rw h6
exact step4 y z
intros
have : ¬¨ order_of f ‚à£ n := nat.not_dvd_of_pos_of_lt npos hn
rw ‚Üêhf.support_pow_eq_iff at this
rw this
intros
obtain ‚ü®l, hl, hl'‚ü© := f.cycle_factors_finset.exists_list_nodup_eq
rw ‚Üêhl'
rw [eq_comm, cycle_factors_finset_eq_list_to_finset hl] at hl'
simpa [list.mem_to_finset, ne.def, ‚Üêhl'.right.right] using mem_list_cycles_iff hl'.left hl'.right.left
intros
rw [nth_le_cons_length, form_perm_apply_last]
intros
have h0 : ‚àÄ y ‚àà s, ‚àÉ x (hx : x ‚àà s), y = (Œª i (hi : i ‚àà s), f i) x hx := finset.surj_on_of_inj_on_of_card_le (Œª x hx, (Œª i hi, f i) x hx) (Œª a ha, h a ha) (Œª a‚ÇÅ a‚ÇÇ ha‚ÇÅ ha‚ÇÇ heq, (equiv.apply_eq_iff_eq f).mp heq) rfl.ge
obtain ‚ü®y2, hy2, heq‚ü© := h0 y hy
convert hy2
rw heq
simp only [inv_apply_self]
intros
simp_rw [finset.ext_iff, mem_support, finset.not_mem_empty, iff_false, not_not, equiv.perm.ext_iff, one_apply]
intros
{ rw [lift_unique f, lift_unique g], simp only * }
rw [lift_unique f, lift_unique g]
simp only *
intros
rw order_of_eq_prime _ _
{ exact ‚ü®nat.prime_two‚ü© }
exact ‚ü®nat.prime_two‚ü©
rw [sq, sr_mul_self]
dec_trivial
intros
assume a w
refine closure_induction w (Œª x hx, _) _ (Œª x y ihx ihy, _) (Œª x ihx, _)
{ exact (conjugates_of_set_subset h hx) }
exact (conjugates_of_set_subset h hx)
{ exact subgroup.one_mem _ }
exact subgroup.one_mem _
{ exact subgroup.mul_mem _ ihx ihy }
exact subgroup.mul_mem _ ihx ihy
{ exact subgroup.inv_mem _ ihx }
exact subgroup.inv_mem _ ihx
intros
{ ext, simp [mem_mker] }
ext
simp [mem_mker]
intros
have : ‚áëf = (Œª x, x + f 0) ‚àò Œª x, x * (f 1 - f 0)
ext x
{ ext x, change f x = x ‚Ä¢ (f 1 -·µ• f 0) +·µ• f 0, rw [‚Üê f.linear_map_vsub, ‚Üê f.linear.map_smul, ‚Üê f.map_vadd], simp only [vsub_eq_sub, add_zero, mul_one, vadd_eq_add, sub_zero, smul_eq_mul] }
change f x = x ‚Ä¢ (f 1 -·µ• f 0) +·µ• f 0
rw [‚Üê f.linear_map_vsub, ‚Üê f.linear.map_smul, ‚Üê f.map_vadd]
simp only [vsub_eq_sub, add_zero, mul_one, vadd_eq_add, sub_zero, smul_eq_mul]
rw [this, set.image_comp]
simp only [set.image_add_const_interval, set.image_mul_const_interval]
intros
rw [direction_eq_vector_span, bot_coe, vector_span_def, vsub_empty, submodule.span_empty]
intros
rw [affine_combination_apply, affine_combination_apply, weighted_vsub_of_point_indicator_subset _ _ _ h]
intros
rw [affine_independent_iff_le_finrank_vector_span k p hc, ‚Üênat.lt_iff_add_one_le, lt_iff_not_ge]
intros
rw [midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, vadd_eq_add, sub_add_eq_add_sub, ‚Üê two_smul R, smul_smul, mul_inv_of_self, one_smul, add_sub_cancel']
intros
ext a
change (equiv_fun_on_fintype.symm (pi.single x m)) a = _
convert congr_fun (equiv_fun_on_fintype_symm_single x m) a
intros
classical; by_cases a = 0; simp [h, map_smul]
classical; by_cases a = 0
classical
by_cases a = 0
simp [h, map_smul]
simp [h, map_smul]
intros
simp_rw [‚Üê top_le_iff, ‚Üê hf, range_eq_map, map_le_map_iff]
intros
rcases set_like.exists_of_lt hp with ‚ü®v, -, hpv‚ü©
clear hp
rcases (linear_pmap.sup_span_singleton ‚ü®p, 0‚ü© v (1 : K) hpv).to_fun.exists_extend with ‚ü®f, hf‚ü©
refine ‚ü®f, _, _‚ü©
rintro rfl
{ rintro rfl, rw [linear_map.zero_comp] at hf, have := linear_pmap.sup_span_singleton_apply_mk ‚ü®p, 0‚ü© v (1 : K) hpv 0 p.zero_mem 1, simpa using (linear_map.congr_fun hf _).trans this }
rw [linear_map.zero_comp] at hf
have := linear_pmap.sup_span_singleton_apply_mk ‚ü®p, 0‚ü© v (1 : K) hpv 0 p.zero_mem 1
simpa using (linear_map.congr_fun hf _).trans this
refine Œª x hx, mem_ker.2 _
{ refine Œª x hx, mem_ker.2 _, have := linear_pmap.sup_span_singleton_apply_mk ‚ü®p, 0‚ü© v (1 : K) hpv x hx 0, simpa using (linear_map.congr_fun hf _).trans this }
have := linear_pmap.sup_span_singleton_apply_mk ‚ü®p, 0‚ü© v (1 : K) hpv x hx 0
simpa using (linear_map.congr_fun hf _).trans this
intros
rw [‚Üê b.total_repr x, finsupp.total_apply, finsupp.sum]
{ rw [‚Üê b.total_repr x, finsupp.total_apply, finsupp.sum], exact submodule.sum_mem _ (Œª i hi, submodule.smul_mem _ _ (submodule.subset_span ‚ü®i, rfl‚ü©)) }
exact submodule.sum_mem _ (Œª i hi, submodule.smul_mem _ _ (submodule.subset_span ‚ü®i, rfl‚ü©))
intros
rw [‚Üê to_lin_restrict_ker_eq_inf_orthogonal _ _ b‚ÇÅ, ‚Üê to_lin_restrict_range_dual_annihilator_comap_eq_orthogonal _ _, finrank_map_subtype_eq]
conv_rhs { rw [‚Üê @subspace.finrank_add_finrank_dual_annihilator_comap_eq K V _ _ _ _ (B.to_lin.dom_restrict W).range, add_comm, ‚Üê add_assoc, add_comm (finrank K ‚Ü•((B.to_lin.dom_restrict W).ker)), linear_map.finrank_range_add_finrank_ker] }
intros
refine ext_basis (pi.basis_fun R‚ÇÉ n) (Œª i j, _)
rw [bilin_form.to_matrix_aux, linear_map.coe_mk, pi.basis_fun_apply, pi.basis_fun_apply, matrix.to_bilin'_aux_std_basis]
intros
ext
simp only [map_range_apply f, coe_smul, pi.smul_apply, hf']
intros
simp [dim_fun']
intros
refine eq_of_sub_eq_zero (h.total _)
intros i
simp [-sub_eq_add_neg, linear_map.map_sub, h.dual_lc, sub_eq_zero]
intros
convert finrank_span_set_eq_card ‚Üës hs
ext
simp
intros
haveI := classical.dec_eq M
refine N.induction_on_rank b _ _
intros N ih
let b' := (b.reindex (fintype.equiv_fin Œπ)).map (linear_equiv.of_top _ rfl).symm
by_cases N_bot : N = ‚ä•
{ subst N_bot, exact ‚ü®0, ‚ü®basis.empty _‚ü©‚ü© }
subst N_bot
exact ‚ü®0, ‚ü®basis.empty _‚ü©‚ü©
obtain ‚ü®y, -, a, hay, M', -, N', N'_le_N, -, -, ay_ortho, h'‚ü© := submodule.basis_of_pid_aux ‚ä§ N b' N_bot le_top
obtain ‚ü®n', ‚ü®bN'‚ü©‚ü© := ih N' N'_le_N _ hay ay_ortho
obtain ‚ü®bN, hbN‚ü© := h' n' bN'
exact ‚ü®n' + 1, ‚ü®bN‚ü©‚ü©
intros
apply @linear_independent_comp_subtype _ _ _ id
intros
rw [‚Üê @subtype.range_coe _ s] at hf_inj
refine (hs.map hf_inj).to_subtype_range' _
simp [set.range_comp f]
intros
apply eq_of_sub_eq_zero
rw ‚Üê coeff_sub
apply polynomial.coeff_eq_zero_of_degree_lt
apply lt_of_lt_of_le (charpoly_sub_diagonal_degree_lt M) _
rw with_bot.coe_le_coe
apply h
intros
rw [‚Üê det_transpose, ‚Üê update_row_transpose, det_update_row_smul]
simp [update_row_transpose, det_transpose]
intros
apply (linear_map.to_matrix B‚ÇÅ.dual_basis B‚ÇÇ.dual_basis).injective
rw [linear_map.to_matrix_to_lin, linear_map.to_matrix_transpose, linear_map.to_matrix_to_lin]
intros
rw [cramer_eq_adjugate_mul_vec, mul_vec_mul_vec, mul_adjugate, smul_mul_vec_assoc, one_mul_vec]
intros
ext i j
simp [linear_map.to_matrix_apply, matrix.one_apply, finsupp.single, eq_comm]
intros
rw [‚Üê update_cons_zero x m (c ‚Ä¢ x), f.map_smul, update_cons_zero]
intros
apply linear_equiv.to_linear_map_injective
ext f
simp only [linear_equiv.trans_apply, linear_equiv.coe_coe, reindex_tprod, linear_map.coe_comp_multilinear_map, function.comp_app, multilinear_map.dom_dom_congr_apply, reindex_comp_tprod]
congr
intros
ext ‚ü®x, y‚ü©; simp
ext ‚ü®x, y‚ü©
simp
intros
conv_rhs { rw [‚Üê (prod_equiv_of_is_compl p q h).apply_symm_apply x] }
rw [coe_prod_equiv_of_is_compl', submodule.add_mem_iff_left _ (submodule.coe_mem _), mem_right_iff_eq_zero_of_disjoint h.disjoint]
intros
ext i j
rw [std_basis_apply, finsupp.single_apply]
split_ifs
{ rw [h, function.update_same] }
rw [h, function.update_same]
{ rw [function.update_noteq (ne.symm h)], refl }
rw [function.update_noteq (ne.symm h)]
refl
intros
simp only [ltensor, rtensor, ‚Üê map_comp, id_comp, comp_id]
intros
by_cases b; simp [h, or_iff_right_of_imp ((‚àò) false.elim)]
by_cases b
simp [h, or_iff_right_of_imp ((‚àò) false.elim)]
simp [h, or_iff_right_of_imp ((‚àò) false.elim)]
intros
simp [pi_premeasure_pi']
intros
have : ‚àÄ x, measurable_set (prod.mk x ‚Åª¬π' s) := Œª x, measurable_prod_mk_left hs
simp only [‚Üê @supr_restrict_spanning_sets _ _ ŒΩ, this]
apply measurable_supr
intro i
haveI := fact.mk (measure_spanning_sets_lt_top ŒΩ i)
exact measurable_measure_prod_mk_left_finite hs
intros
rw [‚Üê s.neg_le_neg_iff _ hu, neg_zero] at hsu
have := subset_positive_null_set hu hv hw hsu
simp only [pi.neg_apply, neg_eq_zero, coe_neg] at this
exact this hw‚ÇÅ hw‚ÇÇ hwt
intros
simp_rw [condexp_ind_smul]
{ simp_rw [condexp_ind_smul], rw [to_span_singleton_add, add_comp_LpL, add_apply], }
rw [to_span_singleton_add, add_comp_LpL, add_apply]
intros
refine (condexp_L1_eq (integrable_zero _ _ _)).trans _
change (condexp_L1_clm hm Œº) (integrable.to_L1 0 _) = 0
rw [integrable.to_L1_zero, continuous_linear_map.map_zero]
intros
refine (ess_sup_mono_ae hf).trans _
by_cases hŒº : Œº = 0
{ simp [hŒº], }
simp [hŒº]
{ rwa ess_sup_const, }
rwa ess_sup_const
intros
simp [‚Üê mem_‚Ñíp_one_iff_integrable, hg.mem_‚Ñíp_comp_iff_of_antilipschitz hg' g0]
intros
simp [integrable.to_L1, snorm, snorm']
{ simp [integrable.to_L1, snorm, snorm'], simp [edist_eq_coe_nnnorm] }
simp [edist_eq_coe_nnnorm]
intros
rw [norm_def, snorm_congr_ae (mem_‚Ñíp.coe_fn_to_Lp hf)]
intros
rw [Lp.norm_def, snorm_congr_ae indicator_const_Lp_coe_fn, snorm_indicator_const hs hp_ne_zero hp_ne_top, ennreal.to_real_mul, ennreal.to_real_rpow, ennreal.coe_to_real, coe_nnnorm]
intros
rw tendsto_Lp_iff_tendsto_‚Ñíp'
suffices h_eq : (Œª n, snorm (f n - mem_‚Ñíp.to_Lp f_lim f_lim_‚Ñíp) p Œº) = (Œª n, snorm (f n - f_lim) p Œº)
rw h_eq
rw h_eq
exact funext (Œª n, snorm_congr_ae (eventually_eq.rfl.sub (mem_‚Ñíp.coe_fn_to_Lp f_lim_‚Ñíp)))
intros
refine ‚ü®measurable_const.ae_measurable, _‚ü©
by_cases h0 : p = 0
{ simp [h0], }
simp [h0]
by_cases hŒº : Œº = 0
{ simp [hŒº], }
simp [hŒº]
rw snorm_const c h0 hŒº
refine ennreal.mul_lt_top ennreal.coe_ne_top _
refine (ennreal.rpow_lt_top_of_nonneg _ (measure_ne_top Œº set.univ)).ne
simp
intros
simp_rw snorm'
congr' 1
refine lintegral_trim hm _
refine @measurable.pow_const _ _ _ _ _ _ _ m _ (@measurable.coe_nnreal_ennreal _ m _ _) _
exact @measurable.nnnorm E _ _ _ _ m _ hf
intros
rwa [filter.eventually_eq, ae_iff, trim_measurable_set_eq hm _]
exact (@measurable_set.compl Œ± _ m (@measurable_set_eq_fun Œ± m E _ _ _ _ _ _ hf hg))
intros
rw [integral_def, set_to_simple_func_eq_sum_filter]
{ rw [integral_def, set_to_simple_func_eq_sum_filter], simp_rw weighted_smul_apply, }
simp_rw weighted_smul_apply
intros
have : f =·µê[Œº.restrict {x}] (Œª y, f x)
filter_upwards [ae_restrict_mem (measurable_set_singleton x)]
{ filter_upwards [ae_restrict_mem (measurable_set_singleton x)], assume a ha, simp only [mem_singleton_iff.1 ha] }
assume a ha
simp only [mem_singleton_iff.1 ha]
rw [integrable_on, integrable_congr this, integrable_const_iff]
simp
intros
set F : ‚Ñù ‚Üí E := update (update f a fa) b fb
have Fderiv : ‚àÄ x ‚àà Ioo a b, has_deriv_at F (f' x) x
refine Œª x hx, (hderiv x hx).congr_of_eventually_eq _
{ refine Œª x hx, (hderiv x hx).congr_of_eventually_eq _, filter_upwards [Ioo_mem_nhds hx.1 hx.2], intros y hy, simp only [F], rw [update_noteq hy.2.ne, update_noteq hy.1.ne'] }
filter_upwards [Ioo_mem_nhds hx.1 hx.2]
intros y hy
simp only [F]
rw [update_noteq hy.2.ne, update_noteq hy.1.ne']
have hcont : continuous_on F (Icc a b)
rw [continuous_on_update_iff, continuous_on_update_iff, Icc_diff_right, Ico_diff_left]
{ rw [continuous_on_update_iff, continuous_on_update_iff, Icc_diff_right, Ico_diff_left], refine ‚ü®‚ü®Œª z hz, (hderiv z hz).continuous_at.continuous_within_at, _‚ü©, _‚ü©, { exact Œª _, ha.mono_left (nhds_within_mono _ Ioo_subset_Ioi_self) }, { rintro -, refine (hb.congr' _).mono_left (nhds_within_mono _ Ico_subset_Iio_self), filter_upwards [Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 hab)], exact Œª z hz, (update_noteq hz.1.ne' _ _).symm } }
refine ‚ü®‚ü®Œª z hz, (hderiv z hz).continuous_at.continuous_within_at, _‚ü©, _‚ü©
{ exact Œª _, ha.mono_left (nhds_within_mono _ Ioo_subset_Ioi_self) }
exact Œª _, ha.mono_left (nhds_within_mono _ Ioo_subset_Ioi_self)
rintro -
{ rintro -, refine (hb.congr' _).mono_left (nhds_within_mono _ Ico_subset_Iio_self), filter_upwards [Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 hab)], exact Œª z hz, (update_noteq hz.1.ne' _ _).symm }
refine (hb.congr' _).mono_left (nhds_within_mono _ Ico_subset_Iio_self)
filter_upwards [Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 hab)]
exact Œª z hz, (update_noteq hz.1.ne' _ _).symm
simpa [F, hab.ne, hab.ne'] using integral_eq_sub_of_has_deriv_at_of_le hab.le hcont Fderiv hint
intros
rw [interval_integral, interval_integral, L.integral_comp_comm, L.integral_comp_comm, L.map_sub]
exacts [hf.2, hf.1]
intros
induction n with n hn
{ simp }
simp
rw [finset.sum_range_succ, hn (Œª k hk, hint k (hk.trans n.lt_succ_self))]
{ rw [finset.sum_range_succ, hn (Œª k hk, hint k (hk.trans n.lt_succ_self))], exact integral_add_adjacent_intervals (interval_integrable.trans_iterate $ Œª k hk, hint k (hk.trans n.lt_succ_self)) (hint n n.lt_succ_self) }
exact integral_add_adjacent_intervals (interval_integrable.trans_iterate $ Œª k hk, hint k (hk.trans n.lt_succ_self)) (hint n n.lt_succ_self)
intros
simp
intros
ext1 s hs
simp_rw [sum_apply _ hs, with_density_apply _ hs]
change ‚à´‚Åª x in s, (‚àë' n, f n) x ‚àÇŒº = ‚àë' (i : ‚Ñï), ‚à´‚Åª x, f i x ‚àÇ(Œº.restrict s)
rw ‚Üê lintegral_tsum h
refine lintegral_congr (Œª x, tsum_apply (pi.summable.2 (Œª _, ennreal.summable)))
intros
rw lintegral_eq_zero_iff' (hf.pow_const p) at hf_zero
refine filter.eventually.mp hf_zero (filter.eventually_of_forall (Œª x, _))
dsimp only
rw [pi.zero_apply, rpow_eq_zero_iff]
intro hx
cases hx
{ exact hx.left, }
exact hx.left
exfalso
{ exfalso, linarith, }
linarith
intros
rw [e.restrict_map, integral_map_equiv]
intros
rw [pi_def]
{ rw [pi_def], exact measurable_set.bInter hs (Œª i hi, measurable_pi_apply _ (ht i hi)) }
exact measurable_set.bInter hs (Œª i hi, measurable_pi_apply _ (ht i hi))
intros
rw inter_eq_compl_compl_union_compl
{ rw inter_eq_compl_compl_union_compl, exact (h‚ÇÅ.compl.union h‚ÇÇ.compl).compl }
exact (h‚ÇÅ.compl.union h‚ÇÇ.compl).compl
intros
simp only [volume_pi_Ioo, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
rw ‚Üê measure_bUnion_finset H h
{ rw ‚Üê measure_bUnion_finset H h, exact measure_mono (subset_univ _) }
exact measure_mono (subset_univ _)
intros
simpa [h‚ÇÅ, h‚ÇÇ] using m.union s‚ÇÅ s‚ÇÇ
intros
refine le_antisymm (le_of_function.2 $ Œª s, _) (Œª s, _)
{ rw comap_apply, apply of_function_le }
rw comap_apply
apply of_function_le
rw [comap_apply, of_function_apply, of_function_apply]
{ rw [comap_apply, of_function_apply, of_function_apply], refine infi_le_infi2 (Œª t, ‚ü®Œª k, f ‚Åª¬π' (t k), _‚ü©), refine infi_le_infi2 (Œª ht, _), rw [set.image_subset_iff, preimage_Union] at ht, refine ‚ü®ht, ennreal.tsum_le_tsum $ Œª n, _‚ü©, cases h, exacts [h (image_preimage_subset _ _), (congr_arg m (h.image_preimage (t n))).le] }
refine infi_le_infi2 (Œª t, ‚ü®Œª k, f ‚Åª¬π' (t k), _‚ü©)
refine infi_le_infi2 (Œª ht, _)
rw [set.image_subset_iff, preimage_Union] at ht
refine ‚ü®ht, ennreal.tsum_le_tsum $ Œª n, _‚ü©
cases h
exacts [h (image_preimage_subset _ _), (congr_arg m (h.image_preimage (t n))).le]
intros
rw [restrict_apply v hi hj, inter_eq_left_iff_subset.2 hij]
intros
apply pmf.ext
rintro c
simp only [ennreal.coe_eq_coe.symm, coe_bind_on_support_apply, ‚Üê tsum_dite_right, ennreal.tsum_mul_left.symm, ennreal.tsum_mul_right.symm]
refine trans (ennreal.tsum_comm) (tsum_congr (Œª b, tsum_congr (Œª a, _)))
split_ifs with h1 h2 h2; ring
split_ifs with h1 h2 h2
ring
ring
ring
ring
{ rw bernoulli'_def, norm_num [sum_range_succ] }
rw bernoulli'_def
norm_num [sum_range_succ]
intros
refine mt ((ring_hom.injective_iff _).mp bS.algebra_map_injective _) _
simp only [finset.prod_eq_zero_iff, not_exists]
rintros x hx rfl
exact finset_approx.zero_not_mem bS adm hx
intros
simpa
intros
ext x
rw ring_hom.mem_ker
split
intro h
{ intro h, suffices : x.appr n = 0, { convert appr_spec n x, simp only [this, sub_zero, cast_zero], }, dsimp [to_zmod_pow, to_zmod_hom] at h, rw zmod.nat_coe_zmod_eq_zero_iff_dvd at h, apply eq_zero_of_dvd_of_lt h (appr_lt _ _), }
suffices : x.appr n = 0
{ convert appr_spec n x, simp only [this, sub_zero, cast_zero], }
convert appr_spec n x
simp only [this, sub_zero, cast_zero]
dsimp [to_zmod_pow, to_zmod_hom] at h
rw zmod.nat_coe_zmod_eq_zero_iff_dvd at h
apply eq_zero_of_dvd_of_lt h (appr_lt _ _)
intro h
{ intro h, rw ‚Üê sub_zero x at h, dsimp [to_zmod_pow, to_zmod_hom], rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero], apply appr_spec, }
rw ‚Üê sub_zero x at h
dsimp [to_zmod_pow, to_zmod_hom]
rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]
apply appr_spec
intros
rw [sup_comm, sup_sdiff_self_right, sup_comm]
intros
rw [sdiff_sdiff_right, inf_idem, sdiff_self, bot_sup_eq]
intros
simp [disjoint_iff]
intros
simp only [insert_eq, bdd_below_union, bdd_below_singleton, true_and]
intros
tfae_have : 1 ‚Üí 2
exact well_founded.is_Sup_finite_compact Œ±
exact well_founded.is_Sup_finite_compact Œ±
{ exact well_founded.is_Sup_finite_compact Œ±, }
{ exact well_founded.is_Sup_finite_compact Œ±, }
tfae_have : 2 ‚Üí 3
exact is_Sup_finite_compact.is_sup_closed_compact Œ±
exact is_Sup_finite_compact.is_sup_closed_compact Œ±
{ exact is_Sup_finite_compact.is_sup_closed_compact Œ±, }
{ exact is_Sup_finite_compact.is_sup_closed_compact Œ±, }
tfae_have : 3 ‚Üí 1
exact is_sup_closed_compact.well_founded Œ±
exact is_sup_closed_compact.well_founded Œ±
{ exact is_sup_closed_compact.well_founded Œ±, }
{ exact is_sup_closed_compact.well_founded Œ±, }
tfae_have : 2 ‚Üî 4
exact is_Sup_finite_compact_iff_all_elements_compact Œ±
exact is_Sup_finite_compact_iff_all_elements_compact Œ±
{ exact is_Sup_finite_compact_iff_all_elements_compact Œ± }
{ exact is_Sup_finite_compact_iff_all_elements_compact Œ± }
tfae_finish
intros
apply le_antisymm; simp only [supr_le_iff]
apply le_antisymm
simp only [supr_le_iff]
exact Œª i hi, le_Sup ‚ü®i - n, by { dsimp only, rw nat.sub_add_cancel hi }‚ü©
{ exact Œª i hi, le_Sup ‚ü®i - n, by { dsimp only, rw nat.sub_add_cancel hi }‚ü© }
simp only [supr_le_iff]
exact Œª i, le_Sup ‚ü®i + n, supr_pos (nat.le_add_left _ _)‚ü©
{ exact Œª i, le_Sup ‚ü®i + n, supr_pos (nat.le_add_left _ _)‚ü© }
intros
{ symmetry, exact infi_and }
symmetry
exact infi_and
intros
simpa only [(‚àò), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))
intros
erw [(filter_basis.of_sets s).generate, ‚Üê (has_basis_generate s).filter_eq]
erw [(filter_basis.of_sets s).generate, ‚Üê (has_basis_generate s).filter_eq] ; refl
refl
intros
ext x
suffices : (‚àÄ t ‚àà l, x ‚àà t) ‚Üî ‚àÄ i, p i ‚Üí x ‚àà s i
simpa only [mem_Inter, mem_set_of_eq, mem_sInter]
simpa only [mem_Inter, mem_set_of_eq, mem_sInter]
simp_rw h.mem_iff
split
intros h i hi
{ intros h i hi, exact h (s i) ‚ü®i, hi, subset.refl _‚ü© }
exact h (s i) ‚ü®i, hi, subset.refl _‚ü©
rintros h _ ‚ü®i, hi, sub‚ü©
{ rintros h _ ‚ü®i, hi, sub‚ü©, exact sub (h i hi) }
exact sub (h i hi)
intros
simp
intros
rw [‚Üê principal_singleton, comap_principal]
intros
simp only [filter.push_pull, inf_comm]
intros
simp only [tendsto_def, mem_inf_principal] at *
intros s hs
filter_upwards [h‚ÇÄ s hs, h‚ÇÅ s hs]
simp only [mem_preimage]
intros x hp‚ÇÄ hp‚ÇÅ
split_ifs
exacts [hp‚ÇÄ h, hp‚ÇÅ h]
intros
rw [‚Üê e.bdd_below_image, e.image_preimage]
intros
refine le_antisymm _ (hy _)
{ refine le_antisymm _ (hy _), rw [‚Üê f.apply_symm_apply y, f.map_rel_iff], apply hx }
rw [‚Üê f.apply_symm_apply y, f.map_rel_iff]
apply hx
intros
rw [(Œî), sdiff_bot, bot_sdiff, sup_bot_eq]
intros
rw [set.partially_well_ordered_on]
apply forall_congr (Œª f, _)
simp [is_bad_seq]
intros
intros t1 t2 ht1 ht2
{intros t1 t2 ht1 ht2, cases h with n h, exact h t1 t2 (set.mem_Inter.mp ht1 n) ht2 }
cases h with n h
exact h t1 t2 (set.mem_Inter.mp ht1 n) ht2
intros
delta algebra.is_algebraic subalgebra.is_algebraic
rw [subtype.forall']
apply forall_congr
rintro ‚ü®x, hx‚ü©
apply exists_congr
intro p
apply and_congr iff.rfl
have h : function.injective (S.val) := subtype.val_injective
conv_rhs { rw [‚Üê h.eq_iff, alg_hom.map_zero], }
rw [‚Üê aeval_alg_hom_apply, S.val_apply]
intros
{ rw mul_comm at H, exact H.of_mul_right_left }
rw mul_comm at H
exact H.of_mul_right_left
intros
obtain ‚ü®n, hn‚ü© := associated_pow_irreducible hx hirr
obtain ‚ü®u, rfl‚ü© := hn.symm
use [n, u]
apply mul_comm
intros
{ ext, simp [submodule.mem_span_singleton, eq_comm] }
ext
simp [submodule.mem_span_singleton, eq_comm]
intros
split
intro hJ
{ intro hJ, refine ‚ü®‚ü®{x : R | algebra_map R P x ‚àà J}, _, _, _‚ü©, _‚ü©, { rw [mem_set_of_eq, ring_hom.map_zero], exact J.val.zero_mem }, { intros a b ha hb, rw [mem_set_of_eq, ring_hom.map_add], exact J.val.add_mem ha hb }, { intros c x hx, rw [smul_eq_mul, mem_set_of_eq, ring_hom.map_mul, ‚Üê algebra.smul_def], exact J.val.smul_mem c hx }, { ext x, split, { rintros ‚ü®y, hy, eq_y‚ü©, rwa ‚Üê eq_y }, { intro hx, obtain ‚ü®y, eq_x‚ü© := (fractional_ideal.mem_one_iff S).mp (hJ hx), rw ‚Üê eq_x at *, exact ‚ü®y, hx, rfl‚ü© } } }
refine ‚ü®‚ü®{x : R | algebra_map R P x ‚àà J}, _, _, _‚ü©, _‚ü©
rw [mem_set_of_eq, ring_hom.map_zero]
{ rw [mem_set_of_eq, ring_hom.map_zero], exact J.val.zero_mem }
exact J.val.zero_mem
intros a b ha hb
{ intros a b ha hb, rw [mem_set_of_eq, ring_hom.map_add], exact J.val.add_mem ha hb }
rw [mem_set_of_eq, ring_hom.map_add]
exact J.val.add_mem ha hb
intros c x hx
{ intros c x hx, rw [smul_eq_mul, mem_set_of_eq, ring_hom.map_mul, ‚Üê algebra.smul_def], exact J.val.smul_mem c hx }
rw [smul_eq_mul, mem_set_of_eq, ring_hom.map_mul, ‚Üê algebra.smul_def]
exact J.val.smul_mem c hx
ext x
{ ext x, split, { rintros ‚ü®y, hy, eq_y‚ü©, rwa ‚Üê eq_y }, { intro hx, obtain ‚ü®y, eq_x‚ü© := (fractional_ideal.mem_one_iff S).mp (hJ hx), rw ‚Üê eq_x at *, exact ‚ü®y, hx, rfl‚ü© } }
split
rintros ‚ü®y, hy, eq_y‚ü©
{ rintros ‚ü®y, hy, eq_y‚ü©, rwa ‚Üê eq_y }
rwa ‚Üê eq_y
intro hx
{ intro hx, obtain ‚ü®y, eq_x‚ü© := (fractional_ideal.mem_one_iff S).mp (hJ hx), rw ‚Üê eq_x at *, exact ‚ü®y, hx, rfl‚ü© }
obtain ‚ü®y, eq_x‚ü© := (fractional_ideal.mem_one_iff S).mp (hJ hx)
rw ‚Üê eq_x at *
exact ‚ü®y, hx, rfl‚ü©
rintro ‚ü®I, hI‚ü©
{ rintro ‚ü®I, hI‚ü©, rw ‚Üê hI, apply coe_ideal_le_one }
rw ‚Üê hI
apply coe_ideal_le_one
intros
ext g
by_cases hg : g ‚àà set.range f
obtain ‚ü®a, rfl‚ü© := hg
{ obtain ‚ü®a, rfl‚ü© := hg, simp }
simp
{ simp [emb_domain_notin_range, hg] }
simp [emb_domain_notin_range, hg]
intros
rw [‚Üêgcd_eq_one_iff_coprime, nat.coprime_iff_gcd_eq_one, gcd_eq_nat_abs]
intros
letI : algebra R S := f.to_algebra
have := fg_mul _ _ (fg_adjoin_singleton_of_integral x hx) (fg_adjoin_singleton_of_integral y hy)
rw [‚Üê algebra.adjoin_union_coe_submodule, set.singleton_union] at this
exact is_integral_of_mem_of_fg (algebra.adjoin R {x, y}) this z (algebra.mem_adjoin_iff.2 $ subring.closure_mono (set.subset_union_right _ _) hz)
intros
rw [‚Üê enat.coe_inj, enat.coe_get, unique hk hsucc]
intros
simp [frange, eq_comm]
intros
obtain ‚ü®n, rfl‚ü© := nat.exists_eq_add_of_le h
rw add_comm
exact U_add_two R n
intros
rw degree_cyclotomic n R
{ rw degree_cyclotomic n R, exact_mod_cast (nat.totient_pos hpos) }
exact_mod_cast (nat.totient_pos hpos)
intros
simp
intros
obtain ‚ü®f, rfl‚ü© := pb.exists_eq_aeval' x
obtain ‚ü®g, rfl‚ü© := pb.exists_eq_aeval' x'
simp only [‚Üê aeval_mul, pb.constr_pow_aeval hy]
intros
simp
intros
by_cases hp0 : p = 0
{ simp [hp0] }
simp [hp0]
refine ‚ü®Œª h, _, prime.irreducible‚ü©
obtain ‚ü®f, hf‚ü© := pf p hp0
obtain ‚ü®q, hq, rfl‚ü© := prime_factors_irreducible h hf
rw hq.prime_iff
exact hf.1 q (multiset.mem_singleton_self _)
intros
apply le_antisymm
rintro ‚ü®x‚ü© hx
{ rintro ‚ü®x‚ü© hx, apply ideal.subset_span, exact ‚ü®x, hx, rfl‚ü© }
apply ideal.subset_span
exact ‚ü®x, hx, rfl‚ü©
rw ideal.map_le_iff_le_comap
{ rw ideal.map_le_iff_le_comap, intros x hx, exact hx }
intros x hx
exact hx
intros
rw [‚Üê frobenius_verschiebung, frobenius_zmodp]
intros
witt_truncate_fun_tac
intros
apply nat.strong_induction_on n; clear n
apply nat.strong_induction_on n
clear n
intros n IH
rw [X_in_terms_of_W_eq, mul_comm, ring_hom.map_mul, ring_hom.map_sub, ring_hom.map_sum, constant_coeff_C, sum_eq_zero]
{ simp only [constant_coeff_X, sub_zero, mul_zero] }
simp only [constant_coeff_X, sub_zero, mul_zero]
intros m H
{ intros m H, rw mem_range at H, simp only [ring_hom.map_mul, ring_hom.map_pow, constant_coeff_C, IH m H], rw [zero_pow, mul_zero], apply pow_pos hp.1.pos, }
rw mem_range at H
simp only [ring_hom.map_mul, ring_hom.map_pow, constant_coeff_C, IH m H]
rw [zero_pow, mul_zero]
apply pow_pos hp.1.pos
intros
{unfold_sizeof, apply sizeof_pos}
unfold_sizeof
apply sizeof_pos
intros
simp only [le_antisymm_iff, succ_le_succ]
intros
simp
intros
simpa [normalize_fin_lt, ‚Üê e, ‚Üê hn] using h
intro h1
rcases h1 with ‚ü®c,h1,h2‚ü©
cases h1
intros
constructor; intro h1
constructor
intro h1
{ cases h1, apply le_antisymm; assumption }
cases h1
apply le_antisymm
apply le_antisymm; assumption
assumption
assumption
intro h1
constructor; apply le_of_eq; rw h1
constructor; apply le_of_eq
{ constructor; apply le_of_eq; rw h1 }
constructor
apply le_of_eq
rw h1
apply le_of_eq
rw h1
intros
simp [horner]
intros
induction xs generalizing ys i
case list.nil : ys i h‚ÇÅ h‚ÇÇ { cases h‚ÇÇ }
cases h‚ÇÇ
case list.cons : x' xs xs_ih ys i h‚ÇÅ h‚ÇÇ { cases i, { injection h‚ÇÇ with h‚ÇÄ h‚ÇÅ, subst h‚ÇÄ, cases ys, { cases h‚ÇÅ }, { simp only [list.apply_id, to_sigma, option.get_or_else_some, nth, lookup_cons_eq, zip_cons_cons, list.map], } }, { cases ys, { cases h‚ÇÅ }, { cases h‚ÇÄ with _ _ h‚ÇÄ h‚ÇÅ, simp only [nth, zip_cons_cons, list.apply_id_cons] at h‚ÇÇ ‚ä¢, rw if_neg, { apply xs_ih; solve_by_elim [succ.inj] }, { apply h‚ÇÄ, apply nth_mem h‚ÇÇ } } } }
intros
simp [nhds_infty_eq, and_comm]
intros
rw set_like.ext'_iff at hs ‚ä¢
simp only [subgroup.topological_closure_coe, subgroup.coe_top, ‚Üê dense_iff_closure_eq] at hs ‚ä¢
exact hf'.dense_image hf hs
intros
convert hs.to_finset.summable f; simp only [hs.coe_to_finset]
convert hs.to_finset.summable f
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
intros
refine iff.trans _ ((range k).has_sum_compl_iff)
rw [‚Üê (not_mem_range_equiv k).symm.has_sum_iff]
refl
intros
have hx : 0 < 2 * (1 + abs x) := (mul_pos (zero_lt_two) $ lt_of_lt_of_le zero_lt_one $ le_add_of_le_of_nonneg le_rfl (abs_nonneg x))
rw ((nhds_basis_zero_abs_sub_lt Œ±).prod $ nhds_basis_abs_sub_lt x).tendsto_iff (nhds_basis_zero_abs_sub_lt Œ±)
refine Œª Œµ Œµ_pos, ‚ü®(Œµ/(2 * (1 + abs x)), 1), ‚ü®div_pos Œµ_pos hx, zero_lt_one‚ü©, _‚ü©
suffices : ‚àÄ (a b : Œ±), abs a < Œµ / (2 * (1 + abs x)) ‚Üí abs (b - x) < 1 ‚Üí (abs a) * (abs b) < Œµ
simpa only [and_imp, prod.forall, mem_prod, ‚Üê abs_mul]
simpa only [and_imp, prod.forall, mem_prod, ‚Üê abs_mul]
intros a b h h'
refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h)
calc abs b = abs ((b - x) + x) : by rw sub_add_cancel b x ... ‚â§ abs (b - x) + abs x : abs_add (b - x) x ... ‚â§ 1 + abs x : add_le_add_right (le_of_lt h') (abs x) ... ‚â§ 2 * (1 + abs x) : by linarith
intros
rw [‚Üê compl_Iio, interior_compl, closure_Iio, compl_Iic]
intros
rw [‚Üê nhds_within_union, Iic_union_Ioi, nhds_within_univ]
intros
rw union_eq_Union; exact is_open_Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)
rw union_eq_Union
exact is_open_Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)
intros
simp [closure_eq_compl_interior_compl]
intros
simp only [cluster_pt, inf_eq_left.mpr H, nhds_ne_bot]
intros
simp
intros
rw ‚Üêset.image_univ
{ rw ‚Üêset.image_univ, exact is_closed_map_sigma_mk _ is_closed_univ }
exact is_closed_map_sigma_mk _ is_closed_univ
intros
simp only [norm_eq, coe_norm_comp, norm_norm]
intros
intros x hx
by_cases hx' : x ‚àà frontier t
exact (hpf x ‚ü®hx, hx'‚ü©).piecewise_nhds_within (hpg x ‚ü®hx, hx'‚ü©)
{ exact (hpf x ‚ü®hx, hx'‚ü©).piecewise_nhds_within (hpg x ‚ü®hx, hx'‚ü©) }
rw [‚Üê inter_univ s, ‚Üê union_compl_self t, inter_union_distrib_left] at hx ‚ä¢
{ rw [‚Üê inter_univ s, ‚Üê union_compl_self t, inter_union_distrib_left] at hx ‚ä¢, cases hx, { apply continuous_within_at.union, { exact (hf x hx).congr (Œª y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2) }, { have : x ‚àâ closure t·∂ú, from Œª h, hx' ‚ü®subset_closure hx.2, by rwa closure_compl at h‚ü©, exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2) } }, { apply continuous_within_at.union, { have : x ‚àâ closure t, from (Œª h, hx' ‚ü®h, (Œª (h' : x ‚àà interior t), hx.2 (interior_subset h'))‚ü©), exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2) }, { exact (hg x hx).congr (Œª y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2) } } }
cases hx
apply continuous_within_at.union
{ apply continuous_within_at.union, { exact (hf x hx).congr (Œª y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2) }, { have : x ‚àâ closure t·∂ú, from Œª h, hx' ‚ü®subset_closure hx.2, by rwa closure_compl at h‚ü©, exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2) } }
exact (hf x hx).congr (Œª y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2)
{ exact (hf x hx).congr (Œª y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2) }
have : x ‚àâ closure t·∂ú
{ have : x ‚àâ closure t·∂ú, from Œª h, hx' ‚ü®subset_closure hx.2, by rwa closure_compl at h‚ü©, exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2) }
from Œª h, hx' ‚ü®subset_closure hx.2, by rwa closure_compl at h‚ü©
exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2)
apply continuous_within_at.union
{ apply continuous_within_at.union, { have : x ‚àâ closure t, from (Œª h, hx' ‚ü®h, (Œª (h' : x ‚àà interior t), hx.2 (interior_subset h'))‚ü©), exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2) }, { exact (hg x hx).congr (Œª y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2) } }
have : x ‚àâ closure t
{ have : x ‚àâ closure t, from (Œª h, hx' ‚ü®h, (Œª (h' : x ‚àà interior t), hx.2 (interior_subset h'))‚ü©), exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2) }
from (Œª h, hx' ‚ü®h, (Œª (h' : x ‚àà interior t), hx.2 (interior_subset h'))‚ü©)
exact continuous_within_at_of_not_mem_closure (Œª h, this (closure_inter_subset_inter_closure _ _ h).2)
exact (hg x hx).congr (Œª y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2)
{ exact (hg x hx).congr (Œª y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2) }
intros
obtain ‚ü®x,hx‚ü© := is_compact.nonempty_Inter_of_directed_nonempty_compact_closed (Œª (Q : discrete_quotient X), Q.proj ‚Åª¬π' {Qs _}) (Œª A B, _) (Œª i, _) (Œª i, (fiber_closed _ _).is_compact) (Œª i, fiber_closed _ _)
refine ‚ü®x, Œª Q, _‚ü©
{ refine ‚ü®x, Œª Q, _‚ü©, specialize hx _ ‚ü®Q,rfl‚ü©, dsimp at hx, rcases proj_surjective _ (Qs Q) with ‚ü®y,hy‚ü©, rw ‚Üê hy at *, rw fiber_eq at hx, exact quotient.sound' (Q.symm y x hx) }
specialize hx _ ‚ü®Q,rfl‚ü©
dsimp at hx
rcases proj_surjective _ (Qs Q) with ‚ü®y,hy‚ü©
rw ‚Üê hy at *
rw fiber_eq at hx
exact quotient.sound' (Q.symm y x hx)
refine ‚ü®A ‚äì B, Œª a ha, _, Œª a ha, _‚ü©
{ refine ‚ü®A ‚äì B, Œª a ha, _, Œª a ha, _‚ü©, { dsimp only, erw ‚Üê compat (A ‚äì B) A inf_le_left, exact fiber_le_of_le _ _ ha }, { dsimp only, erw ‚Üê compat (A ‚äì B) B inf_le_right, exact fiber_le_of_le _ _ ha } }
dsimp only
{ dsimp only, erw ‚Üê compat (A ‚äì B) A inf_le_left, exact fiber_le_of_le _ _ ha }
erw ‚Üê compat (A ‚äì B) A inf_le_left
exact fiber_le_of_le _ _ ha
dsimp only
{ dsimp only, erw ‚Üê compat (A ‚äì B) B inf_le_right, exact fiber_le_of_le _ _ ha }
erw ‚Üê compat (A ‚äì B) B inf_le_right
exact fiber_le_of_le _ _ ha
obtain ‚ü®x,hx‚ü© := i.proj_surjective (Qs i)
{ obtain ‚ü®x,hx‚ü© := i.proj_surjective (Qs i), refine ‚ü®x,_‚ü©, dsimp only, rw [‚Üê hx, fiber_eq], apply i.refl }
refine ‚ü®x,_‚ü©
dsimp only
rw [‚Üê hx, fiber_eq]
apply i.refl
intros
rw [h.nhds_eq_comap, h.apply_symm_apply]
intros
rw _root_.mem_nhds_iff
by_cases x0 : x = 0
use Iio (x + Œµ)
{ use Iio (x + Œµ), have : Iio (x + Œµ) ‚äÜ Icc (x - Œµ) (x + Œµ), assume a, rw x0, simpa using le_of_lt, use this, exact ‚ü®is_open_Iio, mem_Iio_self_add xt Œµ0‚ü© }
have : Iio (x + Œµ) ‚äÜ Icc (x - Œµ) (x + Œµ)
assume a
rw x0
simpa using le_of_lt
use this
exact ‚ü®is_open_Iio, mem_Iio_self_add xt Œµ0‚ü©
use Ioo (x - Œµ) (x + Œµ)
{ use Ioo (x - Œµ) (x + Œµ), use Ioo_subset_Icc_self, exact ‚ü®is_open_Ioo, mem_Ioo_self_sub_add xt x0 Œµ0 Œµ0 ‚ü© }
use Ioo_subset_Icc_self
exact ‚ü®is_open_Ioo, mem_Ioo_self_sub_add xt x0 Œµ0 Œµ0 ‚ü©
intros
rw [iff_symm_preimage_eq, ‚Üê image_source_inter_eq, ‚Üê image_source_inter_eq']
intros
intros s hs; rw [image_comp]; exact hg _ (hf _ hs)
intros s hs; rw [image_comp]
intros s hs
rw [image_comp]
exact hg _ (hf _ hs)
intros
apply proper_space_of_compact_closed_ball_of_le 0 (Œªx‚ÇÄ r hr, _)
let K := f ‚Åª¬π' (closed_ball x‚ÇÄ r)
have A : is_closed K := is_closed_ball.preimage f_cont
have B : bounded K := hK.bounded_preimage bounded_closed_ball
have : is_compact K := compact_iff_closed_bounded.2 ‚ü®A, B‚ü©
convert this.image f_cont
exact (hf.image_preimage _).symm
intros
rw ‚Üê pseudo_metric_space.uniformity_dist.symm
refine has_basis_binfi_principal _ nonempty_Ioi
exact Œª r (hr : 0 < r) p (hp : 0 < p), ‚ü®min r p, lt_min hr hp, Œª x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_left r p), Œª x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_right r p)‚ü©
intros
simpa only [dist_comm _ z] using abs_sub_right_of_mem_interval h
intros
convert tendsto_iterate_efixed_point hf (edist_ne_top x _)
refine (fixed_point_unique _ _).symm
apply efixed_point_is_fixed_pt
intros
funext
simp only [comp, to_inductive_limit, quotient.eq]
show inductive_limit_dist f ‚ü®n.succ, f n x‚ü© ‚ü®n, x‚ü© = 0
rw [inductive_limit_dist_eq_dist I ‚ü®n.succ, f n x‚ü© ‚ü®n, x‚ü© n.succ, le_rec_on_self, le_rec_on_succ, le_rec_on_self, dist_self]
{ rw [inductive_limit_dist_eq_dist I ‚ü®n.succ, f n x‚ü© ‚ü®n, x‚ü© n.succ, le_rec_on_self, le_rec_on_succ, le_rec_on_self, dist_self], exact le_refl _, exact le_refl _, exact le_succ _ }
exact le_refl _
exact le_refl _
exact le_succ _
intros
apply metric.diam_le_of_forall_dist_le (mul_nonneg K.coe_nonneg metric.diam_nonneg)
rintros _ ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©
calc dist (f x) (f y) ‚â§ ‚ÜëK * dist x y : hf.dist_le_mul x y ... ‚â§ ‚ÜëK * metric.diam s : mul_le_mul_of_nonneg_left (metric.dist_le_diam_of_mem hs hx hy) K.2
intros
have : ‚àÄ (s t : set X), is_closed s ‚Üí is_closed t ‚Üí (‚àÄ x ‚àà s, ‚àÉ u v, is_open u ‚àß is_open v ‚àß x ‚àà u ‚àß t ‚äÜ v ‚àß disjoint u v) ‚Üí ‚àÉ u v, is_open u ‚àß is_open v ‚àß s ‚äÜ u ‚àß t ‚äÜ v ‚àß disjoint u v
intros s t hs ht H
{ intros s t hs ht H, choose u v hu hv hxu htv huv using set_coe.forall'.1 H, rcases precise_refinement_set hs u hu (Œª x hx, mem_Union.2 ‚ü®‚ü®x, hx‚ü©, hxu _‚ü©) with ‚ü®u', hu'o, hcov', hu'fin, hsub‚ü©, refine ‚ü®‚ãÉ i, u' i, (closure (‚ãÉ i, u' i))·∂ú, is_open_Union hu'o, is_closed_closure.is_open_compl, hcov', _, disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)‚ü©, rw [hu'fin.closure_Union, compl_Union, subset_Inter_iff], refine Œª i x hxt hxu, absurd (htv i hxt) (closure_minimal _ (is_closed_compl_iff.2 $ hv _) hxu), exact Œª y hyu hyv, huv i ‚ü®hsub _ hyu, hyv‚ü© }
choose u v hu hv hxu htv huv using set_coe.forall'.1 H
rcases precise_refinement_set hs u hu (Œª x hx, mem_Union.2 ‚ü®‚ü®x, hx‚ü©, hxu _‚ü©) with ‚ü®u', hu'o, hcov', hu'fin, hsub‚ü©
refine ‚ü®‚ãÉ i, u' i, (closure (‚ãÉ i, u' i))·∂ú, is_open_Union hu'o, is_closed_closure.is_open_compl, hcov', _, disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)‚ü©
rw [hu'fin.closure_Union, compl_Union, subset_Inter_iff]
refine Œª i x hxt hxu, absurd (htv i hxt) (closure_minimal _ (is_closed_compl_iff.2 $ hv _) hxu)
exact Œª y hyu hyv, huv i ‚ü®hsub _ hyu, hyv‚ü©
refine ‚ü®Œª s t hs ht hst, this s t hs ht (Œª x hx, _)‚ü©
rcases this t {x} ht is_closed_singleton (Œª y hyt, _) with ‚ü®v, u, hv, hu, htv, hxu, huv‚ü©
exact ‚ü®u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symm‚ü©
{ exact ‚ü®u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symm‚ü© }
have : x ‚â† y
{ have : x ‚â† y, by { rintro rfl, exact hst ‚ü®hx, hyt‚ü© }, rcases t2_separation this with ‚ü®v, u, hv, hu, hxv, hyu, hd‚ü©, exact ‚ü®u, v, hu, hv, hyu, singleton_subset_iff.2 hxv, disjoint.symm hd.le‚ü© }
rintro rfl
rintro rfl
{ rintro rfl, exact hst ‚ü®hx, hyt‚ü© }
{ rintro rfl, exact hst ‚ü®hx, hyt‚ü© }
exact hst ‚ü®hx, hyt‚ü©
exact hst ‚ü®hx, hyt‚ü©
rcases t2_separation this with ‚ü®v, u, hv, hu, hxv, hyu, hd‚ü©
exact ‚ü®u, v, hu, hv, hyu, singleton_subset_iff.2 hxv, disjoint.symm hd.le‚ü©
intros
simp_rw [‚Üê lower_semicontinuous_within_at_univ_iff] at *
exact lower_semicontinuous_within_at_sum ha
intros
rcases (nhds_within_has_basis hb s).mem_iff.1 (singleton_mem_nhds_within_of_mem_discrete hx) with ‚ü®i, hi, hix‚ü©
exact ‚ü®i, hi, subset.antisymm hix $ singleton_subset_iff.2 ‚ü®mem_of_mem_nhds $ hb.mem_of_mem hi, hx‚ü©‚ü©
intros
rw [uniform_continuous, uniformity_prod_eq_prod, tendsto_map'_iff, (‚àò)] at hf
rcases mem_map_iff_exists_image'.1 (hf hs) with ‚ü®t, ht, hts‚ü©
clear hf
rcases mem_prod_iff.1 ht with ‚ü®u, hu, v, hv, huvt‚ü©
clear ht
refine ‚ü®u, hu, assume a b c hab, hts $ (mem_image _ _ _).2 ‚ü®‚ü®‚ü®a, b‚ü©, ‚ü®c, c‚ü©‚ü©, huvt ‚ü®_, _‚ü©, _‚ü©‚ü©
exact hab
exact refl_mem_uniformity hv
refl
intros
rw ‚Üê bind_pure_comp_eq_map _ (x.run r); refl
rw ‚Üê bind_pure_comp_eq_map _ (x.run r)
refl
intros
cases a; cases b; exact dec_trivial
cases a; cases b
cases a
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw [int.sub_eq_add_neg, int.add_assoc, ‚Üêint.sub_eq_add_neg]
intros
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.add_comm] at h
intros
cases l; refl
cases l
refl
refl
intros
simp [gcd]
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
{ ext, refl }
ext
refl
intros
rw [prod_insert (not_mem_singleton.2 h), prod_singleton]
intros
{ simp_rw apply_ite k, exact prod_ite_of_true _ _ h }
simp_rw apply_ite k
exact prod_ite_of_true _ _ h
intros
rw [univ_filter_succ_lt, finset.prod_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
by_contra h'
push_neg at h'
exact h (finprod_mem_of_eq_on_one h')
intros
simp only [finsupp.sum, finset.mul_sum]
intros
refine le_trans (multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _
{ simp [hs_nonempty.ne_empty], }
simp [hs_nonempty.ne_empty]
{ exact multiset.forall_mem_map_iff.mpr hs, }
exact multiset.forall_mem_map_iff.mpr hs
rw multiset.map_map
refl
intros
suffices : (2 : R) ‚â† 0
symmetry
{ symmetry, rw [ne.def, ‚Üê sub_eq_zero, sub_neg_eq_add], exact this }
rw [ne.def, ‚Üê sub_eq_zero, sub_neg_eq_add]
exact this
assume h
rw [show (2 : R) = (2 : ‚Ñï), by norm_cast] at h
have := (char_p.cast_eq_zero_iff R p 2).mp h
have := nat.le_of_dvd dec_trivial this
rw fact_iff at *
linarith
intros
rw [terminated_at_iff_s_none] at terminated_at_n
{ rw [terminated_at_iff_s_none] at terminated_at_n, simp only [terminated_at_n, continuants_aux] }
simp only [terminated_at_n, continuants_aux]
intros
rw lcm
by_cases h : gcd x y = 0
rw [h, zero_mul]
{ rw [h, zero_mul], rw euclidean_domain.gcd_eq_zero_iff at h, rw [h.1, zero_mul] }
rw euclidean_domain.gcd_eq_zero_iff at h
rw [h.1, zero_mul]
rcases gcd_dvd x y with ‚ü®‚ü®r, hr‚ü©, ‚ü®s, hs‚ü©‚ü©
generalize_hyp : gcd x y = g at h hr ‚ä¢
subst hr
rw [mul_assoc, mul_div_cancel_left _ h]
intros
simp [geom_sum_def, f.map_sum]
intros
{ ext z, rw [function.comp_apply, @is_associative.assoc _ f] }
ext z
rw [function.comp_apply, @is_associative.assoc _ f]
intros
rw [sub_eq_add_neg, add_neg_eq_iff_eq_add]
intros
rw [sub_eq_iff_eq_add, sub_add_eq_add_sub, eq_comm, sub_eq_iff_eq_add']
simp only [add_comm, eq_comm]
intros
rw [units.inv_mul_eq_iff_eq_mul, mul_one, coe_lift_right]
intros
induction n with n ih; [exact pow_zero _, rw [pow_succ, ih, one_mul]]
induction n with n ih
exact pow_zero _
rw [pow_succ, ih, one_mul]
intros
induction b with b ih
{ erw [pow_zero, to_add_one, mul_zero] }
erw [pow_zero, to_add_one, mul_zero]
{ simp [*, pow_succ, add_comm, nat.mul_succ] }
simp [*, pow_succ, add_comm, nat.mul_succ]
intros
rw [div_eq_mul_inv, mul_inv_mul_self a]
intros
rw [div_eq_mul_inv, mul_comm]
intros
cases i; refl
{ cases i; refl, }
cases i
refl
refl
intros
rw C.d_from_eq r
apply kernel_subobject_comp_mono
intros
{ dsimp [cycles], simp, }
dsimp [cycles]
simp
intros
dsimp [d_next]
rcases c.next i with _|‚ü®i',w‚ü©
{ exact comp_zero.symm, }
exact comp_zero.symm
dsimp [d_next]
{ dsimp [d_next], simp, }
simp
intros
{ rw [d_to_eq ((single‚ÇÄ V).obj X) rfl], simp, }
rw [d_to_eq ((single‚ÇÄ V).obj X) rfl]
simp
intros
rw [sub_eq_add_neg, indicator_compl']
intros
ext
{ ext, simp only [coe_max_triv_equiv_apply, lie_module_equiv.refl_apply], }
simp only [coe_max_triv_equiv_apply, lie_module_equiv.refl_apply]
intros
ext x y
rcases x
rcases x; rcases y
rcases y
by_cases h : x = y; simp [Pso, indefinite_diagonal, h]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h], }
simp [Pso, indefinite_diagonal, h]
simp [Pso, indefinite_diagonal, h]
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
rcases y
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi], }
simp [Pso, indefinite_diagonal, h, hi]
simp [Pso, indefinite_diagonal, h, hi]
intros
induction k with k ih
{ simp only [function.iterate_zero], }
simp only [function.iterate_zero]
simp only [lower_central_series_succ, function.comp_app, function.iterate_succ', to_endomorphism_apply_apply]
{ simp only [lower_central_series_succ, function.comp_app, function.iterate_succ', to_endomorphism_apply_apply], exact lie_submodule.lie_mem_lie _ _ (lie_submodule.mem_top x) ih, }
exact lie_submodule.lie_mem_lie _ _ (lie_submodule.mem_top x) ih
intros
{ rw [‚Üêlie_skew, ‚Üêneg_lie], apply lie_mem_right, assumption, }
rw [‚Üêlie_skew, ‚Üêneg_lie]
apply lie_mem_right
assumption
intros
{ rw map_le_iff_le_comap, apply le_refl _, }
rw map_le_iff_le_comap
apply le_refl _
intros
split
split; intros h
intros h
{ ext, rw [‚Üê mem_coe_submodule, h], simp, }
ext
rw [‚Üê mem_coe_submodule, h]
simp
intros h
{ rw h, }
rw h
intros
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_inj] at hab
exact eq_of_smul_eq_smul_of_pos_of_le hab (neg_pos_of_neg hc) h
intros
rw [mul_comm, lt_div_iff hc]
intros
rw [div_eq_mul_inv, div_eq_mul_inv]
exact mul_le_mul_of_nonneg_left ((inv_le_inv (hc.trans_le h) hc).mpr h) ha
intros
simp [lt_max_iff, max_lt_iff, *]
intros
rw [‚Üê mul_lt_mul_iff_left a, mul_inv_self, mul_one]
intros
rw [‚Üê inv_mul_le_iff_le_mul, mul_comm]
intros
simpa only [div_eq_mul_inv] using max_mul_mul_right a b (c‚Åª¬π)
intros
simpa [min_comm _ c] using min_mul_distrib c a b
intros
have : 0 < a * ‚Öüa
simp only [mul_inv_of_self, zero_lt_one]
simp only [mul_inv_of_self, zero_lt_one]
exact ‚ü®Œª h, pos_of_mul_pos_right this h.le, Œª h, pos_of_mul_pos_left this h.le‚ü©
intros
by_cases ha : a ‚â§ 0
simp [le_antisymm ha h‚ÇÅ]
{ simp [le_antisymm ha h‚ÇÅ] }
by_cases hb : b ‚â§ 0
simp [le_antisymm hb h‚ÇÇ]
{ simp [le_antisymm hb h‚ÇÇ] }
exact (le_not_le_of_lt (ordered_ring.mul_pos a b (h‚ÇÅ.lt_of_not_le ha) (h‚ÇÇ.lt_of_not_le hb))).1
intros
simp * at *
intros
simp only [‚Üê inv_preimage]
{ simp only [‚Üê inv_preimage], rw [image_eq_preimage_of_inverse]; intro; simp only [inv_inv] }
rw [image_eq_preimage_of_inverse]
rw [image_eq_preimage_of_inverse]; intro; simp only [inv_inv]
rw [image_eq_preimage_of_inverse]; intro
intro
simp only [inv_inv]
simp only [inv_inv]
intro
simp only [inv_inv]
simp only [inv_inv]
intros
simpa using nat_degree_multiset_prod_le (s.1.map f)
intros
rw [map_one, eq_comm]
intros
rw [add_mul, mul_sub, mul_sub, mul_comm a b, sub_add_sub_cancel]
intros
simp [bit1]
intros
rw [set.mem_compl_eq, mem_zero_locus, set.singleton_subset_iff]
rw [set.mem_compl_eq, mem_zero_locus, set.singleton_subset_iff]; refl
refl
intros
rw is_equivalent_iff_exists_eq_mul
refine ‚ü®u/v, huv, hz.mono $ Œª x hz', (div_mul_cancel_of_imp hz').symm‚ü©
intros
refine ‚ü®div_is_bounded_under_of_is_O, Œª h, _‚ü©
obtain ‚ü®c, hc‚ü© := h
rw filter.eventually_iff at hgf hc
simp only [mem_set_of_eq, mem_map, normed_field.norm_div] at hc
refine is_O_iff.2 ‚ü®c, filter.eventually_of_mem (inter_mem hgf hc) (Œª x hx, _)‚ü©
by_cases hgx : g x = 0
{ simp [hx.1 hgx, hgx] }
simp [hx.1 hgx, hgx]
{ refine (div_le_iff (norm_pos_iff.2 hgx)).mp hx.2 }
refine (div_le_iff (norm_pos_iff.2 hgx)).mp hx.2
intros
simp only [is_O_with, norm_neg]
intros
unfold is_o at *
intros c cpos
rcases h‚ÇÇ.exists_pos with ‚ü®c', c'pos, hc'‚ü©
exact ((h‚ÇÅ (div_pos cpos c'pos)).mul hc').congr_const (div_mul_cancel _ (ne_of_gt c'pos))
intros
have := (has_strict_fderiv_at.mul' hc hd).has_strict_deriv_at
rwa [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.one_apply, one_smul, one_smul, add_comm] at this
intros
intro hg
have := (hf.comp a hg.has_deriv_at).congr_of_eventually_eq hfg.symm
simpa using this.unique (has_deriv_at_id a)
intros
simp only [deriv_within, fderiv_within_add_const hxs]
intros
apply has_fderiv_at.fderiv
exact has_fderiv_at.comp x hg.has_fderiv_at hf.has_fderiv_at
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
{ convert hc.mul_const' d, ext z, apply mul_comm }
convert hc.mul_const' d
ext z
apply mul_comm
intros
rw differentiable_at.fderiv_within e.differentiable_at hxs
exact e.fderiv
intros
apply map_implicit_function_of_complemented_eq
intros
{ ext x, simp [iterated_deriv], refl }
ext x
simp [iterated_deriv]
refl
intros
letI : normed_space ‚Ñù G := restrict_scalars.normed_space ‚Ñù ùïú G
letI : is_scalar_tower ‚Ñù ùïú G := restrict_scalars.is_scalar_tower _ _ _
have C0 : 0 ‚â§ C := le_trans (norm_nonneg _) (bound x xs)
set g : ‚Ñù ‚Üí E := Œª t, x + t ‚Ä¢ (y - x)
have Dg : ‚àÄ t, has_deriv_at g (y-x) t
assume t
{ assume t, simpa only [one_smul] using ((has_deriv_at_id t).smul_const (y - x)).const_add x }
simpa only [one_smul] using ((has_deriv_at_id t).smul_const (y - x)).const_add x
have segm : Icc 0 1 ‚äÜ g ‚Åª¬π' s
rw [‚Üê image_subset_iff, ‚Üê segment_eq_image']
{ rw [‚Üê image_subset_iff, ‚Üê segment_eq_image'], apply hs.segment_subset xs ys }
apply hs.segment_subset xs ys
have : f x = f (g 0)
simp only [g]
simp only [g]
{ simp only [g], rw [zero_smul, add_zero] }
{ simp only [g], rw [zero_smul, add_zero] }
rw [zero_smul, add_zero]
rw [zero_smul, add_zero]
rw this
have : f y = f (g 1)
simp only [g]
simp only [g]
{ simp only [g], rw [one_smul, add_sub_cancel'_right] }
{ simp only [g], rw [one_smul, add_sub_cancel'_right] }
rw [one_smul, add_sub_cancel'_right]
rw [one_smul, add_sub_cancel'_right]
rw this
have D2: ‚àÄ t ‚àà Icc (0:‚Ñù) 1, has_deriv_within_at (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t
intros t ht
{ intros t ht, have : has_fderiv_within_at f ((f' (g t)).restrict_scalars ‚Ñù) s (g t), from hf (g t) (segm ht), exact this.comp_has_deriv_within_at _ (Dg t).has_deriv_within_at segm }
have : has_fderiv_within_at f ((f' (g t)).restrict_scalars ‚Ñù) s (g t)
from hf (g t) (segm ht)
exact this.comp_has_deriv_within_at _ (Dg t).has_deriv_within_at segm
apply norm_image_sub_le_of_norm_deriv_le_segment_01' D2
refine Œª t ht, le_of_op_norm_le _ _ _
exact bound (g t) (segm $ Ico_subset_Icc_self ht)
intros
rw f.closure_support_eq
{ rw f.closure_support_eq, exact euclidean.is_compact_closed_ball }
exact euclidean.is_compact_closed_ball
intros
rwa [times_cont_diff_at, ‚Üê times_cont_diff_within_at_inter hx, univ_inter]
intros
set L := Œª m, continuous_multilinear_map.prodL ùïú (Œª i : fin m, E) F G
split
assume x hx
{ assume x hx, rw [‚Üê hf.zero_eq x hx, ‚Üê hg.zero_eq x hx], refl }
rw [‚Üê hf.zero_eq x hx, ‚Üê hg.zero_eq x hx]
refl
assume m hm x hx
{ assume m hm x hx, convert (L m).has_fderiv_at.comp_has_fderiv_within_at x ((hf.fderiv_within m hm x hx).prod (hg.fderiv_within m hm x hx)) }
convert (L m).has_fderiv_at.comp_has_fderiv_within_at x ((hf.fderiv_within m hm x hx).prod (hg.fderiv_within m hm x hx))
assume m hm
{ assume m hm, exact (L m).continuous.comp_continuous_on ((hf.cont m hm).prod (hg.cont m hm)) }
exact (L m).continuous.comp_continuous_on ((hf.cont m hm).prod (hg.cont m hm))
intros
split
assume h x hx
{ assume h x hx, rcases (h x hx) n.succ (le_refl _) with ‚ü®u, hu, p, Hp‚ü©, refine ‚ü®u, hu, Œª y, (continuous_multilinear_curry_fin1 ùïú E F) (p y 1), Œª y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _‚ü©, rw has_ftaylor_series_up_to_on_succ_iff_right at Hp, assume z hz m hm, refine ‚ü®u, _, Œª (x : E), (p x).shift, Hp.2.2.of_le hm‚ü©, convert self_mem_nhds_within, exact insert_eq_of_mem hz, }
rcases (h x hx) n.succ (le_refl _) with ‚ü®u, hu, p, Hp‚ü©
refine ‚ü®u, hu, Œª y, (continuous_multilinear_curry_fin1 ùïú E F) (p y 1), Œª y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _‚ü©
rw has_ftaylor_series_up_to_on_succ_iff_right at Hp
assume z hz m hm
refine ‚ü®u, _, Œª (x : E), (p x).shift, Hp.2.2.of_le hm‚ü©
convert self_mem_nhds_within
exact insert_eq_of_mem hz
assume h x hx
{ assume h x hx, rw times_cont_diff_within_at_succ_iff_has_fderiv_within_at, rcases h x hx with ‚ü®u, u_nhbd, f', hu, hf'‚ü©, have : x ‚àà u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd, exact ‚ü®u, u_nhbd, f', hu, hf' x this‚ü© }
rw times_cont_diff_within_at_succ_iff_has_fderiv_within_at
rcases h x hx with ‚ü®u, u_nhbd, f', hu, hf'‚ü©
have : x ‚àà u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd
exact ‚ü®u, u_nhbd, f', hu, hf' x this‚ü©
intros
intros x y hx hy a b ha hb hab
rw [set.eq_of_mem_singleton hx, set.eq_of_mem_singleton hy, ‚Üêadd_smul, hab, one_smul]
exact mem_singleton c
intros
intros s x hx
rw ‚Üêf.injective.mem_set_image
exact hc _ _ (by rwa set.image_image)
intros
simpa only [metric.ball, sep_univ] using (convex_on_dist a _ convex_univ).convex_lt r
intros
rw [‚Üêinner_conj_sym, abs_conj]
intros
{ rw[‚Üêinner_self_re_abs], exact inner_self_re_to_K }
rw[‚Üêinner_self_re_abs]
exact inner_self_re_to_K
intros
refine ‚ü®Œª h, _, Œª h, eq_orthogonal_projection_of_mem_of_inner_eq_zero h _‚ü©
rw ‚Üê h
{ rw ‚Üê h, simp }
simp
{ simp }
simp
intros
by_cases A : ‚àÉ i ‚àà s, z i = 0 ‚àß w i ‚â† 0
rcases A with ‚ü®i, his, hzi, hwi‚ü©
{ rcases A with ‚ü®i, his, hzi, hwi‚ü©, rw [prod_eq_zero his], { exact sum_nonneg (Œª j hj, mul_nonneg (hw j hj) (hz j hj)) }, { rw hzi, exact zero_rpow hwi } }
rw [prod_eq_zero his]
{ exact sum_nonneg (Œª j hj, mul_nonneg (hw j hj) (hz j hj)) }
exact sum_nonneg (Œª j hj, mul_nonneg (hw j hj) (hz j hj))
{ rw hzi, exact zero_rpow hwi }
rw hzi
exact zero_rpow hwi
simp only [not_exists, not_and, ne.def, not_not] at A
{ simp only [not_exists, not_and, ne.def, not_not] at A, have := convex_on_exp.map_sum_le hw hw' (Œª i _, set.mem_univ $ log (z i)), simp only [exp_sum, (‚àò), smul_eq_mul, mul_comm (w _) (log _)] at this, convert this using 1; [apply prod_congr rfl, apply sum_congr rfl]; intros i hi, { cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { exact rpow_def_of_pos hz _ } }, { cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { rw [exp_log hz] } } }
have := convex_on_exp.map_sum_le hw hw' (Œª i _, set.mem_univ $ log (z i))
simp only [exp_sum, (‚àò), smul_eq_mul, mul_comm (w _) (log _)] at this
convert this using 1; [apply prod_congr rfl, apply sum_congr rfl]; intros i hi
convert this using 1; [apply prod_congr rfl, apply sum_congr rfl]
convert this using 1
apply prod_congr rfl
intros i hi
cases eq_or_lt_of_le (hz i hi) with hz hz
{ cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { exact rpow_def_of_pos hz _ } }
{ simp [A i hi hz.symm] }
simp [A i hi hz.symm]
{ exact rpow_def_of_pos hz _ }
exact rpow_def_of_pos hz _
apply sum_congr rfl
intros i hi
cases eq_or_lt_of_le (hz i hi) with hz hz
{ cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { rw [exp_log hz] } }
{ simp [A i hi hz.symm] }
simp [A i hi hz.symm]
{ rw [exp_log hz] }
rw [exp_log hz]
intros
simp [nndist_dist]
intros
rcases s with ‚ü®‚ü®l‚ü©, hl‚ü©
simpa using (l.map f).norm_prod_le
intros
simpa only [dist_add_left, dist_add_right, dist_comm h‚ÇÇ] using abs_dist_sub_le (g‚ÇÅ + g‚ÇÇ) (h‚ÇÅ + h‚ÇÇ) (h‚ÇÅ + g‚ÇÇ)
intros
rw [mem_closed_ball', dist_eq_norm]
intros
rw show (Œª e, -f e) = (Œª e, (-1 : ùïú) ‚Ä¢ f e), { funext, simp }
exact smul (-1) hf
intros
rcases hf' with ‚ü®cf, hcf, lif, hlif‚ü©
rcases hg' with ‚ü®cg, hcg, lig, hlig‚ü©
refine ‚ü®cg * cf, mul_ne_zero hcg hcf, lig.comp lif, funext (Œª x, _)‚ü©
simp only [coe_comp', linear_isometry.coe_comp, hlif, hlig, pi.smul_apply, function.comp_app, linear_isometry.map_smul, smul_smul]
intros
simp only [norm_indicator_eq_indicator_norm]
exact indicator_le_indicator_of_subset ‚Äπ_‚Ä∫ (Œª _, norm_nonneg _) _
intros
{ erw f.to_add_monoid_hom.mem_ker, refl }
erw f.to_add_monoid_hom.mem_ker
refl
intros
rw ‚Üêsingleton_subset_iff at h
rw [‚Üêunion_eq_self_of_subset_left h]
exact balanced_zero_union_interior hA
intros
have hderiv : deriv (Œª x : ‚Ñù, x ^ (n + 1) / (n + 1)) = Œª x, x ^ n
ext
{ ext, have hne : (n + 1 : ‚Ñù) ‚â† 0 := by exact_mod_cast succ_ne_zero n, simp [mul_div_assoc, mul_div_cancel' _ hne] }
have hne : (n + 1 : ‚Ñù) ‚â† 0 := by exact_mod_cast succ_ne_zero n
simp [mul_div_assoc, mul_div_cancel' _ hne]
rw integral_deriv_eq_sub' _ hderiv; norm_num [div_sub_div_same, continuous_on_pow]
rw integral_deriv_eq_sub' _ hderiv
norm_num [div_sub_div_same, continuous_on_pow]
norm_num [div_sub_div_same, continuous_on_pow]
norm_num [div_sub_div_same, continuous_on_pow]
intros
simp only [mul_comm, interval_integrable.const_mul c h]
intros
rw [‚Üê nnreal.coe_eq, coe_rpow, nnreal.coe_pow]
{ rw [‚Üê nnreal.coe_eq, coe_rpow, nnreal.coe_pow], exact real.pow_nat_rpow_nat_inv x.2 hn }
exact real.pow_nat_rpow_nat_inv x.2 hn
intros
simpa using rpow_add_int hx y (-n)
intros
obtain hx | rfl := hx.lt_or_eq
{ exact (le_rpow_iff_log_le hx hy).2 h }
exact (le_rpow_iff_log_le hx hy).2 h
exact (real.rpow_pos_of_pos hy z).le
simp [arctan_eq_arcsin]
intros
rw [‚Üê cos_neg, neg_sub, cos_sub_pi_div_two]
exact_mod_cast real.pi_pos
intros
simp only [le_antisymm_iff, arcsin_le_iff_le_sin' (mem_Ico_of_Ioo hy), le_arcsin_iff_sin_le' (mem_Ioc_of_Ioo hy)]
intros
rw [‚Üê arcsin_proj_Icc, proj_Icc_of_le_left _ hx, subtype.coe_mk, arcsin_neg_one]
intros
ext
dsimp [transfer_nat_trans_self, transfer_nat_trans]
simp only [id_comp, comp_id]
rw [‚Üêadj‚ÇÉ.unit_naturality_assoc, ‚ÜêR‚ÇÉ.map_comp, g.naturality_assoc, L‚ÇÇ.map_comp, assoc, adj‚ÇÇ.counit_naturality, adj‚ÇÇ.left_triangle_components_assoc, assoc]
intros
rw [‚Üêid_comp (e.inverse.map _), ‚Üêmap_id e.inverse, ‚Üêcounit_inv_functor_comp, map_comp, ‚Üêiso.hom_inv_id_assoc (e.unit_iso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]
slice_lhs 2 3 { erw [e.unit.naturality] }
slice_lhs 1 2 { erw [e.unit.naturality] }
slice_lhs 4 4 { rw [‚Üêiso.hom_inv_id_assoc (e.inverse.map_iso (e.counit_iso.app _)) (e.unit_inv.app _)] }
slice_lhs 3 4 { erw [‚Üêmap_comp e.inverse, e.counit.naturality], erw [(e.counit_iso.app _).hom_inv_id, map_id] }
erw [id_comp]
slice_lhs 2 3 { erw [‚Üêmap_comp e.inverse, e.counit_iso.inv.naturality, map_comp] }
slice_lhs 3 4 { erw [e.unit_inv.naturality] }
slice_lhs 4 5 { erw [‚Üêmap_comp (e.functor ‚ãô e.inverse), (e.unit_iso.app _).hom_inv_id, map_id] }
erw [id_comp]
slice_lhs 3 4 { erw [‚Üêe.unit_inv.naturality] }
slice_lhs 2 3 { erw [‚Üêmap_comp e.inverse, ‚Üêe.counit_iso.inv.naturality, (e.counit_iso.app _).hom_inv_id, map_id] }
erw [id_comp, (e.unit_iso.app _).hom_inv_id]
refl
intros
convert pullback.condition =‚â´ limits.prod.fst; simp
convert pullback.condition =‚â´ limits.prod.fst
simp
simp
intros
ext
{ ext, rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêG.map_comp, colimit.Œπ_desc, colimit.Œπ_desc], refl }
rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêG.map_comp, colimit.Œπ_desc, colimit.Œπ_desc]
refl
intros
{ ext, simp [‚Üê G.map_comp] }
ext
simp [‚Üê G.map_comp]
intros
ext _ X p
apply (assoc _ _ _).symm
intros
simp
intros
ext
simp [biproduct.Œπ_œÄ, biproduct.Œπ_œÄ_assoc, comp_sum, sum_comp, comp_dite, dite_comp]
intros
{ ext, simp [equalizer.iso_source_of_self], }
ext
simp [equalizer.iso_source_of_self]
intros
simp [image_mono_iso_source]
intros
{ ext, simp, }
ext
simp
intros
{ ext, simp [cokernel_iso_of_eq], }
ext
simp [cokernel_iso_of_eq]
intros
rw [‚Üês.w (line j), parallel_family_map_left]
intros
{ simp, refl }
simp
refl
intros
{ rw [‚Üêleft_unitor_tensor'], simp }
rw [‚Üêleft_unitor_tensor']
simp
intros
rw [iso.inv_comp_eq, F.right_unitality, category.assoc, category.assoc, ‚ÜêF.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
intros
rw [‚Üêfunctor.map_comp, prod_comp, category.id_comp, category.comp_id]
intros
{ induction h, simp, }
induction h
simp
intros
apply (cancel_mono P.arrow).mp
simp
intros
apply quotient.induction_on' f‚ÇÇ
intro f‚ÇÇ
refl
intros
simp [factor_thru_image_subobject, image_subobject_arrow]
intros
erw [category.id_comp, category.comp_id]
refl
intros
rw [‚Üêsdiff_le_sdiff_iff_le, sdiff_eq_empty_iff_subset.2 h]
apply empty_to_colex_le
intros
refine ‚ü®Œª H, by rw H, Œª H, _‚ü©
rcases c with ‚ü®n, c‚ü©
rcases c' with ‚ü®n', c'‚ü©
have : n = n'
rw [‚Üê c.blocks_sum, ‚Üê c'.blocks_sum, H]
rw [‚Üê c.blocks_sum, ‚Üê c'.blocks_sum, H]
{ rw [‚Üê c.blocks_sum, ‚Üê c'.blocks_sum, H] }
{ rw [‚Üê c.blocks_sum, ‚Üê c'.blocks_sum, H] }
induction this
simp only [true_and, eq_self_iff_true, heq_iff_eq]
ext1
exact H
intros
simp [composition_as_set.to_composition, composition.length, composition.blocks]
intros
simp [mul_apply, neighbor_finset_eq_filter, sum_filter]
intros
induction b with x b IH generalizing a d s
{ refine trans_gen.single _, simp, refl }
refine trans_gen.single _
simp
refl
refine trans_gen.head rfl _
simp
exact IH _ _ _
intros
conv {to_rhs, rw [‚Üê add_bottom_map L, list_blank.nth_map]}
conv {to_rhs, rw [‚Üê add_bottom_map L, list_blank.nth_map]}; refl
refl
intros
cases T; simp only [tape.right‚ÇÄ, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self]
cases T
simp only [tape.right‚ÇÄ, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self]
intros
simp only [free.mk, list.ret, list.mfoldl, bind_pure]
intros
ext
ext; simp [id_traverse]; refl
ext; simp [id_traverse]
simp [id_traverse]
refl
intros
simp [bits_to_nat_to_list]
unfold bits_to_nat add_lsb list.foldl cond
simp [cond_to_bool_mod_two]
intros
simpa [h] using mono.le p cb n
intros
simp [seq_eq_bind_map]
intros
ext cb n
rw [str, char_buf]
congr
{ simp [buffer.to_string, string.as_string_inv_to_list] }
simp [buffer.to_string, string.as_string_inv_to_list]
{ simp }
simp
intros
simp [fix_core]
intros
simp [bit0]
intros
rw [‚Üê of_real_int_cast, of_real_re]
intros
rw [lim_eq_lim_im_add_lim_re]; simp
rw [lim_eq_lim_im_add_lim_re]
simp
intros
simp [cos_two_mul, div_add_div_same, mul_div_cancel_left, two_ne_zero', -one_div]
intros
haveI : char_zero K := char_zero_R_or_C
rw [add_conj, mul_div_cancel_left ((re z):K) two_ne_zero']
intros
apply le_antisymm
apply supr_le _
{ apply supr_le _, intros i y hy, exact ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, dfinsupp.sum_add_hom_single _ _ _‚ü©, }
intros i y hy
exact ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, dfinsupp.sum_add_hom_single _ _ _‚ü©
rintros x ‚ü®v, rfl‚ü©
{ rintros x ‚ü®v, rfl‚ü©, exact add_submonoid.dfinsupp_sum_add_hom_mem _ v _ (Œª i _, (le_supr S i : S i ‚â§ _) (v i).prop) }
exact add_submonoid.dfinsupp_sum_add_hom_mem _ v _ (Œª i _, (le_supr S i : S i ‚â§ _) (v i).prop)
intros
rw [perm.subsingleton_eq_refl e, coe_refl]
intros
{ ext, simp only [comp, arrow_congr_apply, eb.symm_apply_apply] }
ext
simp only [comp, arrow_congr_apply, eb.symm_apply_apply]
intros
{ ext1 x, cases x, refl }
ext1 x
cases x
refl
intros
dunfold extend_subtype
{ dunfold extend_subtype, simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply], rw [sum_compl_apply_symm_of_neg _ _ hx, sum.map_inr, sum_compl_apply_inr] }
simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply]
rw [sum_compl_apply_symm_of_neg _ _ hx, sum.map_inr, sum_compl_apply_inr]
intros
simp only [is_image, set.ext_iff, mem_inter_eq, and.congr_right_iff, mem_preimage]
intros
cases h : e (some x) with a
rw remove_none_none _ h
{ rw remove_none_none _ h, simpa using (congr_arg e.symm h).symm }
simpa using (congr_arg e.symm h).symm
rw remove_none_some _ ‚ü®a, h‚ü©
{ rw remove_none_some _ ‚ü®a, h‚ü©, have := (congr_arg e.symm h), rw [symm_apply_apply] at this, simp only [false_iff, apply_eq_iff_eq], simp [this] }
have := (congr_arg e.symm h)
rw [symm_apply_apply] at this
simp only [false_iff, apply_eq_iff_eq]
simp [this]
intros
{ ext j, simp [init, ne_of_lt, cast_succ_lt_last] }
ext j
simp [init, ne_of_lt, cast_succ_lt_last]
intros
split
{ rintros h rfl, exact lt_irrefl _ h, }
rintros h rfl
exact lt_irrefl _ h
rintros h
{ rintros h, apply (@pos_iff_ne_zero _ _ (a : ‚Ñï)).mpr, cases a, rintro w, apply h, simp at w, subst w, refl, }
apply (@pos_iff_ne_zero _ _ (a : ‚Ñï)).mpr
cases a
rintro w
apply h
simp at w
subst w
refl
intros
refine ‚ü®Œª h, _, congr_arg _‚ü©
rw eq_of_mem_of_not_mem_erase hx
rw ‚Üêh
simp
intros
rw [subtype_map, filter_true_of_mem h]
intros
rcases s with ‚ü®‚ü®s‚ü©‚ü©; apply list.mem_cons_iff
rcases s with ‚ü®‚ü®s‚ü©‚ü©
apply list.mem_cons_iff
intros
by_cases (a ‚àà s)
rw [‚Üê insert_erase h]
{ rw [‚Üê insert_erase h], simp [‚Üê ha.assoc, hi.idempotent] }
simp [‚Üê ha.assoc, hi.idempotent]
{ apply fold_insert h }
apply fold_insert h
intros
rw [of_dual, to_dual, equiv.coe_fn_mk, equiv.coe_fn_symm_mk, id.def]
simp_rw (@image_id (order_dual Œ±) (s : finset (order_dual Œ±)))
refl
intros
induction s using quotient.induction_on
simp
intros
let l := s.sort (‚â§)
apply le_antisymm
have : s.min' H ‚àà l := (finset.mem_sort (‚â§)).mpr (s.min'_mem H)
{ have : s.min' H ‚àà l := (finset.mem_sort (‚â§)).mpr (s.min'_mem H), obtain ‚ü®i, i_lt, hi‚ü© : ‚àÉ i (hi : i < l.length), l.nth_le i hi = s.min' H := list.mem_iff_nth_le.1 this, rw ‚Üê hi, exact (s.sort_sorted (‚â§)).rel_nth_le_of_le _ _ (nat.zero_le i) }
obtain ‚ü®i, i_lt, hi‚ü© : ‚àÉ i (hi : i < l.length), l.nth_le i hi = s.min' H := list.mem_iff_nth_le.1 this
rw ‚Üê hi
exact (s.sort_sorted (‚â§)).rel_nth_le_of_le _ _ (nat.zero_le i)
have : l.nth_le 0 h ‚àà s := (finset.mem_sort (‚â§)).1 (list.nth_le_mem l 0 h)
{ have : l.nth_le 0 h ‚àà s := (finset.mem_sort (‚â§)).1 (list.nth_le_mem l 0 h), exact s.min'_le _ this }
exact s.min'_le _ this
intros
simpa [support_single_ne_zero, hb, hb'] using ne_comm
intros
simp [eq_univ_iff_forall, finset.nonempty]
intros
rw [‚Üêlt_eq_ssubset, ‚Üêfinset.lt_iff_ssubset, lt_iff_le_and_ne, lt_iff_le_and_ne]
simp
intros
rw [‚Üê abs_le_iff_mul_self_le, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_le.symm
intros
rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul]
{ rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul], apply nat.gcd_mul_left }
apply nat.gcd_mul_left
intros
unfold gcd_b xgcd
induction s
{ exact absurd rfl h, }
exact absurd rfl h
{ simp [xgcd_aux], }
simp [xgcd_aux]
intros
induction l with hd tl IH generalizing n
simp only [length, nonpos_iff_eq_zero] at hn
{ simp only [length, nonpos_iff_eq_zero] at hn, simp [hn] }
simp [hn]
cases n
{ cases n, { simp }, { simp only [nat.succ_le_succ_iff, length] at hn, simpa using IH _ hn } }
{ simp }
simp
simp only [nat.succ_le_succ_iff, length] at hn
{ simp only [nat.succ_le_succ_iff, length] at hn, simpa using IH _ hn }
simpa using IH _ hn
intros
cases l; cases k; simp [nat.succ_ne_zero]
cases l; cases k
{ cases l; cases k; simp [nat.succ_ne_zero] }
cases l
cases k
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
cases k
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
intros
induction l with x l ih
{ exact dvd_zero _ }
exact dvd_zero _
rw [list.sum_cons]
{ rw [list.sum_cons], exact dvd_add (h _ (mem_cons_self _ _)) (ih (Œª x hx, h x (mem_cons_of_mem _ hx))) }
exact dvd_add (h _ (mem_cons_self _ _)) (ih (Œª x hx, h x (mem_cons_of_mem _ hx)))
intros
induction l; [refl, simp only [*, pmap, map]]; split; refl
induction l; [refl, simp only [*, pmap, map]]; split
induction l; [refl, simp only [*, pmap, map]]
induction l
refl
simp only [*, pmap, map]
split
refl
refl
intros
simp only [countp_eq_length_filter, filter_filter]
intros
induction a generalizing c
rw nil_append
case nil { rw nil_append, split, { rintro rfl, left, exact ‚ü®_, rfl, rfl‚ü© }, { rintro (‚ü®a', rfl, rfl‚ü© | ‚ü®a', H, rfl‚ü©), {refl}, {rw [‚Üê append_assoc, ‚Üê H], refl} } }
split
{ rintro rfl, left, exact ‚ü®_, rfl, rfl‚ü© }
rintro rfl
left
exact ‚ü®_, rfl, rfl‚ü©
rintro (‚ü®a', rfl, rfl‚ü© | ‚ü®a', H, rfl‚ü©)
{ rintro (‚ü®a', rfl, rfl‚ü© | ‚ü®a', H, rfl‚ü©), {refl}, {rw [‚Üê append_assoc, ‚Üê H], refl} }
refl
{refl}
rw [‚Üê append_assoc, ‚Üê H]
{rw [‚Üê append_assoc, ‚Üê H], refl}
refl
case cons : a as ih { cases c, { simp only [cons_append, nil_append, false_and, exists_false, false_or, exists_eq_left'], exact eq_comm }, { simp only [cons_append, @eq_comm _ a, ih, and_assoc, and_or_distrib_left, exists_and_distrib_left] } }
intros
rw [erase_eq_erasep, erasep_of_forall_not]; rintro b h' rfl; exact h h'
rw [erase_eq_erasep, erasep_of_forall_not]; rintro b h' rfl
rw [erase_eq_erasep, erasep_of_forall_not]
rintro b h' rfl
exact h h'
intros
apply list.ext_le
{ simp }
simp
intros
{ intros, rw [nth_le_pmap, nth_le_rotate, next_nth_le _ h] }
rw [nth_le_pmap, nth_le_rotate, next_nth_le _ h]
intros
induction l with y l IH
{ simp }
simp
by_cases hx : x = y
{ by_cases hx : x = y, { simp [hx, cons_sublist_cons_iff, singleton_sublist] }, { rw [duplicate_cons_iff_of_ne hx, IH], refine ‚ü®sublist_cons_of_sublist y, Œª h, _‚ü©, cases h, { assumption }, { contradiction } } }
{ simp [hx, cons_sublist_cons_iff, singleton_sublist] }
simp [hx, cons_sublist_cons_iff, singleton_sublist]
rw [duplicate_cons_iff_of_ne hx, IH]
{ rw [duplicate_cons_iff_of_ne hx, IH], refine ‚ü®sublist_cons_of_sublist y, Œª h, _‚ü©, cases h, { assumption }, { contradiction } }
refine ‚ü®sublist_cons_of_sublist y, Œª h, _‚ü©
cases h
{ assumption }
assumption
{ contradiction }
contradiction
intros
simp [indexes_values, foldr_with_index_eq_foldr_enum, uncurry, filter_eq_foldr]
intros
simp [argmax]
intros
rw [‚Üê length_eq_zero, length_range']
intros
induction h with l‚ÇÅ l‚ÇÇ a s IH l‚ÇÅ l‚ÇÇ a s IH
{ exact or.inl rfl }
exact or.inl rfl
cases l‚ÇÅ with b l‚ÇÅ
{ cases l‚ÇÅ with b l‚ÇÅ, { exact or.inl rfl }, { rw [length, sublists_len_succ_cons], exact mem_append_left _ IH } }
{ exact or.inl rfl }
exact or.inl rfl
rw [length, sublists_len_succ_cons]
{ rw [length, sublists_len_succ_cons], exact mem_append_left _ IH }
exact mem_append_left _ IH
rw [length, sublists_len_succ_cons]
{ rw [length, sublists_len_succ_cons], exact mem_append_right _ (mem_map.2 ‚ü®_, IH, rfl‚ü©) }
exact mem_append_right _ (mem_map.2 ‚ü®_, IH, rfl‚ü©)
intros
{ rw ‚Üêzip_map', congr, exact map_id _ }
rw ‚Üêzip_map'
congr
exact map_id _
intros
{ ext, rw [‚Üêdiagonal_one, vec_mul_diagonal, mul_one] }
ext
rw [‚Üêdiagonal_one, vec_mul_diagonal, mul_one]
intros
{ ext, refl }
ext
refl
intros
rw [conj_transpose, diagonal_transpose, diagonal_map (star_zero _)]
refl
intros
ext i j; by_cases i = j; simp [h]
ext i j; by_cases i = j
ext i j
by_cases i = j
simp [h]
simp [h]
intros
simp [mul_apply, std_basis_matrix, mul_comm]
intros
ext ‚ü®ii, ix‚ü© ‚ü®ji, jx‚ü©
simp only [transpose_apply, block_diagonal'_apply, eq_comm]
split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÇ
{ subst h‚ÇÅ, refl, }
subst h‚ÇÅ
refl
{ refl }
refl
intros
rw [rel_iff]; simp
rw [rel_iff]
simp
intros
rw [antidiagonal, coe_card, list.nat.length_antidiagonal]
intros
simp [vars, degrees_neg]
intros
simp only [bind‚ÇÇ, eval‚ÇÇ_comp_right, coe_eval‚ÇÇ_hom, eval‚ÇÇ_map]
congr' 1 with : 1
simp only [function.comp_app, map_X]
intros
intros x hx
simp only [vars, finset.mem_union, multiset.mem_to_finset] at hx ‚ä¢
simpa using multiset.mem_of_le (degrees_add _ _) hx
intros
simp [find_eq_iff]
intros
rw [nat.succ_eq_add_one, nat.add_comm]
intros
conv { to_lhs, rw [le_rec_on, or.by_cases, dif_pos h1] }
intros
rw [mul_comm, nat.eq_mul_of_div_eq_right H1 H2]
intros
rw [‚Üê choose_mul_factorial_mul_factorial (nat.le_add_left _ _), nat.add_sub_cancel, mul_right_comm]
intros
rw [int.alternating_sum_range_choose, if_neg h0]
intros
{ simp only [‚Üê some_eq_coe] at h ‚ä¢, refl }
simp only [‚Üê some_eq_coe] at h ‚ä¢
refl
intros
convert to_with_top_coe n
intros
rw [mul_comm, gcd_mul_left_left]
simp
intros
cases le_or_lt b 1 with hb hb
{ rw clog_of_left_le_one hb, exact zero_le _ }
rw clog_of_left_le_one hb
exact zero_le _
obtain rfl | hn := n.eq_zero_or_pos
{ obtain rfl | hn := n.eq_zero_or_pos, { rw [clog_zero_right], exact zero_le _ }, { rw ‚Üêle_pow_iff_clog_le hb, exact h.trans (le_pow_clog hb _) } }
{ rw [clog_zero_right], exact zero_le _ }
rw [clog_zero_right]
exact zero_le _
rw ‚Üêle_pow_iff_clog_le hb
{ rw ‚Üêle_pow_iff_clog_le hb, exact h.trans (le_pow_clog hb _) }
exact h.trans (le_pow_clog hb _)
{ rw unpair, simp }
rw unpair
simp
simp [‚Üê set.compl_set_of, is_compl_compl]
intros
rw [pow_succ', ‚Üê mul_assoc, mul_lt_mul_right (zero_lt_one.trans q1)]
exact lt_mul_of_one_le_of_lt (nat.succ_le_iff.mpr a0) (nat.lt_pow_self q1 n)
intros
induction m with m IH generalizing i
simp [pow_succ, le_zero_iff] at *
{simp [pow_succ, le_zero_iff] at *}
by_cases p ‚à£ i
cases h with a e
{ cases h with a e, subst e, rw [pow_succ, nat.mul_dvd_mul_iff_left pp.pos, IH], split; intro h; rcases h with ‚ü®k, h, e‚ü©, { exact ‚ü®succ k, succ_le_succ h, by rw [e, pow_succ]; refl‚ü© }, cases k with k, { apply pp.not_dvd_one.elim, simp at e, rw ‚Üê e, apply dvd_mul_right }, { refine ‚ü®k, le_of_succ_le_succ h, _‚ü©, rwa [mul_comm, pow_succ', nat.mul_left_inj pp.pos] at e } }
subst e
rw [pow_succ, nat.mul_dvd_mul_iff_left pp.pos, IH]
split; intro h; rcases h with ‚ü®k, h, e‚ü©
split; intro h
split
intro h
rcases h with ‚ü®k, h, e‚ü©
{ exact ‚ü®succ k, succ_le_succ h, by rw [e, pow_succ]; refl‚ü© }
exact ‚ü®succ k, succ_le_succ h, by rw [e, pow_succ]; refl‚ü©
intro h
rcases h with ‚ü®k, h, e‚ü©
cases k with k
apply pp.not_dvd_one.elim
{ apply pp.not_dvd_one.elim, simp at e, rw ‚Üê e, apply dvd_mul_right }
simp at e
rw ‚Üê e
apply dvd_mul_right
refine ‚ü®k, le_of_succ_le_succ h, _‚ü©
{ refine ‚ü®k, le_of_succ_le_succ h, _‚ü©, rwa [mul_comm, pow_succ', nat.mul_left_inj pp.pos] at e }
rwa [mul_comm, pow_succ', nat.mul_left_inj pp.pos] at e
split; intro d
split
{ split; intro d, { rw (pp.coprime_pow_of_not_dvd h).eq_one_of_dvd d, exact ‚ü®0, zero_le _, rfl‚ü© }, { rcases d with ‚ü®k, l, e‚ü©, rw e, exact pow_dvd_pow _ l } }
intro d
rw (pp.coprime_pow_of_not_dvd h).eq_one_of_dvd d
{ rw (pp.coprime_pow_of_not_dvd h).eq_one_of_dvd d, exact ‚ü®0, zero_le _, rfl‚ü© }
exact ‚ü®0, zero_le _, rfl‚ü©
intro d
rcases d with ‚ü®k, l, e‚ü©
{ rcases d with ‚ü®k, l, e‚ü©, rw e, exact pow_dvd_pow _ l }
rw e
exact pow_dvd_pow _ l
intros
rw ‚Üê succ_mul; exact le_of_lt_succ (lt_succ_sqrt n)
rw ‚Üê succ_mul
exact le_of_lt_succ (lt_succ_sqrt n)
intros
cases n
cases n; refl
refl
refl
intros
cases x; simp only [map_none', map_some', pmap]
{ cases x; simp only [map_none', map_some', pmap] }
cases x
simp only [map_none', map_some', pmap]
simp only [map_none', map_some', pmap]
intros
simp
intros
have := H.dual.erase_max_aux; rwa [‚Üê dual_node', size_dual, ‚Üê dual_erase_min, size_dual, ‚Üê valid'.dual_iff, find_max'_dual] at this
have := H.dual.erase_max_aux
rwa [‚Üê dual_node', size_dual, ‚Üê dual_erase_min, size_dual, ‚Üê valid'.dual_iff, find_max'_dual] at this
intros
cases r with rs rl rx rr
{ refl }
refl
cases l with ls ll lx lr
{ cases l with ls ll lx lr, { have : size rl = 0 ‚àß size rr = 0, { have := H1 rfl, rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this }, cases sr.2.1.size_eq_zero.1 this.1, cases sr.2.2.size_eq_zero.1 this.2, rw sr.eq_node', refl }, { replace H2 : ¬¨ rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos), simp [balance_l, balance, H2]; split_ifs; simp [add_comm] } }
have : size rl = 0 ‚àß size rr = 0
{ have : size rl = 0 ‚àß size rr = 0, { have := H1 rfl, rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this }, cases sr.2.1.size_eq_zero.1 this.1, cases sr.2.2.size_eq_zero.1 this.2, rw sr.eq_node', refl }
have := H1 rfl
{ have := H1 rfl, rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this }
rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this
cases sr.2.1.size_eq_zero.1 this.1
cases sr.2.2.size_eq_zero.1 this.2
rw sr.eq_node'
refl
replace H2 : ¬¨ rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos)
{ replace H2 : ¬¨ rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos), simp [balance_l, balance, H2]; split_ifs; simp [add_comm] }
simp [balance_l, balance, H2]; split_ifs; simp [add_comm]
simp [balance_l, balance, H2]; split_ifs
simp [balance_l, balance, H2]
split_ifs
simp [add_comm]
simp [add_comm]
intros
rcases part.eq_none_or_eq_some x with h | ‚ü®b, h‚ÇÄ‚ü©
{ rw h, left, apply order_bot.bot_le _ }
rw h
left
apply order_bot.bot_le _
right
intros b' h‚ÇÅ
rw part.eq_some_iff at h‚ÇÄ
replace hx := hx _ h‚ÇÄ
replace hy := hy _ h‚ÇÅ
replace hx := part.mem_unique hx hy
subst hx
exact h‚ÇÄ
intros
ext
ext; dsimp [pequiv.trans]; simp
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
simp
intros
cases x with a f
rw map_eq
conv { to_rhs, rw [M.dest, M.dest', map_eq, append_fun_comp_split_fun] }
reflexivity
intros
split
rintros ‚ü®u, xeq, yeq‚ü©
{ rintros ‚ü®u, xeq, yeq‚ü©, cases h : u with a f, use [a, Œª i, (f i).val.fst, Œª i, (f i).val.snd], split, { rw [‚Üêxeq, h], refl }, split, { rw [‚Üêyeq, h], refl }, intro i, exact (f i).property }
cases h : u with a f
use [a, Œª i, (f i).val.fst, Œª i, (f i).val.snd]
split
rw [‚Üêxeq, h]
{ rw [‚Üêxeq, h], refl }
refl
split
rw [‚Üêyeq, h]
{ rw [‚Üêyeq, h], refl }
refl
intro i
exact (f i).property
rintros ‚ü®a, f‚ÇÄ, f‚ÇÅ, xeq, yeq, h‚ü©
use ‚ü®a, Œª i, ‚ü®(f‚ÇÄ i, f‚ÇÅ i), h i‚ü©‚ü©
split
{ rw [xeq], refl }
rw [xeq]
refl
rw [yeq]
refl
intros
apply pos_iff_ne_zero.2
intro hzero
rw hzero at h
exact pnat.ne_zero n (eq_zero_of_zero_dvd h)
intros
rcases multiset.mem_map.mp h with ‚ü®‚ü®p', hp'‚ü©, ‚ü®h_mem, h_eq‚ü©‚ü©
{ rcases multiset.mem_map.mp h with ‚ü®‚ü®p', hp'‚ü©, ‚ü®h_mem, h_eq‚ü©‚ü©, exact h_eq ‚ñ∏ hp' }
exact h_eq ‚ñ∏ hp'
intros
{ dsimp [v], ext, { simp only, ring }, { simp only, ring } }
dsimp [v]
ext
simp only
{ simp only, ring }
ring
simp only
{ simp only, ring }
ring
intros
{ ext, simp only [eval_X, aeval_tower_X, coe_aeval_eq_eval], }
ext
simp only [eval_X, aeval_tower_X, coe_aeval_eq_eval]
intros
simp only [‚Üêmonomial_zero_left, monomial_mul_monomial, zero_add]
intros
{ rw [C_mul_X_pow_eq_monomial], exact support_monomial' n c }
rw [C_mul_X_pow_eq_monomial]
exact support_monomial' n c
intros
simpa only [pow_one] using degree_C_mul_X_pow_le 1 a
intros
rw [X_pow_eq_monomial, degree_monomial _ (@one_ne_zero R _ _)]
intros
by_cases hp : p = 0
rw [hp, trailing_degree_zero]
{ rw [hp, trailing_degree_zero], exact le_top }
exact le_top
rw [trailing_degree_eq_nat_trailing_degree hp]
exact le_refl _
intros
induction k with k ih generalizing f g
{ simp [nat.iterate], }
simp [nat.iterate]
{ simp [nat.iterate, ih], }
simp [nat.iterate, ih]
intros
simp only [erase_lead, support_erase]
intros
rw [‚ÜêC_eq_nat_cast, eval_C_mul]
intros
apply (degree_le_iff_coeff_zero _ _).2 (Œª m hm, _)
rw degree_lt_iff_coeff_zero at hm
simp [hm m (le_refl _)]
intros
rwa [monic, leading_coeff_add_of_degree_lt hpq]
intros
intro h
rw [h, monic.def, leading_coeff_zero] at hq
rw [‚Üê mul_one p, ‚Üê C_1, ‚Üê hq, C_0, mul_zero] at hp
exact hp rfl
intros
rw [coeff_reverse, next_coeff]
split_ifs with hf
have : coeff f 1 = 0 := coeff_eq_zero_of_nat_degree_lt (by simp only [hf, zero_lt_one])
{ have : coeff f 1 = 0 := coeff_eq_zero_of_nat_degree_lt (by simp only [hf, zero_lt_one]), simp [*, rev_at] }
simp [*, rev_at]
rw rev_at_le
{ rw rev_at_le, exact nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf) }
exact nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf)
intros
rw [‚Üê C_1, taylor_C]
intros
rw [recF, mvpfunctor.W_rec_eq]; refl
rw [recF, mvpfunctor.W_rec_eq]
refl
intros
ext u
rw [mem_supp]
split
{ intro h', apply h' _ _ rfl }
intro h'
apply h' _ _ rfl
intros h' a' f' e
rw [‚Üêh _ _ _ _ e.symm]
apply h'
intros
{ conv_lhs { rw ‚Üê(@num_denom q) }, cases q, simp [div_num_denom] }
conv_lhs { rw ‚Üê(@num_denom q) }
cases q
simp [div_num_denom]
intros
ext r
refine rat.num_denom_cases_on' r _
intros a b b0
let œÜ : ‚Ñ§ ‚Üí+* R := f.comp (int.cast_ring_hom ‚Ñö)
let œà : ‚Ñ§ ‚Üí+* R := g.comp (int.cast_ring_hom ‚Ñö)
rw [rat.mk_eq_div, int.cast_coe_nat]
have b0' : (b:‚Ñö) ‚â† 0 := nat.cast_ne_zero.2 b0
have : ‚àÄ n : ‚Ñ§, f n = g n := Œª n, show œÜ n = œà n, by rw [œÜ.ext_int œà]
calc f (a * b‚Åª¬π) = f a * f b‚Åª¬π * (g (b:‚Ñ§) * g b‚Åª¬π) : by rw [int.cast_coe_nat, ‚Üê g.map_mul, mul_inv_cancel b0', g.map_one, mul_one, f.map_mul] ... = g a * f b‚Åª¬π * (f (b:‚Ñ§) * g b‚Åª¬π) : by rw [this a, ‚Üê this b] ... = g (a * b‚Åª¬π) : by rw [int.cast_coe_nat, mul_assoc, ‚Üê mul_assoc (f b‚Åª¬π), ‚Üê f.map_mul, inv_mul_cancel b0', f.map_one, one_mul, g.map_mul]
intros
unfold has_le.le rat.le; rw add_sub_add_left_eq_sub
unfold has_le.le rat.le
rw add_sub_add_left_eq_sub
intros
simp [div_eq_mul_inv, ennreal.mul_eq_top]
intros
{ refine le_trans _ h, simp }
refine le_trans _ h
simp
intros
by_cases a0 : a = 0
{ rw [a0, zero_div, zero_div] }
rw [a0, zero_div, zero_div]
cases a with a ha
{ cases a with a ha, replace a0 : 0 < a := lt_of_le_of_ne ha (ne_of_lt (zero_lt_iff.mpr a0)), exact (div_le_div_left a0 b0 c0).mpr cb }
replace a0 : 0 < a := lt_of_le_of_ne ha (ne_of_lt (zero_lt_iff.mpr a0))
exact (div_le_div_left a0 b0 c0).mpr cb
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ‚Ñù)
rw sign_of_neg hn
{ rw sign_of_neg hn, exact mul_nonneg_of_nonpos_of_nonpos (by norm_num) hn.le }
exact mul_nonneg_of_nonpos_of_nonpos (by norm_num) hn.le
{ rw mul_zero, }
rw mul_zero
{ rw [sign_of_pos hp, one_mul], exact hp.le }
rw [sign_of_pos hp, one_mul]
exact hp.le
intros
rw [not_iff_not, sqrt_eq_zero h]
intros
{ ext x z, simp [comp, inv, flip, and.comm] }
ext x z
simp [comp, inv, flip, and.comm]
intros
cases a with a ca; cases b with b cb; simp only [lift_rel_aux]
cases a with a ca; cases b with b cb
cases a with a ca
cases b with b cb
simp only [lift_rel_aux]
simp only [lift_rel_aux]
cases b with b cb
simp only [lift_rel_aux]
simp only [lift_rel_aux]
intros
simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]
intros
rw image_eq_preimage_of_inverse h‚ÇÅ h‚ÇÇ; refl
rw image_eq_preimage_of_inverse h‚ÇÅ h‚ÇÇ
refl
intros
rw [image_preimage_eq_inter_range, preimage_inter_range]
intros
rw [‚Üêimage_preimage_coe, ‚Üêimage_preimage_coe]
split
intro h
{ intro h, rw h }
rw h
intro h
exact coe_injective.image_injective h
intros
obtain (rfl | hs) := s.eq_empty_or_nonempty
use ‚ü®Œª _, or.inl rfl, Œª _, empty_subset _‚ü©
simp [eq_singleton_iff_nonempty_unique_mem, hs, ne_empty_iff_nonempty.2 hs]
intros
haveI := classical.dec_eq Œ±
rw [‚Üêto_finset_card, to_finset_ne_eq_erase, finset.card_erase_of_mem (finset.mem_univ _), finset.card_univ, nat.pred_eq_sub_one]
intros
simp [piecewise, h]
intros
rw [Icc_inter_Icc, sup_of_le_right hab, inf_of_le_left hbc, Icc_self]
intros
rw [‚Üênot_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioo]
intros
rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iio]
intros
simp [le_refl]
intros
simp
intros
simp [‚Üê Ioi_inter_Iio, h]
intros
rintro (f : finite (Ioo a b))
obtain ‚ü®m, hm‚ÇÅ, hm‚ÇÇ‚ü© : ‚àÉ m ‚àà Ioo a b, ‚àÄ x ‚àà Ioo a b, ¬¨x < m
{ simpa [h] using finset.exists_minimal f.to_finset }
simpa [h] using finset.exists_minimal f.to_finset
obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© : ‚àÉ z, a < z ‚àß z < m := exists_between hm‚ÇÅ.1
exact hm‚ÇÇ z ‚ü®hz‚ÇÅ, lt_trans hz‚ÇÇ hm‚ÇÅ.2‚ü© hz‚ÇÇ
intros
simp only [pi_def, Inter_true, mem_univ]
intros
simp only [‚ÜêsUnion_range, subtype.range_coe]
intros
induction aca with a H IH
constructor
intros y h
cases h with a' _ h'
exact IH _ h'
intros
replace h‚ÇÄ := congr_fun h‚ÇÄ; ext1 (ieq | ‚ü®j, ieq‚ü©); apply_assumption
replace h‚ÇÄ := congr_fun h‚ÇÄ; ext1 (ieq | ‚ü®j, ieq‚ü©)
replace h‚ÇÄ := congr_fun h‚ÇÄ
ext1 (ieq | ‚ü®j, ieq‚ü©)
apply_assumption
apply_assumption
intros
{ ext i : 1, induction i; simp [last_fun,*]; refl }
ext i : 1
induction i
induction i; simp [last_fun,*]; refl
induction i; simp [last_fun,*]
simp [last_fun,*]
refl
intros
rw [‚Üê f.map_add_int, zero_add]
intros
rcases eventually_closure_subset_of_is_open_of_omega_limit_subset f œï s hv‚ÇÅ hv‚ÇÇ with ‚ü®u, hu_mem, hu‚ü©
refine mem_of_superset hu_mem (Œª t ht x hx, _)
exact hu (subset_closure $ mem_image2_of_mem ht hx)
intros
have hp : 0 < fintype.card K := lt_trans zero_lt_one fintype.one_lt_card
by_cases h : a = 0
rw h
{ rw h, apply zero_pow hp }
apply zero_pow hp
rw [‚Üê nat.succ_pred_eq_of_pos hp, pow_succ, nat.pred_eq_sub_one, pow_card_sub_one_eq_one a h, mul_one]
intros
rw [coeff_expand hp, if_pos (dvd_mul_left _ _), nat.mul_div_cancel _ hp]
intros
rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots hsplit]
intros
{ ext, simp }
ext
simp
intros
refine lt_of_le_of_ne s.circumradius_nonneg _
intro h
have hr := s.dist_circumcenter_eq_circumradius
simp_rw [‚Üêh, dist_eq_zero] at hr
have h01 := s.independent.injective.ne (dec_trivial : (0 : fin (n + 2)) ‚â† 1)
simpa [hr] using h01
intros
simp_rw monge_plane_def
congr' 3
congr' 1
{ congr' 1, exact insert_singleton_comm _ _ }
exact insert_singleton_comm _ _
ext
{ ext, simp_rw submodule.mem_span_singleton, split, all_goals { rintros ‚ü®r, rfl‚ü©, use -r, rw [neg_smul, ‚Üêsmul_neg, neg_vsub_eq_vsub_rev] } }
simp_rw submodule.mem_span_singleton
split
rintros ‚ü®r, rfl‚ü©
all_goals { rintros ‚ü®r, rfl‚ü©, use -r, rw [neg_smul, ‚Üêsmul_neg, neg_vsub_eq_vsub_rev] }
use -r
rw [neg_smul, ‚Üêsmul_neg, neg_vsub_eq_vsub_rev]
rintros ‚ü®r, rfl‚ü©
use -r
rw [neg_smul, ‚Üêsmul_neg, neg_vsub_eq_vsub_rev]
intros
rw [add_assoc, real.sin_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy, sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy]
ring
intros
simp only [‚Üê finprod_subtype_eq_finprod_cond]
exact smooth_finprod (Œª i, hc i i.2) (hf.comp_injective subtype.coe_injective)
intros
rw [f.support_eq_inter_preimage, ‚Üê ext_chart_at_source I]
{ rw [f.support_eq_inter_preimage, ‚Üê ext_chart_at_source I], exact inter_subset_left _ _ }
exact inter_subset_left _ _
intros
suffices h : Q (e ‚àò e.symm) e.target x
have A : e.symm ‚Åª¬π' e.source ‚à© e.target = e.target
{ have A : e.symm ‚Åª¬π' e.source ‚à© e.target = e.target, by mfld_set_tac, have : e.symm x ‚àà e.source, by simp only [hx] with mfld_simps, rw [lift_prop_at, hG.lift_prop_within_at_indep_chart G.id_mem_maximal_atlas (mem_univ _) he this], refine ‚ü®(e.symm.continuous_at hx).continuous_within_at, _‚ü©, simp only with mfld_simps, rwa [hG.is_local e.open_target hx, A] }
mfld_set_tac
mfld_set_tac
have : e.symm x ‚àà e.source
simp only [hx] with mfld_simps
simp only [hx] with mfld_simps
rw [lift_prop_at, hG.lift_prop_within_at_indep_chart G.id_mem_maximal_atlas (mem_univ _) he this]
refine ‚ü®(e.symm.continuous_at hx).continuous_within_at, _‚ü©
simp only with mfld_simps
rwa [hG.is_local e.open_target hx, A]
have A : Q id e.target x
simpa only with mfld_simps using (hG.is_local e.open_target hx).1 (hQ x)
simpa only with mfld_simps using (hG.is_local e.open_target hx).1 (hQ x)
apply hG.congr _ _ A; simp only [hx] with mfld_simps {contextual := tt}
apply hG.congr _ _ A
simp only [hx] with mfld_simps {contextual := tt}
simp only [hx] with mfld_simps {contextual := tt}
intros
simp only [mfderiv_within, h, dif_pos]
intros
simp only [unique_mdiff_within_at] with mfld_simps
intros
assume x
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
split
apply continuous.continuous_within_at
{ apply continuous.continuous_within_at, apply topological_fiber_bundle_core.continuous_const_section, assume i j y hy, exact h _ _ _ hy }
apply topological_fiber_bundle_core.continuous_const_section
assume i j y hy
exact h _ _ _ hy
have : times_cont_diff ùïú ‚ä§ (Œª (y : E), (y, v)) := times_cont_diff_id.prod times_cont_diff_const
{ have : times_cont_diff ùïú ‚ä§ (Œª (y : E), (y, v)) := times_cont_diff_id.prod times_cont_diff_const, apply this.times_cont_diff_within_at.congr, { assume y hy, simp only with mfld_simps at hy, simp only [chart, hy, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only [hy] with mfld_simps }, { simp only [chart, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only with mfld_simps } }
apply this.times_cont_diff_within_at.congr
assume y hy
{ assume y hy, simp only with mfld_simps at hy, simp only [chart, hy, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only [hy] with mfld_simps }
simp only with mfld_simps at hy
simp only [chart, hy, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps
apply h
simp only [hy] with mfld_simps
simp only [chart, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps
{ simp only [chart, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only with mfld_simps }
apply h
simp only with mfld_simps
intros
cases f; cases g; congr'; exact funext h
cases f; cases g; congr'
cases f; cases g
cases f
cases g
congr'
exact funext h
intros
rw con_gen_eq; exact Inf_le h
rw con_gen_eq
exact Inf_le h
intros
rw [add_subgroup.fg_iff_add_submonoid.fg, subgroup.fg_iff_submonoid_fg]
exact add_submonoid.fg_iff_mul_fg (add_subgroup.to_add_submonoid P)
intros
rw [‚Üê add_monoid_hom.comp_apply, to_finsupp_comp_to_free_abelian_group, add_monoid_hom.id_apply]
intros
apply closure_mono
rintros x ‚ü®p, hp, q, hq, rfl‚ü©
exact ‚ü®p, h‚ÇÅ hp, q, h‚ÇÇ hq, rfl‚ü©
intros
split_ifs; refl
split_ifs
refl
refl
intros
rw [cycle.length_subsingleton_iff, cycle.length_subsingleton_iff]
revert s s'
intros s s'
apply quotient.induction_on‚ÇÇ' s s'
intros l l'
simpa using form_perm_eq_form_perm_iff
intros
rw [‚Üêfinset.card_univ, ‚Üêh2, ‚Üêorder_of_is_cycle h1] at h0
cases exists_pow_eq_self_of_coprime h0 with m hm
have h2' : (œÉ ^ n).support = ‚ä§ := eq.trans (support_pow_coprime h0) h2
have h1' : is_cycle ((œÉ ^ n) ^ (m : ‚Ñ§)) := by rwa ‚Üê hm at h1
replace h1' : is_cycle (œÉ ^ n) := is_cycle_of_is_cycle_pow h1' (le_trans (support_pow_le œÉ n) (ge_of_eq (congr_arg support hm)))
rw [eq_top_iff, ‚Üêclosure_cycle_adjacent_swap h1' h2' x, closure_le, set.insert_subset]
exact ‚ü®subgroup.pow_mem (closure _) (subset_closure (set.mem_insert œÉ _)) n, set.singleton_subset_iff.mpr (subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)))‚ü©
intros
classical
have : n.coprime (order_of f)
refine nat.coprime.symm _
{ refine nat.coprime.symm _, rw nat.prime.coprime_iff_not_dvd hf', exact nat.not_dvd_of_pos_of_lt hn hn' }
rw nat.prime.coprime_iff_not_dvd hf'
exact nat.not_dvd_of_pos_of_lt hn hn'
obtain ‚ü®m, hm‚ü© := exists_pow_eq_self_of_coprime this
have hf'' := hf
rw ‚Üêhm at hf''
refine is_cycle_of_is_cycle_pow hf'' _
rw [hm]
exact support_pow_le f n
intros
rw mem_cycle_factors_finset_iff
split
rintro ‚ü®hc, h‚ü©
{ rintro ‚ü®hc, h‚ü©, contrapose! hc, rw [not_mem_support, ‚Üêcycle_of_eq_one_iff] at hc, simp [hc] }
contrapose! hc
rw [not_mem_support, ‚Üêcycle_of_eq_one_iff] at hc
simp [hc]
intros hx
{ intros hx, refine ‚ü®is_cycle_cycle_of _ (mem_support.mp hx), _‚ü©, intros y hy, rw mem_support at hy, rw cycle_of_apply, split_ifs with H, { refl }, { rw cycle_of_apply_of_not_same_cycle H at hy, contradiction } }
refine ‚ü®is_cycle_cycle_of _ (mem_support.mp hx), _‚ü©
intros y hy
rw mem_support at hy
rw cycle_of_apply
split_ifs with H
{ refl }
refl
rw cycle_of_apply_of_not_same_cycle H at hy
{ rw cycle_of_apply_of_not_same_cycle H at hy, contradiction }
contradiction
intros
simp [form_perm_apply_of_not_mem _ _ (not_mem_of_nodup_cons h)]
intros
apply perm.swap_induction_on e
{ simp [perm.one_def] }
simp [perm.one_def]
intros f x y hne h
{ intros f x y hne h, simp [h, hne, perm.mul_def, ‚Üêequiv_functor.map_equiv_trans] }
simp [h, hne, perm.mul_def, ‚Üêequiv_functor.map_equiv_trans]
intros
rw support_eq_empty_iff
intros
{ rw disjoint_comm, exact H1.symm.mul_left H2.symm }
rw disjoint_comm
exact H1.symm.mul_left H2.symm
intros
by_cases hnpos : 0 < n
haveI : fact (0 < n) := ‚ü®hnpos‚ü©
{ haveI : fact (0 < n) := ‚ü®hnpos‚ü©, cases lt_or_eq_of_le (nat.le_of_dvd hnpos (order_of_dvd_of_pow_eq_one (@r_one_pow_n n))) with h h, { have h1 : (r 1 : dihedral_group n)^(order_of (r 1)) = 1, { exact pow_order_of_eq_one _ }, rw r_one_pow at h1, injection h1 with h2, rw [‚Üê zmod.val_eq_zero, zmod.val_nat_cast, nat.mod_eq_of_lt h] at h2, apply absurd h2.symm, apply ne_of_lt, exact absurd h2.symm (ne_of_lt (order_of_pos _)) }, { exact h } }
cases lt_or_eq_of_le (nat.le_of_dvd hnpos (order_of_dvd_of_pow_eq_one (@r_one_pow_n n))) with h h
have h1 : (r 1 : dihedral_group n)^(order_of (r 1)) = 1
{ have h1 : (r 1 : dihedral_group n)^(order_of (r 1)) = 1, { exact pow_order_of_eq_one _ }, rw r_one_pow at h1, injection h1 with h2, rw [‚Üê zmod.val_eq_zero, zmod.val_nat_cast, nat.mod_eq_of_lt h] at h2, apply absurd h2.symm, apply ne_of_lt, exact absurd h2.symm (ne_of_lt (order_of_pos _)) }
{ exact pow_order_of_eq_one _ }
exact pow_order_of_eq_one _
rw r_one_pow at h1
injection h1 with h2
rw [‚Üê zmod.val_eq_zero, zmod.val_nat_cast, nat.mod_eq_of_lt h] at h2
apply absurd h2.symm
apply ne_of_lt
exact absurd h2.symm (ne_of_lt (order_of_pos _))
{ exact h }
exact h
simp only [not_lt, nonpos_iff_eq_zero] at hnpos
{ simp only [not_lt, nonpos_iff_eq_zero] at hnpos, rw hnpos, apply order_of_eq_zero, rw is_of_fin_order_iff_pow_eq_one, push_neg, intros m hm, rw [r_one_pow, one_def], by_contradiction, rw not_not at h, have h' : (m : zmod 0) = 0, { exact r.inj h, }, have h'' : m = 0, { simp only [int.coe_nat_eq_zero, int.nat_cast_eq_coe_nat] at h', exact h', }, rw h'' at hm, apply nat.lt_irrefl, exact hm }
rw hnpos
apply order_of_eq_zero
rw is_of_fin_order_iff_pow_eq_one
push_neg
intros m hm
rw [r_one_pow, one_def]
by_contradiction
have h' : (m : zmod 0) = 0
{ exact r.inj h, }
exact r.inj h
have h'' : m = 0
simp only [int.coe_nat_eq_zero, int.nat_cast_eq_coe_nat] at h'
{ simp only [int.coe_nat_eq_zero, int.nat_cast_eq_coe_nat] at h', exact h', }
exact h'
rw h'' at hm
apply nat.lt_irrefl
exact hm
intros
simpa only [div_eq_mul_inv] using H.mul_mem' hx (H.inv_mem' hy)
intros
rw [closure_singleton_eq, mem_mrange]; refl
rw [closure_singleton_eq, mem_mrange]
refl
intros
rw [‚Üêcomap_bot', ‚Üêcomap_bot', ‚Üêcomap_bot', ‚Üêprod_map_comap_prod', bot_prod_bot]
intros
split
intro hd
{ intro hd, rw ‚Üêdirection_top k V P at hd, refine ext_of_direction_eq hd _, simp [h] }
rw ‚Üêdirection_top k V P at hd
refine ext_of_direction_eq hd _
simp [h]
rintro rfl
{ rintro rfl, simp }
simp
intros
simp_rw [affine_combination_apply, weighted_vsub_of_point_map]
intros
have h := collinear_iff_dim_le_one k s
rw ‚Üêfinrank_eq_dim at h
exact_mod_cast h
intros
rw [one_div, line_map_inv_two]
intros
rw [‚Üê set_like.mem_coe, coe_supr_of_directed S H, mem_Union]
{ rw [‚Üê set_like.mem_coe, coe_supr_of_directed S H, mem_Union], refl }
refl
intros
apply span_induction h H; simp {contextual := tt}
apply span_induction h H
simp {contextual := tt}
simp {contextual := tt}
simp {contextual := tt}
intros
rw [mem_ker, map_sub, sub_eq_zero]
intros
ext
{ ext, simp only [symm_apply_apply, arrow_congr_apply, linear_map.comp_apply], }
simp only [symm_apply_apply, arrow_congr_apply, linear_map.comp_apply]
intros
obtain ‚ü®x, y, ne‚ü© : ‚àÉ (x y : M), x ‚â† y := nontrivial.exists_pair_ne
obtain ‚ü®i, _‚ü© := not_forall.mp (mt b.ext_elem ne)
exact ‚ü®i‚ü©
intros
induction x using clifford_algebra.induction
case h_grade0 : r { exact reverse.commutes _}
rw [Œπ_eq_zero, linear_map.zero_apply, reverse.map_zero]
case h_grade1 : x { rw [Œπ_eq_zero, linear_map.zero_apply, reverse.map_zero] }
case h_mul : x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ { rw [reverse.map_mul, mul_comm, hx‚ÇÅ, hx‚ÇÇ] }
case h_add : x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ { rw [reverse.map_add, hx‚ÇÅ, hx‚ÇÇ] }
intros
apply le_antisymm
apply supr_le _
{ apply supr_le _, intros i y hy, exact ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, dfinsupp.sum_add_hom_single _ _ _‚ü©, }
intros i y hy
exact ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, dfinsupp.sum_add_hom_single _ _ _‚ü©
rintros x ‚ü®v, rfl‚ü©
{ rintros x ‚ü®v, rfl‚ü©, exact dfinsupp_sum_add_hom_mem _ v _ (Œª i _, (le_supr p i : p i ‚â§ _) (v i).prop) }
exact dfinsupp_sum_add_hom_mem _ v _ (Œª i _, (le_supr p i : p i ‚â§ _) (v i).prop)
intros
intros contra
apply hŒº
erw linear_map.ker_eq_bot at ‚ä¢ contra
rw linear_map.coe_pow
exact function.injective.iterate contra k
intros
apply le_antisymm
{ exact finrank_span_le_card ({v} : set V) }
exact finrank_span_le_card ({v} : set V)
rw [nat.succ_le_iff, finrank_pos_iff]
{ rw [nat.succ_le_iff, finrank_pos_iff], use [‚ü®v, mem_span_singleton_self v‚ü©, 0], simp [hv] }
use [‚ü®v, mem_span_singleton_self v‚ü©, 0]
simp [hv]
intros
rw [finrank_eq_card_basis h, fintype.card_coe]
intros
refine le_antisymm _ (supr_le $ Œª i, supported_mono $ set.subset_Union _ _)
haveI := classical.dec_pred (Œª x, x ‚àà (‚ãÉ i, s i))
suffices : ((submodule.subtype _).comp (restrict_dom M R (‚ãÉ i, s i))).range ‚â§ ‚®Ü i, supported M R (s i)
rwa [linear_map.range_comp, range_restrict_dom, map_top, range_subtype] at this
{ rwa [linear_map.range_comp, range_restrict_dom, map_top, range_subtype] at this }
rw [range_le_iff_comap, eq_top_iff]
rintro l ‚ü®‚ü©
apply finsupp.induction l
exact zero_mem _
{exact zero_mem _}
refine Œª x a l hl a0, add_mem _ _
by_cases (‚àÉ i, x ‚àà s i); simp [h]
by_cases (‚àÉ i, x ‚àà s i)
simp [h]
cases h with i hi
{ cases h with i hi, exact le_supr (Œª i, supported M R (s i)) i (single_mem_supported R _ hi) }
exact le_supr (Œª i, supported M R (s i)) i (single_mem_supported R _ hi)
simp [h]
intros
rw [linear_independent_comp_subtype, linear_map.disjoint_ker]
intros
intros k1 k2 hk12
have h01 : ‚àÄ (k : m ‚äï n), sum.elim (Œª i, 0) (Œª j, 1) k = 0 ‚à® sum.elim (Œª i, 0) (Œª j, 1) k = 1
{ simp }
simp
have h0 : ‚àÄ (k : m ‚äï n), sum.elim (Œª i, 0) (Œª j, 1) k = 0 ‚Üí ‚àÉ i, k = sum.inl i
simp
{ simp }
have h1 : ‚àÄ (k : m ‚äï n), sum.elim (Œª i, 0) (Œª j, 1) k = 1 ‚Üí ‚àÉ j, k = sum.inr j
simp
{ simp }
cases (h01 k1) with hk1 hk1; cases (h01 k2) with hk2 hk2; rw [hk1, hk2] at hk12
cases (h01 k1) with hk1 hk1; cases (h01 k2) with hk2 hk2
cases (h01 k1) with hk1 hk1
cases (h01 k2) with hk2 hk2
rw [hk1, hk2] at hk12
{ exact absurd hk12 (nat.not_lt_zero 0) }
exact absurd hk12 (nat.not_lt_zero 0)
rw [hk1, hk2] at hk12
{ exact absurd hk12 (nat.not_lt_zero 1) }
exact absurd hk12 (nat.not_lt_zero 1)
cases (h01 k2) with hk2 hk2
rw [hk1, hk2] at hk12
obtain ‚ü®i, hi‚ü© := h1 k1 hk1
{ obtain ‚ü®i, hi‚ü© := h1 k1 hk1, obtain ‚ü®j, hj‚ü© := h0 k2 hk2, rw [hi, hj], simp }
obtain ‚ü®j, hj‚ü© := h0 k2 hk2
rw [hi, hj]
simp
rw [hk1, hk2] at hk12
{ exact absurd hk12 (irrefl 1) }
exact absurd hk12 (irrefl 1)
intros
rw fintype.card_eq_zero_iff at h
{ rw fintype.card_eq_zero_iff at h, suffices : M = 1, { simp [this] }, ext i, exact h.elim i }
suffices : M = 1
simp [this]
{ simp [this] }
ext i
exact h.elim i
intros
rw [@linear_equiv.finrank_eq R (matrix m n R) _ _ _ _ _ _ (linear_equiv.curry R m n).symm, finite_dimensional.finrank_fintype_fun_eq_card, fintype.card_prod]
intros
ext i j
by_cases g : i = j
rw g
{ rw g }
simp [h g, h (ne.symm g)]
intros
intros v hv
ext i
specialize hv (M.cramer (pi.single i 1))
refine (mul_eq_zero.mp _).resolve_right hM
convert hv
simp only [mul_vec_cramer M (pi.single i 1), dot_product, pi.smul_apply, smul_eq_mul]
rw [finset.sum_eq_single i, pi.single_eq_same, mul_one]
{ intros j _ hj, simp [hj] }
intros j _ hj
simp [hj]
{ intros, have := finset.mem_univ i, contradiction }
intros
have := finset.mem_univ i
contradiction
intros
rw [‚Üê linear_map.to_matrix_id v‚ÇÅ, matrix.to_lin_to_matrix]
intros
have : (‚àÉ (v ‚â† 0), mul_vec ((algebra_map A K).map_matrix M) v = 0) ‚Üî _ := exists_mul_vec_eq_zero_iff_aux
rw [‚Üê ring_hom.map_det, is_fraction_ring.to_map_eq_zero_iff] at this
refine iff.trans _ this
split
split; rintro ‚ü®v, hv, mul_eq‚ü©
rintro ‚ü®v, hv, mul_eq‚ü©
refine ‚ü®Œª i, algebra_map _ _ (v i), mt (Œª h, funext $ Œª i, _) hv, _‚ü©
{ refine ‚ü®Œª i, algebra_map _ _ (v i), mt (Œª h, funext $ Œª i, _) hv, _‚ü©, { exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i) }, { ext i, refine (ring_hom.map_mul_vec _ _ _ i).symm.trans _, rw [mul_eq, pi.zero_apply, ring_hom.map_zero, pi.zero_apply] } }
{ exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i) }
exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i)
ext i
{ ext i, refine (ring_hom.map_mul_vec _ _ _ i).symm.trans _, rw [mul_eq, pi.zero_apply, ring_hom.map_zero, pi.zero_apply] }
refine (ring_hom.map_mul_vec _ _ _ i).symm.trans _
rw [mul_eq, pi.zero_apply, ring_hom.map_zero, pi.zero_apply]
rintro ‚ü®v, hv, mul_eq‚ü©
letI := classical.dec_eq K
{ letI := classical.dec_eq K, obtain ‚ü®‚ü®b, hb‚ü©, ba_eq‚ü© := is_localization.exist_integer_multiples_of_finset (non_zero_divisors A) (finset.univ.image v), choose f hf using ba_eq, refine ‚ü®Œª i, f _ (finset.mem_image.mpr ‚ü®i, finset.mem_univ i, rfl‚ü©), mt (Œª h, funext $ Œª i, _) hv, _‚ü©, { have := congr_arg (algebra_map A K) (congr_fun h i), rw [hf, subtype.coe_mk, pi.zero_apply, ring_hom.map_zero, algebra.smul_def, mul_eq_zero, is_fraction_ring.to_map_eq_zero_iff] at this, exact this.resolve_left (mem_non_zero_divisors_iff_ne_zero.mp hb), }, { ext i, refine is_fraction_ring.injective A K _, calc algebra_map A K (M.mul_vec (Œª (i : n), f (v i) _) i) = ((algebra_map A K).map_matrix M).mul_vec (algebra_map _ K b ‚Ä¢ v) i : _ ... = 0 : _ ... = algebra_map A K 0 : (ring_hom.map_zero _).symm, { simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def] }, { rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero] } } }
obtain ‚ü®‚ü®b, hb‚ü©, ba_eq‚ü© := is_localization.exist_integer_multiples_of_finset (non_zero_divisors A) (finset.univ.image v)
choose f hf using ba_eq
refine ‚ü®Œª i, f _ (finset.mem_image.mpr ‚ü®i, finset.mem_univ i, rfl‚ü©), mt (Œª h, funext $ Œª i, _) hv, _‚ü©
have := congr_arg (algebra_map A K) (congr_fun h i)
{ have := congr_arg (algebra_map A K) (congr_fun h i), rw [hf, subtype.coe_mk, pi.zero_apply, ring_hom.map_zero, algebra.smul_def, mul_eq_zero, is_fraction_ring.to_map_eq_zero_iff] at this, exact this.resolve_left (mem_non_zero_divisors_iff_ne_zero.mp hb), }
rw [hf, subtype.coe_mk, pi.zero_apply, ring_hom.map_zero, algebra.smul_def, mul_eq_zero, is_fraction_ring.to_map_eq_zero_iff] at this
exact this.resolve_left (mem_non_zero_divisors_iff_ne_zero.mp hb)
ext i
{ ext i, refine is_fraction_ring.injective A K _, calc algebra_map A K (M.mul_vec (Œª (i : n), f (v i) _) i) = ((algebra_map A K).map_matrix M).mul_vec (algebra_map _ K b ‚Ä¢ v) i : _ ... = 0 : _ ... = algebra_map A K 0 : (ring_hom.map_zero _).symm, { simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def] }, { rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero] } }
refine is_fraction_ring.injective A K _
calc algebra_map A K (M.mul_vec (Œª (i : n), f (v i) _) i) = ((algebra_map A K).map_matrix M).mul_vec (algebra_map _ K b ‚Ä¢ v) i : _ ... = 0 : _ ... = algebra_map A K 0 : (ring_hom.map_zero _).symm
simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def]
{ simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def] }
{ rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero] }
rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero]
intros
induction k with k IH
simp only [matrix.mul_one, list.take_zero, list.prod_nil]
{ simp only [matrix.mul_one, list.take_zero, list.prod_nil], }
have hkr : k < r := hk
{ have hkr : k < r := hk, let k' : fin r := ‚ü®k, hkr‚ü©, have : (list_transvec_row M).nth k = ‚Üë(transvection (inr unit.star) (inl k') (-M (inr unit.star) (inl k') / M (inr unit.star) (inr unit.star))), { simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn], refl }, simp only [list.take_succ, ‚Üê matrix.mul_assoc, this, list.prod_append, matrix.mul_one, matrix.mul_eq_mul, list.prod_cons, list.prod_nil, option.to_list_some], rw [mul_transvection_apply_of_ne, IH hkr.le], simp only [ne.def, not_false_iff], }
let k' : fin r := ‚ü®k, hkr‚ü©
have : (list_transvec_row M).nth k = ‚Üë(transvection (inr unit.star) (inl k') (-M (inr unit.star) (inl k') / M (inr unit.star) (inr unit.star)))
simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn]
{ simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn], refl }
refl
simp only [list.take_succ, ‚Üê matrix.mul_assoc, this, list.prod_append, matrix.mul_one, matrix.mul_eq_mul, list.prod_cons, list.prod_nil, option.to_list_some]
rw [mul_transvection_apply_of_ne, IH hkr.le]
simp only [ne.def, not_false_iff]
intros
rw [‚Üê update_snoc_last x m (x+y), f.map_add, update_snoc_last, update_snoc_last]
intros
apply linear_equiv.to_linear_map_injective
ext1
rw [reindex_comp_tprod, linear_equiv.refl_to_linear_map, equiv.refl_symm]
refl
intros
ext
ext; simp
simp
intros
conv_rhs { rw [‚Üê (prod_equiv_of_is_compl p q h).apply_symm_apply x] }
rw [coe_prod_equiv_of_is_compl', submodule.add_mem_iff_right _ (submodule.coe_mem _), mem_left_iff_eq_zero_of_disjoint h.disjoint]
intros
rw [polar, polar, add_comm, sub_sub, sub_sub, add_comm (f x) (f y)]
intros
have hs' : ‚àÄj : Œ∑, linear_independent R (Œª i : Œπs j, std_basis R Ms j (v j i))
intro j
{ intro j, exact (hs j).map' _ (ker_std_basis _ _ _) }
exact (hs j).map' _ (ker_std_basis _ _ _)
apply linear_independent_Union_finite hs'
assume j J _ hiJ
{ assume j J _ hiJ, simp [(set.Union.equations._eqn_1 _).symm, submodule.span_image, submodule.span_Union], have h‚ÇÄ : ‚àÄ j, span R (range (Œª (i : Œπs j), std_basis R Ms j (v j i))) ‚â§ range (std_basis R Ms j), { intro j, rw [span_le, linear_map.range_coe], apply range_comp_subset_range }, have h‚ÇÅ : span R (range (Œª (i : Œπs j), std_basis R Ms j (v j i))) ‚â§ ‚®Ü i ‚àà {j}, range (std_basis R Ms i), { rw @supr_singleton _ _ _ (Œª i, linear_map.range (std_basis R (Œª (j : Œ∑), Ms j) i)), apply h‚ÇÄ }, have h‚ÇÇ : (‚®Ü j ‚àà J, span R (range (Œª (i : Œπs j), std_basis R Ms j (v j i)))) ‚â§ ‚®Ü j ‚àà J, range (std_basis R (Œª (j : Œ∑), Ms j) j) := supr_le_supr (Œª i, supr_le_supr (Œª H, h‚ÇÄ i)), have h‚ÇÉ : disjoint (Œª (i : Œ∑), i ‚àà {j}) J, { convert set.disjoint_singleton_left.2 hiJ using 0 }, exact (disjoint_std_basis_std_basis _ _ _ _ h‚ÇÉ).mono h‚ÇÅ h‚ÇÇ }
simp [(set.Union.equations._eqn_1 _).symm, submodule.span_image, submodule.span_Union]
have h‚ÇÄ : ‚àÄ j, span R (range (Œª (i : Œπs j), std_basis R Ms j (v j i))) ‚â§ range (std_basis R Ms j)
intro j
{ intro j, rw [span_le, linear_map.range_coe], apply range_comp_subset_range }
rw [span_le, linear_map.range_coe]
apply range_comp_subset_range
have h‚ÇÅ : span R (range (Œª (i : Œπs j), std_basis R Ms j (v j i))) ‚â§ ‚®Ü i ‚àà {j}, range (std_basis R Ms i)
rw @supr_singleton _ _ _ (Œª i, linear_map.range (std_basis R (Œª (j : Œ∑), Ms j) i))
{ rw @supr_singleton _ _ _ (Œª i, linear_map.range (std_basis R (Œª (j : Œ∑), Ms j) i)), apply h‚ÇÄ }
apply h‚ÇÄ
have h‚ÇÇ : (‚®Ü j ‚àà J, span R (range (Œª (i : Œπs j), std_basis R Ms j (v j i)))) ‚â§ ‚®Ü j ‚àà J, range (std_basis R (Œª (j : Œ∑), Ms j) j) := supr_le_supr (Œª i, supr_le_supr (Œª H, h‚ÇÄ i))
have h‚ÇÉ : disjoint (Œª (i : Œ∑), i ‚àà {j}) J
{ convert set.disjoint_singleton_left.2 hiJ using 0 }
convert set.disjoint_singleton_left.2 hiJ using 0
exact (disjoint_std_basis_std_basis _ _ _ _ h‚ÇÉ).mono h‚ÇÅ h‚ÇÇ
intros
simp only [ltensor, rtensor, ‚Üê map_comp, id_comp, comp_id]
intros
simp only [exists_unique_iff_exists] at h
exact h.unique ‚ü®hpy‚ÇÅ, hqy‚ÇÅ‚ü© ‚ü®hpy‚ÇÇ, hqy‚ÇÇ‚ü©
intros
rw [@iff_def (¬¨ a), @iff_def' a]; exact and_congr decidable.not_imp_not decidable.not_imp_not
rw [@iff_def (¬¨ a), @iff_def' a]
exact and_congr decidable.not_imp_not decidable.not_imp_not
intros
cases (pi univ s).eq_empty_or_nonempty with h h
{ cases (pi univ s).eq_empty_or_nonempty with h h, simp [h], exact (bounded_by_le _).trans_eq (pi_premeasure_pi h) }
simp [h]
exact (bounded_by_le _).trans_eq (pi_premeasure_pi h)
intros
apply measurable_of_measurable_coe
intros s hs
simp_rw [map_apply measurable_prod_mk_left hs]
exact measurable_measure_prod_mk_left hs
intros
filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk]
intros x hx
exact ‚ü®Œª y, hf.mk f (x, y), hf.measurable_mk.comp measurable_prod_mk_left, hx‚ü©
intros
rw [‚Üê s.neg_le_neg_iff _ hu, neg_zero] at hsu
rw [‚Üê s.neg_le_neg_iff _ hv, neg_zero] at hsv
have := of_diff_eq_zero_of_symm_diff_eq_zero_positive hu hv hsu hsv
simp only [pi.neg_apply, neg_eq_zero, coe_neg] at this
exact this hs
intros
rw [‚Üê lift_rel_mk_mk, mk_coe_fn, mk_coe_fn]
intros
simp_rw [condexp_ind_smul]
{ simp_rw [condexp_ind_smul], rw [to_span_singleton_smul, smul_comp_LpL, smul_apply], }
rw [to_span_singleton_smul, smul_comp_LpL, smul_apply]
intros
simp only [has_finite_integral, of_real_norm_eq_coe_nnnorm]
intros
refine ‚ü®hf.ae_measurable.real_to_nnreal.coe_nnreal_real, _‚ü©
rw has_finite_integral_iff_norm
refine lt_of_le_of_lt _ ((has_finite_integral_iff_norm _).1 hf.has_finite_integral)
apply lintegral_mono
assume x
simp [real.norm_eq_abs, ennreal.of_real_le_of_real, abs_le, abs_nonneg, le_abs_self]
intros
apply (integrable_zero _ _ _).congr
change (0 : measure Œ±) {x | 0 ‚â† f x} = 0
refl
intros
simp_rw [dist, norm_def]
congr' 1
apply snorm_congr_ae (coe_fn_sub _ _)
intros
rw [Lp.norm_def, snorm_congr_ae indicator_const_Lp_coe_fn, snorm_indicator_const' hs hŒºs_ne_zero ennreal.top_ne_zero, ennreal.top_to_real, div_zero, ennreal.rpow_zero, mul_one, ennreal.coe_to_real, coe_nnnorm]
intros
convert Lp.tendsto_Lp_iff_tendsto_‚Ñíp' _ _
ext1 n
apply snorm_congr_ae
filter_upwards [((f_‚Ñíp n).sub f_lim_‚Ñíp).coe_fn_to_Lp, Lp.coe_fn_sub ((f_‚Ñíp n).to_Lp (f n)) (f_lim_‚Ñíp.to_Lp f_lim)]
intros x hx‚ÇÅ hx‚ÇÇ
rw ‚Üê hx‚ÇÇ
exact hx‚ÇÅ.symm
intros
rw ‚Üê snorm_const_lt_top_iff hp_ne_zero hp_ne_top
exact ‚ü®Œª h, h.2, Œª h, ‚ü®ae_measurable_const, h‚ü©‚ü©
intros
apply hs.induction_on
{ simp }
simp
intros a s ha hs hf
{ intros a s ha hs hf, simp [hf, or_imp_distrib, forall_and_distrib] }
simp [hf, or_imp_distrib, forall_and_distrib]
intros
rw [‚Üê integral_add_adjacent_intervals hac hcd, add_assoc, add_left_comm, integral_add_adjacent_intervals hac (hac.symm.trans hab), add_comm]
intros
refine le_trans le_top (le_of_eq _)
have hp0_inv_lt : 0 < 1/p
simp [hp0_lt]
simp [hp0_lt]
rw [hf_top, ennreal.top_rpow_of_pos hp0_inv_lt]
simp [hq0, hg_nonzero]
intros
rw ‚Üê measure.restrict_apply_univ at *
haveI : is_finite_measure (Œº.restrict s) := ‚ü®‚Äπ_‚Ä∫‚ü©
exact norm_integral_le_of_norm_le_const hC
intros
{ cases i, exacts [h‚ÇÇ, h‚ÇÅ] }
cases i
exacts [h‚ÇÇ, h‚ÇÅ]
intros
simp [apply_eq_coe_to_fun, Œº.mono' _ _ h]
intros
simp only [index, nat.Inf_eq_zero]
left
use ‚àÖ
simp only [finset.card_empty, empty_subset, mem_set_of_eq, eq_self_iff_true, and_self]
intros
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp *
{ convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp * }
simp *
simp *
intros
simp only [volume_pi_Ioc, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
rw [infi, Inf_apply (range_nonempty m)]
{ rw [infi, Inf_apply (range_nonempty m)], simp only [infi_range] }
simp only [infi_range]
intros
ext1 s hs
{ ext1 s hs, erw [with_density·µ•_apply (integrable_zero Œ± E Œº) hs], simp, }
erw [with_density·µ•_apply (integrable_zero Œ± E Œº) hs]
simp
intros
simp [map]
intros
{ rw [ppow, dif_neg (ne_of_gt kpos)], refl }
rw [ppow, dif_neg (ne_of_gt kpos)]
refl
intros
apply nat.eq_prime_pow_of_dvd_least_prime_pow
{ norm_num, }
norm_num
intro o
{ intro o, have œâ_pow := order_of_dvd_iff_pow_eq_one.1 o, replace œâ_pow := congr_arg (units.coe_hom (X (q (p'+2))) : units (X (q (p'+2))) ‚Üí X (q (p'+2))) œâ_pow, simp at œâ_pow, have h : (1 : zmod (q (p'+2))) = -1 := congr_arg (prod.fst) ((œâ_pow.symm).trans (œâ_pow_eq_neg_one p' h)), haveI : fact (2 < (q (p'+2) : ‚Ñï)) := ‚ü®two_lt_q _‚ü©, apply zmod.neg_one_ne_one h.symm, }
have œâ_pow := order_of_dvd_iff_pow_eq_one.1 o
replace œâ_pow := congr_arg (units.coe_hom (X (q (p'+2))) : units (X (q (p'+2))) ‚Üí X (q (p'+2))) œâ_pow
simp at œâ_pow
have h : (1 : zmod (q (p'+2))) = -1 := congr_arg (prod.fst) ((œâ_pow.symm).trans (œâ_pow_eq_neg_one p' h))
haveI : fact (2 < (q (p'+2) : ‚Ñï)) := ‚ü®two_lt_q _‚ü©
apply zmod.neg_one_ne_one h.symm
apply order_of_dvd_iff_pow_eq_one.2
{ apply order_of_dvd_iff_pow_eq_one.2, apply units.ext, push_cast, exact œâ_pow_eq_one p' h, }
apply units.ext
push_cast
exact œâ_pow_eq_one p' h
intros
rw [mul_comm, mul_inv hz]
intros
simp [padic_val_nat]
intros
apply zmod.ring_hom_eq_of_ker_eq
ext x
rw [ring_hom.mem_ker, ring_hom.mem_ker]
simp only [function.comp_app, zmod.cast_hom_apply, ring_hom.coe_comp]
simp only [to_zmod_pow, to_zmod_hom, ring_hom.coe_mk]
rw [zmod.cast_nat_cast (pow_dvd_pow p h), zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]
{ rw [sub_self], apply ideal.zero_mem _, }
rw [sub_self]
apply ideal.zero_mem _
rw ideal.mem_span_singleton
{ rw ideal.mem_span_singleton, rcases dvd_appr_sub_appr x m n h with ‚ü®c, hc‚ü©, use c, rw [‚Üê nat.cast_sub (appr_mono _ h), hc, nat.cast_mul, nat.cast_pow], }
rcases dvd_appr_sub_appr x m n h with ‚ü®c, hc‚ü©
use c
rw [‚Üê nat.cast_sub (appr_mono _ h), hc, nat.cast_mul, nat.cast_pow]
{ apply_instance }
apply_instance
simp only [pythagorean_triple, zero_mul, zero_add]
intros
simp [to_complex_def]
intros
rw [‚Üêis_atomic_dual_iff_is_coatomic, ‚Üêis_atomic_dual_iff_is_coatomic]
{ rw [‚Üêis_atomic_dual_iff_is_coatomic, ‚Üêis_atomic_dual_iff_is_coatomic], exact f.dual.is_atomic_iff }
exact f.dual.is_atomic_iff
intros
rw [sup_sdiff_self_right, sup_sdiff_self_right, sup_comm]
intros
rw [sdiff_sdiff_right_self, inf_of_le_right h]
intros
simp [disjoint_iff]
intros
exact is_lub_singleton.union hs
intros
rcases is_compactly_generated.exists_Sup_eq b with ‚ü®s, hs, rfl‚ü©
exact le_antisymm (Sup_le (Œª c hc, hc.2)) (Sup_le_Sup (Œª c cs, ‚ü®hs c cs, le_Sup cs‚ü©))
intros
have hf : monotone (Œª n, ‚®Ö i ‚â• n, f i)
from Œª n m hnm, le_infi (Œª i, (infi_le _ i).trans (le_infi (Œª h, infi_le _ (hnm.trans h))))
rw ‚Üêmonotone.supr_nat_add hf k
{ simp_rw [infi_ge_eq_infi_nat_add, ‚Üênat.add_assoc], }
simp_rw [infi_ge_eq_infi_nat_add, ‚Üênat.add_assoc]
intros
{ symmetry, exact supr_and }
symmetry
exact supr_and
intros
{ convert supr_unique, apply_instance }
convert supr_unique
apply_instance
intros
simp [directed, directed_on]; refine ball_congr (Œª x hx, by simp; refl)
simp [directed, directed_on]
intros
simpa only [mul_comm] using hf.neg_const_mul_at_bot hr
intros
rw [‚Üê (filter_basis.of_sets s).generate, generate_eq_generate_inter s]
rw [‚Üê (filter_basis.of_sets s).generate, generate_eq_generate_inter s] ; refl
refl
intros
simpa only [tendsto, hlb.ge_iff, mem_map, filter.eventually]
intros
simp [filter.frequently]
intros
simpa using bInter_mem finite_univ
intros
simp only [mem_seq_def, seq_subset, exists_prop, iff_self]
intros
cases ha with i ha
replace ha := ha.symm
cases hb with j hb
replace hb := hb.symm
wlog h : i ‚â§ j := le_total i j using [a b i j, b a j i]
rw [eq_some_iff] at ha hb
have := c.monotone h _ ha
apply mem_unique this hb
intros
refine (f.to_order_embedding.map_inf_le x y).antisymm _
simpa [‚Üê f.symm.le_iff_le] using f.symm.to_order_embedding.map_inf_le (f x) (f y)
intros
rw [symm_diff_comm, symm_diff_bot]
intros
change indep_sets ((Œª x, (m x).measurable_set') i) ((Œª x, (m x).measurable_set') j) Œº
exact Indep_sets.indep_sets h_indep hij
intros
rw [is_root, eval_map, eval‚ÇÇ_root]
intros
delta algebra.is_algebraic subalgebra.is_algebraic
simp only [algebra.mem_top, forall_prop_of_true, iff_self]
intros
rw [is_coprime_comm, is_coprime.mul_left_iff, is_coprime_comm, @is_coprime_comm _ _ z]
intros
refine le_trans _ (is_integral_closure.range_le_span_dual_basis (integral_closure A L) b hb_int)
intros x hx
exact ‚ü®‚ü®x, hx‚ü©, rfl‚ü©
intros
have gen_ne_zero : generator s ‚â† 0
rw [ne.def, ‚Üê eq_bot_iff_generator_eq_zero]
{ rw [ne.def, ‚Üê eq_bot_iff_generator_eq_zero], assumption }
assumption
rcases associated_pow_irreducible gen_ne_zero hirr with ‚ü®n, u, hnu‚ü©
use n
have : span _ = _ := span_singleton_generator s
rw [‚Üê this, ‚Üê hnu, span_singleton_eq_span_singleton]
use u
intros
cases subsingleton_or_nontrivial R with h h
cases subsingleton_or_nontrivial R with h h; haveI := h
haveI := h
rw [subsingleton.elim (1 : hahn_series Œì R) 0, order_zero]
{ rw [subsingleton.elim (1 : hahn_series Œì R) 0, order_zero] }
haveI := h
{ exact order_single one_ne_zero }
exact order_single one_ne_zero
intros
rw pi_eq_sum_univ x
simp only [finset.sum_apply, smul_eq_mul, linear_map.map_sum, pi.smul_apply, linear_map.map_smul]
exact I.sum_mem (Œª j hj, I.mul_mem_right _ (hi j))
intros
rw [mul_comm, annihilator_mul]
intros
refine eq_bot_iff.2 (Œª x hx, _)
by_cases hx0 : x = 0
{ exact hx0.symm ‚ñ∏ ideal.zero_mem ‚ä• }
exact hx0.symm ‚ñ∏ ideal.zero_mem ‚ä•
exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (hRS x))
{ exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (hRS x)) }
intros
simpa only [sub_eq_add_neg] using f.is_integral_add hx (f.is_integral_neg hy)
intros
refine eq_bot_iff.2 (le_trans jacobson_bot_polynomial_le_Inf_map_maximal _)
refine (Œª f hf, ((submodule.mem_bot _).2 (polynomial.ext (Œª n, trans _ (coeff_zero n).symm))))
suffices : f.coeff n ‚àà ideal.jacobson ‚ä•
rwa [h, submodule.mem_bot] at this
rwa [h, submodule.mem_bot] at this
exact mem_Inf.2 (Œª j hj, (mem_map_C_iff.1 ((mem_Inf.1 hf) ‚ü®j, ‚ü®hj.2, rfl‚ü©‚ü©)) n)
intros
rw [is_noetherian_iff_well_founded, well_founded.well_founded_iff_has_max']
intros
simp [frange, finset.image_subset_iff]
simp only [‚Üê C_1, coeff_C]
assume n hn
simp only [exists_prop, ite_eq_right_iff, not_forall] at hn
simp [hn]
intros
rcases hdvd with ‚ü®r, rfl‚ü©
rw [is_primitive_iff_content_eq_one, ‚Üê normalize_content, normalize_eq_one, is_unit_iff_dvd_one]
apply dvd.intro r.content
rwa [is_primitive_iff_content_eq_one, content_mul] at hp
intros
simp [pochhammer_eval_zero, h]
intros
rw [coeff, monomial_def, linear_map.proj_apply, linear_map.std_basis_apply, function.update_apply, pi.zero_apply]
intros
rw [‚Üê monomial_zero_eq_C_apply, coeff_monomial]
intros
simp_rw is_simple_module_iff_is_atom
exact Sup_atoms_eq_top
intros
{ classical, apply dif_neg, apply (mt mk_eq_zero.1 h) }
classical
apply dif_neg
apply (mt mk_eq_zero.1 h)
intros
{ rw supp_quot, exact ideal.map_quotient_self _ }
rw supp_quot
exact ideal.map_quotient_self _
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [witt_add, witt_structure_rat, alg_hom.map_add, ring_hom.map_add, rename_X, X_in_terms_of_W_zero, map_X, witt_polynomial_zero, bind‚ÇÅ_X_right, map_witt_structure_int]
intros
induction i with i h
{ simp only [one_coeff_zero, ne.def, pow_zero] }
simp only [one_coeff_zero, ne.def, pow_zero]
rw [pow_succ', ‚Üê frobenius_verschiebung, coeff_frobenius_char_p, verschiebung_coeff_succ, h, one_pow]
{ rw [pow_succ', ‚Üê frobenius_verschiebung, coeff_frobenius_char_p, verschiebung_coeff_succ, h, one_pow], }
intros
witt_truncate_fun_tac
intros
rw [X_in_terms_of_W_eq, range_zero, sum_empty, pow_zero, C_1, mul_one, sub_zero]
intros
simp [le_antisymm_iff]
intros
split
intro h
{ intro h, by_cases ha : a = 0, { left, exact ha }, right, by_cases hb : b = 0, { left, exact hb }, right, rw [‚Üê ne, ‚Üê one_le_iff_ne_zero] at ha hb, split, { rw [‚Üê mul_one a], refine lt_of_le_of_lt (mul_le_mul' (le_refl a) hb) h }, { rw [‚Üê _root_.one_mul b], refine lt_of_le_of_lt (mul_le_mul' ha (le_refl b)) h }}
by_cases ha : a = 0
left
{ left, exact ha }
exact ha
right
by_cases hb : b = 0
left
{ left, exact hb }
exact hb
right
rw [‚Üê ne, ‚Üê one_le_iff_ne_zero] at ha hb
split
rw [‚Üê mul_one a]
{ rw [‚Üê mul_one a], refine lt_of_le_of_lt (mul_le_mul' (le_refl a) hb) h }
refine lt_of_le_of_lt (mul_le_mul' (le_refl a) hb) h
rw [‚Üê _root_.one_mul b]
{ rw [‚Üê _root_.one_mul b], refine lt_of_le_of_lt (mul_le_mul' ha (le_refl b)) h }
refine lt_of_le_of_lt (mul_le_mul' ha (le_refl b)) h
rintro (rfl|rfl|‚ü®ha,hb‚ü©); simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
rintro (rfl|rfl|‚ü®ha,hb‚ü©)
simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
intros
simp only [quotient.eq] at hl hr
apply quotient.sound
apply equiv_of_mk_equiv L R hl hr
intros
rw subsingleton.elim f g
intros
rw [‚Üê cardinal.ord_omega, cardinal.lt_ord, lt_omega]
rw [‚Üê cardinal.ord_omega, cardinal.lt_ord, lt_omega]; simp only [card_eq_nat]
simp only [card_eq_nat]
intros
cases n; simp
cases n
simp
simp
intros
simp
intros
simp [term, zero_nsmul, one_nsmul]
intros
have ha' := normalize_fin_lt.mk rfl ha (h.trans hb.lt)
have ha' := normalize_fin_lt.mk rfl ha (h.trans hb.lt); rwa [‚Üê hb.coe, ‚Üê ha'.coe] at h
rwa [‚Üê hb.coe, ‚Üê ha'.coe] at h
intros
rw [prl, prr, prt]
intros
cc
intros
simp [ha, tsum]; exact some_spec ha
simp [ha, tsum]
exact some_spec ha
intros
apply_instance
intros
rw [‚Üê compl_Ioi, interior_compl, closure_Ioi, compl_Ici]
intros
simp only [continuous_within_at, continuous_at, ‚Üê tendsto_sup, nhds_left_sup_nhds_right]
intros
rw continuous_iff_coinduced_le
refine le_Inf _
rintros _ ‚ü®t', ht', rfl‚ü©
exact ht'
intros
refine ‚ü®Œª t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ x hx, h_nhds _ _ hx (is_open.inter (h_open _ ht‚ÇÅ) (h_open _ ht‚ÇÇ)), _, _‚ü©
{ refine sUnion_eq_univ_iff.2 (Œª a, _), rcases h_nhds a univ trivial is_open_univ with ‚ü®u, h‚ÇÅ, h‚ÇÇ, -‚ü©, exact ‚ü®u, h‚ÇÅ, h‚ÇÇ‚ü© }
refine sUnion_eq_univ_iff.2 (Œª a, _)
rcases h_nhds a univ trivial is_open_univ with ‚ü®u, h‚ÇÅ, h‚ÇÇ, -‚ü©
exact ‚ü®u, h‚ÇÅ, h‚ÇÇ‚ü©
refine (le_generate_from h_open).antisymm (Œª u hu, _)
{ refine (le_generate_from h_open).antisymm (Œª u hu, _), refine (@is_open_iff_nhds Œ± (generate_from s) u).mpr (Œª a ha, _), rcases h_nhds a u ha hu with ‚ü®v, hvs, hav, hvu‚ü©, rw nhds_generate_from, exact binfi_le_of_le v ‚ü®hav, hvs‚ü© (le_principal_iff.2 hvu) }
refine (@is_open_iff_nhds Œ± (generate_from s) u).mpr (Œª a ha, _)
rcases h_nhds a u ha hu with ‚ü®v, hvs, hav, hvu‚ü©
rw nhds_generate_from
exact binfi_le_of_le v ‚ü®hav, hvs‚ü© (le_principal_iff.2 hvu)
intros
simp [closure_eq_compl_interior_compl]
intros
simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map]
{ simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map], refl }
refl
intros
change (X.a ‚â´ f.f) _ = _
rw ‚Üêf.h
refl
intros
split
intro h
{ intro h, haveI : limits.preserves_limits Profinite_to_CompHaus := infer_instance, haveI : mono (Profinite_to_CompHaus.map f) := infer_instance, rwa ‚Üê CompHaus.mono_iff_injective }
haveI : limits.preserves_limits Profinite_to_CompHaus := infer_instance
haveI : mono (Profinite_to_CompHaus.map f) := infer_instance
rwa ‚Üê CompHaus.mono_iff_injective
rw ‚Üê category_theory.mono_iff_injective
{ rw ‚Üê category_theory.mono_iff_injective, apply faithful_reflects_mono (forget Profinite) }
apply faithful_reflects_mono (forget Profinite)
intros
simp
intros
apply is_preconnected_of_forall x
rintros y ‚ü®s, sc, ys‚ü©
exact ‚ü®s, subset_sUnion_of_mem sc, H1 s sc, ys, H2 s sc‚ü©
intros
rw [is_open_map_iff_nhds_le]
rintros ‚ü®a, b‚ü©
rw [nhds_prod_eq, nhds_prod_eq, ‚Üê filter.prod_map_map_eq]
exact filter.prod_mono (is_open_map_iff_nhds_le.1 hf a) (is_open_map_iff_nhds_le.1 hg b)
intros
rw [nhds_within, principal_empty, inf_bot_eq]
intros
apply continuous_on.if'
rintros a ha
{ rintros a ha, simp only [‚Üê hp a ha, if_t_t], apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure), exact hf a ‚ü®ha.1, ha.2.1‚ü© }
simp only [‚Üê hp a ha, if_t_t]
apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure)
exact hf a ‚ü®ha.1, ha.2.1‚ü©
rintros a ha
{ rintros a ha, simp only [hp a ha, if_t_t], apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure), rcases ha with ‚ü®has, ‚ü®_, ha‚ü©‚ü©, rw [‚Üê mem_compl_iff, ‚Üê closure_compl] at ha, apply hg a ‚ü®has, ha‚ü© }
simp only [hp a ha, if_t_t]
apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure)
rcases ha with ‚ü®has, ‚ü®_, ha‚ü©‚ü©
rw [‚Üê mem_compl_iff, ‚Üê closure_compl] at ha
apply hg a ‚ü®has, ha‚ü©
exact hf.mono (inter_subset_inter_right s subset_closure)
{ exact hf.mono (inter_subset_inter_right s subset_closure) }
exact hg.mono (inter_subset_inter_right s subset_closure)
{ exact hg.mono (inter_subset_inter_right s subset_closure) }
intros
simp only [has_sum, coe_sum.symm, tendsto_coe]
intros
rw [e.map_nhds_within_eq hx, h.image_eq, e.nhds_within_target_inter (e.map_source hx)]
intros
{ rw ‚Üê image_univ, exact hf _ is_open_univ }
rw ‚Üê image_univ
exact hf _ is_open_univ
intros
simp [hf.1]
intros
have : (‚®Ö q, dist (Œ¶ p) (Œ¶ q) + dist (Œ® p) (Œ® q)) = 0
have A : ‚àÄ q, 0 ‚â§ dist (Œ¶ p) (Œ¶ q) + dist (Œ® p) (Œ® q) := Œªq, by rw ‚Üê add_zero (0 : ‚Ñù); exact add_le_add dist_nonneg dist_nonneg
{ have A : ‚àÄ q, 0 ‚â§ dist (Œ¶ p) (Œ¶ q) + dist (Œ® p) (Œ® q) := Œªq, by rw ‚Üê add_zero (0 : ‚Ñù); exact add_le_add dist_nonneg dist_nonneg, refine le_antisymm _ (le_cinfi A), have : 0 = dist (Œ¶ p) (Œ¶ p) + dist (Œ® p) (Œ® p), by simp, rw this, exact cinfi_le ‚ü®0, forall_range_iff.2 A‚ü© p }
refine le_antisymm _ (le_cinfi A)
have : 0 = dist (Œ¶ p) (Œ¶ p) + dist (Œ® p) (Œ® p)
simp
simp
rw this
exact cinfi_le ‚ü®0, forall_range_iff.2 A‚ü© p
rw [glue_dist, this, zero_add]
rw [dimH_univ_eq_finrank ‚Ñù, finite_dimensional.finrank_self, nat.cast_one]
intros
rintro a (rfl : a = x) b (rfl : b = a)
{ rintro a (rfl : a = x) b (rfl : b = a), rw edist_self, exact zero_le _ }
rw edist_self
exact zero_le _
intros
have := paracompact_space.locally_finite_refinement (range u) coe (set_coe.forall.2 $ forall_range_iff.2 uo) (by rwa [‚Üê sUnion_range, subtype.range_coe])
simp only [set_coe.exists, subtype.coe_mk, exists_range_iff', Union_eq_univ_iff, exists_prop] at this
choose Œ± t hto hXt htf ind hind
choose t_inv ht_inv using hXt
choose U hxU hU using htf
refine ‚ü®Œª i, ‚ãÉ (a : Œ±) (ha : ind a = i), t a, _, _, _, _‚ü©
exact Œª a, is_open_Union (Œª a, is_open_Union $ Œª ha, hto a)
{ exact Œª a, is_open_Union (Œª a, is_open_Union $ Œª ha, hto a) }
simp only [eq_univ_iff_forall, mem_Union]
{ simp only [eq_univ_iff_forall, mem_Union], exact Œª x, ‚ü®ind (t_inv x), _, rfl, ht_inv _‚ü© }
exact Œª x, ‚ü®ind (t_inv x), _, rfl, ht_inv _‚ü©
refine Œª x, ‚ü®U x, hxU x, ((hU x).image ind).subset _‚ü©
{ refine Œª x, ‚ü®U x, hxU x, ((hU x).image ind).subset _‚ü©, simp only [subset_def, mem_Union, mem_set_of_eq, set.nonempty, mem_inter_eq], rintro i ‚ü®y, ‚ü®a, rfl, hya‚ü©, hyU‚ü©, exact mem_image_of_mem _ ‚ü®y, hya, hyU‚ü© }
simp only [subset_def, mem_Union, mem_set_of_eq, set.nonempty, mem_inter_eq]
rintro i ‚ü®y, ‚ü®a, rfl, hya‚ü©, hyU‚ü©
exact mem_image_of_mem _ ‚ü®y, hya, hyU‚ü©
simp only [subset_def, mem_Union]
{ simp only [subset_def, mem_Union], rintro i x ‚ü®a, rfl, hxa‚ü©, exact hind _ hxa }
rintro i x ‚ü®a, rfl, hxa‚ü©
exact hind _ hxa
intros
assume y hy
rcases lt_supr_iff.1 hy with ‚ü®i, hi‚ü©
filter_upwards [h i y hi]
assume x' hx'
exact lt_supr_iff.2 ‚ü®i, hx'‚ü©
intros
apply stalk_to_fiber_injective
intros
rcases hU ‚ü®x, U.2‚ü© with ‚ü®U', mU, iU, gU, wU‚ü©
rcases hV ‚ü®x, V.2‚ü© with ‚ü®V', mV, iV, gV, wV‚ü©
have wUx := wU ‚ü®x, mU‚ü©
dsimp at wUx
erw wUx at e
clear wUx
have wVx := wV ‚ü®x, mV‚ü©
dsimp at wVx
erw wVx at e
clear wVx
rcases F.germ_eq x mU mV gU gV e with ‚ü®W, mW, iU', iV', e'‚ü©
dsimp at e'
use ‚ü®W ‚äì (U' ‚äì V'), ‚ü®mW, mU, mV‚ü©‚ü©
refine ‚ü®_, _, _‚ü©
change W ‚äì (U' ‚äì V') ‚ü∂ U.val
{ change W ‚äì (U' ‚äì V') ‚ü∂ U.val, exact (opens.inf_le_right _ _) ‚â´ (opens.inf_le_left _ _) ‚â´ iU, }
exact (opens.inf_le_right _ _) ‚â´ (opens.inf_le_left _ _) ‚â´ iU
change W ‚äì (U' ‚äì V') ‚ü∂ V.val
{ change W ‚äì (U' ‚äì V') ‚ü∂ V.val, exact (opens.inf_le_right _ _) ‚â´ (opens.inf_le_right _ _) ‚â´ iV, }
exact (opens.inf_le_right _ _) ‚â´ (opens.inf_le_right _ _) ‚â´ iV
intro w
{ intro w, dsimp, specialize wU ‚ü®w.1, w.2.2.1‚ü©, dsimp at wU, specialize wV ‚ü®w.1, w.2.2.2‚ü©, dsimp at wV, erw [wU, ‚ÜêF.germ_res iU' ‚ü®w, w.2.1‚ü©, wV, ‚ÜêF.germ_res iV' ‚ü®w, w.2.1‚ü©, category_theory.types_comp_apply, category_theory.types_comp_apply, e'] }
dsimp
specialize wU ‚ü®w.1, w.2.2.1‚ü©
dsimp at wU
specialize wV ‚ü®w.1, w.2.2.2‚ü©
dsimp at wV
erw [wU, ‚ÜêF.germ_res iU' ‚ü®w, w.2.1‚ü©, wV, ‚ÜêF.germ_res iV' ‚ü®w, w.2.1‚ü©, category_theory.types_comp_apply, category_theory.types_comp_apply, e']
intros
rw [uniformity_prod]; exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)
rw [uniformity_prod]
exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)
intros
rw ‚Üê tendsto_locally_uniformly_on_univ at h ‚ä¢
rw continuous_iff_continuous_on_univ at cg
exact h.comp _ (maps_to_univ _ _) cg
intros
cases a; cases b; exact dec_trivial
cases a; cases b
cases a
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw int.mul_comm
simp [neg_succ_of_nat_mul_neg_of_nat, nat.mul_comm]
intros
have h := int.add_le_add_right h c
rwa int.sub_add_cancel at h
intros
simp [gcd]
intros
have npos : 0 < n := n.eq_zero_or_pos.resolve_left (Œª n0, by rw [n0, nat.zero_mul] at h‚ÇÅ; exact nat.not_lt_zero _ h‚ÇÅ)
apply nat.div_eq_of_lt_le
rw [nat.mul_sub_right_distrib, nat.mul_comm]
{ rw [nat.mul_sub_right_distrib, nat.mul_comm], apply nat.sub_le_sub_left, exact (div_lt_iff_lt_mul _ _ npos).1 (lt_succ_self _) }
apply nat.sub_le_sub_left
exact (div_lt_iff_lt_mul _ _ npos).1 (lt_succ_self _)
change succ (pred (n * p - x)) ‚â§ (succ (pred (p - x / n))) * n
{ change succ (pred (n * p - x)) ‚â§ (succ (pred (p - x / n))) * n, rw [succ_pred_eq_of_pos (nat.sub_pos_of_lt h‚ÇÅ), succ_pred_eq_of_pos (nat.sub_pos_of_lt _)], { rw [nat.mul_sub_right_distrib, nat.mul_comm], apply nat.sub_le_sub_left, apply div_mul_le_self }, { apply (div_lt_iff_lt_mul _ _ npos).2, rwa nat.mul_comm } }
rw [succ_pred_eq_of_pos (nat.sub_pos_of_lt h‚ÇÅ), succ_pred_eq_of_pos (nat.sub_pos_of_lt _)]
rw [nat.mul_sub_right_distrib, nat.mul_comm]
{ rw [nat.mul_sub_right_distrib, nat.mul_comm], apply nat.sub_le_sub_left, apply div_mul_le_self }
apply nat.sub_le_sub_left
apply div_mul_le_self
{ apply (div_lt_iff_lt_mul _ _ npos).2, rwa nat.mul_comm }
apply (div_lt_iff_lt_mul _ _ npos).2
rwa nat.mul_comm
intros
apply nat.strong_induction_on m
clear m
intros m IH
cases decidable.em (0 < k ‚àß k ‚â§ m) with h h'
have h' : m - k < m
{ have h' : m - k < m, { apply nat.sub_lt _ h.left, apply lt_of_lt_of_le h.left h.right }, rw [div_def, mod_def, if_pos h, if_pos h], simp [nat.left_distrib, IH _ h', nat.add_comm, nat.add_left_comm], rw [nat.add_comm, ‚Üê nat.add_sub_assoc h.right, nat.mul_one, nat.add_sub_cancel_left] }
apply nat.sub_lt _ h.left
{ apply nat.sub_lt _ h.left, apply lt_of_lt_of_le h.left h.right }
apply lt_of_lt_of_le h.left h.right
rw [div_def, mod_def, if_pos h, if_pos h]
simp [nat.left_distrib, IH _ h', nat.add_comm, nat.add_left_comm]
rw [nat.add_comm, ‚Üê nat.add_sub_assoc h.right, nat.mul_one, nat.add_sub_cancel_left]
rw [div_def, mod_def, if_neg h', if_neg h', nat.mul_zero, nat.add_zero]
{ rw [div_def, mod_def, if_neg h', if_neg h', nat.mul_zero, nat.add_zero] }
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
{ rintros _ ‚ü®i, j, hi, hj, rfl‚ü©, exact mul_mem_mul hi hj }
rintros _ ‚ü®i, j, hi, hj, rfl‚ü©
exact mul_mem_mul hi hj
intros
rw [‚Üê multiset.rel_eq, multiset.rel_map]
{ rw [‚Üê multiset.rel_eq, multiset.rel_map], simp only [mk_eq_mk_iff_associated] }
simp only [mk_eq_mk_iff_associated]
intros
rw [‚Üê prod_insert (not_mem_erase a s), insert_erase h]
intros
simp only [finset.prod, multiset.map_const, multiset.prod_repeat, one_pow]
intros
split_ifs with h
rw [finset.prod_eq_single a, dif_pos rfl]
{ rw [finset.prod_eq_single a, dif_pos rfl], { intros, rw dif_neg, cc }, { cc } }
{ intros, rw dif_neg, cc }
intros
rw dif_neg
cc
{ cc }
cc
rw finset.prod_eq_one
{ rw finset.prod_eq_one, intros, rw dif_neg, intro, cc }
intros
rw dif_neg
intro
cc
intros
rw [finprod, dif_pos]
refine finset.prod_subset hs (Œª x hx hxf, _)
rwa [hf.mem_to_finset, nmem_mul_support] at hxf
intros
simp
intros
rw eq_neg_iff_add_eq_zero
nth_rewrite 1 ‚Üê one_pow p
rw [‚Üê add_pow_char, add_left_neg, zero_pow (fact.out (nat.prime p)).pos]
intros
induction succ_n_le_m with m succ_n_le_m IH
{ refl }
refl
have : g.continuants_aux (m + 1) = g.continuants_aux m
{ have : g.continuants_aux (m + 1) = g.continuants_aux m, by { have : n ‚â§ m - 1, from nat.le_pred_of_lt succ_n_le_m, have : g.terminated_at (m - 1), from terminated_stable this terminated_at_n, have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1), from continuants_aux_stable_step_of_terminated this, have one_le_m : 1 ‚â§ m, from nat.one_le_of_lt succ_n_le_m, have : m - 1 + 2 = m + 2 - 1, from (nat.sub_add_comm one_le_m).symm, have : m - 1 + 1 = m + 1 - 1, from (nat.sub_add_comm one_le_m).symm, simpa [*] using stable_step }, exact (eq.trans this IH) }
have : n ‚â§ m - 1
have : n ‚â§ m - 1
{ have : n ‚â§ m - 1, from nat.le_pred_of_lt succ_n_le_m, have : g.terminated_at (m - 1), from terminated_stable this terminated_at_n, have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1), from continuants_aux_stable_step_of_terminated this, have one_le_m : 1 ‚â§ m, from nat.one_le_of_lt succ_n_le_m, have : m - 1 + 2 = m + 2 - 1, from (nat.sub_add_comm one_le_m).symm, have : m - 1 + 1 = m + 1 - 1, from (nat.sub_add_comm one_le_m).symm, simpa [*] using stable_step }
{ have : n ‚â§ m - 1, from nat.le_pred_of_lt succ_n_le_m, have : g.terminated_at (m - 1), from terminated_stable this terminated_at_n, have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1), from continuants_aux_stable_step_of_terminated this, have one_le_m : 1 ‚â§ m, from nat.one_le_of_lt succ_n_le_m, have : m - 1 + 2 = m + 2 - 1, from (nat.sub_add_comm one_le_m).symm, have : m - 1 + 1 = m + 1 - 1, from (nat.sub_add_comm one_le_m).symm, simpa [*] using stable_step }
from nat.le_pred_of_lt succ_n_le_m
from nat.le_pred_of_lt succ_n_le_m
have : g.terminated_at (m - 1)
have : g.terminated_at (m - 1)
from terminated_stable this terminated_at_n
from terminated_stable this terminated_at_n
have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1)
have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1)
from continuants_aux_stable_step_of_terminated this
from continuants_aux_stable_step_of_terminated this
have one_le_m : 1 ‚â§ m
have one_le_m : 1 ‚â§ m
from nat.one_le_of_lt succ_n_le_m
from nat.one_le_of_lt succ_n_le_m
have : m - 1 + 2 = m + 2 - 1
have : m - 1 + 2 = m + 2 - 1
from (nat.sub_add_comm one_le_m).symm
from (nat.sub_add_comm one_le_m).symm
have : m - 1 + 1 = m + 1 - 1
have : m - 1 + 1 = m + 1 - 1
from (nat.sub_add_comm one_le_m).symm
from (nat.sub_add_comm one_le_m).symm
simpa [*] using stable_step
simpa [*] using stable_step
exact (eq.trans this IH)
intros
{ rw mul_comm, exact mul_left_not_lt b h }
rw mul_comm
exact mul_left_not_lt b h
intros
ext
{ext, refl}
refl
intros
obtain ‚ü®m', hm', n', hn', h‚ü© := (exists_dvd_and_dvd_of_dvd_mul $ gcd_dvd_right k (m * n))
replace h : gcd k (m * n) = m' * n' := h
rw h
have hm'n' : m' * n' ‚à£ k := h ‚ñ∏ gcd_dvd_left _ _
apply mul_dvd_mul
have hm'k : m' ‚à£ k := (dvd_mul_right m' n').trans hm'n'
{ have hm'k : m' ‚à£ k := (dvd_mul_right m' n').trans hm'n', exact dvd_gcd hm'k hm' }
exact dvd_gcd hm'k hm'
have hn'k : n' ‚à£ k := (dvd_mul_left n' m').trans hm'n'
{ have hn'k : n' ‚à£ k := (dvd_mul_left n' m').trans hm'n', exact dvd_gcd hn'k hn' }
exact dvd_gcd hn'k hn'
intros
simp [geom_sum‚ÇÇ_def, f.map_sum]
intros
rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]
intros
rw [‚Üê sub_eq_zero, H, sub_eq_zero]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h], }
by_cases h : P
simp [h]
simp [h]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
replace h := group.mk.inj h
dsimp at h
rcases h with ‚ü®rfl, rfl, rfl, rfl, rfl, rfl‚ü©
refl
intros
induction n with n ih
{ rw [nat.mul_zero, pow_zero, pow_zero] }
rw [nat.mul_zero, pow_zero, pow_zero]
{ rw [nat.mul_succ, pow_add, pow_succ', ih] }
rw [nat.mul_succ, pow_add, pow_succ', ih]
intros
rw [sq, sq, mul_self_sub_mul_self]
intros
have : 0 ‚â§ C
simpa only [pow_zero, mul_one] using h 0
simpa only [pow_zero, mul_one] using h 0
refine this.eq_or_lt.elim (Œª h, or.inl h.symm) (Œª hC, or.inr ‚ü®hC, _‚ü©)
refine nonneg_of_mul_nonneg_left _ hC
simpa only [pow_one] using h 1
intros
induction b; simp [*, mul_add, pow_succ, add_comm]
induction b
simp [*, mul_add, pow_succ, add_comm]
simp [*, mul_add, pow_succ, add_comm]
intros
rw [‚Üê one_div_one_div a, h, one_div_one_div]
intros
rw [‚Üê mul_div_assoc, mul_div_right_comm]
intros
rw C.shape
{ rw C.shape, simp only [complex_shape.up_rel, zero_add], exact (nat.one_lt_succ_succ _).ne }
simp only [complex_shape.up_rel, zero_add]
exact (nat.one_lt_succ_succ _).ne
intros
rw C.d_to_eq r
apply image_subobject_iso_comp
intros
rw eq_top_iff
apply le_kernel_subobject
rw [C.d_from_eq_zero h, comp_zero]
intros
dsimp [d_next]
rcases c.next i with _|‚ü®i',w‚ü©
{ exact zero_comp.symm, }
exact zero_comp.symm
dsimp [d_next]
{ dsimp [d_next], simp, }
simp
intros
cases i
{ rw [d_from_eq_zero], simp, }
rw [d_from_eq_zero]
simp
{ rw [d_from_eq ((single‚ÇÄ V).obj X) rfl], simp, }
rw [d_from_eq ((single‚ÇÄ V).obj X) rfl]
simp
intros
induction n with d hd
{ simp [zero_nsmul, id_def] }
simp [zero_nsmul, id_def]
{ simp [hd, add_assoc, succ_nsmul] }
simp [hd, add_assoc, succ_nsmul]
intros
{ ext, refl, }
ext
refl
intros
suffices : ‚ÅÖ(‚ä• : lie_ideal R L), N‚ÅÜ ‚â§ ‚ä•
exact le_bot_iff.mp this
{ exact le_bot_iff.mp this, }
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ‚ü®‚ü®x, hx‚ü©, n, hn‚ü©
rw ‚Üê hn
change x ‚àà (‚ä• : lie_ideal R L) at hx
rw mem_bot at hx
simp [hx]
intros
induction k with k h
rw [derived_series_def, derived_series_of_ideal_zero, lower_central_series_zero]
{ rw [derived_series_def, derived_series_of_ideal_zero, lower_central_series_zero], exact le_refl _, }
exact le_refl _
have h' : derived_series R L k ‚â§ ‚ä§
{ have h' : derived_series R L k ‚â§ ‚ä§, { by simp only [le_top], }, rw [derived_series_def, derived_series_of_ideal_succ, lower_central_series_succ], exact lie_submodule.mono_lie _ _ _ _ h' h, }
simp only [le_top]
simp only [le_top]
{ by simp only [le_top], }
rw [derived_series_def, derived_series_of_ideal_succ, lower_central_series_succ]
exact lie_submodule.mono_lie _ _ _ _ h' h
intros
{ rw eq_bot_iff, exact derived_series_of_ideal_le_self ‚ä• k, }
rw eq_bot_iff
exact derived_series_of_ideal_le_self ‚ä• k
intros
{ rw ‚Üê map_le_iff_le_comap, apply le_refl _, }
rw ‚Üê map_le_iff_le_comap
apply le_refl _
intros
simp only [ne.def, smul_eq_zero, not_or_distrib]
intros
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff] at h
exact lt_of_smul_lt_smul_of_nonneg h (neg_nonneg_of_nonpos hc)
intros
simp [one_def]
intros
rw [mul_comm, div_lt_iff hc]
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonpos_right h (one_div_nonpos.2 hc)
intros
rw [div_add_div_same, ‚Üê two_mul, mul_div_cancel_left a two_ne_zero]
intros
rw [abs_eq_max_neg, max_comm, neg_neg, abs_eq_max_neg]
intros
rw [‚Üê mul_lt_mul_iff_left a, mul_inv_self, mul_one]
intros
rw [mul_comm c, mul_inv_le_inv_mul_iff, mul_comm]
intros
simp only [div_eq_mul_inv, min_mul_mul_left, min_inv_inv']
intros
rw [abs_mul, abs_mul_abs_self]
intros
simp only [‚Üê not_lt, inv_of_pos]
intros
induction n; simp [nat.succ_eq_add_one, add_nsmul, ‚Üê add_assoc, zero_nsmul, *] at *
induction n
simp [nat.succ_eq_add_one, add_nsmul, ‚Üê add_assoc, zero_nsmul, *] at *
simp [nat.succ_eq_add_one, add_nsmul, ‚Üê add_assoc, zero_nsmul, *] at *
intros
simp [*, neg_div_neg_eq] at *
intros
simp only [‚Üê inv_preimage, preimage_preimage, inv_inv, preimage_id']
{ simp only [‚Üê inv_preimage, preimage_preimage, inv_inv, preimage_id'] }
intros
rw ‚Üê mul_and_mul_iff
exact ‚ü®Œª ab, ‚ü®ab, by rwa mul_comm‚ü©, Œª rab, rab.1‚ü©
intros
rw [‚Üê mul_self_sub_mul_self, mul_one]
intros
simp [mk_alg_hom, mk_ring_hom, quot.sound (rel.of w)]
intros
dsimp [Œ¥]
{ dsimp [Œ¥], simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_Œ¥ H] }
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_Œ¥ H]
intros
rcases (hf.eventually.and hg.eventually).exists with ‚ü®r, hr‚ü©
exact ‚ü®r, hr.1.add hr.2‚ü©
intros
rcases hab.exists_eq_mul with ‚ü®œÜ, hœÜ, habœÜ‚ü©
have : (Œª (x : Œ±), a x ‚Ä¢ u x) - (Œª (x : Œ±), b x ‚Ä¢ v x) =·∂†[l] Œª x, b x ‚Ä¢ ((œÜ x ‚Ä¢ u x) - v x)
convert (habœÜ.comp‚ÇÇ (‚Ä¢) $ eventually_eq.refl _ u).sub (eventually_eq.refl _ (Œª x, b x ‚Ä¢ v x))
{ convert (habœÜ.comp‚ÇÇ (‚Ä¢) $ eventually_eq.refl _ u).sub (eventually_eq.refl _ (Œª x, b x ‚Ä¢ v x)), ext, rw [pi.mul_apply, mul_comm, mul_smul, ‚Üê smul_sub] }
ext
rw [pi.mul_apply, mul_comm, mul_smul, ‚Üê smul_sub]
refine (is_o_congr this.symm $ eventually_eq.rfl).mp ((is_O_refl b l).smul_is_o _)
rcases huv.is_O.exists_pos with ‚ü®C, hC, hCuv‚ü©
rw is_equivalent at *
rw is_o_iff at *
rw is_O_with at hCuv
simp only [metric.tendsto_nhds, dist_eq_norm] at hœÜ
intros c hc
specialize hœÜ ((c/2)/C) (div_pos (by linarith) hC)
specialize huv (show 0 < c/2, by linarith)
refine hœÜ.mp (huv.mp $ hCuv.mono $ Œª x hCuvx huvx hœÜx, _)
have key := calc ‚à•œÜ x - 1‚à• * ‚à•u x‚à• ‚â§ (c/2) / C * ‚à•u x‚à• : mul_le_mul_of_nonneg_right hœÜx.le (norm_nonneg $ u x) ... ‚â§ (c/2) / C * (C*‚à•v x‚à•) : mul_le_mul_of_nonneg_left hCuvx (div_pos (by linarith) hC).le ... = c/2 * ‚à•v x‚à• : by {field_simp [hC.ne.symm], ring}
calc ‚à•((Œª (x : Œ±), œÜ x ‚Ä¢ u x) - v) x‚à• = ‚à•(œÜ x - 1) ‚Ä¢ u x + (u x - v x)‚à• : by simp [sub_smul, sub_add] ... ‚â§ ‚à•(œÜ x - 1) ‚Ä¢ u x‚à• + ‚à•u x - v x‚à• : norm_add_le _ _ ... = ‚à•œÜ x - 1‚à• * ‚à•u x‚à• + ‚à•u x - v x‚à• : by rw norm_smul ... ‚â§ c / 2 * ‚à•v x‚à• + ‚à•u x - v x‚à• : add_le_add_right key _ ... ‚â§ c / 2 * ‚à•v x‚à• + c / 2 * ‚à•v x‚à• : add_le_add_left huvx _ ... = c * ‚à•v x‚à• : by ring
intros
suffices h : is_o u (Œª x, (1 : ùïú)) l
{ rwa is_o_one_iff at h }
rwa is_o_one_iff at h
exact huv.trans_is_O (is_O_one_of_tendsto ùïú hv)
intros
{ unfold is_O, exact exists_congr (Œª _, is_O_with_neg_right) }
unfold is_O
exact exists_congr (Œª _, is_O_with_neg_right)
intros
convert hc.mul (has_deriv_within_at_const x s d)
rw [mul_zero, add_zero]
intros
apply p.induction_on
{ simp [has_strict_deriv_at_const] }
simp [has_strict_deriv_at_const]
assume p q hp hq
{ assume p q hp hq, convert hp.add hq; simp }
convert hp.add hq; simp
convert hp.add hq
simp
simp
assume n a h
{ assume n a h, convert h.mul (has_strict_deriv_at_id x), { ext y, simp [pow_add, mul_assoc] }, { simp [pow_add], ring } }
convert h.mul (has_strict_deriv_at_id x)
{ ext y, simp [pow_add, mul_assoc] }
ext y
simp [pow_add, mul_assoc]
{ simp [pow_add], ring }
simp [pow_add]
ring
intros
simp only [deriv, fderiv_add_const]
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact has_fderiv_at.comp_has_fderiv_within_at x (hg.has_fderiv_at) (hf.has_fderiv_within_at)
intros
simpa only [sub_eq_add_neg] using hf.add_const (-c)
intros
rw differentiable_at.fderiv_within h.differentiable_at hxs
exact h.fderiv
intros
apply implicit_function_of_complemented_apply_image
intros
rw lipschitz_on_with_iff_norm_sub_le
intros x x_in y y_in
exact hs.norm_image_sub_le_of_norm_has_fderiv_within_le hf bound y_in x_in
intros
assume m hm
rcases hf m hm with ‚ü®u, hu, p, hp‚ü©
rcases hg m hm with ‚ü®v, hv, q, hq‚ü©
exact ‚ü®u ‚à© v, filter.inter_mem hu hv, _, (hp.mono (inter_subset_left u v)).prod (hq.mono (inter_subset_right u v))‚ü©
intros
split
{ assume H n, exact H.of_le le_top }
assume H n
exact H.of_le le_top
assume H
{ assume H, split, { exact (H 0).zero_eq }, { assume m hm, apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) }, { assume m hm, apply (H m).cont m (le_refl _) } }
split
{ exact (H 0).zero_eq }
exact (H 0).zero_eq
assume m hm
{ assume m hm, apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) }
apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m))
assume m hm
{ assume m hm, apply (H m).cont m (le_refl _) }
apply (H m).cont m (le_refl _)
intros
refine Œª f g hf hg a b ha hb hab, ‚ü®Œª x, _, _‚ü©
{ apply_rules [add_nonneg, mul_nonneg, hf.1, hg.1] }
apply_rules [add_nonneg, mul_nonneg, hf.1, hg.1]
erw [finset.sum_add_distrib, ‚Üê finset.smul_sum, ‚Üê finset.smul_sum, hf.2, hg.2, smul_eq_mul, smul_eq_mul, mul_one, mul_one]
{ erw [finset.sum_add_distrib, ‚Üê finset.smul_sum, ‚Üê finset.smul_sum, hf.2, hg.2, smul_eq_mul, smul_eq_mul, mul_one, mul_one], exact hab }
exact hab
intros
intros x y hx hy a b ha hb hab
apply mem_prod.2
exact ‚ü®hs (mem_prod.1 hx).1 (mem_prod.1 hy).1 ha hb hab, ht (mem_prod.1 hx).2 (mem_prod.1 hy).2 ha hb hab‚ü©
intros
apply set.subset.antisymm
rw set.image_subset_iff
{ rw set.image_subset_iff, exact convex_hull_min (set.image_subset_iff.1 $ subset_convex_hull ùïú $ f '' s) ((convex_convex_hull ùïú (f '' s)).is_linear_preimage hf) }
exact convex_hull_min (set.image_subset_iff.1 $ subset_convex_hull ùïú $ f '' s) ((convex_convex_hull ùïú (f '' s)).is_linear_preimage hf)
exact convex_hull_min (set.image_subset _ $ subset_convex_hull ùïú s) ((convex_convex_hull ùïú s).is_linear_image hf)
{ exact convex_hull_min (set.image_subset _ $ subset_convex_hull ùïú s) ((convex_convex_hull ùïú s).is_linear_image hf) }
intros
split
rintros h‚ÇÅ ‚ü®x, xs, H‚ÇÅ, H‚ÇÇ‚ü©
{ rintros h‚ÇÅ ‚ü®x, xs, H‚ÇÅ, H‚ÇÇ‚ü©, exact h‚ÇÅ x xs H‚ÇÅ H‚ÇÇ }
exact h‚ÇÅ x xs H‚ÇÅ H‚ÇÇ
intro h
{ intro h, unfold flat at h, push_neg at h, exact h }
unfold flat at h
push_neg at h
exact h
intros
rintro ‚ü®w, hw‚ü©
obtain ‚ü®l, rfl‚ü© := hC ‚ü®w, hw‚ü©
exact ‚ü®l, subset.antisymm (Œª x hx, ‚ü®hCB hx, Œª y hy, hx.2 y (hBA hy)‚ü©) (Œª x hx, ‚ü®hBA hx.1, Œª y hy, (hw.2 y hy).trans (hx.2 w (hCB hw))‚ü©)‚ü©
intros
let f : set.range p ‚Üí Œπ := Œª x, x.property.some
have hf : ‚àÄ x, p (f x) = x := Œª x, x.property.some_spec
let fe : set.range p ‚Ü™ Œπ := ‚ü®f, Œª x‚ÇÅ x‚ÇÇ he, subtype.ext (hf x‚ÇÅ ‚ñ∏ hf x‚ÇÇ ‚ñ∏ he ‚ñ∏ rfl)‚ü©
convert hc.comp_embedding fe
ext
rw [embedding.coe_fn_mk, comp_app, hf]
intros
simpa only [metric.closed_ball, sep_univ] using (convex_on_dist a _ convex_univ).convex_le r
intros
{ rw [‚Üê neg_one_smul ùïú x, inner_smul_left], simp }
rw [‚Üê neg_one_smul ùïú x, inner_smul_left]
simp
intros
{ have h := @inner_self_abs_to_K ‚Ñù F _ _ x, simpa using h }
have h := @inner_self_abs_to_K ‚Ñù F _ _ x
simpa using h
intros
{ have h := @norm_eq_sqrt_inner ‚Ñù F _ _ x, simpa using h }
have h := @norm_eq_sqrt_inner ‚Ñù F _ _ x
simpa using h
intros
have : 0 < p := lt_of_lt_of_le zero_lt_one hp
rw [‚Üê rpow_le_rpow_iff _ _ this, ‚Üê rpow_mul, one_div_mul_cancel (ne_of_gt this), rpow_one]
exact rpow_arith_mean_le_arith_mean_rpow s w z hw hw' hz hp
apply_rules [sum_nonneg, rpow_nonneg_of_nonneg]
all_goals { apply_rules [sum_nonneg, rpow_nonneg_of_nonneg], intros i hi, apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi] }
intros i hi
intros i hi
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [sum_nonneg, rpow_nonneg_of_nonneg]
intros i hi
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [sum_nonneg, rpow_nonneg_of_nonneg]
intros i hi
intros i hi
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
intros
convert (cokernel_cocone f).w walking_parallel_pair_hom.left
simp
intros
simp [edist_dist]
intros
rcases lt_trichotomy r 0 with hr|rfl|hr
simp [closed_ball_eq_empty.2 hr, ball_eq_empty.2 hr.le]
{ simp [closed_ball_eq_empty.2 hr, ball_eq_empty.2 hr.le] }
{ rw [closed_ball_zero, ball_zero, interior_singleton] }
rw [closed_ball_zero, ball_zero, interior_singleton]
{ exact interior_closed_ball x hr }
exact interior_closed_ball x hr
refine funext (Œª x, _)
rw [complex.exp, exp_eq_tsum_field]
exact tendsto_nhds_unique x.exp'.tendsto_limit (exp_series_field_summable x).has_sum.tendsto_sum_nat
intros
rw norm_indicator_eq_indicator_norm
{ rw norm_indicator_eq_indicator_norm, apply indicator_norm_le_norm_self }
apply indicator_norm_le_norm_self
intros
rw [show x - y = -(y - x), by abel, quotient_norm_neg]
intros
refine le_antisymm (le_of_forall_pos_le_add (Œª Œµ hŒµ, _)) (norm_nonneg (f x))
rcases normed_group.tendsto_nhds_nhds.1 (hf.tendsto 0) Œµ hŒµ with ‚ü®Œ¥, Œ¥_pos, hŒ¥‚ü©
replace hŒ¥ := hŒ¥ x
rw [sub_zero, hx] at hŒ¥
replace hŒ¥ := le_of_lt (hŒ¥ Œ¥_pos)
rw [linear_map.map_zero, sub_zero] at hŒ¥
rwa [zero_add]
intros
refine op_norm_eq_of_bounds (norm_nonneg _) (Œª x, _) (Œª N hN_nonneg h, _)
{ rw [to_span_singleton_apply, norm_smul, mul_comm], }
rw [to_span_singleton_apply, norm_smul, mul_comm]
specialize h 1
{ specialize h 1, rw [to_span_singleton_apply, norm_smul, mul_comm] at h, exact (mul_le_mul_right (by simp)).mp h, }
rw [to_span_singleton_apply, norm_smul, mul_comm] at h
exact (mul_le_mul_right (by simp)).mp h
intros
simpa using integral_pow 1
intros
simpa only [one_div] using interval_integrable_one_div h hf
intros
rw [‚Üê nnreal.coe_eq, nnreal.coe_pow, coe_rpow]
{ rw [‚Üê nnreal.coe_eq, nnreal.coe_pow, coe_rpow], exact real.rpow_nat_inv_pow_nat x.2 hn }
exact real.rpow_nat_inv_pow_nat x.2 hn
intros
simp [cpow_def]
intros
obtain hx | rfl := hx.lt_or_eq
{ exact (lt_rpow_iff_log_lt hx hy).2 h }
exact (lt_rpow_iff_log_lt hx hy).2 h
exact real.rpow_pos_of_pos hy z
convert tendsto_cos_neg_pi_div_two.inv_tendsto_zero.at_top_mul_neg (by norm_num) tendsto_sin_neg_pi_div_two
simp only [pi.inv_apply, ‚Üê div_eq_inv_mul, ‚Üê tan_eq_sin_div_cos]
intros
convert edist_le_tsum_of_edist_le_of_tendsto _ hu ha _
simp only [pow_add, ennreal.tsum_mul_left, ennreal.tsum_geometric, div_eq_mul_inv, mul_assoc]
intros
tfae_have : 3 ‚Üí 2
{ introsI, exact kernel_Œπ_eq_zero_of_exact_zero_left Z }
introsI
exact kernel_Œπ_eq_zero_of_exact_zero_left Z
tfae_have : 1 ‚Üí 3
{ introsI, exact exact_zero_left_of_mono Z }
introsI
exact exact_zero_left_of_mono Z
tfae_have : 2 ‚Üí 1
{ exact mono_of_kernel_Œπ_eq_zero _ }
exact mono_of_kernel_Œπ_eq_zero _
tfae_finish
intros
rw [equiv.eq_symm_apply, ‚Üê transfer_nat_trans_self_comp _ adj‚ÇÇ]
{ rw [equiv.eq_symm_apply, ‚Üê transfer_nat_trans_self_comp _ adj‚ÇÇ], simp }
simp
intros
erw [iso.inv_eq_inv (e.unit_iso.app (e.inverse.obj Y) ‚â™‚â´ e.inverse.map_iso (e.counit_iso.app Y)) (iso.refl _)]
exact e.unit_inverse_comp Y
intros
ext
ext; simp only [trans_hom, category.assoc]
simp only [trans_hom, category.assoc]
intros
ext
ext; apply functor.map_comp
apply functor.map_comp
intros
apply induction F (Œª X k, G.map k ‚â´ s.Œπ.app X = (s.Œπ.app j : _))
intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h
{ intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h, rw ‚Üêw, rw ‚Üê s.w f at h, simpa using h, }
rw ‚Üêw
rw ‚Üê s.w f at h
simpa using h
intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h
{ intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h, rw ‚Üêw at h, rw ‚Üê s.w f, simpa using h, }
rw ‚Üêw at h
rw ‚Üê s.w f
simpa using h
{ exact s.w (ùüô _), }
exact s.w (ùüô _)
intros
simp
intros
ext
rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêH.map_comp, colimit.Œπ_post]
exact (colimit.Œπ_post F (G ‚ãô H) j).symm
intros
{ ext, simp, }
ext
simp
intros
let q := equalizer.Œπ g h
let e' := equalizer.lift _ w
let F' : mono_factorisation f := { I := equalizer g h, m := q ‚â´ image.Œπ f, m_mono := by apply mono_comp, e := e' }
let v := image.lift F'
have t‚ÇÄ : v ‚â´ q ‚â´ image.Œπ f = image.Œπ f := image.lift_fac F'
have t : v ‚â´ q = ùüô (image f) := (cancel_mono_id (image.Œπ f)).1 (by { convert t‚ÇÄ using 1, rw category.assoc })
calc g = ùüô (image f) ‚â´ g : by rw [category.id_comp] ... = v ‚â´ q ‚â´ g : by rw [‚Üêt, category.assoc] ... = v ‚â´ q ‚â´ h : by rw [equalizer.condition g h] ... = ùüô (image f) ‚â´ h : by rw [‚Üêcategory.assoc, t] ... = h : by rw [category.id_comp]
intros
induction w‚ÇÅ
unfreezingI { induction w‚ÇÅ, induction w‚ÇÇ, }
{ unfreezingI { induction w‚ÇÅ, induction w‚ÇÇ, }, ext, simp [cokernel_iso_of_eq], }
induction w‚ÇÇ
ext
simp [cokernel_iso_of_eq]
intros
haveI := hI.is_iso_to f
haveI := hI.is_iso_to g
exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))
intros
rw [‚Üês.w (line j), parallel_family_map_left]
intros
{ simp, refl }
simp
refl
intros
simp [tensor_right_tensor]
intros
rw [iso.eq_inv_comp, ‚ÜêF.associativity_assoc, ‚ÜêF.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
intros
tidy
intros
rintro X S hS _ ‚ü®‚ü®_, _, ‚ü®P, hP, rfl‚ü©, rfl‚ü©, rfl‚ü©
intros Y f
exact hJ P hP (S.pullback f) (J.pullback_stable f hS)
intros
apply limit.hom_ext
rintro ‚ü®‚ü®Y, f, hf‚ü©, ‚ü®Z, g, hg‚ü©‚ü©
simp only [first_map, second_map, fork_map, limit.lift_œÄ, limit.lift_œÄ_assoc, assoc, fan.mk_œÄ_app, subtype.coe_mk, subtype.val_eq_coe]
rw [‚Üê P.map_comp, ‚Üê op_comp, pullback.condition]
simp
intros
ext Y g
split
rintro ‚ü®_‚ü©
{ rintro ‚ü®_‚ü©, apply singleton.mk }
apply singleton.mk
rintro ‚ü®_‚ü©
{ rintro ‚ü®_‚ü©, exact of_arrows.mk punit.star }
exact of_arrows.mk punit.star
intros
simp
intros
revert f‚ÇÅ
apply quotient.ind'
intro f‚ÇÅ
erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ‚Üê pullback_comp, ‚Üê map_pullback pullback.condition (pullback_is_pullback f‚ÇÅ.arrow g), ‚Üê pullback_comp, pullback.condition]
refl
intros
simp [mul_apply, neighbor_finset_eq_filter, sum_filter, adj_comm]
intros
{ ext, simp }
ext
simp
intros
rw [list_blank.nth_succ, add_bottom, list_blank.tail_cons, list_blank.nth_map]
rw [list_blank.nth_succ, add_bottom, list_blank.tail_cons, list_blank.nth_map]; refl
refl
intros
simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail, and_self, list_blank.tail_cons]
intros
simp only [free.mk, list.ret, list.mfoldr, pure_bind]
intros
simp [equiv.map, id_map]
intros
ext
ext; simp [comp_traverse]
simp [comp_traverse]
intros
have := to_topsp_is_topological_basis F.F; rwa F.eq at this
have := to_topsp_is_topological_basis F.F
rwa F.eq at this
intros
rcases b with ‚ü®_|n, ‚ü®a‚ü©‚ü©
simp only [size, nil, mk_buffer, true_and, true_iff, eq_self_iff_true, heq_iff_eq, sigma.mk.inj_iff]
{ simp only [size, nil, mk_buffer, true_and, true_iff, eq_self_iff_true, heq_iff_eq, sigma.mk.inj_iff], ext i, exact fin.elim0 i }
ext i
exact fin.elim0 i
{ simp [size, nil, mk_buffer, nat.succ_ne_zero] }
simp [size, nil, mk_buffer, nat.succ_ne_zero]
intros
split
introI
{ introI, constructor, intros cb n n' a h, have : (@parser.decorate_errors Œ± msgs p) cb n = done n' a := by simpa using h, exact of_done this }
constructor
intros cb n n' a h
have : (@parser.decorate_errors Œ± msgs p) cb n = done n' a := by simpa using h
exact of_done this
introI
{ introI, constructor, intros _ _ _ _ h, rw decorate_errors_eq_done at h, exact of_done h }
constructor
intros _ _ _ _ h
rw decorate_errors_eq_done at h
exact of_done h
intros
simp [remaining]
intros
have c9 : '9'.to_nat - '0'.to_nat = 9 := rfl
have l09 : '0'.to_nat ‚â§ '9'.to_nat := dec_trivial
have le_iff_le : ‚àÄ {c c' : char}, c ‚â§ c' ‚Üî c.to_nat ‚â§ c'.to_nat := Œª _ _, iff.rfl
split
simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ‚Üêc9]
{ simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ‚Üêc9], rintro ‚ü®np, c, ‚ü®hn, ‚ü®ge0, le9‚ü©, rfl, rfl‚ü©, rfl, rfl‚ü©, simpa [hn, ge0, le9, true_and, and_true, eq_self_iff_true, exists_prop_of_true, nat.sub_le_sub_right_iff, l09] using (le_iff_le.mp le9) }
rintro ‚ü®np, c, ‚ü®hn, ‚ü®ge0, le9‚ü©, rfl, rfl‚ü©, rfl, rfl‚ü©
simpa [hn, ge0, le9, true_and, and_true, eq_self_iff_true, exists_prop_of_true, nat.sub_le_sub_right_iff, l09] using (le_iff_le.mp le9)
simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ‚Üêc9, le_iff_le]
{ simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ‚Üêc9, le_iff_le], rintro ‚ü®hn, rfl, -, rfl, ge0, le9‚ü©, use [n + 1, cb.read ‚ü®n, hn‚ü©], simp [hn, ge0, le9] }
rintro ‚ü®hn, rfl, -, rfl, ge0, le9‚ü©
use [n + 1, cb.read ‚ü®n, hn‚ü©]
simp [hn, ge0, le9]
simp
intros
rw [‚Üê of_real_int_cast, of_real_im]
intros
rw [‚Üê mul_left_inj' I_ne_zero, ‚Üê sinh_mul_I, add_mul, add_mul, mul_right_comm, ‚Üê sinh_mul_I, mul_assoc, ‚Üê sinh_mul_I, ‚Üê cosh_mul_I, ‚Üê cosh_mul_I, sinh_add]
intros
rw [‚Üêsin_sq_add_cos_sq x, add_sub_cancel']
intros
rw [‚Üê neg_inj, ‚Üê of_real_neg, ‚Üê I_mul_re, re_eq_add_conj]
simp [mul_add, sub_eq_add_neg, neg_div']
intros
apply le_antisymm
apply bsupr_le _
{ apply bsupr_le _, intros i hi y hy, refine ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, _‚ü©, rw [add_monoid_hom.comp_apply, filter_add_monoid_hom_apply, filter_single_pos _ _ hi], exact sum_add_hom_single _ _ _, }
intros i hi y hy
refine ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, _‚ü©
rw [add_monoid_hom.comp_apply, filter_add_monoid_hom_apply, filter_single_pos _ _ hi]
exact sum_add_hom_single _ _ _
rintros x ‚ü®v, rfl‚ü©
{ rintros x ‚ü®v, rfl‚ü©, refine add_submonoid.dfinsupp_sum_add_hom_mem _ _ _ (Œª i hi, _), refine add_submonoid.mem_supr_of_mem i _, by_cases hp : p i, { simp [hp], }, { simp [hp] }, }
refine add_submonoid.dfinsupp_sum_add_hom_mem _ _ _ (Œª i hi, _)
refine add_submonoid.mem_supr_of_mem i _
by_cases hp : p i
{ simp [hp], }
simp [hp]
{ simp [hp] }
simp [hp]
intros
simp only [single_apply, dif_pos rfl]
intros
apply (equiv.set.sum_diff_subset h).injective
simp only [apply_symm_apply, sum_diff_subset_apply_inl]
exact subtype.eq rfl
intros
split
rintro ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü©
{ rintro ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü©, exact ‚ü®f a, h.1 ha‚ÇÅ, Œª b hb, f.symm_apply_eq.1 (ha‚ÇÇ (f.symm b) (h.2 (by simpa using hb)))‚ü© }
exact ‚ü®f a, h.1 ha‚ÇÅ, Œª b hb, f.symm_apply_eq.1 (ha‚ÇÇ (f.symm b) (h.2 (by simpa using hb)))‚ü©
rintro ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©
{ rintro ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©, exact ‚ü®f.symm b, h.2 (by simpa using hb‚ÇÅ), Œª y hy, (eq_symm_apply f).2 (hb‚ÇÇ _ (h.1 hy))‚ü© }
exact ‚ü®f.symm b, h.2 (by simpa using hb‚ÇÅ), Œª y hy, (eq_symm_apply f).2 (hb‚ÇÇ _ (h.1 hy))‚ü©
intros
apply arrow_congr_comp
intros
simp only [directed.sequence, encodek]
exact (classical.some_spec (hf _ a)).2
intros
convert (e.to_compl ‚ü®x, hx‚ü©).2
{ convert (e.to_compl ‚ü®x, hx‚ü©).2, rw [e.extend_subtype_apply_of_not_mem _ hx, subtype.val_eq_coe] }
rw [e.extend_subtype_apply_of_not_mem _ hx, subtype.val_eq_coe]
intros
rintro x (‚ü®he, hs‚ü©|‚ü®he, hs : x ‚àâ s‚ü©)
rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he]
{ rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he], }
rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs), e'.left_inv he]
{ rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs), e'.left_inv he] }
intros
{ ext i, simp [tail, init, cast_succ_fin_succ] }
ext i
simp [tail, init, cast_succ_fin_succ]
intros
rcases i with ‚ü®_|j, h‚ü©
{ left, refl, }
left
refl
{ right, exact ‚ü®‚ü®j, nat.lt_of_succ_lt_succ h‚ü©, rfl‚ü©, }
right
exact ‚ü®‚ü®j, nat.lt_of_succ_lt_succ h‚ü©, rfl‚ü©
intros
cases a; refl
cases a
refl
intros
{ subst h, simp }
subst h
simp
intros
induction s using finset.cons_induction with x xs hx ih
{ rw [fold_empty, image_empty, fold_empty] }
rw [fold_empty, image_empty, fold_empty]
haveI := classical.dec_eq Œ≥
{ haveI := classical.dec_eq Œ≥, rw [fold_cons, cons_eq_insert, image_insert, fold_insert_idem, ih], }
rw [fold_cons, cons_eq_insert, image_insert, fold_insert_idem, ih]
intros
classical
rw [‚Üêfinset.coe_image, ‚Üêsup_id_eq_Sup, sup_image, function.comp.left_id]
intros
rw [of_dual, to_dual, equiv.coe_fn_mk, equiv.coe_fn_symm_mk, id.def]
simp_rw (@image_id (order_dual Œ±) (s : finset (order_dual Œ±)))
refl
intros
refine ((sum_sum_index _ _).trans _).symm
{ intros, exact single_zero }
intros
exact single_zero
{ intros, exact single_add }
intros
exact single_add
refine sum_congr rfl (Œª _ _, sum_single_index _)
{ exact single_zero }
exact single_zero
intros
{ ext, refl, }
ext
refl
intros
haveI := classical.dec_eq Œ±
obtain ‚ü®p‚ü© := trunc_rec_empty_option @of_equiv h_empty (Œª _ _ _, by exactI h_option) Œ±
exact p
intros
simp [contains_aux, option.is_some_iff_exists, v.find_aux_iff hash_fn]
intros
simpa only [units.ext_iff, units_nat_abs] using nat_abs_eq u
intros
rw [‚Üê int.coe_nat_zero, coe_nat_inj']
intros
{ rw [sq, sq], exact nat_abs_eq_iff_mul_self_eq }
rw [sq, sq]
exact nat_abs_eq_iff_mul_self_eq
intros
simp
intros
rw int.gcd
split
intro h
{ intro h, exact ‚ü®nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_left h), nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_right h)‚ü© }
exact ‚ü®nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_left h), nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_right h)‚ü©
intro h
{ intro h, rw [nat_abs_eq_zero.mpr h.left, nat_abs_eq_zero.mpr h.right], apply nat.gcd_zero_left }
rw [nat_abs_eq_zero.mpr h.left, nat_abs_eq_zero.mpr h.right]
apply nat.gcd_zero_left
intros
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.add_mod]; norm_num
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.add_mod]
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.add_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.add_mod]
norm_num
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.add_mod]
norm_num
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.add_mod]
norm_num
intros
rw [nth_le_nth, index_of_nth_le (index_of_lt_length.2 h)]
intros
induction l with hd tl IH generalizing n k
{ simpa using hk' }
simpa using hk'
cases n
{ cases n, { simpa }, { simpa [succ_add] using IH _ _ _ } }
{ simpa }
simpa
{ simpa [succ_add] using IH _ _ _ }
simpa [succ_add] using IH _ _ _
intros
cases l with x l
{ simp [init] }
simp [init]
induction l with hd tl hl generalizing x
{ induction l with hd tl hl generalizing x, { simp [init], }, { simp [init, hl] } }
{ simp [init], }
simp [init]
{ simp [init, hl] }
simp [init, hl]
intros
induction n with n ih
{ rw pow_zero, refl }
rw pow_zero
refl
{ rw [list.repeat_succ, list.prod_cons, ih, pow_succ] }
rw [list.repeat_succ, list.prod_cons, ih, pow_succ]
intros
induction L; [refl, simp only [*, join, map, sum_cons, length_append]]
induction L
refl
simp only [*, join, map, sum_cons, length_append]
intros
induction l with _ _ ih; [refl, rw [pmap, pmap, h, ih]]
induction l with _ _ ih
refl
rw [pmap, pmap, h, ih]
intros
split
intro h
{ intro h, simp only [subset_def] at *, split; intros; simp* }
simp only [subset_def] at *
split
split; intros; simp*
split; intros
intros
simp*
intros
simp*
rintro ‚ü®h1, h2‚ü©
{ rintro ‚ü®h1, h2‚ü©, apply append_subset_of_subset_of_subset h1 h2 }
apply append_subset_of_subset_of_subset h1 h2
intros
rw count_cons
split_ifs
split_ifs; refl
refl
refl
intros
split
rintro ‚ü®L, hL‚ü©
{ rintro ‚ü®L, hL‚ü©, simp only [cons_append] at hL, exact ‚ü®hL.left, ‚ü®L, hL.right‚ü©‚ü© }
simp only [cons_append] at hL
exact ‚ü®hL.left, ‚ü®L, hL.right‚ü©‚ü©
rintro ‚ü®rfl, h‚ü©
{ rintro ‚ü®rfl, h‚ü©, rwa [prefix_cons_inj] }
rwa [prefix_cons_inj]
intros
simp [foldr_permutations_aux2, (‚àò), length_permutations_aux2]
intros
rcases exists_of_erasep h rfl with ‚ü®_, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, rfl, h‚ÇÇ, h‚ÇÉ‚ü©
rcases exists_of_erasep h rfl with ‚ü®_, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, rfl, h‚ÇÇ, h‚ÇÉ‚ü©; rw erase_eq_erasep; exact ‚ü®l‚ÇÅ, l‚ÇÇ, Œª h, h‚ÇÅ _ h rfl, h‚ÇÇ, h‚ÇÉ‚ü©
rcases exists_of_erasep h rfl with ‚ü®_, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, rfl, h‚ÇÇ, h‚ÇÉ‚ü©; rw erase_eq_erasep
rw erase_eq_erasep
exact ‚ü®l‚ÇÅ, l‚ÇÇ, Œª h, h‚ÇÅ _ h rfl, h‚ÇÇ, h‚ÇÉ‚ü©
intros
rw disjoint_comm; simp only [singleton_disjoint]
rw disjoint_comm
simp only [singleton_disjoint]
intros
apply list.ext_le
{ simp }
simp
intros n hn hn'
{ intros n hn hn', rw [nth_le_rotate, nth_le_pmap, prev_nth_le _ h] }
rw [nth_le_rotate, nth_le_pmap, prev_nth_le _ h]
intros
simp [nodup_iff_forall_not_duplicate]
intros
simp only [indexes_values_eq_filter_enum, map_filter_eq_foldr, find_indexes, foldr_with_index_eq_foldr_enum, uncurry]
intros
rw [argmax, argmax]; simp [argmax‚ÇÇ]
rw [argmax, argmax]
simp [argmax‚ÇÇ]
intros
rw concat_eq_append; exact nodup_append_of_nodup h' (nodup_singleton _) (disjoint_singleton.2 h)
rw concat_eq_append
exact nodup_append_of_nodup h' (nodup_singleton _) (disjoint_singleton.2 h)
intros
rw [‚Üê filter_map_eq_filter, pairwise_filter_map]
apply pairwise.iff
intros
simp only [option.mem_def, option.guard_eq_some, and_imp, forall_eq']
intros
induction d with a l‚ÇÅ' h d IH
{ exact ‚ü®nil, perm.nil, nil_sublist _‚ü© }
exact ‚ü®nil, perm.nil, nil_sublist _‚ü©
cases forall_mem_cons.1 H with H‚ÇÅ H‚ÇÇ
{ cases forall_mem_cons.1 H with H‚ÇÅ H‚ÇÇ, simp at h, exact cons_subperm_of_mem d h H‚ÇÅ (IH H‚ÇÇ) }
simp at h
exact cons_subperm_of_mem d h H‚ÇÅ (IH H‚ÇÇ)
intros
let F := Œª a b, f a ‚Üí f b ‚Üí false
change pairwise F l‚ÇÅ at H
induction p with a l‚ÇÅ l‚ÇÇ p IH a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ p‚ÇÇ IH‚ÇÅ IH‚ÇÇ
simp
{simp}
by_cases h : f a
{ by_cases h : f a, { simp [h, p] }, { simp [h], exact IH (pairwise_cons.1 H).2 } }
{ simp [h, p] }
simp [h, p]
{ simp [h], exact IH (pairwise_cons.1 H).2 }
simp [h]
exact IH (pairwise_cons.1 H).2
by_cases h‚ÇÅ : f a; by_cases h‚ÇÇ : f b; simp [h‚ÇÅ, h‚ÇÇ]
by_cases h‚ÇÅ : f a; by_cases h‚ÇÇ : f b
by_cases h‚ÇÅ : f a
{ by_cases h‚ÇÅ : f a; by_cases h‚ÇÇ : f b; simp [h‚ÇÅ, h‚ÇÇ], { cases (pairwise_cons.1 H).1 _ (or.inl rfl) h‚ÇÇ h‚ÇÅ }, { apply swap } }
by_cases h‚ÇÇ : f b
simp [h‚ÇÅ, h‚ÇÇ]
{ cases (pairwise_cons.1 H).1 _ (or.inl rfl) h‚ÇÇ h‚ÇÅ }
cases (pairwise_cons.1 H).1 _ (or.inl rfl) h‚ÇÇ h‚ÇÅ
simp [h‚ÇÅ, h‚ÇÇ]
by_cases h‚ÇÇ : f b
simp [h‚ÇÅ, h‚ÇÇ]
simp [h‚ÇÅ, h‚ÇÇ]
{ apply swap }
apply swap
refine (IH‚ÇÅ H).trans (IH‚ÇÇ ((p‚ÇÅ.pairwise_iff _).1 H))
{ refine (IH‚ÇÅ H).trans (IH‚ÇÇ ((p‚ÇÅ.pairwise_iff _).1 H)), exact Œª a b h h‚ÇÅ h‚ÇÇ, h h‚ÇÇ h‚ÇÅ }
exact Œª a b h h‚ÇÅ h‚ÇÇ, h h‚ÇÇ h‚ÇÅ
intros
induction l
simp
case list.nil { simp }
case list.cons : hd tl ih { simp at nd, by_cases h : a = hd.1, { subst h, simp [nd.1] }, { simp [h, ih nd.2] } }
intros
induction l generalizing f r; [refl, simp only [*, sublists'_aux]]
induction l generalizing f r
refl
simp only [*, sublists'_aux]
intros
simp only [revzip, length_zip, length_reverse, min_self]
intros
{ ext, apply neg_dot_product }
ext
apply neg_dot_product
intros
ext
{ ext, refl }
refl
intros
ext
{ ext, simp only [one_apply, map_apply], split_ifs; simp [h‚ÇÄ, h‚ÇÅ], }
simp only [one_apply, map_apply]
split_ifs
split_ifs; simp [h‚ÇÄ, h‚ÇÅ]
simp [h‚ÇÄ, h‚ÇÅ]
simp [h‚ÇÄ, h‚ÇÅ]
intros
ext i j; rw [‚Üê diagonal_one, diagonal_mul, one_mul]
ext i j
rw [‚Üê diagonal_one, diagonal_mul, one_mul]
intros
simp [mul_apply, h.symm]
intros
simp only [conj_transpose, block_diagonal'_transpose]
exact block_diagonal'_map _ star (star_zero Œ±)
intros
rw [rel_iff]; simp
rw [rel_iff]
simp
intros
rw nodup_erase_eq_filter b d; simp [and_comm]
rw nodup_erase_eq_filter b d
simp [and_comm]
intros
rw powerset_aux_eq_map_coe; exact (sublists_perm_sublists' _).map _
rw powerset_aux_eq_map_coe
exact (sublists_perm_sublists' _).map _
intros
simp [monomial_eq]
intros
apply mv_polynomial.induction_on p
{ intro r, rw [eval‚ÇÇ_C, map_C, eval‚ÇÇ_C] }
intro r
rw [eval‚ÇÇ_C, map_C, eval‚ÇÇ_C]
intros p q hp hq
{ intros p q hp hq, rw [eval‚ÇÇ_add, k.map_add, (map f).map_add, eval‚ÇÇ_add, hp, hq] }
rw [eval‚ÇÇ_add, k.map_add, (map f).map_add, eval‚ÇÇ_add, hp, hq]
intros p s hp
{ intros p s hp, rw [eval‚ÇÇ_mul, k.map_mul, (map f).map_mul, eval‚ÇÇ_mul, map_X, hp, eval‚ÇÇ_X, eval‚ÇÇ_X] }
rw [eval‚ÇÇ_mul, k.map_mul, (map f).map_mul, eval‚ÇÇ_mul, map_X, hp, eval‚ÇÇ_X, eval‚ÇÇ_X]
intros
convert vars_add_subset p (-q) using 2; simp [sub_eq_add_neg]
convert vars_add_subset p (-q) using 2
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
intros
{ ext1 i, simp }
ext1 i
simp
intros
obtain ‚ü®s, q, rfl‚ü© := exists_finset_rename p
let n := fintype.card {x // x ‚àà s}
let e := fintype.equiv_fin {x // x ‚àà s}
refine ‚ü®n, coe ‚àò e.symm, subtype.val_injective.comp e.symm.injective, rename e q, _‚ü©
rw [‚Üê rename_rename, rename_rename e]
simp only [function.comp, equiv.symm_apply_apply, rename_rename]
intros
apply finset.subset.antisymm (vars_add_subset p q)
intros x hx
simp only [vars, multiset.disjoint_to_finset] at h hx ‚ä¢
rw [degrees_add_of_disjoint h, multiset.to_finset_union]
exact hx
intros
cases le_total n m with H H
{ exact dvd_sub H h‚ÇÅ h‚ÇÇ }
exact dvd_sub H h‚ÇÅ h‚ÇÇ
rw nat.sub_eq_zero_of_le H
{ rw nat.sub_eq_zero_of_le H, exact dvd_zero k }
exact dvd_zero k
intros
rw [pos_iff_ne_zero, ne, nat.find_eq_zero]
intros
simp [add_comm]
intros
rw [le_rec_on_succ (le_refl n), le_rec_on_self]
intros
rw [mul_comm,nat.div_mul_cancel Hd]
intros
rw [‚Üêchoose_mul_factorial_mul_factorial hk, mul_assoc]
rw [‚Üêchoose_mul_factorial_mul_factorial hk, mul_assoc]; exact dvd_mul_left _ _
exact dvd_mul_left _ _
intros
induction L with d L ih
{ change k ‚à£ 0 - 0, simp, }
change k ‚à£ 0 - 0
simp
simp only [of_digits, add_sub_add_left_eq_sub]
{ simp only [of_digits, add_sub_add_left_eq_sub], exact dvd_mul_sub_mul h ih, }
exact dvd_mul_sub_mul h ih
intros
rw [gcd_comm, gcd_mul_right_left]
intros
simp [coprime]
intros
obtain hb | hb := le_or_lt b 1
rw log_of_left_le_one hb
{ rw log_of_left_le_one hb, exact zero_le _}
exact zero_le _
cases n
rw log_zero_right
{ rw log_zero_right, exact zero_le _}
exact zero_le _
exact (pow_right_strict_mono hb).le_iff_le.1 ((pow_log_le_self hb $ succ_pos _).trans $ le_pow_clog hb _)
intros
simpa only [exists_or_distrib, ‚Üê odd, ‚Üê even] using even_or_odd n
intros
simpa only [pow_two] using le_sqrt
intros
cases n
cases n; refl
refl
refl
intros
cases x; simp only [map_none', map_some', pmap]
{ cases x; simp only [map_none', map_some', pmap] }
cases x
simp only [map_none', map_some', pmap]
simp only [map_none', map_some', pmap]
intros
split
rintro (rfl | rfl)
{ exact ‚ü®le_refl _, nat.le_succ _‚ü© }
exact ‚ü®le_refl _, nat.le_succ _‚ü©
{ exact ‚ü®nat.le_succ _, le_refl _‚ü© }
exact ‚ü®nat.le_succ _, le_refl _‚ü©
rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
{ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, rcases eq_or_lt_of_le h‚ÇÅ with rfl | h‚ÇÅ, { exact or.inl rfl }, { exact or.inr (le_antisymm h‚ÇÇ h‚ÇÅ) } }
rcases eq_or_lt_of_le h‚ÇÅ with rfl | h‚ÇÅ
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr (le_antisymm h‚ÇÇ h‚ÇÅ) }
exact or.inr (le_antisymm h‚ÇÇ h‚ÇÅ)
intros
ext
ext; dsimp [pequiv.trans]; simp
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
simp
intros
rw M.dest_map
congr
apply eq_of_drop_last_eq; simp
apply eq_of_drop_last_eq
simp
simp
ext1
apply h
intros
ext
simp only [supp, image_univ, mem_range, mem_set_of_eq]
split
split; intro h
intro h
apply @h (Œª x, ‚àÉ (y : P.B a), f y = x)
{ apply @h (Œª x, ‚àÉ (y : P.B a), f y = x), rw liftp_iff', intro, refine ‚ü®_,rfl‚ü© }
rw liftp_iff'
intro
refine ‚ü®_,rfl‚ü©
intro h
simp only [liftp_iff']
{ simp only [liftp_iff'], cases h, subst x, tauto }
cases h
subst x
tauto
intros
by_cases hq : u.q = 0
let h := u.rq_eq
{ let h := u.rq_eq, rw [hr, hq, mul_zero, add_zero] at h, cases h }
rw [hr, hq, mul_zero, add_zero] at h
cases h
exact (nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hq)).symm
{ exact (nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hq)).symm }
intros
{ ext, simp only [aeval_X, aeval_tower_X], }
ext
simp only [aeval_X, aeval_tower_X]
intros
simp only [‚Üêmonomial_zero_left, monomial_mul_monomial, add_zero]
intros
rw [(commute_X (1 : polynomial R)).add_pow, ‚Üê lcoeff_apply, linear_map.map_sum]
simp only [one_pow, mul_one, lcoeff_apply, ‚Üê C_eq_nat_cast, coeff_mul_C, nat.cast_id]
rw [finset.sum_eq_single k, coeff_X_pow_self, one_mul]
intros _ _
{ intros _ _, simp only [coeff_X_pow, boole_mul, ite_eq_right_iff, ne.def] {contextual := tt}, rintro h rfl, contradiction }
simp only [coeff_X_pow, boole_mul, ite_eq_right_iff, ne.def] {contextual := tt}
rintro h rfl
contradiction
simp only [coeff_X_pow_self, one_mul, not_lt, finset.mem_range]
{ simp only [coeff_X_pow_self, one_mul, not_lt, finset.mem_range], intro h, rw [nat.choose_eq_zero_of_lt h, nat.cast_zero], }
intro h
rw [nat.choose_eq_zero_of_lt h, nat.cast_zero]
intros
simpa only [pow_one] using nat_degree_C_mul_X_pow 1 a ha
intros
unfold nat_trailing_degree; rw h
unfold nat_trailing_degree
rw h
intros
induction k with k ih generalizing p
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
simp only [erase_lead, coeff_erase]
intros
induction k with k ih
{ simp, }
simp
{ simp [pow_succ', ‚Üêmul_assoc, ih], }
simp [pow_succ', ‚Üêmul_assoc, ih]
intros
rw [monomial_eq_C_mul_X, ‚ÜêX_pow_mul, ‚Üêmul_assoc, coeff_mul_C, coeff_mul_X_pow]
intros
obtain ‚ü®r, rfl‚ü© := set.mem_range.1 h
use monomial n r
simp only [coe_map_ring_hom, set.mem_univ, map_monomial, subsemiring.coe_top, eq_self_iff_true, and_self]
intros
split
intro hp
{ intro hp, rw ‚Üêsmul_eq_zero_iff_eq (h.unit)‚Åª¬π at hp, have : (h.unit)‚Åª¬π ‚Ä¢ (p * q) = ((h.unit)‚Åª¬π ‚Ä¢ p) * q, { ext, simp only [units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum], refine sum_congr rfl (Œª x hx, _), rw ‚Üêmul_assoc }, rwa [this, monic.mul_right_eq_zero_iff] at hp, exact monic_of_is_unit_leading_coeff_inv_smul _ }
rw ‚Üêsmul_eq_zero_iff_eq (h.unit)‚Åª¬π at hp
have : (h.unit)‚Åª¬π ‚Ä¢ (p * q) = ((h.unit)‚Åª¬π ‚Ä¢ p) * q
ext
{ ext, simp only [units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum], refine sum_congr rfl (Œª x hx, _), rw ‚Üêmul_assoc }
simp only [units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum]
refine sum_congr rfl (Œª x hx, _)
rw ‚Üêmul_assoc
rwa [this, monic.mul_right_eq_zero_iff] at hp
exact monic_of_is_unit_leading_coeff_inv_smul _
rintro rfl
{ rintro rfl, simp }
simp
intros
rw [neg_eq_neg_one_mul, ‚ÜêC_1, ‚ÜêC_neg, reflect_C_mul, C_neg, C_1, ‚Üêneg_eq_neg_one_mul]
intros
apply q.P.W_cases _ x
intros a f' f
rw [recF_eq, q.P.W_dest'_W_mk, mvpfunctor.map_eq, append_fun_comp_split_fun, typevec.id_comp]
intros
rw [liftp_iff, ‚Üêabs_repr x]
cases repr x with a f
split
rintros ‚ü®a', f', abseq, hf‚ü© u
{ rintros ‚ü®a', f', abseq, hf‚ü© u, rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq], rintros ‚ü®i, _, hi‚ü©, rw ‚Üêhi, apply hf }
rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq]
rintros ‚ü®i, _, hi‚ü©
rw ‚Üêhi
apply hf
intro h'
refine ‚ü®a, f, rfl, Œª i, h' _ _‚ü©
rw supp_eq_of_is_uniform h
exact ‚ü®i, mem_univ i, rfl‚ü©
intros
simp [b0, d0, sub_eq_add_neg]
intros
suffices : mk (q.num) ‚Üë(q.denom) * mk ‚Üë(q.denom) 1 = mk (q.num) 1
conv { for q [1] { rw ‚Üê(@num_denom q) }}
conv { for q [1] { rw ‚Üê(@num_denom q) }}
{ conv { for q [1] { rw ‚Üê(@num_denom q) }}, rwa [coe_int_eq_mk, coe_nat_eq_mk] }
{ conv { for q [1] { rw ‚Üê(@num_denom q) }}, rwa [coe_int_eq_mk, coe_nat_eq_mk] }
rwa [coe_int_eq_mk, coe_nat_eq_mk]
rwa [coe_int_eq_mk, coe_nat_eq_mk]
have : (q.denom : ‚Ñ§) ‚â† 0
from ne_of_gt (by exact_mod_cast q.pos)
rw [(rat.mul_def this one_ne_zero), (mul_comm (q.denom : ‚Ñ§) 1), (div_mk_div_cancel_left this)]
intros
rw ‚Üê nonneg_iff_zero_le at ha hb ‚ä¢; exact rat.nonneg_mul ha hb
rw ‚Üê nonneg_iff_zero_le at ha hb ‚ä¢
exact rat.nonneg_mul ha hb
intros
change lim_zero ((f1 + g1) - _)
convert add_lim_zero hf hg using 1
simp only [sub_eq_add_neg, add_assoc]
rw add_comm (-f2)
simp only [add_assoc]
congr' 2
simp
intros
rw [‚Üê lim_mul_lim, lim_const]
simp [ennreal.of_real]; refl
simp [ennreal.of_real]
intros
split
intro h
{ intro h, rw [‚Üê or_assoc, or_iff_not_imp_right, or_iff_not_imp_right], intros hb ha, exact ‚ü®lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha‚ü© }
rw [‚Üê or_assoc, or_iff_not_imp_right, or_iff_not_imp_right]
intros hb ha
exact ‚ü®lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha‚ü©
rintro (‚ü®ha, hb‚ü©|rfl|rfl); [exact mul_lt_top ha.ne hb.ne, simp, simp]
rintro (‚ü®ha, hb‚ü©|rfl|rfl)
{ rintro (‚ü®ha, hb‚ü©|rfl|rfl); [exact mul_lt_top ha.ne hb.ne, simp, simp] }
exact mul_lt_top ha.ne hb.ne
simp
simp
intros
rwa [‚Üêereal.neg_neg b, ereal.neg_le, ereal.neg_neg]
intros
rw [nnreal.div_le_iff b0.ne.symm, div_mul_eq_mul_div, nnreal.le_div_iff_mul_le c0.ne.symm, mul_le_mul_left a0]
intros
obtain (hn | hz | hp) := sign_apply_eq r
{ rw hn, norm_num }
rw hn
norm_num
{ rw hz, exact inv_zero }
rw hz
exact inv_zero
{ rw hp, exact inv_one }
rw hp
exact inv_one
intros
rw [‚Üê not_le, not_iff_not, sqrt_eq_zero']
intros
apply s.cases_on; intro; simp
apply s.cases_on; intro
apply s.cases_on
intro
simp
intro
simp
intros
rw [‚Üêlift_rel_aux.swap, lift_rel_aux.ret_left]
intros
simp [ret]
intros
rw [set.ite, union_inter_distrib_right, diff_inter_self, inter_assoc, inter_self, union_empty]
intros
simp [range_subset_iff, funext_iff, mem_singleton]
intros
simp only [‚Üê not_nonempty_iff_eq_empty, preimage_coe_nonempty]
intros
refl
intros
rintro _ ‚ü®a, b, ha, hb, rfl‚ü©
{ rintro _ ‚ü®a, b, ha, hb, rfl‚ü©, exact mem_image2_of_mem (hs ha) (ht hb) }
exact mem_image2_of_mem (hs ha) (ht hb)
intros
{ ext, simp, }
ext
simp
intros
simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm]
simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm]; ac_refl
ac_refl
intros
convert @Ico_subset_Ico_iff (order_dual Œ±) _ b‚ÇÅ b‚ÇÇ a‚ÇÅ a‚ÇÇ h‚ÇÅ; exact (@dual_Ico Œ± _ _ _).symm
convert @Ico_subset_Ico_iff (order_dual Œ±) _ b‚ÇÅ b‚ÇÇ a‚ÇÅ a‚ÇÇ h‚ÇÅ
{ convert @Ico_subset_Ico_iff (order_dual Œ±) _ b‚ÇÅ b‚ÇÇ a‚ÇÅ a‚ÇÇ h‚ÇÅ; exact (@dual_Ico Œ± _ _ _).symm }
exact (@dual_Ico Œ± _ _ _).symm
exact (@dual_Ico Œ± _ _ _).symm
intros
simp [le_refl]
intros
simp
intros
refine ‚ü®Œª _ h, ‚ü®add_le_add_right h.1 _, add_le_add_right h.2 _‚ü©, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
obtain ‚ü®c, rfl‚ü© := exists_add_of_le h.1
rw [mem_Icc, add_right_comm, add_le_add_iff_right, add_le_add_iff_right] at h
exact ‚ü®a + c, h, by rw add_right_comm‚ü©
intros
simp only [interval, preimage_const_add_Icc, min_sub_sub_right, max_sub_sub_right]
intros
refine diff_subset_comm.2 (Œª x hx a ha, _)
simp only [mem_diff, mem_pi, mem_Union, not_exists, mem_preimage, not_and, not_not, eval_apply] at hx
exact hx.2 _ ha (hx.1 _ ha)
intros
simp
intros
simp only [‚ÜêsInter_range, subtype.range_coe]
intros
induction acb with b H IH
constructor
intros y h
cases h with _ _ _ b' _ h' a
{ exact IH _ h' }
exact IH _ h'
{ exact aca _ }
exact aca _
intros
rw [‚Üê drop_fun_split_fun f g, H, ‚Üê last_fun_split_fun f g, H]
rw [‚Üê drop_fun_split_fun f g, H, ‚Üê last_fun_split_fun f g, H]; simp
simp
intros
ext i : 2
{ ext i : 2, induction i; simp only [typevec.prod.map,*,drop_fun_id], cases x, refl, refl }
induction i
induction i; simp only [typevec.prod.map,*,drop_fun_id]
simp only [typevec.prod.map,*,drop_fun_id]
cases x
refl
simp only [typevec.prod.map,*,drop_fun_id]
refl
intros
ext a
obtain ‚ü®k, rfl‚ü© := zmod.int_cast_surjective a
let œÜ : ‚Ñ§ ‚Üí+* R := f.comp (int.cast_ring_hom (zmod n))
let œà : ‚Ñ§ ‚Üí+* R := g.comp (int.cast_ring_hom (zmod n))
show œÜ k = œà k
rw œÜ.ext_int œà
intros
rcases ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© with ‚ü®‚ü®f‚ÇÅ, rfl‚ü©, ‚ü®f‚ÇÇ, rfl‚ü©‚ü©
{ rcases ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© with ‚ü®‚ü®f‚ÇÅ, rfl‚ü©, ‚ü®f‚ÇÇ, rfl‚ü©‚ü©, exact units_semiconj_of_translation_number_eq h }
exact units_semiconj_of_translation_number_eq h
intros
rcases hc‚ÇÇ with ‚ü®v, hv‚ÇÅ, hv‚ÇÇ‚ü©
rw omega_limit_eq_Inter_inter _ _ _ hv‚ÇÅ
apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed
rintro ‚ü®u‚ÇÅ, hu‚ÇÅ‚ü© ‚ü®u‚ÇÇ, hu‚ÇÇ‚ü©
{ rintro ‚ü®u‚ÇÅ, hu‚ÇÅ‚ü© ‚ü®u‚ÇÇ, hu‚ÇÇ‚ü©, use ‚ü®u‚ÇÅ ‚à© u‚ÇÇ, inter_mem hu‚ÇÅ hu‚ÇÇ‚ü©, split, all_goals { exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl) }}
use ‚ü®u‚ÇÅ ‚à© u‚ÇÇ, inter_mem hu‚ÇÅ hu‚ÇÇ‚ü©
split
exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl)
all_goals { exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl) }
exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl)
intro u
{ intro u, have hn : (image2 œï (u ‚à© v) s).nonempty, from nonempty.image2 (nonempty_of_mem (inter_mem u.prop hv‚ÇÅ)) hs, exact hn.mono subset_closure }
have hn : (image2 œï (u ‚à© v) s).nonempty
from nonempty.image2 (nonempty_of_mem (inter_mem u.prop hv‚ÇÅ)) hs
exact hn.mono subset_closure
intro _
{ intro _, apply compact_of_is_closed_subset hc‚ÇÅ is_closed_closure, calc _ ‚äÜ closure (image2 œï v s) : closure_mono (image2_subset (inter_subset_right _ _) subset.rfl) ... ‚äÜ c : hv‚ÇÇ }
apply compact_of_is_closed_subset hc‚ÇÅ is_closed_closure
calc _ ‚äÜ closure (image2 œï v s) : closure_mono (image2_subset (inter_subset_right _ _) subset.rfl) ... ‚äÜ c : hv‚ÇÇ
{ exact Œª _, is_closed_closure }
exact Œª _, is_closed_closure
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, pow_mul, ih, pow_card], }
simp [pow_succ, pow_mul, ih, pow_card]
intros
unfold angle
rw [‚Üêreal.arccos_neg, norm_neg, inner_neg_right, neg_div]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ‚Üê vsub_sub_vsub_cancel_right]
exact norm_sub_eq_add_norm_of_angle_eq_pi h
intros
rw [support_eq_inter_preimage, subset_inter_iff, ‚Üê ext_chart_at_source I, ‚Üê image_subset_iff] at hs
cases hs with hse hsf
apply subset.antisymm
refine subset_inter (subset_inter (subset.trans hsf ball_subset_closed_ball) _) _
{ refine subset_inter (subset_inter (subset.trans hsf ball_subset_closed_ball) _) _, { rintro _ ‚ü®x, -, rfl‚ü©, exact mem_range_self _ }, { rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse], exact inter_subset_right _ _ } }
{ rintro _ ‚ü®x, -, rfl‚ü©, exact mem_range_self _ }
rintro _ ‚ü®x, -, rfl‚ü©
exact mem_range_self _
rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse]
{ rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse], exact inter_subset_right _ _ }
exact inter_subset_right _ _
refine subset.trans (inter_subset_inter_left _ f.closed_ball_subset) _
{ refine subset.trans (inter_subset_inter_left _ f.closed_ball_subset) _, rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse] }
rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse]
intros
apply topological_space.generate_open.basic
simp only [exists_prop, mem_Union, mem_singleton_iff]
refine ‚ü®e, he, univ, is_open_univ, _‚ü©
simp only [set.univ_inter, set.preimage_univ]
intros
assume x hx
apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_symm_of_mem_maximal_atlas hQ he hx)
apply is_open.mem_nhds e.open_target hx
intros
refine ‚ü®h.1, _‚ü©
simp only [mfderiv, h, dif_pos] with mfld_simps
exact differentiable_within_at.has_fderiv_within_at h.2
intros
simp [unique_mdiff_on, unique_diff_on, unique_mdiff_within_at_iff_unique_diff_within_at]
intros
apply basic_smooth_bundle_core.smooth_const_section (tangent_bundle_core I M) 0
assume i j x hx
simp only [tangent_bundle_core, continuous_linear_map.map_zero] with mfld_simps
intros
rw [‚Üê normal_closure_eq_self ‚ÅÖH‚ÇÅ, H‚ÇÇ‚ÅÜ, general_commutator_def, normal_closure_closure_eq_normal_closure]
intros
rw [‚Üêfree_group.lift.symm_symm, ‚Üê(@lift' (free_group A) H _ _ _).symm_symm]
congr' 1
ext
refl
intros
rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]
intros
apply multiplicative.of_add.injective
rw [‚Üê order_of_of_add_eq_add_order_of, of_add_nsmul, of_add_nsmul, pow_eq_mod_order_of]
intros
rw [disjoint_iff_eq_or_eq, list.disjoint]
split
rintro h x hx hx'
{ rintro h x hx hx', specialize h x, rw [form_perm_apply_mem_eq_self_iff _ hl _ hx, form_perm_apply_mem_eq_self_iff _ hl' _ hx'] at h, rcases h with hl | hl'; linarith }
specialize h x
rw [form_perm_apply_mem_eq_self_iff _ hl _ hx, form_perm_apply_mem_eq_self_iff _ hl' _ hx'] at h
rcases h with hl | hl'; linarith
rcases h with hl | hl'
linarith
linarith
intros h x
{ intros h x, by_cases hx : x ‚àà l; by_cases hx' : x ‚àà l', { exact (h hx hx').elim }, all_goals { have := form_perm_eq_self_of_not_mem _ _ ‚Äπ_‚Ä∫, tauto } }
by_cases hx : x ‚àà l; by_cases hx' : x ‚àà l'
by_cases hx : x ‚àà l
by_cases hx' : x ‚àà l'
{ exact (h hx hx').elim }
exact (h hx hx').elim
have := form_perm_eq_self_of_not_mem _ _ ‚Äπ_‚Ä∫
all_goals { have := form_perm_eq_self_of_not_mem _ _ ‚Äπ_‚Ä∫, tauto }
tauto
by_cases hx' : x ‚àà l'
have := form_perm_eq_self_of_not_mem _ _ ‚Äπ_‚Ä∫
tauto
have := form_perm_eq_self_of_not_mem _ _ ‚Äπ_‚Ä∫
tauto
intros
haveI : fact (fintype.card Œ±).prime := ‚ü®h0‚ü©
obtain ‚ü®œÉ, hœÉ‚ü© := exists_prime_order_of_dvd_card (fintype.card Œ±) h1
have hœÉ1 : order_of (œÉ : perm Œ±) = fintype.card Œ± := (order_of_subgroup œÉ).trans hœÉ
have hœÉ2 : is_cycle ‚ÜëœÉ := is_cycle_of_prime_order'' h0 hœÉ1
have hœÉ3 : (œÉ : perm Œ±).support = ‚ä§ := finset.eq_univ_of_card (œÉ : perm Œ±).support ((order_of_is_cycle hœÉ2).symm.trans hœÉ1)
have hœÉ4 : subgroup.closure {‚ÜëœÉ, œÑ} = ‚ä§ := closure_prime_cycle_swap h0 hœÉ2 hœÉ3 h3
rw [eq_top_iff, ‚ÜêhœÉ4, subgroup.closure_le, set.insert_subset, set.singleton_subset_iff]
exact ‚ü®subtype.mem œÉ, h2‚ü©
intros
obtain ‚ü®x, y, h4, h5‚ü© := h3
obtain ‚ü®i, hi‚ü© := h1.exists_pow_eq (mem_support.mp ((finset.ext_iff.mp h2 x).mpr (finset.mem_univ x))) (mem_support.mp ((finset.ext_iff.mp h2 y).mpr (finset.mem_univ y)))
rw [h5, ‚Üêhi]
refine closure_cycle_coprime_swap (nat.coprime.symm (h0.coprime_iff_not_dvd.mpr (Œª h, h4 _))) h1 h2 x
cases h with m hm
rwa [hm, pow_mul, ‚Üêfinset.card_univ, ‚Üêh2, ‚Üêorder_of_is_cycle h1, pow_order_of_eq_one, one_pow, one_apply] at hi
intros
rw mem_cycle_factors_finset_iff at h
intros x hx
rwa [mem_support, ‚Üêh.right x hx, ‚Üêmem_support]
intros
rcases l with (_|‚ü®x, _|‚ü®y, tl‚ü©‚ü©)
{ simp }
simp
{ simp }
simp
{ simpa using form_perm_apply_head _ _ _ h }
simpa using form_perm_apply_head _ _ _ h
intros
ext1 x
have : option.map ‚áë(remove_none œÉ) x = (swap none (œÉ none)) (œÉ x)
cases x
{ cases x, { simp }, { cases h : œÉ (some x), { simp [remove_none_none _ h], }, { have hn : œÉ (some x) ‚â† none := by simp [h], have hœÉn : œÉ (some x) ‚â† œÉ none := œÉ.injective.ne (by simp), simp [remove_none_some _ ‚ü®_, h‚ü©, ‚Üêh, swap_apply_of_ne_of_ne hn hœÉn] } } }
{ simp }
simp
cases h : œÉ (some x)
{ cases h : œÉ (some x), { simp [remove_none_none _ h], }, { have hn : œÉ (some x) ‚â† none := by simp [h], have hœÉn : œÉ (some x) ‚â† œÉ none := œÉ.injective.ne (by simp), simp [remove_none_some _ ‚ü®_, h‚ü©, ‚Üêh, swap_apply_of_ne_of_ne hn hœÉn] } }
{ simp [remove_none_none _ h], }
simp [remove_none_none _ h]
have hn : œÉ (some x) ‚â† none := by simp [h]
{ have hn : œÉ (some x) ‚â† none := by simp [h], have hœÉn : œÉ (some x) ‚â† œÉ none := œÉ.injective.ne (by simp), simp [remove_none_some _ ‚ü®_, h‚ü©, ‚Üêh, swap_apply_of_ne_of_ne hn hœÉn] }
have hœÉn : œÉ (some x) ‚â† œÉ none := œÉ.injective.ne (by simp)
simp [remove_none_some _ ‚ü®_, h‚ü©, ‚Üêh, swap_apply_of_ne_of_ne hn hœÉn]
simpa using this
intros
ext x
by_cases hx : x ‚àà g.support
{ exact h' x hx }
exact h' x hx
rw [not_mem_support.mp hx, ‚Üênot_mem_support]
{ rw [not_mem_support.mp hx, ‚Üênot_mem_support], exact Œª H, hx (h H) }
exact Œª H, hx (h H)
intros
refine quotient_group.eq.trans _
rw [mul_one, subgroup.inv_mem_iff]
intros
simp [map]
let g1 := (‚ü®swap 0 2 * swap 0 1, mem_alternating_group.2 dec_trivial‚ü© : alternating_group (fin 5))
let g2 := (‚ü®swap 0 4 * swap 1 3, mem_alternating_group.2 dec_trivial‚ü© : alternating_group (fin 5))
have h5 : g1 * g2 * g1‚Åª¬π * g2‚Åª¬π = ‚ü®fin_rotate 5, fin_rotate_bit1_mem_alternating_group‚ü©
rw subtype.ext_iff
{ rw subtype.ext_iff, simp only [fin.coe_mk, subgroup.coe_mul, subgroup.coe_inv, fin.coe_mk], dec_trivial }
simp only [fin.coe_mk, subgroup.coe_mul, subgroup.coe_inv, fin.coe_mk]
dec_trivial
rw [eq_top_iff, ‚Üê normal_closure_fin_rotate_five]
refine normal_closure_le_normal _
rw [set.singleton_subset_iff, set_like.mem_coe, ‚Üê h5]
have h : g2 ‚àà normal_closure {g2} := set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))
exact mul_mem _ (subgroup.normal_closure_normal.conj_mem _ h g1) (inv_mem _ h)
intros
conv_lhs { rw ‚Üêzmod.nat_cast_zmod_val i }
rw [‚Üêr_one_pow, order_of_pow, order_of_r_one]
intros
simp only [subset_normal_closure, closure_le]
intros
apply_fun comap f at hf
rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf
intros
intros n g hg
simpa only [f.mem_ker, nsmul_eq_smul, f.map_nsmul, smul_eq_zero] using hg
intros
haveI : nonempty K := Kne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hK.directed_coe, set_coe.exists, subtype.coe_mk]
intros
simp [eq_bot_iff_forall, mem_closure_singleton]
intros
simpa only [mrange_eq_map] using map_inl ‚ä§
intros
rintros ‚ü®e, el, h‚ü© ‚ü®e', el', h'‚ü© H
simp only [to_affine_map_mk, equiv.coe_inj, linear_equiv.to_linear_map_inj] at H
congr
exacts [H.1, H.2]
intros
{ ext p, simp [homothety_apply] }
ext p
simp [homothety_apply]
intros
rw [collinear_iff_dim_le_one, vector_span_empty]
simp
intros
rw [one_div, homothety_inv_two]
intros
{ ext f x, refl, }
ext f x
refl
intros
rw [‚Üê nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr hn), nat.succ_eq_add_one, add_comm, pow_add] at h
exact surjective.of_comp h
intros
rw [repr_self, finsupp.single_apply]
intros
simp_rw [matrix.to_bilin'_apply, matrix.dot_product, matrix.mul_vec, matrix.dot_product]
refine finset.sum_congr rfl (Œª _ _, _)
rw finset.mul_sum
refine finset.sum_congr rfl (Œª _ _, _)
rw ‚Üê mul_assoc
intros
apply le_antisymm
apply bsupr_le _
{ apply bsupr_le _, intros i hi y hy, refine ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, _‚ü©, rw [linear_map.comp_apply, filter_linear_map_apply, filter_single_pos _ _ hi], exact dfinsupp.sum_add_hom_single _ _ _, }
intros i hi y hy
refine ‚ü®dfinsupp.single i ‚ü®y, hy‚ü©, _‚ü©
rw [linear_map.comp_apply, filter_linear_map_apply, filter_single_pos _ _ hi]
exact dfinsupp.sum_add_hom_single _ _ _
rintros x ‚ü®v, rfl‚ü©
{ rintros x ‚ü®v, rfl‚ü©, refine dfinsupp_sum_add_hom_mem _ _ _ (Œª i hi, _), refine mem_supr_of_mem i _, by_cases hp : p i, { simp [hp], }, { simp [hp] }, }
refine dfinsupp_sum_add_hom_mem _ _ _ (Œª i hi, _)
refine mem_supr_of_mem i _
by_cases hp : p i
{ simp [hp], }
simp [hp]
{ simp [hp] }
simp [hp]
intros
ext i
{ ext i, rw basis.apply_eq_iff, ext j, rw [h.basis_repr_apply, coeffs_apply, h.eval, finsupp.single_apply], convert if_congr eq_comm rfl rfl }
rw basis.apply_eq_iff
ext j
rw [h.basis_repr_apply, coeffs_apply, h.eval, finsupp.single_apply]
convert if_congr eq_comm rfl rfl
intros
have := dim_quotient_add_dim s
rw [‚Üê finrank_eq_dim, ‚Üê finrank_eq_dim, ‚Üê finrank_eq_dim] at this
exact_mod_cast this
intros
erw [set.union_eq_Union, supported_Union, supr_bool_eq]
erw [set.union_eq_Union, supported_Union, supr_bool_eq]; refl
refl
intros
rw [finsupp_prod_lequiv, linear_equiv.coe_mk, finsupp_prod_equiv, finsupp.curry_apply]
intros
apply @linear_independent_comp_subtype_disjoint _ _ _ id
intros
rintros (i | i) (j | j) hij
{ exact ha (ne_of_apply_ne _ hij) }
exact ha (ne_of_apply_ne _ hij)
{ refl }
refl
{ refl }
refl
{ exact hd (ne_of_apply_ne _ hij) }
exact hd (ne_of_apply_ne _ hij)
intros
by_cases h : is_unit A.det
exact or.inl ‚ü®nonsing_inv_mul _ h, mul_nonsing_inv _ h‚ü©
{ exact or.inl ‚ü®nonsing_inv_mul _ h, mul_nonsing_inv _ h‚ü© }
{ exact or.inr (nonsing_inv_apply_not_is_unit _ h) }
exact or.inr (nonsing_inv_apply_not_is_unit _ h)
intros
simp_rw [linear_map.to_matrix_apply, basis.reindex_range_self, basis.reindex_range_repr]
intros
simpa only [‚Üê M.det_transpose, ‚Üê mul_vec_transpose] using exists_mul_vec_eq_zero_iff
intros
have A : (list_transvec_row M).length = r
simp [list_transvec_row]
simp [list_transvec_row]
rw [‚Üê list.take_length (list_transvec_row M), A]
simpa using mul_list_transvec_row_last_col_take M i le_rfl
intros
rw [‚Üê update_snoc_last x m (c ‚Ä¢ x), f.map_smul, update_snoc_last]
intros
refine pi_ext (Œª i x, _)
convert linear_map.congr_fun (h i) x
intros
ext
ext; simp
simp
intros
simp [linear_proj_of_is_compl]
intros
simp [sub_eq_add_neg]
intros
{ rw ‚Üê v.equiv_fun_symm_apply, refl }
rw ‚Üê v.equiv_fun_symm_apply
refl
intros
split_ifs; simp
{ split_ifs; simp }
split_ifs
simp
simp
intros
simp only [ltensor, rtensor, ‚Üê map_comp, id_comp, comp_id]
intros
rw [@iff_def (¬¨ a), @iff_def (¬¨ b)]; exact and_congr decidable.not_imp_comm imp_not_comm
rw [@iff_def (¬¨ a), @iff_def (¬¨ b)]
exact and_congr decidable.not_imp_comm imp_not_comm
intros
induction hbc
assumption
case refl_trans_gen.refl { assumption }
case refl_trans_gen.tail : c d hbc hcd hac { exact hac.tail hcd }
intros
rw [outer_measure.pi, le_bounded_by']
split
intros h s hs
{ intros h s hs, refine (h _ hs).trans_eq (pi_premeasure_pi hs) }
refine (h _ hs).trans_eq (pi_premeasure_pi hs)
intros h s hs
{ intros h s hs, refine le_trans (n.mono $ subset_pi_eval_image univ s) (h _ _), simp [univ_pi_nonempty_iff, hs] }
refine le_trans (n.mono $ subset_pi_eval_image univ s) (h _ _)
simp [univ_pi_nonempty_iff, hs]
intros
apply measurable_of_measurable_coe
intros s hs
simp_rw [map_apply measurable_prod_mk_right hs]
exact measurable_measure_prod_mk_right hs
intros
rw ‚Üê prod_swap at hf
{ rw ‚Üê prod_swap at hf, rw [‚Üê lintegral_map' hf measurable_swap, prod_swap] }
rw [‚Üê lintegral_map' hf measurable_swap, prod_swap]
intros
have hwuv : s ((w ‚à© u) Œî (w ‚à© v)) = 0
refine subset_positive_null_set (hu.union hv) ((hw.inter hu).symm_diff (hw.inter hv)) (hu.symm_diff hv) (restrict_le_restrict_union _ _ hu hsu hv hsv) hs _ _
{ refine subset_positive_null_set (hu.union hv) ((hw.inter hu).symm_diff (hw.inter hv)) (hu.symm_diff hv) (restrict_le_restrict_union _ _ hu hsu hv hsv) hs _ _, { exact symm_diff_le_sup u v }, { rintro x (‚ü®‚ü®hxw, hxu‚ü©, hx‚ü© | ‚ü®‚ü®hxw, hxv‚ü©, hx‚ü©); rw [set.mem_inter_eq, not_and] at hx, { exact or.inl ‚ü®hxu, hx hxw‚ü© }, { exact or.inr ‚ü®hxv, hx hxw‚ü© } } }
{ exact symm_diff_le_sup u v }
exact symm_diff_le_sup u v
rintro x (‚ü®‚ü®hxw, hxu‚ü©, hx‚ü© | ‚ü®‚ü®hxw, hxv‚ü©, hx‚ü©); rw [set.mem_inter_eq, not_and] at hx
rintro x (‚ü®‚ü®hxw, hxu‚ü©, hx‚ü© | ‚ü®‚ü®hxw, hxv‚ü©, hx‚ü©)
{ rintro x (‚ü®‚ü®hxw, hxu‚ü©, hx‚ü© | ‚ü®‚ü®hxw, hxv‚ü©, hx‚ü©); rw [set.mem_inter_eq, not_and] at hx, { exact or.inl ‚ü®hxu, hx hxw‚ü© }, { exact or.inr ‚ü®hxv, hx hxw‚ü© } }
rw [set.mem_inter_eq, not_and] at hx
{ exact or.inl ‚ü®hxu, hx hxw‚ü© }
exact or.inl ‚ü®hxu, hx hxw‚ü©
rw [set.mem_inter_eq, not_and] at hx
{ exact or.inr ‚ü®hxv, hx hxw‚ü© }
exact or.inr ‚ü®hxv, hx hxw‚ü©
obtain ‚ü®huv, hvu‚ü© := of_diff_eq_zero_of_symm_diff_eq_zero_positive (hw.inter hu) (hw.inter hv) (restrict_le_restrict_subset _ _ hu hsu (w.inter_subset_right u)) (restrict_le_restrict_subset _ _ hv hsv (w.inter_subset_right v)) hwuv
rw [‚Üê of_diff_of_diff_eq_zero (hw.inter hu) (hw.inter hv) hvu, huv, zero_add]
intros
rw [‚Üê lintegral_mk, mk_coe_fn]
intros
rw [condexp_ind_smul, condexp_ind_smul, to_span_singleton_smul', (to_span_singleton ‚Ñù x).smul_comp_LpL_apply c ‚Üë(condexp_L2 ‚Ñù hm (indicator_const_Lp 2 hs hŒºs (1 : ‚Ñù)))]
intros
simp_rw condexp_L1_eq hf
rw set_integral_condexp_L1_clm (hf.to_L1 f) hs
exact set_integral_congr_ae (hm s hs) ((hf.coe_fn_to_L1).mono (Œª x hx hxs, hx))
intros
simp only [has_finite_integral_iff_norm, edist_dist, dist_zero_right]
intros
simp_rw [mem_Lp_iff_snorm_lt_top, snorm_ae_eq_fun]
{ simp_rw [mem_Lp_iff_snorm_lt_top, snorm_ae_eq_fun], exact snorm_inner_lt_top f g, }
exact snorm_inner_lt_top f g
intros
simp_rw [edist, dist, norm_def, ennreal.of_real_to_real (snorm_ne_top _)]
exact snorm_congr_ae (coe_fn_sub _ _)
intros
simp [snorm', hp0_lt]
intros
rw [snorm']
refine ennreal.rpow_le_rpow _ (one_div_nonneg.2 hq)
refine lintegral_mono_ae (h.mono $ Œª x hx, _)
exact ennreal.rpow_le_rpow (ennreal.coe_le_coe.2 hx) hq
intros
rw [snorm_congr_ae hf.ae_eq_mk, snorm_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk)]
exact snorm_trim hm hf.measurable_mk
intros
simpa using @integrable_on_finset_Union _ _ _ _ _ _ f Œº finset.univ t
intros
rw [‚Üê hderiv, integral_deriv_eq_sub hdiff]
rw hderiv
exact hcont.interval_integrable
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
simp only [sub_eq_add_neg, ‚Üê integral_symm, integral_interval_add_interval_comm hab hcd.symm (hac.trans hcd)]
intros
ext1 t ht
rw [restrict_apply ht, with_density_apply _ ht, with_density_apply _ (ht.inter hs), restrict_restrict ht]
intros
simp_rw [ennreal.tsum_eq_supr_nat' (tendsto_add_at_top_nat 1), sum_eapprox_diff, supr_eapprox_apply f hf a]
intros
by_cases hf_zero : ‚à´‚Åª a, (f a) ^ p ‚àÇŒº = 0
refine le_trans (le_of_eq _) (zero_le _)
{ refine le_trans (le_of_eq _) (zero_le _), exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.pos hf hf_zero, }
exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.pos hf hf_zero
by_cases hg_zero : ‚à´‚Åª a, (g a) ^ q ‚àÇŒº = 0
refine le_trans (le_of_eq _) (zero_le _)
{ refine le_trans (le_of_eq _) (zero_le _), rw mul_comm, exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.symm.pos hg hg_zero, }
rw mul_comm
exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.symm.pos hg hg_zero
by_cases hf_top : ‚à´‚Åª a, (f a) ^ p ‚àÇŒº = ‚ä§
exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.pos hpq.symm.nonneg hf_top hg_zero
{ exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.pos hpq.symm.nonneg hf_top hg_zero, }
by_cases hg_top : ‚à´‚Åª a, (g a) ^ q ‚àÇŒº = ‚ä§
rw [mul_comm, mul_comm ((‚à´‚Åª (a : Œ±), (f a) ^ p ‚àÇŒº) ^ (1 / p))]
{ rw [mul_comm, mul_comm ((‚à´‚Åª (a : Œ±), (f a) ^ p ‚àÇŒº) ^ (1 / p))], exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.symm.pos hpq.nonneg hg_top hf_zero, }
exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.symm.pos hpq.nonneg hg_top hf_zero
exact ennreal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top hpq hf hg hf_top hg_top hf_zero hg_zero
intros
apply norm_set_integral_le_of_norm_le_const_ae hs
have A : ‚àÄ·µê (x : Œ±) ‚àÇŒº, x ‚àà s ‚Üí ‚à•ae_measurable.mk f hfm x‚à• ‚â§ C
filter_upwards [hC, hfm.ae_mem_imp_eq_mk]
{ filter_upwards [hC, hfm.ae_mem_imp_eq_mk], assume a h1 h2 h3, rw [‚Üê h2 h3], exact h1 h3 }
assume a h1 h2 h3
rw [‚Üê h2 h3]
exact h1 h3
have B : measurable_set {x | ‚à•(hfm.mk f) x‚à• ‚â§ C} := hfm.measurable_mk.norm measurable_set_Iic
filter_upwards [hfm.ae_eq_mk, (ae_restrict_iff B).2 A]
assume a h1 h2
rwa h1
intros
cases (pi s t).eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
simp [measurable_set_pi_of_nonempty hs, h, ‚Üê not_nonempty_iff_eq_empty]
{ simp [measurable_set_pi_of_nonempty hs, h, ‚Üê not_nonempty_iff_eq_empty] }
intros
by_cases p; simp [h, measurable_set.empty]; apply measurable_set.univ
by_cases p; simp [h, measurable_set.empty]
by_cases p
{ by_cases p; simp [h, measurable_set.empty]; apply measurable_set.univ }
simp [h, measurable_set.empty]
simp [h, measurable_set.empty]
intros
simp [apply_eq_coe_to_fun, Œº.sup_disjoint' _ _ h]
intros
rcases index_elim hK hV with ‚ü®s, h1s, h2s‚ü©
rw [‚Üê h2s]
apply nat.Inf_le
rw [mem_image]
refine ‚ü®s.map (equiv.mul_right g‚Åª¬π).to_embedding, _, finset.card_map _‚ü©
simp only [mem_set_of_eq]
{ simp only [mem_set_of_eq], refine subset.trans (image_subset _ h1s) _, rintro _ ‚ü®g‚ÇÅ, ‚ü®_, ‚ü®g‚ÇÇ, rfl‚ü©, ‚ü®_, ‚ü®hg‚ÇÇ, rfl‚ü©, hg‚ÇÅ‚ü©‚ü©, rfl‚ü©, simp only [mem_preimage] at hg‚ÇÅ, simp only [exists_prop, mem_Union, finset.mem_map, equiv.coe_mul_right, exists_exists_and_eq_and, mem_preimage, equiv.to_embedding_apply], refine ‚ü®_, hg‚ÇÇ, _‚ü©, simp only [mul_assoc, hg‚ÇÅ, inv_mul_cancel_left] }
refine subset.trans (image_subset _ h1s) _
rintro _ ‚ü®g‚ÇÅ, ‚ü®_, ‚ü®g‚ÇÇ, rfl‚ü©, ‚ü®_, ‚ü®hg‚ÇÇ, rfl‚ü©, hg‚ÇÅ‚ü©‚ü©, rfl‚ü©
simp only [mem_preimage] at hg‚ÇÅ
simp only [exists_prop, mem_Union, finset.mem_map, equiv.coe_mul_right, exists_exists_and_eq_and, mem_preimage, equiv.to_embedding_apply]
refine ‚ü®_, hg‚ÇÇ, _‚ü©
simp only [mul_assoc, hg‚ÇÅ, inv_mul_cancel_left]
intros
simp only [volume_pi_Ico, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
rw [‚Üê measure_theory.measure.measure_univ_eq_zero, ‚Üê coe_measure_univ_nnreal]
norm_cast
intros
simp [eventually_le_antisymm_iff, ae_le_set, diff_diff_right, diff_diff, diff_eq_empty.2 (set.subset_union_right _ _)]
intros
refine (map_of_function_le _).antisymm (Œª s, _)
simp only [of_function_apply, map_apply, le_infi_iff]
intros t ht
refine infi_le_of_le (Œª n, (range f)·∂ú ‚à™ f '' (t n)) (infi_le_of_le _ _)
rw [‚Üê union_Union, ‚Üê inter_subset, ‚Üê image_preimage_eq_inter_range, ‚Üê image_Union]
{ rw [‚Üê union_Union, ‚Üê inter_subset, ‚Üê image_preimage_eq_inter_range, ‚Üê image_Union], exact image_subset _ ht }
exact image_subset _ ht
refine ennreal.tsum_le_tsum (Œª n, le_of_eq _)
{ refine ennreal.tsum_le_tsum (Œª n, le_of_eq _), simp [hf.preimage_image] }
simp [hf.preimage_image]
intros
{ rw [infi, Inf_apply' hs], simp only [infi_range] }
rw [infi, Inf_apply' hs]
simp only [infi_range]
intros
refine le_antisymm (infi_le_of_le a $ binfi_le b (subset.refl _)) (le_infi $ Œª a', le_infi $ Œª b', le_infi $ Œª h, ennreal.coe_le_coe.2 _)
cases le_or_lt b a with ab ab
rw real.to_nnreal_of_nonpos (sub_nonpos.2 (f.mono ab))
{ rw real.to_nnreal_of_nonpos (sub_nonpos.2 (f.mono ab)), apply zero_le, }
apply zero_le
cases (Ioc_subset_Ioc_iff ab).1 h with h‚ÇÅ h‚ÇÇ
exact real.to_nnreal_le_to_nnreal (sub_le_sub (f.mono h‚ÇÅ) (f.mono h‚ÇÇ))
intros
ext1 i hi
rw [with_density·µ•_apply (hf.add hg) hi, vector_measure.add_apply, with_density·µ•_apply hf hi, with_density·µ•_apply hg hi]
simp_rw [pi.add_apply]
rw integral_add; rw ‚Üê integrable_on_univ
rw integral_add
rw ‚Üê integrable_on_univ
{ exact hf.integrable_on.restrict measurable_set.univ }
exact hf.integrable_on.restrict measurable_set.univ
rw ‚Üê integrable_on_univ
{ exact hg.integrable_on.restrict measurable_set.univ }
exact hg.integrable_on.restrict measurable_set.univ
intros
simp [map]
intros
ext x
rw [ppow_apply (nat.succ_pos k), pow_succ]
induction k; simp
induction k
simp
simp
intros
intro I'
obtain ‚ü®‚ü®I, hI‚ü©, rfl‚ü© := class_group.mk0_surjective I'
obtain ‚ü®J, mk0_eq_mk0, J_dvd‚ü© := exists_mk0_eq_mk0 L bS adm h ‚ü®I, hI‚ü©
exact ‚ü®‚ü®J, J_dvd‚ü©, mk0_eq_mk0.symm‚ü©
intros
simp [h, divisors_prime_pow]
intros
simp [finite_int_iff, ne.symm (ne_of_lt (p_prime.1.one_lt))]
intros
{ rw ‚Üê zmod_cast_comp_to_zmod_pow _ _ h, refl }
rw ‚Üê zmod_cast_comp_to_zmod_pow _ _ h
refl
intros
obtain ‚ü®m, n, ht1, ht2, ht3, ht4‚ü© := pythagorean_triple.coprime_classification.mp (and.intro h h_coprime)
cases le_or_lt 0 m with hm hm
use [m, n]
{ use [m, n], cases ht1 with h_odd h_even, { apply and.intro h_odd.1, apply and.intro h_odd.2, cases ht2 with h_pos h_neg, { apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm)) }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }, exfalso, rcases h_even with ‚ü®rfl, -‚ü©, rw [mul_assoc, int.mul_mod_right] at h_parity, exact zero_ne_one h_parity }
cases ht1 with h_odd h_even
apply and.intro h_odd.1
{ apply and.intro h_odd.1, apply and.intro h_odd.2, cases ht2 with h_pos h_neg, { apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm)) }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }
apply and.intro h_odd.2
cases ht2 with h_pos h_neg
{ apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm)) }
apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm))
exfalso
{ exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) }
revert h_pos
rw h_neg
exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))
exfalso
rcases h_even with ‚ü®rfl, -‚ü©
rw [mul_assoc, int.mul_mod_right] at h_parity
exact zero_ne_one h_parity
use [-m, -n]
{ use [-m, -n], cases ht1 with h_odd h_even, { rw [neg_sq m], rw [neg_sq n], apply and.intro h_odd.1, split, { rw h_odd.2, ring }, cases ht2 with h_pos h_neg, { apply and.intro h_pos, split, { delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }, { rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith } }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }, exfalso, rcases h_even with ‚ü®rfl, -‚ü©, rw [mul_assoc, int.mul_mod_right] at h_parity, exact zero_ne_one h_parity }
cases ht1 with h_odd h_even
rw [neg_sq m]
{ rw [neg_sq m], rw [neg_sq n], apply and.intro h_odd.1, split, { rw h_odd.2, ring }, cases ht2 with h_pos h_neg, { apply and.intro h_pos, split, { delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }, { rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith } }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }
rw [neg_sq n]
apply and.intro h_odd.1
split
rw h_odd.2
{ rw h_odd.2, ring }
ring
cases ht2 with h_pos h_neg
apply and.intro h_pos
{ apply and.intro h_pos, split, { delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }, { rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith } }
split
delta int.gcd
{ delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }
rw [int.nat_abs_neg, int.nat_abs_neg]
exact ht3
rw [int.neg_mod_two, int.neg_mod_two]
{ rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith }
apply and.intro ht4
linarith
exfalso
{ exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) }
revert h_pos
rw h_neg
exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))
exfalso
rcases h_even with ‚ü®rfl, -‚ü©
rw [mul_assoc, int.mul_mod_right] at h_parity
exact zero_ne_one h_parity
intros
simp [to_complex_def]
intros
rw sdiff_sup
apply sdiff_unique
rw [‚Üêinf_sup_left, sup_sdiff_self_right, inf_sdiff_sup_right]
{ rw [‚Üêinf_sup_left, sup_sdiff_self_right, inf_sdiff_sup_right] }
rw [inf_assoc, @inf_comm _ _ z, inf_assoc, inf_sdiff_self_left, inf_bot_eq, inf_bot_eq]
{ rw [inf_assoc, @inf_comm _ _ z, inf_assoc, inf_sdiff_self_left, inf_bot_eq, inf_bot_eq] }
intros
simp only [disjoint_iff, inf_sup_right, sup_eq_bot_iff]
intros
{ cases x, simpa using h, refl, }
cases x
simpa using h
refl
intros
exact is_glb_singleton.union hs
intros
refine eq.trans (congr rfl (set.ext (Œª x, _))) (Sup_compact_le_eq ‚ä§)
exact (and_iff_left le_top).symm
intros
refine eq_of_forall_ge_iff (Œª c, _)
simp only [sup_le_iff, supr_le_iff]
refine ‚ü®Œª h, _, Œª h, ‚ü®h _, Œª i, h _‚ü©‚ü©
rintro (_|i)
exacts [h.1, h.2 i]
intros
rw ‚Üêsupr_sup_eq
congr' 1 with i
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
haveI := unique_prop hp; exact supr_unique
haveI := unique_prop hp
exact supr_unique
intros
simp only [directed_on, set.ball_image_iff, set.bex_image_iff, order.preimage]
intros
simp [hlb.tendsto_right_iff, hla.eventually_iff]
intros
simp [filter.frequently, not_forall]
intros
{ rw [comap_top], exact le_top }
rw [comap_top]
exact le_top
intros
refine le_antisymm (le_map $ Œª s hs, _) (le_seq $ Œª s hs t ht, _)
rw ‚Üê singleton_seq
{ rw ‚Üê singleton_seq, apply seq_mem_seq _ hs, exact singleton_mem_pure }
apply seq_mem_seq _ hs
exact singleton_mem_pure
refine sets_of_superset (map g f) (image_mem_map ht) _
{ refine sets_of_superset (map g f) (image_mem_map ht) _, rintro b ‚ü®a, ha, rfl‚ü©, exact ‚ü®g, hs, a, ha, rfl‚ü© }
rintro b ‚ü®a, ha, rfl‚ü©
exact ‚ü®g, hs, a, ha, rfl‚ü©
intros
erw [comap_inf, filter.comap_comap, filter.comap_comap]
intros
simp [part.œâSup] at h
split_ifs at h
have h' := classical.some_spec h_1
{ have h' := classical.some_spec h_1, rw ‚Üê eq_some_iff at h, rw ‚Üê h, exact h' }
rw ‚Üê eq_some_iff at h
rw ‚Üê h
exact h'
{ rcases h with ‚ü® ‚ü® ‚ü© ‚ü© }
rcases h with ‚ü® ‚ü® ‚ü© ‚ü©
intros
simp [sup_sdiff, sdiff_inf, sup_comm, (Œî)]
intros
refine (Œª S f hfs, h_indep S (Œª x hxS, _))
simp_rw hms x
exact measurable_set_generate_from (hfs x hxS)
intros
rw [root, lift_mk, eval‚ÇÇ_X]
intros
simp only [is_algebraic, alg_hom.injective_iff, not_forall, and.comm, exists_prop]
intros
simpa only [is_coprime_comm] using is_coprime.prod_left_iff
intros
{ rw is_coprime_comm at H1 H2 ‚ä¢, exact H1.mul_left H2 }
rw is_coprime_comm at H1 H2 ‚ä¢
exact H1.mul_left H2
intros
have key : associated (multiset.repeat p m).prod (multiset.repeat q n).prod
rw [multiset.prod_repeat, multiset.prod_repeat, associated]
{ rw [multiset.prod_repeat, multiset.prod_repeat, associated], refine ‚ü®u * v‚Åª¬π, _‚ü©, simp only [units.coe_mul], rw [mul_left_comm, ‚Üê mul_assoc, h, mul_right_comm, units.mul_inv, one_mul], }
refine ‚ü®u * v‚Åª¬π, _‚ü©
simp only [units.coe_mul]
rw [mul_left_comm, ‚Üê mul_assoc, h, mul_right_comm, units.mul_inv, one_mul]
have := multiset.card_eq_card_of_rel (unique_factorization_monoid.factors_unique _ _ key)
{ simpa only [multiset.card_repeat] }
simpa only [multiset.card_repeat]
all_goals { intros x hx, replace hx := multiset.eq_of_mem_repeat hx, unfreezingI { subst hx, assumption } }
intros x hx
replace hx := multiset.eq_of_mem_repeat hx
unfreezingI { subst hx, assumption }
intros x hx
replace hx := multiset.eq_of_mem_repeat hx
subst hx
unfreezingI { subst hx, assumption }
assumption
intros
apply coe_to_submodule_injective
simp only [coe_mul, coe_span_singleton, span_mul_span, singleton_mul_singleton]
intros
rcases I with ‚ü®I, a, a_nonzero, hI‚ü©
use [a, a_nonzero]
intros b hb
obtain ‚ü®b', b'_mem, hb'‚ü© := submodule.mem_map.mp hb
obtain ‚ü®x, hx‚ü© := hI b' b'_mem
use x
erw [‚Üêg.commutes, hx, g.map_smul, hb']
intros
have : ¬¨ _ := Œª h, hf ‚ü®exists_pair_ne R, mul_comm, h‚ü©
simp_rw is_unit_iff_exists_inv
push_neg at ‚ä¢ this
obtain ‚ü®x, hx, not_unit‚ü© := this
exact ‚ü®x, hx, not_unit‚ü©
intros
erw [submodule.one_eq_range, linear_map.range_id]
intros
refine quotient.maximal_of_is_field _ _
haveI : is_prime (I.comap (algebra_map R S)) := comap_is_prime _ _
exact is_field_of_is_integral_of_is_field (is_integral_quotient_of_is_integral hRS) algebra_map_quotient_injective (by rwa ‚Üê quotient.maximal_ideal_iff_is_field_quotient)
intros
apply nat.dvd_antisymm; rw ‚Üê int.coe_nat_dvd
apply nat.dvd_antisymm
rw ‚Üê int.coe_nat_dvd
rw int.nat_abs_dvd
{ rw int.nat_abs_dvd, exact int.dvd_gcd (euclidean_domain.gcd_dvd_left _ _) (euclidean_domain.gcd_dvd_right _ _) }
exact int.dvd_gcd (euclidean_domain.gcd_dvd_left _ _) (euclidean_domain.gcd_dvd_right _ _)
rw ‚Üê int.coe_nat_dvd
rw int.dvd_nat_abs
{ rw int.dvd_nat_abs, exact euclidean_domain.dvd_gcd (int.gcd_dvd_left _ _) (int.gcd_dvd_right _ _) }
exact euclidean_domain.dvd_gcd (int.gcd_dvd_left _ _) (int.gcd_dvd_right _ _)
intros
ext y
rw subalgebra.mem_map
split
rintros ‚ü®x, hx, rfl‚ü©
{ rintros ‚ü®x, hx, rfl‚ü©, exact is_integral_alg_hom f hx }
exact is_integral_alg_hom f hx
intro hy
{ intro hy, use [f.symm y, is_integral_alg_hom (f.symm : B ‚Üí‚Çê[R] A) hy], simp }
use [f.symm y, is_integral_alg_hom (f.symm : B ‚Üí‚Çê[R] A) hy]
simp
intros
refine ‚ü®Œª h, set.disjoint_left.1 h (mem_powers _), Œª h, (disjoint_iff).mpr (eq_bot_iff.mpr _)‚ü©
rintros x ‚ü®‚ü®n, rfl‚ü©, hx'‚ü©
rw [‚Üê hI] at hx'
exact absurd (hI ‚ñ∏ mem_radical_of_pow_mem hx' : y ‚àà I.carrier) h
intros
convert congr_arg (ideal.map _) at_prime.comap_maximal_ideal.symm
rw map_comap I.prime_compl
intros
{ rw [‚Üê nat.cast_zero, eq_coe_iff], simpa }
rw [‚Üê nat.cast_zero, eq_coe_iff]
simpa
intros
rw [is_noetherian_iff_well_founded, well_founded.monotone_chain_condition]
intros
simp only [frange, exists_prop, mem_support_iff, finset.mem_image, ne.def]
exact ‚ü®n, h, rfl‚ü©
intros
rw [U_eq_X_mul_U_add_T, add_comm (X * U R n), add_sub_cancel]
intros
refine ‚ü®Œª h, h.trans (dvd.intro_left _ q.eq_C_content_mul_prim_part.symm), Œª h, _‚ü©
rcases h with ‚ü®r, rfl‚ü©
apply dvd.intro _
rw [prim_part_mul hq, hp.prim_part_eq]
intros
suffices : ideal.span ({X} : set (power_series R)) = (constant_coeff R).ker
{ rw this, exact ring_hom.ker_is_prime _ }
rw this
exact ring_hom.ker_is_prime _
apply ideal.ext
intro œÜ
rw [ring_hom.mem_ker, ideal.mem_span_singleton, X_dvd_iff]
intros
rw [‚Üê monomial_zero_eq_C_apply, coeff_monomial_same 0 a]
intros
{ ghost_calc x y, rintro ‚ü®‚ü©; ghost_simp [mul_assoc] }
ghost_calc x y
rintro ‚ü®‚ü©
rintro ‚ü®‚ü©; ghost_simp [mul_assoc]
ghost_simp [mul_assoc]
ghost_simp [mul_assoc]
intros
obtain ‚ü®œÜ, hf‚ü© := hf
unfreezingI {obtain ‚ü®œÜ, hf‚ü© := hf}
ext n
simp only [map_coeff, hf, map_aeval, peval, uncurry]
apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl
try { ext ‚ü®i, k‚ü©, fin_cases i }
ext ‚ü®i, k‚ü©
fin_cases i
all_goals { simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one] }
simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
intros
witt_truncate_fun_tac
intros
apply le_antisymm
rw powerlt_le
{ rw powerlt_le, intros c‚ÇÉ h2, apply power_le_power_left h, rwa [‚Üêlt_succ] }
intros c‚ÇÉ h2
apply power_le_power_left h
rwa [‚Üêlt_succ]
{ apply le_powerlt, apply lt_succ_self }
apply le_powerlt
apply lt_succ_self
intros
simp [lt_iff_le_not_le, -not_le]
intros
simp [mul_lt_omega_iff, ha, hb]
intros
rcases zero_or_succ_or_limit o with rfl|‚ü®o,rfl‚ü©|l
{ simp [not_zero_is_limit, cardinal.omega_ne_zero] }
simp [not_zero_is_limit, cardinal.omega_ne_zero]
{ simp [not_succ_is_limit, cardinal.one_lt_omega] }
simp [not_succ_is_limit, cardinal.one_lt_omega]
simp [l]
{ simp [l], refine le_of_not_lt (Œª h, _), cases cardinal.lt_omega.1 h with n e, have := cof_cof o, rw [e, ord_nat] at this, cases n, { simp at e, simpa [e, not_zero_is_limit] using l }, { rw [‚Üê nat_cast_succ, cof_succ] at this, rw [‚Üê this, cof_eq_one_iff_is_succ] at e, rcases e with ‚ü®a, rfl‚ü©, exact not_succ_is_limit _ l } }
refine le_of_not_lt (Œª h, _)
cases cardinal.lt_omega.1 h with n e
have := cof_cof o
rw [e, ord_nat] at this
cases n
{ simp at e, simpa [e, not_zero_is_limit] using l }
simp at e
simpa [e, not_zero_is_limit] using l
rw [‚Üê nat_cast_succ, cof_succ] at this
{ rw [‚Üê nat_cast_succ, cof_succ] at this, rw [‚Üê this, cof_eq_one_iff_is_succ] at e, rcases e with ‚ü®a, rfl‚ü©, exact not_succ_is_limit _ l }
rw [‚Üê this, cof_eq_one_iff_is_succ] at e
rcases e with ‚ü®a, rfl‚ü©
exact not_succ_is_limit _ l
simpa using repr_of_nat 1
intros
simp [termg]
intros
have ha' := normalize_fin_lt.mk rfl ha (h.trans_lt hb.lt)
have ha' := normalize_fin_lt.mk rfl ha (h.trans_lt hb.lt); rwa [‚Üê hb.coe, ‚Üê ha'.coe] at h
rwa [‚Üê hb.coe, ‚Üê ha'.coe] at h
intros
intros v h1
apply implies_neg_elim_core
apply (nnf_equiv v).elim_right h1
intros
rw [div_eq_mul_inv, h]
intros
rwa sub_eq_add_neg
intros
convert has_sum_single b _
{ exact (if_pos rfl).symm }
exact (if_pos rfl).symm
assume b' hb'
exact if_neg hb'
intros
simp [has_sum_nat_add_iff]
intros
split
assume h
{ assume h, rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©, rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©, refine ‚ü®l, u, ‚ü®la, au‚ü©, Œªx hx, _‚ü©, cases le_total a x with hax hax, { exact hu ‚ü®hax, hx.2‚ü© }, { exact hl ‚ü®hx.1, hax‚ü© } }
rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©
rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©
refine ‚ü®l, u, ‚ü®la, au‚ü©, Œªx hx, _‚ü©
cases le_total a x with hax hax
{ exact hu ‚ü®hax, hx.2‚ü© }
exact hu ‚ü®hax, hx.2‚ü©
{ exact hl ‚ü®hx.1, hax‚ü© }
exact hl ‚ü®hx.1, hax‚ü©
rintros ‚ü®l, u, ha, h‚ü©
{ rintros ‚ü®l, u, ha, h‚ü©, apply mem_of_superset (is_open.mem_nhds is_open_Ioo ha) h }
apply mem_of_superset (is_open.mem_nhds is_open_Ioo ha) h
intros
rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]
intros
let S := s ‚à© Icc a b
replace ha : a ‚àà S
from ‚ü®ha, left_mem_Icc.2 hab‚ü©
have Sbd : bdd_above S
from ‚ü®b, Œª z hz, hz.2.2‚ü©
let c := Sup (s ‚à© Icc a b)
have c_mem : c ‚àà S
from hs.cSup_mem ‚ü®_, ha‚ü© Sbd
have c_le : c ‚â§ b
from cSup_le ‚ü®_, ha‚ü© (Œª x hx, hx.2.2)
cases eq_or_lt_of_le c_le with hc hc
from hc ‚ñ∏ c_mem.1
exfalso
rcases hgt c ‚ü®c_mem.1, c_mem.2.1, hc‚ü© with ‚ü®x, xs, cx, xb‚ü©
exact not_lt_of_le (le_cSup Sbd ‚ü®xs, le_trans (le_cSup Sbd ha) (le_of_lt cx), xb‚ü©) cx
intros
simp only [‚Üê Ici_diff_left, continuous_within_at_diff_self]
intros
rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©
rw [@is_open_iff_generate_intervals Œ± _ _ t]
exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©
intros
rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]
intros
{ ext, refl }
ext
refl
intros
intros s hs
rw is_open_sigma_iff at hs
have : s = ‚ãÉ i, sigma.mk i '' (sigma.mk i ‚Åª¬π' s)
{ rw Union_image_preimage_sigma_mk_eq_self }
rw Union_image_preimage_sigma_mk_eq_self
rw this
rw [image_Union]
apply is_open_Union
intro i
rw [image_image]
exact h i _ (hs i)
intros
{ ext, simp [sup'_apply], }
ext
simp [sup'_apply]
intros
simp [continuous_iff_continuous_at, continuous_on, continuous_at, continuous_within_at, nhds_within_univ]
intros
rw continuous_iff_continuous_on_univ
apply continuous_on.if'; simp *; assumption
apply continuous_on.if'; simp *
apply continuous_on.if'
simp *
assumption
simp *
assumption
simp *
simp *
intros
simp only [nhds_of_ne_top ha, tendsto_infi, tendsto_principal, mem_Icc]
intros
cases add_subgroup.bot_or_exists_ne_zero G with H H
right
{ right, use 0, rw [H, add_subgroup.closure_singleton_zero] }
use 0
rw [H, add_subgroup.closure_singleton_zero]
let G_pos := {g : ‚Ñù | g ‚àà G ‚àß 0 < g}
{ let G_pos := {g : ‚Ñù | g ‚àà G ‚àß 0 < g}, by_cases H' : ‚àÉ a, is_least G_pos a, { right, rcases H' with ‚ü®a, ha‚ü©, exact ‚ü®a, add_subgroup.cyclic_of_min ha‚ü© }, { left, rcases H with ‚ü®g‚ÇÄ, g‚ÇÄ_in, g‚ÇÄ_ne‚ü©, exact real.subgroup_dense_of_no_min g‚ÇÄ_in g‚ÇÄ_ne H' } }
by_cases H' : ‚àÉ a, is_least G_pos a
right
{ right, rcases H' with ‚ü®a, ha‚ü©, exact ‚ü®a, add_subgroup.cyclic_of_min ha‚ü© }
rcases H' with ‚ü®a, ha‚ü©
exact ‚ü®a, add_subgroup.cyclic_of_min ha‚ü©
left
{ left, rcases H with ‚ü®g‚ÇÄ, g‚ÇÄ_in, g‚ÇÄ_ne‚ü©, exact real.subgroup_dense_of_no_min g‚ÇÄ_in g‚ÇÄ_ne H' }
rcases H with ‚ü®g‚ÇÄ, g‚ÇÄ_in, g‚ÇÄ_ne‚ü©
exact real.subgroup_dense_of_no_min g‚ÇÄ_in g‚ÇÄ_ne H'
intros
assume s hs
rw [image_eq_preimage_of_inverse r_inv l_inv]
exact hs.preimage h
intros
{ simp only [antilipschitz_with, edist_nndist], norm_cast }
simp only [antilipschitz_with, edist_nndist]
norm_cast
intros
simpa only [real.dist_eq, abs_of_nonpos (sub_nonpos.2 $ hx.1.trans hx.2), neg_sub] using real.dist_le_of_mem_interval (Icc_subset_interval hx) (Icc_subset_interval hy)
intros
{ norm_cast, exact ennreal.coe_ne_top }
norm_cast
exact ennreal.coe_ne_top
intros
simp only [diam, supr_le_iff]
intros
simp only [to_GH_space, quotient.eq]
split
assume h
{ assume h, rcases setoid.symm h with ‚ü®e‚ü©, have f := (Kuratowski_embedding.isometry X).isometric_on_range.trans e, use Œª x, f x, split, { apply isometry_subtype_coe.comp f.isometry }, { rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe] } }
rcases setoid.symm h with ‚ü®e‚ü©
have f := (Kuratowski_embedding.isometry X).isometric_on_range.trans e
use Œª x, f x
split
{ apply isometry_subtype_coe.comp f.isometry }
apply isometry_subtype_coe.comp f.isometry
{ rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe] }
rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe]
rintros ‚ü®Œ®, ‚ü®isomŒ®, rangeŒ®‚ü©‚ü©
{ rintros ‚ü®Œ®, ‚ü®isomŒ®, rangeŒ®‚ü©‚ü©, have f := ((Kuratowski_embedding.isometry X).isometric_on_range.symm.trans isomŒ®.isometric_on_range).symm, have E : (range Œ® ‚âÉ·µ¢ (nonempty_compacts.Kuratowski_embedding X).val) = (p.val ‚âÉ·µ¢ range (Kuratowski_embedding X)), by { dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeŒ®]; refl }, have g := cast E f, exact ‚ü®g‚ü© }
have f := ((Kuratowski_embedding.isometry X).isometric_on_range.symm.trans isomŒ®.isometric_on_range).symm
have E : (range Œ® ‚âÉ·µ¢ (nonempty_compacts.Kuratowski_embedding X).val) = (p.val ‚âÉ·µ¢ range (Kuratowski_embedding X))
dunfold nonempty_compacts.Kuratowski_embedding
dunfold nonempty_compacts.Kuratowski_embedding
{ dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeŒ®]; refl }
{ dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeŒ®]; refl }
rw [rangeŒ®]
rw [rangeŒ®]
rw [rangeŒ®]; refl
rw [rangeŒ®]; refl
have g := cast E f
exact ‚ü®g‚ü©
intros
refine Œª x, mem_closure_iff_nhds.2 (Œª t ht, ne_empty_iff_nonempty.1 $ Œª he, hs.not_le _)
rw [‚Üê diff_eq, diff_eq_empty] at he
rw [‚Üê real.dimH_of_mem_nhds ht]
exact dimH_mono he
intros
simp [inf_dist, inf_edist_closure]
intros
simp only [holder_on_with, holder_with, mem_univ, true_implies_iff]
intros
rw [iterate_succ, mul_comm]
simpa only [nnreal.coe_pow] using (hf.iterate n).dist_le_mul x (f x)
intros
rcases exists_subset_Union_closure_subset hs ho (Œª x _, hf.point_finite x) hU with ‚ü®V, hsV, hVo, hVU‚ü©
have hVU' : ‚àÄ i, V i ‚äÜ U i
from Œª i, subset.trans subset_closure (hVU i)
rcases exists_subset_Union_closure_subset hs hVo (Œª x _, (hf.subset hVU').point_finite x) hsV with ‚ü®W, hsW, hWo, hWV‚ü©
choose f hfp hf0 hf1 hf01 using Œª i, h01 _ _ (is_closed_compl_iff.2 $ hVo i) is_closed_closure (disjoint_right.2 $ Œª x hx, not_not.2 (hWV i hx))
have hsupp : ‚àÄ i, support (f i) ‚äÜ V i
from Œª i, support_subset_iff'.2 (hf0 i)
refine ‚ü®‚ü®f, hf.subset (Œª i, subset.trans (hsupp i) (hVU' i)), Œª i x, (hf01 i x).1, Œª i x, (hf01 i x).2, Œª x hx, _‚ü©, hfp, Œª i, subset.trans (closure_mono (hsupp i)) (hVU i)‚ü©
rcases mem_Union.1 (hsW hx) with ‚ü®i, hi‚ü©
exact ‚ü®i, ((hf1 i).mono subset_closure).eventually_eq_of_mem ((hWo i).mem_nhds hi)‚ü©
intros
simp [joined_in, joined, exists_true_iff_nonempty]
intros
simp_rw [‚Üê lower_semicontinuous_within_at_univ_iff] at *
exact lower_semicontinuous_within_at_supr h
intros
rw ‚Üê bUnion_univ; exact finite_univ.compact_bUnion (Œª i _, h i)
rw ‚Üê bUnion_univ
exact finite_univ.compact_bUnion (Œª i _, h i)
intros
rw [uniform_continuous, uniformity_prod]; exact tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©
rw [uniform_continuous, uniformity_prod]
exact tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©
intros
simp only [‚Üê and_assoc]
refine uniformity_has_basis_open.restrict (Œª s hs, ‚ü®symmetrize_rel s, _‚ü©)
exact ‚ü®‚ü®symmetrize_mem_uniformity hs.1, is_open.inter hs.2 (hs.2.preimage continuous_swap)‚ü©, symmetric_symmetrize_rel s, symmetrize_rel_subset_self s‚ü©
intros
cases x; cases x'; simp * at *
cases x; cases x'
cases x
cases x'
simp * at *
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
have h := int.add_le_add_right h (-c)
rwa int.add_neg_cancel_right at h
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
cases x; simp [gcd, succ_ne_zero]
cases x
simp [gcd, succ_ne_zero]
simp [gcd, succ_ne_zero]
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
simp [infi]
intros
simp only [finset.prod_eq_multiset_prod, g.map_multiset_prod, multiset.map_map]
intros
split_ifs with h; refl
{ split_ifs with h; refl }
split_ifs with h
refl
refl
intros
rw [‚Üê finprod_mem_inter_mul_support f s, ‚Üê finprod_mem_inter_mul_support f t, ‚Üê finprod_mem_union_inter hs ht, ‚Üê union_inter_distrib_right, finprod_mem_inter_mul_support, ‚Üê finprod_mem_inter_mul_support f (s ‚à© t)]
congr' 2
rw [inter_left_comm, inter_assoc, inter_assoc, inter_self, inter_left_comm]
intros
rw eq_neg_iff_add_eq_zero
nth_rewrite 1 ‚Üê one_pow (p ^ n)
rw [‚Üê add_pow_char_pow, add_left_neg, zero_pow (pow_pos (fact.out (nat.prime p)).pos _)]
intros
{ rw [nth_cont_eq_succ_nth_cont_aux], exact (exists_gcf_pair_rat_eq_of_nth_conts_aux v $ n + 1) }
rw [nth_cont_eq_succ_nth_cont_aux]
exact (exists_gcf_pair_rat_eq_of_nth_conts_aux v $ n + 1)
intros
change s.nth n = none at terminated_at_n
induction n with n IH generalizing s
case nat.zero { simp only [convergents'_aux, terminated_at_n, seq.head] }
simp only [convergents'_aux, terminated_at_n, seq.head]
case nat.succ { cases s_head_eq : s.head with gp_head, case option.none { simp only [convergents'_aux, s_head_eq] }, case option.some { have : s.tail.terminated_at n, by simp only [seq.terminated_at, s.nth_tail, terminated_at_n], simp only [convergents'_aux, s_head_eq, (IH this)] } }
cases s_head_eq : s.head with gp_head
simp only [convergents'_aux, s_head_eq]
case option.none { simp only [convergents'_aux, s_head_eq] }
case option.some { have : s.tail.terminated_at n, by simp only [seq.terminated_at, s.nth_tail, terminated_at_n], simp only [convergents'_aux, s_head_eq, (IH this)] }
have : s.tail.terminated_at n
simp only [seq.terminated_at, s.nth_tail, terminated_at_n]
simp only [seq.terminated_at, s.nth_tail, terminated_at_n]
simp only [convergents'_aux, s_head_eq, (IH this)]
intros
split
intros h x hx
{ intros h x hx, apply eq_zero_of_zero_dvd, rw ‚Üê h, apply gcd_dvd hx }
apply eq_zero_of_zero_dvd
rw ‚Üê h
apply gcd_dvd hx
apply s.induction_on
{ apply s.induction_on, { simp }, intros a s sgcd h, simp [h a (mem_cons_self a s), sgcd (Œª x hx, h x (mem_cons_of_mem hx))] }
{ simp }
simp
intros a s sgcd h
simp [h a (mem_cons_self a s), sgcd (Œª x hx, h x (mem_cons_of_mem hx))]
intros
rw [mul_inv_rev, mul_comm]
intros
split
split; { rintro rfl, simpa using h }
{ rintro rfl, simpa using h }
rintro rfl
{ rintro rfl, simpa using h }
simpa using h
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
rcases h with ‚ü®y, rfl‚ü©; exact (units.map f y).is_unit
rcases h with ‚ü®y, rfl‚ü©
exact (units.map f y).is_unit
intros
rw [nat.mul_comm, pow_mul]
intros
induction n with n ih
rw pow_zero at H
{ rw pow_zero at H, rw [‚Üê mul_one x, H, mul_zero] }
rw [‚Üê mul_one x, H, mul_zero]
rw pow_succ at H
{ rw pow_succ at H, exact or.cases_on (mul_eq_zero.1 H) id ih }
exact or.cases_on (mul_eq_zero.1 H) id ih
intros
rw [inv_eq_iff, inv_zero, eq_comm]
intros
rw [div_mul_eq_mul_div, mul_comm, mul_div_right_comm]
intros
rw eq_bot_iff
refine image_subobject_le _ 0 _
rw [C.d_to_eq_zero h, zero_comp]
intros
rw [indicator_diff' h, sub_eq_add_neg]
intros
simp [add_right_iterate]
intros
{ ext, refl, }
ext
refl
intros
erw [lie_equiv.trans_apply, lie_equiv.of_eq_apply, skew_adjoint_matrices_lie_subalgebra_equiv_apply]
intros
intros m h
rw [lie_ideal_oper_eq_span, mem_lie_span] at h
rw [lie_ideal_oper_eq_span, mem_lie_span]
intros N hN
apply h
rintros m' ‚ü®‚ü®x, hx‚ü©, ‚ü®n, hn‚ü©, hm‚ü©
rw ‚Üê hm
apply hN
use [‚ü®x, h‚ÇÅ hx‚ü©, ‚ü®n, h‚ÇÇ hn‚ü©]
refl
intros
rw [derived_series_of_ideal_succ, derived_series_of_ideal_zero, lie_submodule.lie_abelian_iff_lie_self_eq_bot]
intros
split
{ rintros ‚ü®N, rfl‚ü©, exact N.lie_mem, }
rintros ‚ü®N, rfl‚ü©
exact N.lie_mem
intros h
{ intros h, use { lie_mem := h, ..p }, exact lie_submodule.coe_to_submodule_mk p _, }
use { lie_mem := h, ..p }
exact lie_submodule.coe_to_submodule_mk p _
intros
rw [‚Üêneg_neg c, neg_smul, neg_neg_iff_pos]
exact smul_pos_iff_of_pos (neg_pos_of_neg hc)
intros
rw [inv_eq_one_div, mul_comm, ‚Üê div_eq_mul_one_div]
exact div_le_iff' h
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_lt_mul_of_pos_right h (one_div_pos.2 hc)
intros
simpa only [‚Üê h, eq_comm, eq_neg_iff_eq_neg] using abs_choice a
intros
{ rw [‚Üê mul_lt_mul_iff_left a], simp }
rw [‚Üê mul_lt_mul_iff_left a]
simp
intros
rw [inv_mul_lt_iff_lt_mul, mul_comm]
intros
simp only [div_eq_mul_inv, max_mul_mul_left, max_inv_inv']
intros
cases le_total n m with h h; simp [h, mul_comm]
{ cases le_total n m with h h; simp [h, mul_comm] }
cases le_total n m with h h
simp [h, mul_comm]
simp [h, mul_comm]
intros
rw [‚Üê neg_pos, neg_mul_eq_mul_neg, mul_pos_iff, neg_pos, neg_lt_zero]
intros
simp only [pos_iff_ne_zero, ne.def, mul_eq_zero, not_or_distrib]
intros
have : 0 < a * ‚Öüa
simp only [mul_inv_of_self, zero_lt_one]
simp only [mul_inv_of_self, zero_lt_one]
exact ‚ü®Œª h, (pos_of_mul_pos_right this h).le, Œª h, (pos_of_mul_pos_left this h).le‚ü©
intros
rw [‚Üê sub_nonneg, ‚Üê mul_sub]
exact decidable.ordered_ring.mul_nonneg h‚ÇÇ (sub_nonneg.2 h‚ÇÅ)
intros
simpa only [nsmul_eq_mul] using h.nsmul n
intros
simp * at *
intros
{ rw [‚Üê inv_subset_inv, set.inv_inv] }
rw [‚Üê inv_subset_inv, set.inv_inv]
intros
intros x y h
convert congr_arg ((‚Ä¢) g‚Åª¬π) h using 1
convert congr_arg ((‚Ä¢) g‚Åª¬π) h using 1; simp [‚Üêsmul_assoc]
simp [‚Üêsmul_assoc]
simp [‚Üêsmul_assoc]
intros
have : c = -(x * x - b * x) := (neg_eq_of_add_eq_zero h).symm
have : c = x * (b - x)
subst this
subst this
subst this; simp [mul_sub, mul_comm]
subst this; simp [mul_sub, mul_comm]
simp [mul_sub, mul_comm]
simp [mul_sub, mul_comm]
refine ‚ü®b - x, _, by simp, by rw this‚ü©
rw [this, sub_add, ‚Üê sub_mul, sub_self]
intros
{ dsimp [mk_alg_hom], rintro ‚ü®‚ü®a‚ü©‚ü©, use a, refl, }
dsimp [mk_alg_hom]
rintro ‚ü®‚ü®a‚ü©‚ü©
use a
refl
intros
simp only [@eq_comm _ U·∂ú]; refl
simp only [@eq_comm _ U·∂ú]
refl
intros
cases n; dsimp
cases n
dsimp
simp only [subobject.factor_thru_arrow_assoc]
{ simp only [subobject.factor_thru_arrow_assoc], slice_lhs 2 3 { erw ‚ÜêX.Œ¥_comp_Œ¥ (fin.zero_le 0), }, rw ‚Üêfactor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin 2) (by simp)), slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }, simp, }
slice_lhs 2 3 { erw ‚ÜêX.Œ¥_comp_Œ¥ (fin.zero_le 0), }
rw ‚Üêfactor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin 2) (by simp))
slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }
simp
dsimp
{ simp [factor_thru_right], slice_lhs 2 3 { erw ‚ÜêX.Œ¥_comp_Œ¥ (fin.zero_le 0), }, rw ‚Üêfactor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin (n+3)) (by simp)), slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }, simp, }
simp [factor_thru_right]
slice_lhs 2 3 { erw ‚ÜêX.Œ¥_comp_Œ¥ (fin.zero_le 0), }
rw ‚Üêfactor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin (n+3)) (by simp))
slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }
simp
intros
dsimp [Œ¥]
{ dsimp [Œ¥], simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_Œ¥_self] }
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_Œ¥_self]
intros
induction j with j IHj
{ show sum (take ((b.blocks.take i).sum) a.blocks) = sum (take i (map sum (split_wrt_composition a.blocks b))), induction i with i IH, { refl }, { have A : i < b.length := nat.lt_of_succ_lt hi, have B : i < list.length (map list.sum (split_wrt_composition a.blocks b)), by simp [A], have C : 0 < blocks_fun b ‚ü®i, A‚ü© := composition.blocks_pos' _ _ _, rw [sum_take_succ _ _ B, ‚Üê IH A C], have : take (sum (take i b.blocks)) a.blocks = take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks), { rw [take_take, min_eq_left], apply monotone_sum_take _ (nat.le_succ _) }, rw [this, nth_le_map', nth_le_split_wrt_composition, ‚Üê take_append_drop (sum (take i b.blocks)) ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append], congr, rw [take_append_drop] } }
show sum (take ((b.blocks.take i).sum) a.blocks) = sum (take i (map sum (split_wrt_composition a.blocks b)))
induction i with i IH
{ refl }
refl
{ have A : i < b.length := nat.lt_of_succ_lt hi, have B : i < list.length (map list.sum (split_wrt_composition a.blocks b)), by simp [A], have C : 0 < blocks_fun b ‚ü®i, A‚ü© := composition.blocks_pos' _ _ _, rw [sum_take_succ _ _ B, ‚Üê IH A C], have : take (sum (take i b.blocks)) a.blocks = take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks), { rw [take_take, min_eq_left], apply monotone_sum_take _ (nat.le_succ _) }, rw [this, nth_le_map', nth_le_split_wrt_composition, ‚Üê take_append_drop (sum (take i b.blocks)) ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append], congr, rw [take_append_drop] }
have A : i < b.length := nat.lt_of_succ_lt hi
have B : i < list.length (map list.sum (split_wrt_composition a.blocks b))
simp [A]
simp [A]
have C : 0 < blocks_fun b ‚ü®i, A‚ü© := composition.blocks_pos' _ _ _
rw [sum_take_succ _ _ B, ‚Üê IH A C]
have : take (sum (take i b.blocks)) a.blocks = take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks)
rw [take_take, min_eq_left]
{ rw [take_take, min_eq_left], apply monotone_sum_take _ (nat.le_succ _) }
apply monotone_sum_take _ (nat.le_succ _)
rw [this, nth_le_map', nth_le_split_wrt_composition, ‚Üê take_append_drop (sum (take i b.blocks)) ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append]
congr
rw [take_append_drop]
have A : j < blocks_fun b ‚ü®i, hi‚ü© := lt_trans (lt_add_one j) hj
{ have A : j < blocks_fun b ‚ü®i, hi‚ü© := lt_trans (lt_add_one j) hj, have B : j < length (sigma_composition_aux a b ‚ü®i, (length_gather a b).symm ‚ñ∏ hi‚ü©), by { convert A, rw [‚Üê length_sigma_composition_aux], refl }, have C : size_up_to b i + j < size_up_to b (i + 1), { simp only [size_up_to_succ b hi, add_lt_add_iff_left], exact A }, have D : size_up_to b i + j < length a := lt_of_lt_of_le C (b.size_up_to_le _), have : size_up_to b i + nat.succ j = (size_up_to b i + j).succ := rfl, rw [this, size_up_to_succ _ D, IHj A, size_up_to_succ _ B], simp only [sigma_composition_aux, add_assoc, add_left_inj, fin.coe_mk], rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take _ _ C] }
have B : j < length (sigma_composition_aux a b ‚ü®i, (length_gather a b).symm ‚ñ∏ hi‚ü©)
convert A
convert A
{ convert A, rw [‚Üê length_sigma_composition_aux], refl }
{ convert A, rw [‚Üê length_sigma_composition_aux], refl }
rw [‚Üê length_sigma_composition_aux]
rw [‚Üê length_sigma_composition_aux]
refl
refl
have C : size_up_to b i + j < size_up_to b (i + 1)
simp only [size_up_to_succ b hi, add_lt_add_iff_left]
{ simp only [size_up_to_succ b hi, add_lt_add_iff_left], exact A }
exact A
have D : size_up_to b i + j < length a := lt_of_lt_of_le C (b.size_up_to_le _)
have : size_up_to b i + nat.succ j = (size_up_to b i + j).succ := rfl
rw [this, size_up_to_succ _ D, IHj A, size_up_to_succ _ B]
simp only [sigma_composition_aux, add_assoc, add_left_inj, fin.coe_mk]
rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take _ _ C]
intros
refine ‚ü®by rintro rfl; exact ‚ü®rfl, rfl‚ü©, _‚ü©
rcases i with ‚ü®a, b‚ü©
rcases j with ‚ü®a', b'‚ü©
rintros ‚ü®h, h'‚ü©
have H : a = a'
ext1
ext1
{ ext1, exact h }
{ ext1, exact h }
exact h
exact h
induction H
congr
ext1
exact h'
intros
unfold is_o
{ unfold is_o, exact forall_congr (Œª _, (forall_congr (Œª _, is_O_with_neg_right))) }
exact forall_congr (Œª _, (forall_congr (Œª _, is_O_with_neg_right)))
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hc.mul_const d
intros
convert (polynomial.C (1 : ùïú) * (polynomial.X)^n).has_strict_deriv_at x
{ simp }
simp
{ rw [polynomial.derivative_C_mul_X_pow], simp }
rw [polynomial.derivative_C_mul_X_pow]
simp
intros
simp only [deriv_within, fderiv_within_const_add hxs]
intros
simpa only [sub_eq_add_neg] using hf.add_const (-c)
intros
refine ‚ü®Œª H, _, Œª H, iso.differentiable.differentiable_at.comp_differentiable_within_at x H‚ü©
have : differentiable_within_at ùïú (iso.symm ‚àò (iso ‚àò f)) s x := iso.symm.differentiable.differentiable_at.comp_differentiable_within_at x H
rwa [‚Üê function.comp.assoc iso.symm iso f, iso.symm_comp_self] at this
intros
{ ext, rw h.unique h.differentiable_at.has_fderiv_at }
ext
rw h.unique h.differentiable_at.has_fderiv_at
intros
apply eq_implicit_function_of_complemented
intros
ext x
rw [‚Üê iterated_deriv_within_univ, ‚Üê iterated_deriv_within_univ, ‚Üê deriv_within_univ]
exact iterated_deriv_within_succ unique_diff_within_at_univ
intros
simpa only [add_sub_cancel'] using mem_pos_tangent_cone_at_of_segment_subset h
intros
obtain ‚ü®Œµ, Œµ0, hŒµ‚ü© : ‚àÉ Œµ > 0, ball x Œµ ‚à© s ‚äÜ {y | has_fderiv_within_at f (f' y) s y ‚àß ‚à•f' y‚à•‚Çä < K}
from mem_nhds_within_iff.1 (hder.and $ hcont.nnnorm.eventually (gt_mem_nhds hK))
rw inter_comm at hŒµ
refine ‚ü®s ‚à© ball x Œµ, inter_mem_nhds_within _ (ball_mem_nhds _ Œµ0), _‚ü©
exact (hs.inter (convex_ball _ _)).lipschitz_on_with_of_nnnorm_has_fderiv_within_le (Œª y hy, (hŒµ hy).1.mono (inter_subset_left _ _)) (Œª y hy, (hŒµ hy).2.le)
intros
rcases euclidean.exists_pos_lt_subset_ball hR hs hsR with ‚ü®r, hr, hsr‚ü©
exact ‚ü®‚ü®‚ü®r, R, hr.1, hr.2‚ü©‚ü©, rfl, hsr‚ü©
intros
simpa [continuous_within_at_univ] using h.continuous_within_at
intros
induction n using with_top.nat_induction with n IH Itop
intros m hm
{ intros m hm, refine ‚ü®{y : R | is_unit y}, _, _‚ü©, { simp [nhds_within_univ], exact x.nhds }, { use (ftaylor_series_within ùïú inverse univ), rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff], split, { rintros _ ‚ü®x', rfl‚ü©, exact (inverse_continuous_at x').continuous_within_at }, { simp [ftaylor_series_within] } } }
refine ‚ü®{y : R | is_unit y}, _, _‚ü©
simp [nhds_within_univ]
{ simp [nhds_within_univ], exact x.nhds }
exact x.nhds
use (ftaylor_series_within ùïú inverse univ)
{ use (ftaylor_series_within ùïú inverse univ), rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff], split, { rintros _ ‚ü®x', rfl‚ü©, exact (inverse_continuous_at x').continuous_within_at }, { simp [ftaylor_series_within] } }
rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff]
split
rintros _ ‚ü®x', rfl‚ü©
{ rintros _ ‚ü®x', rfl‚ü©, exact (inverse_continuous_at x').continuous_within_at }
exact (inverse_continuous_at x').continuous_within_at
{ simp [ftaylor_series_within] }
simp [ftaylor_series_within]
apply times_cont_diff_at_succ_iff_has_fderiv_at.mpr
{ apply times_cont_diff_at_succ_iff_has_fderiv_at.mpr, refine ‚ü®Œª (x : R), - lmul_left_right ùïú R (inverse x) (inverse x), _, _‚ü©, { refine ‚ü®{y : R | is_unit y}, x.nhds, _‚ü©, rintros _ ‚ü®y, rfl‚ü©, rw [inverse_unit], exact has_fderiv_at_ring_inverse y }, { convert (lmul_left_right_is_bounded_bilinear ùïú R).times_cont_diff.neg.comp_times_cont_diff_at (x : R) (IH.prod IH) } }
refine ‚ü®Œª (x : R), - lmul_left_right ùïú R (inverse x) (inverse x), _, _‚ü©
refine ‚ü®{y : R | is_unit y}, x.nhds, _‚ü©
{ refine ‚ü®{y : R | is_unit y}, x.nhds, _‚ü©, rintros _ ‚ü®y, rfl‚ü©, rw [inverse_unit], exact has_fderiv_at_ring_inverse y }
rintros _ ‚ü®y, rfl‚ü©
rw [inverse_unit]
exact has_fderiv_at_ring_inverse y
convert (lmul_left_right_is_bounded_bilinear ùïú R).times_cont_diff.neg.comp_times_cont_diff_at (x : R) (IH.prod IH)
{ convert (lmul_left_right_is_bounded_bilinear ùïú R).times_cont_diff.neg.comp_times_cont_diff_at (x : R) (IH.prod IH) }
{ exact times_cont_diff_at_top.mpr Itop }
exact times_cont_diff_at_top.mpr Itop
intros
{ ext m, rw iterated_fderiv_within_succ_apply_right hs hx, refl }
ext m
rw iterated_fderiv_within_succ_apply_right hs hx
refl
intros
rintro x y hx hy a b ha hb hab
rw mem_Union at ‚ä¢ hx hy
obtain ‚ü®i, hx‚ü© := hx
obtain ‚ü®j, hy‚ü© := hy
obtain ‚ü®k, hik, hjk‚ü© := hdir i j
exact ‚ü®k, hc (hik hx) (hjk hy) ha hb hab‚ü©
intros
refine ‚ü®Œª hc i s h, _, Œª h s i hi, _‚ü©
rw hc.mem_convex_hull_iff at h
{ rw hc.mem_convex_hull_iff at h, exact h.2 (set.mem_singleton _) }
exact h.2 (set.mem_singleton _)
by_contra H
{ by_contra H, refine h i s _, rw set.diff_singleton_eq_self H, exact hi }
refine h i s _
rw set.diff_singleton_eq_self H
exact hi
intros
rcases convex_hull_exists_dist_ge hx y with ‚ü®x', hx', Hx'‚ü©
rcases convex_hull_exists_dist_ge hy x' with ‚ü®y', hy', Hy'‚ü©
use [x', hx', y', hy']
exact le_trans Hx' (dist_comm y x' ‚ñ∏ dist_comm y' x' ‚ñ∏ Hy')
intros
rw [‚Üêinner_conj_sym, inner_neg_left]; simp only [ring_hom.map_neg, inner_conj_sym]
rw [‚Üêinner_conj_sym, inner_neg_left]
simp only [ring_hom.map_neg, inner_conj_sym]
intros
rw [‚Üêinner_conj_sym, abs_conj]
intros
ext
intros
exact_mod_cast real.geom_mean_le_arith_mean_weighted _ _ _ (Œª i _, (w i).coe_nonneg) (by assumption_mod_cast) (Œª i _, (z i).coe_nonneg)
intros
let g : Y ‚ü∂ Z := explicit_cokernel_œÄ f ‚â´ e‚ÇÇ
have w : f ‚â´ g = 0
simp
simp
have : e‚ÇÇ = explicit_cokernel_desc w
{ apply explicit_cokernel_desc_unique, refl }
apply explicit_cokernel_desc_unique
refl
rw this
apply explicit_cokernel_desc_unique
exact h
intros
{ ext, refl }
ext
refl
intros
simpa [sub_eq_add_neg] using add hf (neg hg)
intros
rw inclusion_in_double_dual_norm_eq
{ rw inclusion_in_double_dual_norm_eq, exact continuous_linear_map.norm_id_le }
exact continuous_linear_map.norm_id_le
intros
simp [exp_series]
intros
obtain (rfl|rfl) := int.units_eq_one_or e
obtain (rfl|rfl) := int.units_eq_one_or e; simp only [units.coe_neg_one, units.coe_one, nnnorm_neg, nnnorm_one]
simp only [units.coe_neg_one, units.coe_one, nnnorm_neg, nnnorm_one]
simp only [units.coe_neg_one, units.coe_one, nnnorm_neg, nnnorm_one]
intros
refine (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _
rw linear_isometry_equiv.symm_apply_apply
intros
dunfold mk_continuous_linear
exact linear_map.mk_continuous_norm_le _ (le_max_right _ _) _
intros
{ ext, refl }
ext
refl
intros
apply cInf_le
use 0
rintros _ ‚ü®n, h, rfl‚ü©
{ rintros _ ‚ü®n, h, rfl‚ü©, apply norm_nonneg }
apply norm_nonneg
apply set.mem_image_of_mem
{ apply set.mem_image_of_mem, rw set.mem_set_of_eq }
rw set.mem_set_of_eq
intros
simpa only using hf.map œÜ.to_linear_map.to_add_monoid_hom œÜ.continuous
intros
simpa only [arg_eq_pi_iff.2 ‚ü®hre, him‚ü©] using (continuous_within_at_arg_of_re_neg_of_im_zero hre him).tendsto
intros
simp [log_re]
intros
refine ‚ü®Œª h, _, Œª h, ‚ü®abs (P.coeff 0), eventually_map.mpr (eventually_of_forall (forall_imp (Œª _, le_of_eq) (Œª x, congr_arg abs $ trans (congr_arg (eval x) (eq_C_of_degree_le_zero h)) (eval_C))))‚ü©‚ü©
contrapose! h
exact not_is_bounded_under_of_tendsto_at_top (abs_tendsto_at_top P (nat.with_bot.one_le_iff_zero_lt.2 h))
intros
simpa only [mul_zero, add_zero, mul_one] using (has_strict_deriv_at_id x).cpow (has_strict_deriv_at_const x c) h
intros
simpa using rpow_add_nat hx y 1
intros
simp [cpow_def]; split_ifs; simp [*, exp_add, mul_add] at *
simp [cpow_def]; split_ifs
simp [cpow_def]
split_ifs
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
intros
induction n with d hd
simp only [U_zero, nat.cast_zero, eval_one, mul_one, zero_add, one_mul]
{ simp only [U_zero, nat.cast_zero, eval_one, mul_one, zero_add, one_mul] }
rw U_eq_X_mul_U_add_T
{ rw U_eq_X_mul_U_add_T, simp only [eval_add, eval_mul, eval_X, T_complex_cos, add_mul, mul_assoc, hd, one_mul], conv_rhs { rw [sin_add, mul_comm] }, push_cast, simp only [add_mul, one_mul] }
simp only [eval_add, eval_mul, eval_X, T_complex_cos, add_mul, mul_assoc, hd, one_mul]
conv_rhs { rw [sin_add, mul_comm] }
push_cast
simp only [add_mul, one_mul]
intros
simp [le_antisymm_iff]
intros
simpa only [pow_zero, mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0
intros
apply epi_of_zero_cokernel _ (cokernel f)
simp_rw ‚Üêh
exact is_colimit.of_iso_colimit (colimit.is_colimit (parallel_pair f 0)) (iso_of_œÄ _)
intros
tfae_have : 3 ‚Üí 2
rw exact_iff
{ rw exact_iff, rintro ‚ü®-, h‚ü©, exact zero_of_epi_comp _ h }
rintro ‚ü®-, h‚ü©
exact zero_of_epi_comp _ h
tfae_have : 1 ‚Üí 3
rw exact_iff
{ rw exact_iff, introI, exact ‚ü®by simp, by simp [cokernel.œÄ_of_epi]‚ü© }
introI
exact ‚ü®by simp, by simp [cokernel.œÄ_of_epi]‚ü©
tfae_have : 2 ‚Üí 1
{ exact epi_of_cokernel_œÄ_eq_zero _ }
exact epi_of_cokernel_œÄ_eq_zero _
tfae_finish
intros
rw [neg_def, neg_def]
conv_lhs { rw ‚Üêsub_self (0 : X ‚ü∂ Y) }
rw [sub_sub_sub, add_def, neg_def]
intros
rw [transfer_nat_trans_self_comp, gf, transfer_nat_trans_self_id]
intros
apply faithful.map_injective (forget C)
ext
exact w x
intros
erw [‚Üêiso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp]
{ erw [‚Üêiso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp], refl }
refl
intros
fsplit
rintro ‚ü®L‚ü©
{ rintro ‚ü®L‚ü©, fsplit, intros X Y, specialize L (e.inverse.obj X) (e.inverse.obj Y), refine (small_congr _).mpr L, exact equiv_of_fully_faithful e.inverse, }
fsplit
intros X Y
specialize L (e.inverse.obj X) (e.inverse.obj Y)
refine (small_congr _).mpr L
exact equiv_of_fully_faithful e.inverse
rintro ‚ü®L‚ü©
{ rintro ‚ü®L‚ü©, fsplit, intros X Y, specialize L (e.functor.obj X) (e.functor.obj Y), refine (small_congr _).mpr L, exact equiv_of_fully_faithful e.functor, }
fsplit
intros X Y
specialize L (e.functor.obj X) (e.functor.obj Y)
refine (small_congr _).mpr L
exact equiv_of_fully_faithful e.functor
intros
split_ifs; refl
{ split_ifs; refl, }
split_ifs
refl
refl
intros
ext
ext; apply category.id_comp
apply category.id_comp
intros
{ ext, simp [‚ÜêF.map_comp], }
ext
simp [‚ÜêF.map_comp]
intros
dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]
{ dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso], tidy, }
tidy
intros
ext
rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêG.map_comp, colimit.Œπ_pre, ‚Üêassoc]
letI : has_colimit (E ‚ãô F ‚ãô G) := show has_colimit ((E ‚ãô F) ‚ãô G), by apply_instance
erw [colimit.Œπ_pre (F ‚ãô G) E j, colimit.Œπ_post]
intros
simp
intros
simp [biproduct.Œπ_œÄ]
intros
{ ext, simp, }
ext
simp
intros
{ ext, simp [coequalizer.iso_target_of_self], }
ext
simp [coequalizer.iso_target_of_self]
intros
{ rw [‚Üêleft_unitor_tensor_inv'], simp }
rw [‚Üêleft_unitor_tensor_inv']
simp
intros
simp
intros
tidy
intros
simpa using quot.sound (comp_closure.intro (ùüô a) f‚ÇÅ f‚ÇÇ (ùüô b) h)
intros
ext Y f
split
rintro ‚ü®_, _, _, ‚ü®i‚ü©, ‚ü®i'‚ü©, rfl‚ü©
{ rintro ‚ü®_, _, _, ‚ü®i‚ü©, ‚ü®i'‚ü©, rfl‚ü©, exact of_arrows.mk (sigma.mk _ _) }
exact of_arrows.mk (sigma.mk _ _)
rintro ‚ü®i‚ü©
{ rintro ‚ü®i‚ü©, exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _) }
exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _)
intros
convert mk_le_mk_of_comm _ w; simp
convert mk_le_mk_of_comm _ w
simp
simp
intros
{ ext, simp, }
ext
simp
intros
revert f‚ÇÅ
apply quotient.ind'
intro f‚ÇÅ
erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ‚Üê map_comp]
dsimp
rw [pullback_comp, pullback_map_self]
intros
{ ext, simp, }
ext
simp
intros
simp [size_up_to, ones_blocks, take_repeat]
intros
ext j
simp [c.mem_boundaries_iff_exists_blocks_sum_take_eq, c.card_boundaries_eq_succ_length, composition.boundary, fin.ext_iff, composition.size_up_to, exists_prop, finset.mem_univ, take, exists_prop_of_true, finset.mem_image, composition_as_set.to_composition_blocks, composition.boundaries]
split
rintros ‚ü®i, hi‚ü©
{ rintros ‚ü®i, hi‚ü©, refine ‚ü®i.1, _, hi‚ü©, convert i.2, simp }
refine ‚ü®i.1, _, hi‚ü©
convert i.2
simp
rintros ‚ü®i, i_lt, hi‚ü©
{ rintros ‚ü®i, i_lt, hi‚ü©, have : i < c.to_composition.length + 1, by simpa using i_lt, exact ‚ü®‚ü®i, this‚ü©, hi‚ü© }
have : i < c.to_composition.length + 1
simpa using i_lt
simpa using i_lt
exact ‚ü®‚ü®i, this‚ü©, hi‚ü©
intros
let r' := Œª a, (rel.image r {a}).to_finset
have h : ‚àÄ (A : finset Œ±), fintype.card (rel.image r A) = (A.bUnion r').card
intro A
{ intro A, rw ‚Üêset.to_finset_card, apply congr_arg, ext b, simp [rel.image], }
rw ‚Üêset.to_finset_card
apply congr_arg
ext b
simp [rel.image]
have h' : ‚àÄ (f : Œ± ‚Üí Œ≤) x, r x (f x) ‚Üî f x ‚àà r' x
{ simp [rel.image], }
simp [rel.image]
simp only [h, h']
apply finset.all_card_le_bUnion_card_iff_exists_injective
intros
simp
intros
simp [(part.bind_some_eq_map _ _).symm]; exact hf.bind hg
simp [(part.bind_some_eq_map _ _).symm]
exact hf.bind hg
intros
simp [many_one_equiv]
intros
let o : option Œì' := list.cases_on L none (Œª _ _, some Œì'.cons)
refine (move_ok dec_trivial (split_at_pred_eq _ _ (tr_nat L.head) o (tr_list L.tail) (tr_nat_nat_end _) _)).trans (trans_gen.head rfl (trans_gen.head rfl _))
cases L; exact ‚ü®rfl, rfl‚ü©
{ cases L; exact ‚ü®rfl, rfl‚ü© }
cases L
exact ‚ü®rfl, rfl‚ü©
exact ‚ü®rfl, rfl‚ü©
simp [show o ‚â† some Œì'.Cons, by cases L; rintro ‚ü®‚ü©]
refine (clear_ok (split_at_pred_eq _ _ _ none [] _ ‚ü®rfl, rfl‚ü©)).trans _
{ exact Œª x h, (to_bool_ff (tr_list_ne_Cons _ _ h)) }
exact Œª x h, (to_bool_ff (tr_list_ne_Cons _ _ h))
convert unrev_ok
simp [list.reverse_core_eq]
intros
rw [add_bottom, list_blank.head_cons]; refl
rw [add_bottom, list_blank.head_cons]
intros
simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail, and_self, list_blank.tail_cons]
intros
simp [fst,bimap_bimap]
intros
ext
ext; simp only [(‚àò), mfoldl.of_free_monoid, mfoldl.mk, flip, fold_mfoldl_cons]; refl
ext; simp only [(‚àò), mfoldl.of_free_monoid, mfoldl.mk, flip, fold_mfoldl_cons]
simp only [(‚àò), mfoldl.of_free_monoid, mfoldl.mk, flip, fold_mfoldl_cons]
refl
intros
simp [equiv.map]; apply comp_map
simp [equiv.map]
apply comp_map
intros
have := mem_nhds_to_topsp F.F; rwa F.eq at this
have := mem_nhds_to_topsp F.F
rwa F.eq at this
intros
rw size_eq_zero_iff
intros
simp [seq_left_eq, seq_eq_fail]
intros
simp [remaining]
intros
simp [digit, sat_eq_fail]
intros
simp
intros
rw [‚Üê of_real_rat_cast, of_real_re]
intros
rw [‚Üêsin_sq_add_cos_sq x, add_sub_cancel]
intros
rw add_submonoid.mem_supr_iff_exists_dfinsupp
simp_rw sum_add_hom_apply
congr'
intros
simp only [single_apply, dif_neg h]
intros
refine quotient.induction_on f (Œª x, _)
dsimp only [support, quotient.lift_on_mk]
rw [finset.mem_filter, multiset.mem_to_finset]
exact and_iff_right_of_imp (x.3 i).resolve_right
intros
rw [prod_extend_right, coe_fn_mk]
split_ifs with h
{ rw h }
rw h
{ refl }
refl
intros
rw [‚Üê h.image_eq, ‚Üê h'.image_eq, ‚Üê hs, Heq.image_eq]
intros
haveI := e.symm.to_equiv.nontrivial
refine @local_of_surjective A B _ _ _ _ e e.to_equiv.surjective
intros
dsimp [pred_above]
rw dif_pos
exact (pos_iff_ne_zero _).mpr hi
intros
{ induction h, simp [ext_iff] }
induction h
simp [ext_iff]
intros
simp [lt_iff_coe_lt_coe]
intros
simpa [lt_iff_coe_lt_coe] using h
intros
ext x
{ ext x, simp, split_ifs with h; by_cases h' : x = a; simp [h, h'] }
simp
split_ifs with h
split_ifs with h; by_cases h' : x = a; simp [h, h']
split_ifs with h; by_cases h' : x = a
by_cases h' : x = a
simp [h, h']
simp [h, h']
by_cases h' : x = a
simp [h, h']
simp [h, h']
intros
rcases s with ‚ü®‚ü®s‚ü©‚ü©; rcases t with ‚ü®‚ü®t‚ü©‚ü©; apply list.mem_append
rcases s with ‚ü®‚ü®s‚ü©‚ü©; rcases t with ‚ü®‚ü®t‚ü©‚ü©
rcases s with ‚ü®‚ü®s‚ü©‚ü©
rcases t with ‚ü®‚ü®t‚ü©‚ü©
apply list.mem_append
intros
subst hs; exact finset.fold_congr hfg
subst hs
exact finset.fold_congr hfg
intros
rw ‚Üêlist.erase_dup_eq_self at hl
simp [noncomm_prod, hl]
intros
conv_lhs { rw ‚Üêf.apply_symm_apply a }
exact map_domain_apply f.injective _ _
intros
{ classical, exact (trunc_of_card_le h).nonempty }
classical
exact (trunc_of_card_le h).nonempty
intros
classical
haveI : nonempty Œ±
rcases h ‚àÖ (by simp) with ‚ü®y, hy‚ü©
{ rcases h ‚àÖ (by simp) with ‚ü®y, hy‚ü©, exact ‚ü®y‚ü© }
exact ‚ü®y‚ü©
choose! F hF using h
have h' : ‚àÄ (s : finset Œ±), ‚àÉ y, (‚àÄ x ‚àà s, P x) ‚Üí (P y ‚àß (‚àÄ x ‚àà s, r x y)) := Œª s, ‚ü®F s, hF s‚ü©
set f := seq_of_forall_finset_exists_aux P r h' with hf
have A : ‚àÄ (n : ‚Ñï), P (f n)
assume n
{ assume n, induction n using nat.strong_induction_on with n IH, have IH' : ‚àÄ (x : fin n), P (f x) := Œª n, IH n.1 n.2, rw [hf, seq_of_forall_finset_exists_aux], exact (classical.some_spec (h' (finset.image (Œª (i : fin n), f i) (finset.univ : finset (fin n)))) (by simp [IH'])).1 }
induction n using nat.strong_induction_on with n IH
have IH' : ‚àÄ (x : fin n), P (f x) := Œª n, IH n.1 n.2
rw [hf, seq_of_forall_finset_exists_aux]
exact (classical.some_spec (h' (finset.image (Œª (i : fin n), f i) (finset.univ : finset (fin n)))) (by simp [IH'])).1
refine ‚ü®f, A, Œª m n hmn, _‚ü©
nth_rewrite 1 hf
rw seq_of_forall_finset_exists_aux
apply (classical.some_spec (h' (finset.image (Œª (i : fin n), f i) (finset.univ : finset (fin n)))) (by simp [A])).2
exact finset.mem_image.2 ‚ü®‚ü®m, hmn‚ü©, finset.mem_univ _, rfl‚ü©
intros
ext
ext; simp
simp
intros
rw [‚Üê prod_filter, filter_mem_eq_inter, univ_inter]
intros
simp only [not_lt, iff_false]
intros
{ rw [sq, sq], exact nat_abs_lt_iff_mul_self_lt }
rw [sq, sq]
exact nat_abs_lt_iff_mul_self_lt
intros
rw [mul_comm, int.div_mul_cancel H]
intros
rw [xgcd, ‚Üê xgcd_aux_fst x y 1 0 0 1]; cases xgcd_aux x 1 0 y 0 1; refl
rw [xgcd, ‚Üê xgcd_aux_fst x y 1 0 0 1]; cases xgcd_aux x 1 0 y 0 1
rw [xgcd, ‚Üê xgcd_aux_fst x y 1 0 0 1]
cases xgcd_aux x 1 0 y 0 1
refl
intros
induction n with n IH
have : insert_nth 0 x = cons x := funext (Œª _, rfl)
{ have : insert_nth 0 x = cons x := funext (Œª _, rfl), simp [this] }
simp [this]
rintros (_|‚ü®a, as‚ü©) (_|‚ü®b, bs‚ü©) h; simpa [IH.eq_iff] using h <|> refl
rintros (_|‚ü®a, as‚ü©) (_|‚ü®b, bs‚ü©) h
{ rintros (_|‚ü®a, as‚ü©) (_|‚ü®b, bs‚ü©) h; simpa [IH.eq_iff] using h <|> refl }
refl
simpa [IH.eq_iff] using h
simpa [IH.eq_iff] using h
simpa [IH.eq_iff] using h
simpa [IH.eq_iff] using h
intros
simp [init_eq_take, min_eq_left_of_lt h, take_take, pred_le]
intros
rw ‚Üêfoldr_reverse; simp
rw ‚Üêfoldr_reverse
simp
intros
rw [list.bind, length_join, map_map]
intros
induction l; [refl, simp only [*, pmap, map]]; split; refl
induction l; [refl, simp only [*, pmap, map]]; split
induction l; [refl, simp only [*, pmap, map]]
induction l
refl
simp only [*, pmap, map]
split
refl
refl
intros
simp only [reduce_option, filter_map, id.def, eq_self_iff_true, and_self]
intros
rw [length_foldr_permutations_aux2, (_ : sum (map length L) = n * length L)]
induction L with l L ih
simp
{simp}
have sum_map : sum (map length L) = n * length L := ih (Œª l m, H l (mem_cons_of_mem _ m))
have length_l : length l = n := H _ (mem_cons_self _ _)
simp [sum_map, length_l, mul_add, add_comm]
intros
simp [erase_eq_erasep]; exact erasep_append_left (by refl) l‚ÇÇ h
simp [erase_eq_erasep]
exact erasep_append_left (by refl) l‚ÇÇ h
intros
induction l; intros
{induction l; intros, contradiction, reflexivity}
induction l
contradiction
reflexivity
intros
induction l with lh lt l_ih generalizing a
{ simp }
simp
simp [H _ _ _ _ (rel_of_chain_cons hl‚ÇÇ), l_ih _ _ (chain_of_chain_cons hl‚ÇÇ)]
{ simp [H _ _ _ _ (rel_of_chain_cons hl‚ÇÇ), l_ih _ _ (chain_of_chain_cons hl‚ÇÇ)] }
intros
obtain ‚ü®n, hn, rfl‚ü© := nth_le_of_mem hx
simp only [next_nth_le, prev_nth_le, h, nat.mod_add_mod]
cases l with hd tl
simp
have : n < 1 + tl.length := by simpa [add_comm] using hn
{ have : n < 1 + tl.length := by simpa [add_comm] using hn, simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this] }
simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this]
intros
apply eq_nil_iff_forall_not_mem.2
intro a
simp only [and_imp, not_and, not_lt, list.mem_inter, list.Ico.mem]
intros h‚ÇÅ h‚ÇÇ h‚ÇÉ
exfalso
exact not_lt_of_ge h‚ÇÉ h‚ÇÇ
intros
induction l with a l ihl
simp
{ simp }
obtain ‚ü®ha, hl‚ü© : p a ‚àß ‚àÄ b, b ‚àà l ‚Üí p b
simpa using h
simpa using h
simp only [ihl hl, pairwise_cons, bex_imp_distrib, pmap, and.congr_left_iff, mem_pmap]
refine Œª _, ‚ü®Œª H b hb hpa hpb, H _ _ hb rfl, _‚ü©
rintro H _ b hb rfl
exact H b hb _ _
intros
simp [rotate]
intros
induction l
refl
case list.nil { refl }
case list.cons : hd tl ih { cases hd with ah bh, by_cases h‚ÇÅ : a = ah; by_cases h‚ÇÇ : a' = ah, { substs h‚ÇÅ h‚ÇÇ, cases ne.irrefl h }, { subst h‚ÇÅ, simp [h‚ÇÇ] }, { subst h‚ÇÇ, simp [h] }, { simp [h‚ÇÅ, h‚ÇÇ, ih] } }
intros
suffices : ‚àÄ (L : list Œ±) h1, @@and.rec (Œª a a (_ : length l‚ÇÅ < length l + 1 + 1 ‚àß length l‚ÇÇ < length l + 1 + 1), L) h1 h1 = L
{ simp [merge_sort, h], apply this }
simp [merge_sort, h]
apply this
intros
cases h1
refl
intros
rw [sublists', map_sublists'_aux, ‚Üê sublists'_aux_append]
rw [sublists', map_sublists'_aux, ‚Üê sublists'_aux_append]; refl
refl
intros
rw [‚Üê unzip_right, unzip_revzip]
intros
{ ext, apply dot_product_neg }
ext
apply dot_product_neg
intros
ext
{ ext, refl }
refl
intros
simp only [one_apply, pi.single_apply, eq_comm]
simp only [one_apply, pi.single_apply, eq_comm]; congr
intros
ext i j; rw [‚Üê diagonal_one, mul_diagonal, mul_one]
ext i j
rw [‚Üê diagonal_one, mul_diagonal, mul_one]
intros
simp [mul_apply, hbj.symm]
intros
{ ext, simp [block_diagonal'_apply] }
ext
simp [block_diagonal'_apply]
intros
simp [vec_head, vec_alt1]
intros
rw [‚Üê to_matrix_trans, single_trans_single]
intros
rw [‚Üêmultiset.mem_coe, multiset.coe_to_list]
intros
rw mem_erase_iff_of_nodup h; simp
rw mem_erase_iff_of_nodup h
simp
intros
simp [powerset_aux']; refl
simp [powerset_aux']
refl
intros
have := coeff_monomial m (finsupp.single i k) (1:R)
rwa [@monomial_eq _ _ (1:R) (finsupp.single i k) _, C_1, one_mul, finsupp.prod_single_index] at this
exact pow_zero _
intros
apply mv_polynomial.induction_on p
{ intro r, rw [eval‚ÇÇ_C, map_C, map_C, eval‚ÇÇ_C] }
intro r
rw [eval‚ÇÇ_C, map_C, map_C, eval‚ÇÇ_C]
intros p q hp hq
{ intros p q hp hq, rw [eval‚ÇÇ_add, (map f).map_add, hp, hq, (map f).map_add, eval‚ÇÇ_add] }
rw [eval‚ÇÇ_add, (map f).map_add, hp, hq, (map f).map_add, eval‚ÇÇ_add]
intros p s hp
{ intros p s hp, rw [eval‚ÇÇ_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval‚ÇÇ_mul, eval‚ÇÇ_X, eval‚ÇÇ_X] }
rw [eval‚ÇÇ_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval‚ÇÇ_mul, eval‚ÇÇ_X, eval‚ÇÇ_X]
intros
refine (find_eq_iff _).2 ‚ü®nat.find_spec h‚ÇÇ, Œª n hn, _‚ü©
cases n with n
exacts [h0, @nat.find_min (Œª n, p (n + 1)) _ h‚ÇÇ _ (succ_lt_succ_iff.1 hn)]
intros
by_cases h1 : m ‚â§ n
rw [max_eq_right h1, max_eq_right (succ_le_succ h1)]
rw not_le at h1
{ rw not_le at h1, have h2 := le_of_lt h1, rw [max_eq_left h2, max_eq_left (succ_le_succ h2)] }
have h2 := le_of_lt h1
rw [max_eq_left h2, max_eq_left (succ_le_succ h2)]
intros
induction hmk with k hmk ih
rw le_rec_on_self
{ rw le_rec_on_self }
rw [le_rec_on_succ (le_trans hnm hmk), ih, le_rec_on_succ]
intros
rw [mul_comm, mul_comm b, a.mul_div_mul_left b hc]
intros
convert factorial_mul_factorial_dvd_factorial (le.intro rfl)
rw nat.add_sub_cancel_left
intros
rw sum_powerset_apply_card
simp only [nsmul_eq_mul', ‚Üê card_eq_zero]
convert int.alternating_sum_range_choose
ext
simp
intros
cases n
{ cases w, }
cases w
{ rw [digits_aux], }
rw [digits_aux]
intros
{ rw [‚Üê some_eq_coe] at h, exact dom_of_le_some h }
rw [‚Üê some_eq_coe] at h
exact dom_of_le_some h
intros
rw [gcd_comm n m, gcd_gcd_self_right_left]
intros
simp [coprime]
intros
rw [or_iff_not_and_not, not_lt, not_le] at hnb
rw [log, ‚Üêite_not, if_pos hnb]
intros
simpa using unpair_left_le (mkpair a b)
intros
cases even_or_odd n with h
{ exact or.inl ‚ü®h, even_iff_not_odd.mp h‚ü© }
exact or.inl ‚ü®h, even_iff_not_odd.mp h‚ü©
{ exact or.inr ‚ü®h, odd_iff_not_even.mp h‚ü© }
exact or.inr ‚ü®h, odd_iff_not_even.mp h‚ü©
rw [sqrt, size_zero, sqrt._match_1]
intros
cases x; simp only [pmap, none_bind, some_bind]
{ cases x; simp only [pmap, none_bind, some_bind] }
cases x
simp only [pmap, none_bind, some_bind]
simp only [pmap, none_bind, some_bind]
intros
rw [valid.dual_iff, dual_erase_max]; exact erase_min.valid h.dual
rw [valid.dual_iff, dual_erase_max]
exact erase_min.valid h.dual
intros
cases r
exact hl.node' hr
{exact hl.node' hr}
rw rotate_l
split_ifs
{ exact hl.node3_l hr.2.1 hr.2.2 }
exact hl.node3_l hr.2.1 hr.2.2
{ exact hl.node4_l hr.2.1 hr.2.2 }
exact hl.node4_l hr.2.1 hr.2.2
intros
cases p; reflexivity
cases p
reflexivity
intros
{ dsimp [start, is_special], refl }
dsimp [start, is_special]
refl
intros
induction n with n ih
{ simp [monomial_zero_one], }
simp [monomial_zero_one]
rw [pow_succ, ‚Üêih, ‚Üêmonomial_one_one_eq_X, monomial_mul_monomial, add_comm, one_mul]
{ rw [pow_succ, ‚Üêih, ‚Üêmonomial_one_one_eq_X, monomial_mul_monomial, add_comm, one_mul], }
intros
simp [monic_X.degree_mul]
intros
rw [‚Üê with_top.coe_le_coe, ‚Üê trailing_degree_eq_nat_trailing_degree]
{ exact le_trailing_degree_of_ne_zero h, }
exact le_trailing_degree_of_ne_zero h
{ assume h, subst h, exact h rfl }
assume h
subst h
exact h rfl
intros
convert derivative_smul a p; apply C_mul'
convert derivative_smul a p
apply C_mul'
apply C_mul'
intros
simp [erase_lead_coeff]
intros
simp [eval‚ÇÇ_eq_sum]
intros
rw [monomial_eq_C_mul_X, mul_assoc, coeff_C_mul, X_pow_mul, coeff_mul_X_pow]
intros
rw [lifts_iff_ring_hom_srange, mem_map_srange] at h ‚ä¢
intros k
by_cases hk : k = n
use 0
{ use 0, simp only [hk, ring_hom.map_zero, erase_same] }
simp only [hk, ring_hom.map_zero, erase_same]
obtain ‚ü®i, hi‚ü© := h k
use i
simp only [hi, hk, erase_ne, ne.def, not_false_iff]
intros
rw [‚Üêhp.nat_degree_eq_zero_iff_eq_one, nat_degree_eq_zero_iff_degree_le_zero]
intros
split
intro hp
{ intro hp, replace hp := congr_arg (* C ‚Üë(h.unit)‚Åª¬π) hp, simp only [zero_mul] at hp, rwa [mul_assoc, monic.mul_left_eq_zero_iff] at hp, nontriviality, refine monic_mul_C_of_leading_coeff_mul_eq_one _, simp [units.mul_inv_eq_iff_eq_mul, is_unit.unit_spec] }
replace hp := congr_arg (* C ‚Üë(h.unit)‚Åª¬π) hp
simp only [zero_mul] at hp
rwa [mul_assoc, monic.mul_left_eq_zero_iff] at hp
nontriviality
refine monic_mul_C_of_leading_coeff_mul_eq_one _
simp [units.mul_inv_eq_iff_eq_mul, is_unit.unit_spec]
rintro rfl
{ rintro rfl, rw zero_mul }
rw zero_mul
intros
rw [sub_eq_add_neg, sub_eq_add_neg, reflect_add, reflect_neg]
intros
rw [taylor_coeff, hasse_deriv_zero, linear_map.id_apply]
intros
rw ‚Üêabs_repr x
cases repr x with a f
rw [‚Üêabs_map, pfunctor.map_eq]
rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, image_comp]
intros
replace hn : (n:‚Ñö) ‚â† 0
rwa [ne.def, ‚Üê int.cast_zero, coe_int_inj]
rwa [ne.def, ‚Üê int.cast_zero, coe_int_inj]
split
intro h
{ intro h, lift ((m : ‚Ñö) / n) to ‚Ñ§ using h with k hk, use k, rwa [eq_div_iff_mul_eq hn, ‚Üê int.cast_mul, mul_comm, eq_comm, coe_int_inj] at hk }
lift ((m : ‚Ñö) / n) to ‚Ñ§ using h with k hk
use k
rwa [eq_div_iff_mul_eq hn, ‚Üê int.cast_mul, mul_comm, eq_comm, coe_int_inj] at hk
rintros ‚ü®d, rfl‚ü©
{ rintros ‚ü®d, rfl‚ü©, rw [int.cast_mul, mul_comm, mul_div_cancel _ hn, rat.coe_int_denom] }
rw [int.cast_mul, mul_comm, mul_div_cancel _ hn, rat.coe_int_denom]
intros
have hf : lim_zero _ := neg_lim_zero hf
show lim_zero (-f - -g)
convert hf using 1
simp
intros
suffices : a * b‚Åª¬π ‚â§ c ‚Üî a ‚â§ c / b‚Åª¬π
simpa [div_eq_mul_inv]
simpa [div_eq_mul_inv]
refine (le_div_iff_mul_le _ _).symm; simpa
refine (le_div_iff_mul_le _ _).symm
simpa
simpa
intros
simp [bit1, bit1, to_nnreal_add (by rwa [ne.def, bit0_eq_top_iff]) ennreal.one_ne_top]
intros
rw [ennreal.mul_lt_top_iff, and_self, or_self, or_iff_left_iff_imp]
{ rw [ennreal.mul_lt_top_iff, and_self, or_self, or_iff_left_iff_imp], rintro rfl, norm_num }
rintro rfl
norm_num
intros
conv_lhs { rw [ereal.neg_le, ereal.neg_neg] }
intros
cases le_total b c with h h
simp [sup_eq_max, max_eq_right h, max_eq_right (mul_le_mul_of_nonneg_left h (zero_le a))]
{ simp [sup_eq_max, max_eq_right h, max_eq_right (mul_le_mul_of_nonneg_left h (zero_le a))] }
simp [sup_eq_max, max_eq_left h, max_eq_left (mul_le_mul_of_nonneg_left h (zero_le a))]
{ simp [sup_eq_max, max_eq_left h, max_eq_left (mul_le_mul_of_nonneg_left h (zero_le a))] }
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ‚Ñù)
{ rw [sign_of_neg hn, sign_of_neg (inv_lt_zero.mpr hn)] }
rw [sign_of_neg hn, sign_of_neg (inv_lt_zero.mpr hn)]
{ rw [sign_zero, inv_zero, sign_zero] }
rw [sign_zero, inv_zero, sign_zero]
{ rw [sign_of_pos hp, sign_of_pos (inv_pos.mpr hp)] }
rw [sign_of_pos hp, sign_of_pos (inv_pos.mpr hp)]
intros
revert cb
refine mem_rec_on ha _ (Œª ca' IH, _)
refine mem_rec_on ha _ (Œª ca' IH, _); intros cb Hc; have h := H Hc
refine mem_rec_on ha _ (Œª ca' IH, _); intros cb Hc
intros cb Hc
have h := H Hc
{ simp at h, simp [h] }
simp at h
simp [h]
intros cb Hc
have h := H Hc
have h := H Hc
{ have h := H Hc, simp, revert h, apply cb.cases_on (Œª b, _) (Œª cb', _); intro h; simp at h; simp [h], exact IH _ h }
simp
revert h
apply cb.cases_on (Œª b, _) (Œª cb', _)
apply cb.cases_on (Œª b, _) (Œª cb', _); intro h; simp at h; simp [h]
apply cb.cases_on (Œª b, _) (Œª cb', _); intro h; simp at h
apply cb.cases_on (Œª b, _) (Œª cb', _); intro h
intro h
simp at h
simp [h]
intro h
simp at h
simp [h]
exact IH _ h
intros
rw [set.ite, set.ite, diff_compl, union_comm, diff_eq]
intros
rw [compl_eq_univ_diff, image_diff_preimage, image_univ]
intros
simp [and_assoc]
intros
simp
intros
ext c
split
rintros ‚ü®a, b, h1a|h2a, hb, rfl‚ü©;[left, right]; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
rintros ‚ü®a, b, h1a|h2a, hb, rfl‚ü©;[left, right]
rintros ‚ü®a, b, h1a|h2a, hb, rfl‚ü©
{ rintros ‚ü®a, b, h1a|h2a, hb, rfl‚ü©;[left, right]; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü© }
left
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
right
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©); refine ‚ü®_, _, _, ‚Äπ_‚Ä∫, rfl‚ü©; simp [mem_union, *]
rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©); refine ‚ü®_, _, _, ‚Äπ_‚Ä∫, rfl‚ü©
rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©)
{ rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©); refine ‚ü®_, _, _, ‚Äπ_‚Ä∫, rfl‚ü©; simp [mem_union, *] }
refine ‚ü®_, _, _, ‚Äπ_‚Ä∫, rfl‚ü©
simp [mem_union, *]
refine ‚ü®_, _, _, ‚Äπ_‚Ä∫, rfl‚ü©
simp [mem_union, *]
intros
rw [union_comm, union_compl_self]
intros
simp only [injective, subtype.ext_iff, coe_cod_restrict_apply]
intros
simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm]
simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm]; ac_refl
ac_refl
intros
simp
intros
simp
intros
simp [‚Üê Ioi_inter_Iic, h]
intros
apply @Iio.infinite (order_dual Œ±)
intros
simpa only [add_comm] using preimage_const_add_interval a b c
intros
{ ext, simp [classical.skolem] }
ext
simp [classical.skolem]
intros
rw [bInter_insert, bInter_singleton]
intros
simp [@Union_comm _ Œπ]
intros
cases x; refl
cases x
refl
refl
intros
ext i
{ clear_except, ext i, induction i; [refl, apply i_ih], }
clear_except
induction i
induction i; [refl, apply i_ih]
refl
apply i_ih
intros
cases v; cases i; simp [vector.update_nth, vector.nth_eq_nth_le]
cases v; cases i
cases v
cases i
simp [vector.update_nth, vector.nth_eq_nth_le]
intros
by_contradiction H
have : measurable_set (s ‚à© {x | ‚àÄ m ‚â• n, f^[m] x ‚àâ s})
simp only [set_of_forall, ‚Üê compl_set_of]
{ simp only [set_of_forall, ‚Üê compl_set_of], exact hs.inter (measurable_set.bInter (countable_encodable _) (Œª m _, hf.measurable.iterate m hs.compl)) }
exact hs.inter (measurable_set.bInter (countable_encodable _) (Œª m _, hf.measurable.iterate m hs.compl))
rcases (hf.exists_gt_measure_inter_ne_zero this H) n with ‚ü®m, hmn, hm‚ü©
rcases nonempty_of_measure_ne_zero hm with ‚ü®x, ‚ü®hxs, hxn‚ü©, hxm, -‚ü©
exact hxn m hmn.lt.le hxm
intros
revert Œ±
apply solvable_by_rad.induction
exact Œª Œ±, by { rw minpoly.eq_X_sub_C, exact gal_X_sub_C_is_solvable Œ± }
{ exact Œª Œ±, by { rw minpoly.eq_X_sub_C, exact gal_X_sub_C_is_solvable Œ± } }
exact Œª Œ± Œ≤, induction2 (add_mem _ (subset_adjoin F _ (set.mem_insert Œ± _)) (subset_adjoin F _ (set.mem_insert_of_mem Œ± (set.mem_singleton Œ≤))))
{ exact Œª Œ± Œ≤, induction2 (add_mem _ (subset_adjoin F _ (set.mem_insert Œ± _)) (subset_adjoin F _ (set.mem_insert_of_mem Œ± (set.mem_singleton Œ≤)))) }
exact Œª Œ±, induction1 (neg_mem _ (mem_adjoin_simple_self F Œ±))
{ exact Œª Œ±, induction1 (neg_mem _ (mem_adjoin_simple_self F Œ±)) }
exact Œª Œ± Œ≤, induction2 (mul_mem _ (subset_adjoin F _ (set.mem_insert Œ± _)) (subset_adjoin F _ (set.mem_insert_of_mem Œ± (set.mem_singleton Œ≤))))
{ exact Œª Œ± Œ≤, induction2 (mul_mem _ (subset_adjoin F _ (set.mem_insert Œ± _)) (subset_adjoin F _ (set.mem_insert_of_mem Œ± (set.mem_singleton Œ≤)))) }
exact Œª Œ±, induction1 (inv_mem _ (mem_adjoin_simple_self F Œ±))
{ exact Œª Œ±, induction1 (inv_mem _ (mem_adjoin_simple_self F Œ±)) }
{ exact Œª Œ± n, induction3 }
exact Œª Œ± n, induction3
intros
haveI hp : fact p.prime := ‚ü®char_p.char_is_prime K p‚ü©
letI : module (zmod p) K := { .. (zmod.cast_hom dvd_rfl K).to_module }
obtain ‚ü®n, h‚ü© := vector_space.card_fintype (zmod p) K
rw zmod.card at h
refine ‚ü®‚ü®n, _‚ü©, hp.1, h‚ü©
apply or.resolve_left (nat.eq_zero_or_pos n)
rintro rfl
rw pow_zero at h
have : (0 : K) = 1
apply fintype.card_le_one_iff.mp (le_of_eq h)
{ apply fintype.card_le_one_iff.mp (le_of_eq h) }
exact absurd this zero_ne_one
intros
rw [eval·µ¢, linear_map.range_comp, range_subtype]
exact map_restrict_dom_eval‚Çó
intros
rw [‚Üê (expand R p).map_zero, expand_inj hp, alg_hom.map_zero]
intros
{ rw [separable_def, derivative_X], exact is_coprime_one_right }
rw [separable_def, derivative_X]
exact is_coprime_one_right
intros
rw [‚Üêangle_neg_neg, neg_neg, angle_neg_right]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ‚Üê vsub_sub_vsub_cancel_right]
exact norm_sub_eq_add_norm_iff_angle_eq_pi ((Œª he, hp1p2 (vsub_eq_zero_iff_eq.1 he))) (Œª he, hp3p2 (vsub_eq_zero_iff_eq.1 he))
intros
erw [pseudo_metric_space.dist_comm p3 p2, dist_eq_norm_vsub V p1 p3, dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p2 p3, ‚Üênorm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two, vsub_sub_vsub_cancel_right p1, ‚Üêneg_vsub_eq_vsub_rev p2 p3, norm_neg]
intros
simp
intros
simp only [mfderiv, h, dif_pos]
intros
simpa only [has_mfderiv_within_at, and_iff_right_iff_imp] with mfld_simps using has_fderiv_within_at.continuous_within_at
intros
rcases smooth_bump_covering.exists_is_subordinate I is_closed_univ (Œª (x : M) _, univ_mem) with ‚ü®Œπ, f, -‚ü©
haveI := f.fintype
rcases f.exists_immersion_euclidean with ‚ü®n, e, hsmooth, hinj, hinj_mfderiv‚ü©
exact ‚ü®n, e, hsmooth, hsmooth.continuous.closed_embedding hinj, hinj_mfderiv‚ü©
intros
rw [general_commutator, closure_le]
split
intros h p hp q hq
{ intros h p hp q hq, exact h ‚ü®p, hp, q, hq, rfl‚ü©, }
exact h ‚ü®p, hp, q, hq, rfl‚ü©
rintros h x ‚ü®p, hp, q, hq, rfl‚ü©
{ rintros h x ‚ü®p, hp, q, hq, rfl‚ü©, exact h p hp q hq, }
exact h p hp q hq
intros
rw [equiv.symm_apply_eq, fin_equiv_powers_apply, subtype.mk_eq_mk, pow_eq_mod_order_of, fin.coe_mk]
intros
rw [‚ÜêH.subtype_range, monoid_hom.map_range]
exact hH.of_surjective (œï.restrict H).range_restrict (œï.restrict H).range_restrict_surjective
intros
simpa [cycle_factors_finset_eq_finset] using eq_comm
intros
contrapose! hx
simp_rw [mem_support, not_not] at hx ‚ä¢
induction l with f l ih generalizing hx
{ refl }
refl
rw [list.prod_cons, mul_apply, ih (Œª g hg, hx g (or.inr hg)), hx f (or.inl rfl)]
{ rw [list.prod_cons, mul_apply, ih (Œª g hg, hx g (or.inr hg)), hx f (or.inl rfl)] }
intros
refine eq_comm.trans (quotient_group.eq.trans _)
rw [nN.mem_comm_iff, div_eq_mul_inv]
intros
simp [map]
intros
rw [‚Üê H.inv_mem_iff, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, inv_inv]
intros
rw [mrange_eq_map, ‚Üê free_monoid.closure_range_of, map_mclosure, ‚Üê set.range_comp, free_monoid.lift_comp_of, subtype.range_coe]
intros
simpa only [mrange_eq_map] using map_inr ‚ä§
intros
{ ext p, simp [homothety_apply, mul_smul] }
ext p
simp [homothety_apply, mul_smul]
intros
ext v
rw [submodule.mem_inf, ‚Üêvadd_mem_iff_mem_direction v h‚ÇÅ, ‚Üêvadd_mem_iff_mem_direction v h‚ÇÇ, ‚Üêvadd_mem_iff_mem_direction v ((mem_inf_iff p s‚ÇÅ s‚ÇÇ).2 ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©), mem_inf_iff]
intros
simp_rw [affine_combination_apply, eq_vadd_iff_vsub_eq]
exact eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype
intros
rw [collinear_iff_dim_le_one, vector_span_singleton]
simp
intros
rw equiv.comp_swap_eq_update
convert f.map_update_update v hij (v i + v j)
simp [f.map_update_self _ hij, f.map_update_self _ hij.symm, function.update_comm hij (v i + v j) (v _) v, function.update_comm hij.symm (v i) (v i) v]
intros
simpa [disjoint] using @disjoint_ker' _ _ _ _ _ _ _ _ _ _ _ f ‚ä§
intros
{ ext, simp [conj_apply], }
ext
simp [conj_apply]
intros
conv_lhs { rw [pi_eq_sum_univ x, f.map_sum] }
apply finset.sum_congr rfl (Œªl hl, _)
rw f.map_smul
intros
simp only [constr_def, linear_map.comp_apply, finsupp.lmap_domain_apply, finsupp.total_apply]
{ simp only [constr_def, linear_map.comp_apply, finsupp.lmap_domain_apply, finsupp.total_apply], rw finsupp.sum_map_domain_index; simp [add_smul] }
rw finsupp.sum_map_domain_index; simp [add_smul]
rw finsupp.sum_map_domain_index
simp [add_smul]
simp [add_smul]
simp [add_smul]
intros
rw [‚Üê@zero_smul _ _ _ _ _ (0 : M), smul_right, zero_mul]
intros
rw [dual_basis, basis.map_repr, linear_equiv.symm_symm, linear_equiv.trans_apply, basis.dual_basis_repr, to_dual_def]
intros
simp only [coevaluation, id]
rw [(basis.singleton unit K).constr_apply_fintype K]
simp only [fintype.univ_punit, finset.sum_const, one_smul, basis.singleton_repr, basis.equiv_fun_apply,basis.coe_of_vector_space, one_nsmul, finset.card_singleton]
intros
rw mem_supr_iff_exists_dfinsupp
simp_rw [dfinsupp.lsum_apply_apply, dfinsupp.sum_add_hom_apply]
congr'
intros
rw [‚Üê dim_range_add_dim_ker f, ‚Üê dim_range_of_surjective f h]
intros
{ rw ‚Üê s.finrank_quotient_add_finrank, exact nat.le_add_left _ _ }
rw ‚Üê s.finrank_quotient_add_finrank
exact nat.le_add_left _ _
intros
rw [set.inter_eq_Inter, supported_Inter, infi_bool_eq]
rw [set.inter_eq_Inter, supported_Inter, infi_bool_eq]; refl
refl
intros
conv_rhs { rw [‚Üê (finsupp_prod_lequiv R).apply_symm_apply f, finsupp_prod_lequiv_apply, prod.mk.eta] }
intros
revert N
refine induction_on_rank b _ _ O
intros M ih N N_le_M
obtain ‚ü®m, b'M‚ü© := M.basis_of_pid b
by_cases N_bot : N = ‚ä•
subst N_bot
{ subst N_bot, exact ‚ü®0, m, nat.zero_le _, b'M, basis.empty _, fin_zero_elim, fin_zero_elim‚ü© }
exact ‚ü®0, m, nat.zero_le _, b'M, basis.empty _, fin_zero_elim, fin_zero_elim‚ü©
obtain ‚ü®y, hy, a, hay, M', M'_le_M, N', N'_le_N, N'_le_M', y_ortho, ay_ortho, h‚ü© := submodule.basis_of_pid_aux M N b'M N_bot N_le_M
obtain ‚ü®n', m', hn'm', bM', bN', as', has'‚ü© := ih M' M'_le_M y hy y_ortho N' N'_le_M'
obtain ‚ü®bN, h'‚ü© := h n' bN'
obtain ‚ü®hmn, bM, h''‚ü© := h' m' hn'm' bM'
obtain ‚ü®as, has‚ü© := h'' as' has'
exact ‚ü®_, _, hmn, bM, bN, as, has‚ü©
intros
rw [finsupp.total_on, linear_map.ker, linear_map.comap_cod_restrict, map_bot, comap_bot, linear_map.ker_comp, linear_independent_subtype_disjoint, disjoint, ‚Üê map_comap_subtype, map_le_iff_le_comap, comap_bot, ker_subtype, le_bot_iff]
intros
let n : ‚Ñï := (Sup (finset.image b finset.univ : set ‚Ñï)).succ
have hn : ‚àÄ i, b i < n
have hbi : ‚àÄ i, b i ‚àà finset.image b finset.univ
{ have hbi : ‚àÄ i, b i ‚àà finset.image b finset.univ, { simp }, intro i, dsimp only [n], apply nat.lt_succ_iff.mpr, exact le_cSup (finset.bdd_above _) (hbi i) }
simp
{ simp }
intro i
dsimp only [n]
apply nat.lt_succ_iff.mpr
exact le_cSup (finset.bdd_above _) (hbi i)
rw det_of_block_triangular_matrix M b h n hn
refine (finset.prod_subset _ _).symm
intros a ha
{ intros a ha, apply finset.mem_range.mpr, obtain ‚ü®i, ‚ü®hi, hbi‚ü©‚ü© := finset.mem_image.mp ha, rw ‚Üêhbi, exact hn i }
apply finset.mem_range.mpr
obtain ‚ü®i, ‚ü®hi, hbi‚ü©‚ü© := finset.mem_image.mp ha
rw ‚Üêhbi
exact hn i
intros k hk hbk
{ intros k hk hbk, apply det_eq_one_of_card_eq_zero, apply fintype.card_eq_zero_iff.mpr, constructor, simp only [subtype.forall], intros a hba, apply hbk, apply finset.mem_image.mpr, use a, exact ‚ü®finset.mem_univ a, hba‚ü© }
apply det_eq_one_of_card_eq_zero
apply fintype.card_eq_zero_iff.mpr
constructor
simp only [subtype.forall]
intros a hba
apply hbk
apply finset.mem_image.mpr
use a
exact ‚ü®finset.mem_univ a, hba‚ü©
intros
ext i j
simp only [mul_apply, mul_vec, circulant, dot_product]
refine fintype.sum_equiv (equiv.sub_right j) _ _ _
intro x
simp only [equiv.sub_right_apply, sub_sub_sub_cancel_right]
intros
simp [det_update_row_add, det_zero_of_row_eq hij ((update_row_self).trans (update_row_ne hij.symm).symm)]
intros
split
intros h
{ intros h, refine ‚ü®Œª i j hij, _, ext $ Œª i j, _, ext $ Œª i j, _, Œª i j hij, _‚ü©, { exact h (sum.inl_injective.ne hij), }, { exact h sum.inl_ne_inr, }, { exact h sum.inr_ne_inl, }, { exact h (sum.inr_injective.ne hij), }, }
refine ‚ü®Œª i j hij, _, ext $ Œª i j, _, ext $ Œª i j, _, Œª i j hij, _‚ü©
{ exact h (sum.inl_injective.ne hij), }
exact h (sum.inl_injective.ne hij)
{ exact h sum.inl_ne_inr, }
exact h sum.inl_ne_inr
{ exact h sum.inr_ne_inl, }
exact h sum.inr_ne_inl
{ exact h (sum.inr_injective.ne hij), }
exact h (sum.inr_injective.ne hij)
rintros ‚ü®ha, hb, hc, hd‚ü©
{ rintros ‚ü®ha, hb, hc, hd‚ü©, convert is_diag.from_blocks ha hd }
convert is_diag.from_blocks ha hd
intros
rw [show (@has_mul.mul (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ) _) = linear_map.comp, from rfl, linear_map.to_matrix_comp v‚ÇÅ v‚ÇÅ v‚ÇÅ f g]
{ rw [show (@has_mul.mul (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ) _) = linear_map.comp, from rfl, linear_map.to_matrix_comp v‚ÇÅ v‚ÇÅ v‚ÇÅ f g] }
intros
refine iff.trans _ (not_iff_not.mpr exists_vec_mul_eq_zero_iff)
simp only [not_exists]
split
intros hM v hv hMv
{ intros hM v hv hMv, obtain ‚ü®w, hwMv‚ü© := hM.exists_not_ortho_of_ne_zero hv, simpa only [dot_product_mul_vec, hMv, zero_dot_product] using hwMv }
obtain ‚ü®w, hwMv‚ü© := hM.exists_not_ortho_of_ne_zero hv
simpa only [dot_product_mul_vec, hMv, zero_dot_product] using hwMv
intros h v hv
{ intros h v hv, refine not_imp_not.mp (h v) (funext $ Œª i, _), simpa only [dot_product_mul_vec, dot_product_single, mul_one] using hv (pi.single i 1) }
refine not_imp_not.mp (h v) (funext $ Œª i, _)
simpa only [dot_product_mul_vec, dot_product_single, mul_one] using hv (pi.single i 1)
intros
ext x
ext x; simp [(‚ü®0, zero_mem _‚ü© : ‚àÉ x, x ‚àà q)]
simp [(‚ü®0, zero_mem _‚ü© : ‚àÉ x, x ‚àà q)]
intros
simp [linear_proj_of_is_compl]
intros
simp [sub_eq_add_neg]
intros
ext ‚ü®j', i'‚ü©
by_cases hj : j = j'
subst hj
{ subst hj, simp only [pi.basis, linear_equiv.trans_apply, basis.repr_self, std_basis_same, linear_equiv.Pi_congr_right_apply, finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply], symmetry, exact basis.finsupp.single_apply_left (Œª i i' (h : (‚ü®j, i‚ü© : Œ£ j, Œπs j) = ‚ü®j, i'‚ü©), eq_of_heq (sigma.mk.inj h).2) _ _ _ }
simp only [pi.basis, linear_equiv.trans_apply, basis.repr_self, std_basis_same, linear_equiv.Pi_congr_right_apply, finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply]
symmetry
exact basis.finsupp.single_apply_left (Œª i i' (h : (‚ü®j, i‚ü© : Œ£ j, Œπs j) = ‚ü®j, i'‚ü©), eq_of_heq (sigma.mk.inj h).2) _ _ _
simp only [pi.basis, linear_equiv.trans_apply, finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply, linear_equiv.Pi_congr_right_apply]
dsimp
rw [std_basis_ne _ _ _ _ (ne.symm hj), linear_equiv.map_zero, finsupp.zero_apply, finsupp.single_eq_of_ne]
rintros ‚ü®‚ü©
contradiction
intros
split_ifs; simp
{ split_ifs; simp }
split_ifs
simp
simp
intros
simp only [ltensor, rtensor, ‚Üê map_comp, id_comp, comp_id]
intros
rw [‚Üê s.neg_le_neg_iff _ hu, neg_zero] at hsu
rw [‚Üê s.neg_le_neg_iff _ hv, neg_zero] at hsv
have := of_inter_eq_of_symm_diff_eq_zero_positive hu hv hw hsu hsv
simp only [pi.neg_apply, neg_inj, neg_eq_zero, coe_neg] at this
exact this hs
intros
rw sub_eq_add_neg at hst
rw [sub_eq_add_neg, sub_eq_add_neg]
exactI ae_eq_trans (rn_deriv_add _ _ _) (filter.eventually_eq.add (ae_eq_refl _) (rn_deriv_neg _ _))
intros
rw [‚Üê of_real_integral_norm_eq_lintegral_nnnorm hfi, ‚Üê of_real_integral_norm_eq_lintegral_nnnorm hgi, ennreal.of_real_le_of_real_iff]
exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hŒºs
{ exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hŒºs, }
{ exact integral_nonneg (Œª x, norm_nonneg _), }
exact integral_nonneg (Œª x, norm_nonneg _)
intros
rw edist_def
{ rw edist_def, exact snorm_congr_ae (hf.coe_fn_to_Lp.sub hg.coe_fn_to_Lp) }
exact snorm_congr_ae (hf.coe_fn_to_Lp.sub hg.coe_fn_to_Lp)
intros
rw Lp.eq_zero_iff_ae_eq_zero
convert indicator_const_Lp_coe_fn
simp [set.indicator_empty']
intros
simp_rw [cauchy_seq_iff_tendsto_dist_at_top_0, dist_def]
rw [‚Üê ennreal.zero_to_real, ennreal.tendsto_to_real_iff (Œª n, _) ennreal.zero_ne_top]
rw snorm_congr_ae (Lp.coe_fn_sub _ _).symm
exact snorm_ne_top _
intros
simp [snorm']
intros
delta integrable_on
{ delta integrable_on, rw measure.restrict_add, exact hŒº.integrable.add_measure hŒΩ }
rw measure.restrict_add
exact hŒº.integrable.add_measure hŒΩ
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c, sub_neg_eq_add, sub_eq_neg_add]
{ rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c, sub_neg_eq_add, sub_eq_neg_add], }
intros
simpa [tsum_fintype] using lintegral_sum_measure f (Œª b, cond b Œº ŒΩ)
intros
convert h_supr (Œª n, (eapprox f n).measurable) (monotone_eapprox f) _
{ ext1 x, rw [supr_eapprox_apply f hf] }
ext1 x
rw [supr_eapprox_apply f hf]
exact Œª n, simple_func.induction (Œª c s hs, h_ind c hs) (Œª f g hfg hf hg, h_add hfg f.measurable g.measurable hf hg) (eapprox f n)
{ exact Œª n, simple_func.induction (Œª c s hs, h_ind c hs) (Œª f g hfg hf hg, h_add hfg f.measurable g.measurable hf hg) (eapprox f n) }
intros
cases f; cases g; congr; exact H
cases f; cases g; congr
cases f; cases g
cases f
cases g
congr
exact H
intros
apply measurable_pi_iff.2 (Œª j, _)
by_cases hj : p j
simp only [hj, dif_pos, equiv.pi_equiv_pi_subtype_prod_symm_apply]
{ simp only [hj, dif_pos, equiv.pi_equiv_pi_subtype_prod_symm_apply], have : measurable (Œª (f : (Œ† (i : {x // p x}), œÄ ‚Üëi)), f ‚ü®j, hj‚ü©) := measurable_pi_apply ‚ü®j, hj‚ü©, exact measurable.comp this measurable_fst }
have : measurable (Œª (f : (Œ† (i : {x // p x}), œÄ ‚Üëi)), f ‚ü®j, hj‚ü©) := measurable_pi_apply ‚ü®j, hj‚ü©
exact measurable.comp this measurable_fst
simp only [hj, equiv.pi_equiv_pi_subtype_prod_symm_apply, dif_neg, not_false_iff]
{ simp only [hj, equiv.pi_equiv_pi_subtype_prod_symm_apply, dif_neg, not_false_iff], have : measurable (Œª (f : (Œ† (i : {x // ¬¨ p x}), œÄ ‚Üëi)), f ‚ü®j, hj‚ü©) := measurable_pi_apply ‚ü®j, hj‚ü©, exact measurable.comp this measurable_snd }
have : measurable (Œª (f : (Œ† (i : {x // ¬¨ p x}), œÄ ‚Üëi)), f ‚ü®j, hj‚ü©) := measurable_pi_apply ‚ü®j, hj‚ü©
exact measurable.comp this measurable_snd
intros
simp only [apply_eq_coe_to_fun]
{ simp only [apply_eq_coe_to_fun], norm_cast, exact Œº.sup_le' _ _ }
norm_cast
exact Œº.sup_le' _ _
intros
refine le_antisymm (mul_left_index_le hK hV g) _
convert mul_left_index_le (hK.image $ continuous_mul_left g) hV g‚Åª¬π
rw [image_image]
symmetry
convert image_id' _
ext h
apply inv_mul_cancel_left
intros
let Œπ := fin (finrank ‚Ñù E)
haveI : finite_dimensional ‚Ñù (Œπ ‚Üí ‚Ñù) := by apply_instance
have : finrank ‚Ñù E = finrank ‚Ñù (Œπ ‚Üí ‚Ñù)
simp
simp
have e : E ‚âÉ‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù := linear_equiv.of_finrank_eq E (Œπ ‚Üí ‚Ñù) this
obtain ‚ü®g, hg‚ü© : ‚àÉ g, g = (e : E ‚Üí‚Çó[‚Ñù] (Œπ ‚Üí ‚Ñù)).comp (f.comp (e.symm : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] E)) := ‚ü®_, rfl‚ü©
have gdet : g.det = f.det
rw [hg]
rw [hg]
{ rw [hg], exact linear_map.det_conj f e }
{ rw [hg], exact linear_map.det_conj f e }
exact linear_map.det_conj f e
exact linear_map.det_conj f e
rw ‚Üê gdet at hf ‚ä¢
have fg : f = (e.symm : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] E).comp (g.comp (e : E ‚Üí‚Çó[‚Ñù] (Œπ ‚Üí ‚Ñù)))
ext x
{ ext x, simp only [linear_equiv.coe_coe, function.comp_app, linear_map.coe_comp, linear_equiv.symm_apply_apply, hg] }
simp only [linear_equiv.coe_coe, function.comp_app, linear_map.coe_comp, linear_equiv.symm_apply_apply, hg]
simp only [fg, linear_equiv.coe_coe, linear_map.coe_comp]
have Ce : continuous e := (e : E ‚Üí‚Çó[‚Ñù] (Œπ ‚Üí ‚Ñù)).continuous_of_finite_dimensional
have Cg : continuous g := linear_map.continuous_of_finite_dimensional g
have Cesymm : continuous e.symm := (e.symm : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] E).continuous_of_finite_dimensional
rw [‚Üê map_map Cesymm.measurable (Cg.comp Ce).measurable, ‚Üê map_map Cg.measurable Ce.measurable]
haveI : is_add_haar_measure (map e Œº) := is_add_haar_measure_map Œº e.to_add_equiv Ce Cesymm
have ecomp : (e.symm) ‚àò e = id
ext x
ext x
{ ext x, simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply] }
{ ext x, simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply] }
simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply]
simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply]
rw [map_linear_map_add_haar_pi_eq_smul_add_haar hf (map e Œº), linear_map.map_smul, map_map Cesymm.measurable Ce.measurable, ecomp, measure.map_id]
intros
simp only [volume_pi_closed_ball a hr, volume_closed_ball, finset.prod_const]
exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr) _).symm
intros
haveI := hs.to_encodable
rw bUnion_eq_Union
exact measure_Union (hd.on_injective subtype.coe_injective $ Œª x, x.2) (Œª x, h x x.2)
intros
contrapose! hŒº
simpa [measure_univ_nnreal_eq_zero, le_zero_iff] using hŒº
intros
rw [ennreal.tsum_eq_supr_sum]
exact supr_le (Œª s, sum_measure_le_measure_univ (Œª i hi, hs i) (Œª i hi j hj hij, H i j hij))
intros
simp [eventually_le_antisymm_iff, ae_le_set]
intros
set g := Œª i : ‚Ñï, ‚ãÉ (b : Œ≤) (H : b ‚àà encodable.decode‚ÇÇ Œ≤ i), f b with hg
have hg‚ÇÅ : ‚àÄ i, measurable_set (g i)
exact Œª _, measurable_set.Union (Œª b, measurable_set.Union_Prop $ Œª _, hf‚ÇÅ b)
{ exact Œª _, measurable_set.Union (Œª b, measurable_set.Union_Prop $ Œª _, hf‚ÇÅ b) }
have hg‚ÇÇ : pairwise (disjoint on g)
{ exact encodable.Union_decode‚ÇÇ_disjoint_on hf‚ÇÇ }
exact encodable.Union_decode‚ÇÇ_disjoint_on hf‚ÇÇ
have := v.of_disjoint_Union_nat hg‚ÇÅ hg‚ÇÇ
rw [hg, encodable.Union_decode‚ÇÇ] at this
have hg‚ÇÉ : (Œª (i : Œ≤), v (f i)) = (Œª i, v (g (encodable.encode i)))
ext
{ ext, rw hg, simp only, congr, ext y, simp only [exists_prop, mem_Union, option.mem_def], split, { intro hy, refine ‚ü®x, (encodable.decode‚ÇÇ_is_partial_inv _ _).2 rfl, hy‚ü© }, { rintro ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©, rw (encodable.decode‚ÇÇ_is_partial_inv _ _) at hb‚ÇÅ, rwa ‚Üê encodable.encode_injective hb‚ÇÅ } }
rw hg
simp only
congr
ext y
simp only [exists_prop, mem_Union, option.mem_def]
split
intro hy
{ intro hy, refine ‚ü®x, (encodable.decode‚ÇÇ_is_partial_inv _ _).2 rfl, hy‚ü© }
refine ‚ü®x, (encodable.decode‚ÇÇ_is_partial_inv _ _).2 rfl, hy‚ü©
rintro ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©
{ rintro ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©, rw (encodable.decode‚ÇÇ_is_partial_inv _ _) at hb‚ÇÅ, rwa ‚Üê encodable.encode_injective hb‚ÇÅ }
rw (encodable.decode‚ÇÇ_is_partial_inv _ _) at hb‚ÇÅ
rwa ‚Üê encodable.encode_injective hb‚ÇÅ
rw [summable.has_sum_iff, this, ‚Üê tsum_Union_decode‚ÇÇ]
{ exact v.empty }
exact v.empty
rw hg‚ÇÉ
{ rw hg‚ÇÉ, change summable ((Œª i, v (g i)) ‚àò encodable.encode), rw function.injective.summable_iff encodable.encode_injective, { exact (v.m_Union hg‚ÇÅ hg‚ÇÇ).summable }, { intros x hx, convert v.empty, simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at ‚ä¢ hx, intros i hi, exact false.elim ((hx i) ((encodable.decode‚ÇÇ_is_partial_inv _ _).1 hi)) } }
change summable ((Œª i, v (g i)) ‚àò encodable.encode)
rw function.injective.summable_iff encodable.encode_injective
{ exact (v.m_Union hg‚ÇÅ hg‚ÇÇ).summable }
exact (v.m_Union hg‚ÇÅ hg‚ÇÇ).summable
intros x hx
{ intros x hx, convert v.empty, simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at ‚ä¢ hx, intros i hi, exact false.elim ((hx i) ((encodable.decode‚ÇÇ_is_partial_inv _ _).1 hi)) }
convert v.empty
simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at ‚ä¢ hx
intros i hi
exact false.elim ((hx i) ((encodable.decode‚ÇÇ_is_partial_inv _ _).1 hi))
intros
rw [sub_eq_add_neg, sub_eq_add_neg, with_density·µ•_add hf hg.neg, with_density·µ•_neg]
intros
simp [map]
intros
ext x
rw [ppow_apply (nat.succ_pos k), pow_succ']
induction k; simp
induction k
simp
simp
intros
simp [bernoulli, ‚Üê mul_assoc, ‚Üê sq, ‚Üê pow_mul, mul_comm n 2, pow_mul]
intros
apply finset.ext
simp only [h, mem_filter, and_true, and_iff_right_iff_imp, cast_id, mem_range, ne.def, not_false_iff, mem_divisors]
intros a ha
exact nat.lt_succ_of_le (nat.divisor_le (nat.mem_divisors.2 ‚ü®ha, h‚ü©))
intros
cases i; simp [s_mod]
cases i
simp [s_mod]
simp [s_mod]
intros
{ dsimp [s_mod, mersenne], rw [h1, h2, sq, h3] }
dsimp [s_mod, mersenne]
rw [h1, h2, sq, h3]
intros
simp [has_norm.norm, padic_norm_e.mul']
intros
injection (pell_zd_add _ m n) with h _; repeat {rw ‚Üê int.coe_nat_add at h <|> rw ‚Üê int.coe_nat_mul at h}; exact int.coe_nat_inj h
injection (pell_zd_add _ m n) with h _; repeat {rw ‚Üê int.coe_nat_add at h <|> rw ‚Üê int.coe_nat_mul at h}
injection (pell_zd_add _ m n) with h _
repeat {rw ‚Üê int.coe_nat_add at h <|> rw ‚Üê int.coe_nat_mul at h}
rw ‚Üê int.coe_nat_add at h
rw ‚Üê int.coe_nat_mul at h
exact int.coe_nat_inj h
intros
split
intro h
{ intro h, obtain ‚ü®k, m, n, H‚ü© := h.classified, use [k, m, n], rcases H with ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, { refine ‚ü®or.inl ‚ü®rfl, rfl‚ü©, _‚ü©, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ‚Üê h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this }, { refine ‚ü®or.inr ‚ü®rfl, rfl‚ü©, _‚ü©, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ‚Üê h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this } }
obtain ‚ü®k, m, n, H‚ü© := h.classified
use [k, m, n]
rcases H with ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©
refine ‚ü®or.inl ‚ü®rfl, rfl‚ü©, _‚ü©
{ refine ‚ü®or.inl ‚ü®rfl, rfl‚ü©, _‚ü©, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ‚Üê h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this }
have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2
{ rw [sq, ‚Üê h.eq], ring }
rw [sq, ‚Üê h.eq]
ring
simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this
refine ‚ü®or.inr ‚ü®rfl, rfl‚ü©, _‚ü©
{ refine ‚ü®or.inr ‚ü®rfl, rfl‚ü©, _‚ü©, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ‚Üê h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this }
have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2
{ rw [sq, ‚Üê h.eq], ring }
rw [sq, ‚Üê h.eq]
ring
simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this
rintro ‚ü®k, m, n, ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, rfl | rfl‚ü©; delta pythagorean_triple; ring
rintro ‚ü®k, m, n, ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, rfl | rfl‚ü©; delta pythagorean_triple
rintro ‚ü®k, m, n, ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, rfl | rfl‚ü©
{ rintro ‚ü®k, m, n, ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, rfl | rfl‚ü©; delta pythagorean_triple; ring }
delta pythagorean_triple
ring
delta pythagorean_triple
ring
delta pythagorean_triple
ring
delta pythagorean_triple
ring
intros
apply sq_add_sq_of_nat_prime_of_not_irreducible p
rw [principal_ideal_ring.irreducible_iff_prime, prime_iff_mod_four_eq_three_of_nat_prime p, hp1]
norm_num
intros
refine ‚ü®_, _, _, _‚ü©; { intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
refine ‚ü®_, _, _, _‚ü©
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
intros xy zw
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw))
refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _)
convert this
simp only [one_mul, int.coe_nat_add, int.coe_nat_mul]
ring
intros
simp [to_complex_def]
intros
{ ext x y, exact H x y }
ext x y
exact H x y
intros
rw sup_eq_left
{ rw sup_eq_left, exact sdiff_le }
exact sdiff_le
intros
rw [sdiff_sdiff_left, sdiff_sup]
intros
simp [(‚â§)]
intros
exact is_greatest_singleton.union hs
intros
simp only [‚Üê Sup_range, Sup_eq_top, set.exists_range_iff]
intros
rw [supr, supr, ‚Üê image_eq_range, ‚Üê range_comp]
intros
ext n
induction n with k ih
rw [partial_sups_zero, partial_sups_zero, disjointed_zero]
{ rw [partial_sups_zero, partial_sups_zero, disjointed_zero] }
rw [partial_sups_succ, partial_sups_succ, disjointed_succ, ih, sup_sdiff_self_right]
{ rw [partial_sups_succ, partial_sups_succ, disjointed_succ, ih, sup_sdiff_self_right] }
intros
simp [at_top, ‚Üê e.surjective.infi_comp]
intros
simp only [tendsto_def, mem_at_top_sets]; refl
simp only [tendsto_def, mem_at_top_sets]
refl
intros
simpa using hl.mem_iff
intros
simp only [filter.frequently, eventually_sup, not_and_distrib]
intros
refine le_antisymm (le_map $ Œª s hs, _) (le_seq $ Œª s hs t ht, _)
rw ‚Üê seq_singleton
{ rw ‚Üê seq_singleton, exact seq_mem_seq hs singleton_mem_pure }
exact seq_mem_seq hs singleton_mem_pure
refine sets_of_superset (map (Œªg:Œ±‚ÜíŒ≤, g a) f) (image_mem_map hs) _
{ refine sets_of_superset (map (Œªg:Œ±‚ÜíŒ≤, g a) f) (image_mem_map hs) _, rintro b ‚ü®g, hg, rfl‚ü©, exact ‚ü®g, hg, a, ht, rfl‚ü© }
rintro b ‚ü®g, hg, rfl‚ü©
exact ‚ü®g, hg, a, ht, rfl‚ü©
intros
rw [filter.prod, comap_sup, inf_sup_left, ‚Üê filter.prod, ‚Üê filter.prod]
intros
rw [mem_top_iff_forall, eq_univ_iff_forall]
intros
simp only [bUnion_eq_Union]
haveI := hS.to_encodable
exact eventually_le.countable_Union (Œª i, h i i.2)
intros
simp
intros
rw [limsup_eq, eq_bot_iff]
exact Inf_le (eventually_of_forall (Œª x, le_refl _))
intros
rw [symm_diff_eq_sup_sdiff_inf]
exact disjoint_sdiff_self_left
intros
rw [iff_forall_not_is_bad_seq, ‚Üê not_exists, not_congr]
split
{ apply exists_min_bad_of_exists_bad }
apply exists_min_bad_of_exists_bad
rintro ‚ü®f, hf1, hf2‚ü©
exact ‚ü®f, hf1‚ü©
intros
rw [‚Üê mk_C x, lift_mk, eval‚ÇÇ_C]
intros
{ rcases h with ‚ü®p, hp, hpx‚ü©, exact ‚ü®p, hp.ne_zero, hpx‚ü© }
rcases h with ‚ü®p, hp, hpx‚ü©
exact ‚ü®p, hp.ne_zero, hpx‚ü©
intros
rw [‚Üê finset.card_range m, ‚Üê finset.prod_const]
{ rw [‚Üê finset.card_range m, ‚Üê finset.prod_const], exact is_coprime.prod_left (Œª _ _, H) }
exact is_coprime.prod_left (Œª _ _, H)
intros
obtain rfl : m = n := unit_mul_pow_congr_pow hirr hirr u v m n h
rw ‚Üê sub_eq_zero at h
rw [‚Üê sub_mul, mul_eq_zero] at h
cases h
{ rw sub_eq_zero at h, exact_mod_cast h }
rw sub_eq_zero at h
exact_mod_cast h
{ apply (hirr.ne_zero (pow_eq_zero h)).elim, }
apply (hirr.ne_zero (pow_eq_zero h)).elim
intros
ext y
refine (mem_coe_ideal S).trans (iff.trans _ (mem_span_singleton S).symm)
split
rintros ‚ü®y', hy', rfl‚ü©
{ rintros ‚ü®y', hy', rfl‚ü©, obtain ‚ü®x', rfl‚ü© := submodule.mem_span_singleton.mp hy', use x', rw [smul_eq_mul, ring_hom.map_mul, algebra.smul_def] }
obtain ‚ü®x', rfl‚ü© := submodule.mem_span_singleton.mp hy'
use x'
rw [smul_eq_mul, ring_hom.map_mul, algebra.smul_def]
rintros ‚ü®y', rfl‚ü©
{ rintros ‚ü®y', rfl‚ü©, refine ‚ü®y' * x, submodule.mem_span_singleton.mpr ‚ü®y', rfl‚ü©, _‚ü©, rw [ring_hom.map_mul, algebra.smul_def] }
refine ‚ü®y' * x, submodule.mem_span_singleton.mpr ‚ü®y', rfl‚ü©, _‚ü©
rw [ring_hom.map_mul, algebra.smul_def]
intros
ext x
simp only [mem_coe_ideal]
split
rintro ‚ü®_, ‚ü®y, hy, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®_, ‚ü®y, hy, rfl‚ü©, rfl‚ü©, exact ‚ü®y, hy, (g.commutes y).symm‚ü© }
exact ‚ü®y, hy, (g.commutes y).symm‚ü©
rintro ‚ü®y, hy, rfl‚ü©
{ rintro ‚ü®y, hy, rfl‚ü©, exact ‚ü®_, ‚ü®y, hy, rfl‚ü©, g.commutes y‚ü© }
exact ‚ü®_, ‚ü®y, hy, rfl‚ü©, g.commutes y‚ü©
intros
by_contradiction hnonmax
rcases exists_le_maximal J hnonmax with ‚ü®M, hM1, hM2‚ü©
exact hmax M (lt_of_lt_of_le hPJ hM2) hM1
intros
split
intro h
{ intro h, obtain ‚ü®x, nz, nu‚ü© := exists_not_is_unit_of_not_is_field h, use ideal.span {x}, rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top], exact ‚ü®mt ideal.span_singleton_eq_bot.mp nz, mt ideal.span_singleton_eq_top.mp nu‚ü© }
obtain ‚ü®x, nz, nu‚ü© := exists_not_is_unit_of_not_is_field h
use ideal.span {x}
rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top]
exact ‚ü®mt ideal.span_singleton_eq_bot.mp nz, mt ideal.span_singleton_eq_top.mp nu‚ü©
rintros ‚ü®I, bot_lt, lt_top‚ü© hf
{ rintros ‚ü®I, bot_lt, lt_top‚ü© hf, obtain ‚ü®x, mem, ne_zero‚ü© := set_like.exists_of_lt bot_lt, rw submodule.mem_bot at ne_zero, obtain ‚ü®y, hy‚ü© := hf.mul_inv_cancel ne_zero, rw [lt_top_iff_ne_top, ne.def, ideal.eq_top_iff_one, ‚Üê hy] at lt_top, exact lt_top (I.mul_mem_right _ mem), }
obtain ‚ü®x, mem, ne_zero‚ü© := set_like.exists_of_lt bot_lt
rw submodule.mem_bot at ne_zero
obtain ‚ü®y, hy‚ü© := hf.mul_inv_cancel ne_zero
rw [lt_top_iff_ne_top, ne.def, ideal.eq_top_iff_one, ‚Üê hy] at lt_top
exact lt_top (I.mul_mem_right _ mem)
intros
refine ideal.is_maximal_iff.mpr ‚ü®Œª h1, @one_ne_zero K _ _ $ f.map_one ‚ñ∏ f.mem_ker.mp h1, Œª J x hJ hxf hxJ, _‚ü©
obtain ‚ü®y, hy‚ü© := hf (f x)‚Åª¬π
have H : 1 = y * x - (y * x - 1) := (sub_sub_cancel _ _).symm
rw H
refine J.sub_mem (J.mul_mem_left _ hxJ) (hJ _)
rw f.mem_ker
simp only [hy, ring_hom.map_sub, ring_hom.map_one, ring_hom.map_mul, inv_mul_cancel (mt f.mem_ker.mpr hxf), sub_self]
intros
induction n with n ih
simp only [pow_zero, ideal.one_eq_top]
{ simp only [pow_zero, ideal.one_eq_top], }
simpa only [pow_succ] using mul_mem_mul hx ih
intros
rw [ne.def, eq_top_iff_not_finite, not_not]
intros
intros v hv
rcases hpq with ‚ü®p', q', hpq'‚ü©
simpa [linear_map.mem_ker.1 (submodule.mem_inf.1 hv).1, linear_map.mem_ker.1 (submodule.mem_inf.1 hv).2] using congr_arg (Œª p : polynomial R, aeval f p v) hpq'.symm
intros
classical
have h : ‚àÉ (n : ‚Ñï) (r : polynomial R), r.nat_degree = n ‚àß r.is_primitive ‚àß p ‚à£ r ‚àß q ‚à£ r := ‚ü®(p * q).nat_degree, p * q, rfl, hp.mul hq, dvd_mul_right _ _, dvd_mul_left _ _‚ü©
rcases nat.find_spec h with ‚ü®r, rdeg, rprim, pr, qr‚ü©
refine ‚ü®r, rprim, Œª s, ‚ü®_, Œª rs, ‚ü®pr.trans rs, qr.trans rs‚ü©‚ü©‚ü©
suffices hs : ‚àÄ (n : ‚Ñï) (s : polynomial R), s.nat_degree = n ‚Üí (p ‚à£ s ‚àß q ‚à£ s ‚Üí r ‚à£ s)
{ apply hs s.nat_degree s rfl }
apply hs s.nat_degree s rfl
clear s
by_contra con
push_neg at con
rcases nat.find_spec con with ‚ü®s, sdeg, ‚ü®ps, qs‚ü©, rs‚ü©
have s0 : s ‚â† 0
{ contrapose! rs, simp [rs] }
contrapose! rs
simp [rs]
have hs := nat.find_min' h ‚ü®_, s.nat_degree_prim_part, s.is_primitive_prim_part, (hp.dvd_prim_part_iff_dvd s0).2 ps, (hq.dvd_prim_part_iff_dvd s0).2 qs‚ü©
rw ‚Üê rdeg at hs
by_cases sC : s.nat_degree ‚â§ 0
rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), is_primitive_iff_content_eq_one, content_C, normalize_eq_one] at rprim
{ rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), is_primitive_iff_content_eq_one, content_C, normalize_eq_one] at rprim, rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), ‚Üê dvd_content_iff_C_dvd] at rs, apply rs rprim.dvd }
rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), ‚Üê dvd_content_iff_C_dvd] at rs
apply rs rprim.dvd
have hcancel := nat_degree_cancel_leads_lt_of_nat_degree_le_nat_degree hs (lt_of_not_ge sC)
rw sdeg at hcancel
apply nat.find_min con hcancel
refine ‚ü®_, rfl, ‚ü®dvd_cancel_leads_of_dvd_of_dvd pr ps, dvd_cancel_leads_of_dvd_of_dvd qr qs‚ü©, Œª rcs, rs _‚ü©
rw ‚Üê rprim.dvd_prim_part_iff_dvd s0
rw [cancel_leads, nat.sub_eq_zero_of_le hs, pow_zero, mul_one] at rcs
have h := dvd_add rcs (dvd.intro_left _ rfl)
have hC0 := rprim.ne_zero
rw [ne.def, ‚Üê leading_coeff_eq_zero, ‚Üê C_eq_zero] at hC0
rw [sub_add_cancel, ‚Üê rprim.dvd_prim_part_iff_dvd (mul_ne_zero hC0 s0)] at h
rcases is_unit_prim_part_C r.leading_coeff with ‚ü®u, hu‚ü©
apply h.trans (associated.symm ‚ü®u, _‚ü©).dvd
rw [prim_part_mul (mul_ne_zero hC0 s0), hu, mul_comm]
intros
rw submodule.mul_le
intros œÜ hœÜ œà hœà c hc
rw [coeff_mul] at hc
obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := finset.exists_ne_zero_of_sum_ne_zero hc
have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0
contrapose! H
{ contrapose! H, by_cases h : coeff d œÜ = 0; simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at * }
by_cases h : coeff d œÜ = 0; simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at *
by_cases h : coeff d œÜ = 0
simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at *
simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at *
specialize hœÜ aux.1
specialize hœà aux.2
rw finsupp.mem_antidiagonal at hde
classical
have hd' : d.support ‚äÜ d.support ‚à™ e.support := finset.subset_union_left _ _
have he' : e.support ‚äÜ d.support ‚à™ e.support := finset.subset_union_right _ _
rw [‚Üê hde, ‚Üê hœÜ, ‚Üê hœà, finset.sum_subset (finsupp.support_add), finset.sum_subset hd', finset.sum_subset he', ‚Üê finset.sum_add_distrib]
{ congr }
congr
intros i hi
all_goals { intros i hi, apply finsupp.not_mem_support_iff.mp }
apply finsupp.not_mem_support_iff.mp
intros i hi
apply finsupp.not_mem_support_iff.mp
intros i hi
apply finsupp.not_mem_support_iff.mp
intros
rw [mul_add, add_comp, mul_X_comp, ‚Üênat.cast_comm, nat_cast_mul_comp, nat.cast_comm, mul_add]
intros
rw ‚Üê ideal.span_singleton_prime
{ exact span_X_is_prime }
exact span_X_is_prime
{ intro h, simpa using congr_arg (coeff R 1) h }
intro h
simpa using congr_arg (coeff R 1) h
intros
rw [X_eq, coeff_monomial]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [witt_mul, witt_structure_rat, rename_X, X_in_terms_of_W_zero, map_X, witt_polynomial_zero, ring_hom.map_mul, bind‚ÇÅ_X_right, alg_hom.map_mul, map_witt_structure_int]
intros
dsimp [select, select_poly]
split_ifs with hi
{ rw aeval_X }
rw aeval_X
{ rw alg_hom.map_zero }
rw alg_hom.map_zero
intros
induction n with n ih generalizing k
simp only [nat.nat_zero_eq_zero, nat.cast_zero, mul_zero, zero_coeff, witt_mul_n, alg_hom.map_zero, pi.zero_apply]
{ simp only [nat.nat_zero_eq_zero, nat.cast_zero, mul_zero, zero_coeff, witt_mul_n, alg_hom.map_zero, pi.zero_apply], }
rw [witt_mul_n, nat.succ_eq_add_one, nat.cast_add, nat.cast_one, mul_add, mul_one, aeval_bind‚ÇÅ, add_coeff]
{ rw [witt_mul_n, nat.succ_eq_add_one, nat.cast_add, nat.cast_one, mul_add, mul_one, aeval_bind‚ÇÅ, add_coeff], apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl, ext1 ‚ü®b, i‚ü©, fin_cases b, { simp only [function.uncurry, matrix.cons_val_zero, ih] }, { simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X] } }
apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl
ext1 ‚ü®b, i‚ü©
fin_cases b
{ simp only [function.uncurry, matrix.cons_val_zero, ih] }
simp only [function.uncurry, matrix.cons_val_zero, ih]
simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X]
{ simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X] }
intros
simp only [ring_hom.mem_ker, truncate, truncate_fun, ring_hom.coe_mk, truncated_witt_vector.ext_iff, truncated_witt_vector.coeff_mk, coeff_zero]
exact subtype.forall
intros
rw [X_in_terms_of_W_eq, mul_assoc, ‚Üê C_mul, ‚Üê mul_pow, inv_of_mul_self, one_pow, C_1, mul_one]
intros
simp [bit0]
intros
simp [bit1]
intros
cases a; simp [cons]
cases a
simp [cons]
intros
simp only [le_antisymm_iff, ordinal.zero_le, and_true]
rw lt_def; exact or.inr ‚ü®‚ü®0, zero_lt_one‚ü©, (by split; rintros ‚ü®‚ü©)‚ü©
rw lt_def
exact or.inr ‚ü®‚ü®0, zero_lt_one‚ü©, (by split; rintros ‚ü®‚ü©)‚ü©
intros
rw lt_def_le
left
use i
intros
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, termg]; ac_refl
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, termg]
ac_refl
intros
apply val_between_set
apply zero_le
apply lt_of_lt_of_le (lt_add_one _)
simp only [length_set, zero_add, le_max_right]
apply_instance
intros
simp [mul_assoc]
intros
rwa div_eq_mul_inv
intros
simp
intros
simpa only [add_comm] using ((has_sum_nat_add_iff k).1 ((summable_nat_add_iff k).2 h).has_sum).unique h.has_sum
intros
have hx‚ÇÄ' : 0 < abs x‚ÇÄ := abs_pos.2 hx‚ÇÄ
refine filter.ext (Œª t, _)
simp only [exists_prop, set_of_subset_set_of, (nhds_basis_abs_sub_lt x‚ÇÄ).mem_iff, (nhds_basis_abs_sub_lt (1 : Œ±)).mem_iff, filter.mem_map']
refine ‚ü®Œª h, _, Œª h, _‚ü©
obtain ‚ü®i, hi, hit‚ü© := h
{ obtain ‚ü®i, hi, hit‚ü© := h, refine ‚ü®i / (abs x‚ÇÄ), div_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, hit _‚ü©, calc abs (x‚ÇÄ * x - x‚ÇÄ) = abs (x‚ÇÄ * (x - 1)) : congr_arg abs (by ring_nf) ... = abs x‚ÇÄ * abs (x - 1) : abs_mul x‚ÇÄ (x - 1) ... < abs x‚ÇÄ * (i / abs x‚ÇÄ) : mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hx‚ÇÄ) ... = abs x‚ÇÄ * i / abs x‚ÇÄ : by ring ... = i : mul_div_cancel_left i (Œª h, hx‚ÇÄ (abs_eq_zero.1 h)) }
refine ‚ü®i / (abs x‚ÇÄ), div_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, hit _‚ü©
calc abs (x‚ÇÄ * x - x‚ÇÄ) = abs (x‚ÇÄ * (x - 1)) : congr_arg abs (by ring_nf) ... = abs x‚ÇÄ * abs (x - 1) : abs_mul x‚ÇÄ (x - 1) ... < abs x‚ÇÄ * (i / abs x‚ÇÄ) : mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hx‚ÇÄ) ... = abs x‚ÇÄ * i / abs x‚ÇÄ : by ring ... = i : mul_div_cancel_left i (Œª h, hx‚ÇÄ (abs_eq_zero.1 h))
obtain ‚ü®i, hi, hit‚ü© := h
{ obtain ‚ü®i, hi, hit‚ü© := h, refine ‚ü®i * (abs x‚ÇÄ), mul_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, _‚ü©, have : abs (x / x‚ÇÄ - 1) < i, calc abs (x / x‚ÇÄ - 1) = abs (x / x‚ÇÄ - x‚ÇÄ / x‚ÇÄ) : (by rw div_self hx‚ÇÄ) ... = abs ((x - x‚ÇÄ) / x‚ÇÄ) : congr_arg abs (sub_div x x‚ÇÄ x‚ÇÄ).symm ... = abs (x - x‚ÇÄ) / abs x‚ÇÄ : abs_div (x - x‚ÇÄ) x‚ÇÄ ... < i * abs x‚ÇÄ / abs x‚ÇÄ : div_lt_div hx le_rfl (mul_nonneg (le_of_lt hi) (abs_nonneg x‚ÇÄ)) (abs_pos.2 hx‚ÇÄ) ... = i : by rw [‚Üê mul_div_assoc', div_self (ne_of_lt $ abs_pos.2 hx‚ÇÄ).symm, mul_one], specialize hit (x / x‚ÇÄ) this, rwa [mul_div_assoc', mul_div_cancel_left x hx‚ÇÄ] at hit }
refine ‚ü®i * (abs x‚ÇÄ), mul_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, _‚ü©
have : abs (x / x‚ÇÄ - 1) < i
calc abs (x / x‚ÇÄ - 1) = abs (x / x‚ÇÄ - x‚ÇÄ / x‚ÇÄ) : (by rw div_self hx‚ÇÄ) ... = abs ((x - x‚ÇÄ) / x‚ÇÄ) : congr_arg abs (sub_div x x‚ÇÄ x‚ÇÄ).symm ... = abs (x - x‚ÇÄ) / abs x‚ÇÄ : abs_div (x - x‚ÇÄ) x‚ÇÄ ... < i * abs x‚ÇÄ / abs x‚ÇÄ : div_lt_div hx le_rfl (mul_nonneg (le_of_lt hi) (abs_nonneg x‚ÇÄ)) (abs_pos.2 hx‚ÇÄ) ... = i : by rw [‚Üê mul_div_assoc', div_self (ne_of_lt $ abs_pos.2 hx‚ÇÄ).symm, mul_one]
specialize hit (x / x‚ÇÄ) this
rwa [mul_div_assoc', mul_div_cancel_left x hx‚ÇÄ] at hit
intros
rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]
intros
assume y hy
have : is_closed (s ‚à© Icc a y)
suffices : s ‚à© Icc a y = s ‚à© Icc a b ‚à© Icc a y
{ suffices : s ‚à© Icc a y = s ‚à© Icc a b ‚à© Icc a y, { rw this, exact is_closed.inter hs is_closed_Icc }, rw [inter_assoc], congr, exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm }
{ rw this, exact is_closed.inter hs is_closed_Icc }
rw this
exact is_closed.inter hs is_closed_Icc
rw [inter_assoc]
congr
exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm
exact is_closed.mem_of_ge_of_forall_exists_gt this ha hy.1 (Œª x hx, hgt x ‚ü®hx.1, Ico_subset_Ico_right hy.2 hx.2‚ü© y hx.2.2)
intros
rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©
rw [@is_open_iff_generate_intervals Œ± _ _ t]
exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©
intros
rw ‚Üê sUnion_empty; exact is_open_sUnion (assume a, false.elim)
rw ‚Üê sUnion_empty
exact is_open_sUnion (assume a, false.elim)
intros
rw [dense, dense, closure_closure]
intros
rw ‚Üê is_open_compl_iff
split
intros cond F h
{ intros cond F h, by_contradiction c, specialize cond F c, rw compl_mem_iff_not_mem at cond, contradiction }
by_contradiction c
specialize cond F c
rw compl_mem_iff_not_mem at cond
contradiction
intros h1 F h2
{ intros h1 F h2, specialize h1 F, cases F.mem_or_compl_mem S; finish }
specialize h1 F
cases F.mem_or_compl_mem S; finish
cases F.mem_or_compl_mem S
finish
finish
intros
simp
intros
rcases H with ‚ü®x, hx‚ü©
refine ‚ü®‚ü®x, mem_union_left t (mem_of_mem_inter_left hx)‚ü©, _‚ü©
exact is_preconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx) Hs.is_preconnected Ht.is_preconnected
intros
rw [filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]
intros
intros u hu
rw is_open_sum_iff at hu
cases hu with hu‚ÇÅ hu‚ÇÇ
have : u = inl '' (inl ‚Åª¬π' u) ‚à™ inr '' (inr ‚Åª¬π' u)
ext (_|_); simp
{ ext (_|_); simp }
ext (_|_)
simp
simp
rw [this, set.image_union, set.image_image, set.image_image]
exact is_open.union (h‚ÇÅ _ hu‚ÇÅ) (h‚ÇÇ _ hu‚ÇÇ)
intros
refine ‚ü®‚ü®_‚ü©, function.injective_id.sigma_map (Œª i, (hf i).inj)‚ü©
refine le_antisymm (continuous_iff_le_induced.mp (continuous_sigma_map (Œª i, (hf i).continuous))) _
intros s hs
replace hs := is_open_sigma_iff.mp hs
have : ‚àÄ i, ‚àÉ t, is_open t ‚àß f i ‚Åª¬π' t = sigma.mk i ‚Åª¬π' s
intro i
{ intro i, apply is_open_induced_iff.mp, convert hs i, exact (hf i).induced.symm }
apply is_open_induced_iff.mp
convert hs i
exact (hf i).induced.symm
choose t ht using this
apply is_open_induced_iff.mpr
refine ‚ü®‚ãÉ i, sigma.mk i '' t i, is_open_Union (Œª i, is_open_map_sigma_mk _ (ht i).1), _‚ü©
ext ‚ü®i, x‚ü©
change (sigma.mk i (f i x) ‚àà ‚ãÉ (i : Œπ), sigma.mk i '' t i) ‚Üî x ‚àà sigma.mk i ‚Åª¬π' s
rw [‚Üê(ht i).2, mem_Union]
split
rintro ‚ü®j, hj‚ü©
{ rintro ‚ü®j, hj‚ü©, rw mem_image at hj, rcases hj with ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©, rcases sigma.mk.inj_iff.mp hy‚ÇÇ with ‚ü®rfl, hy‚ü©, replace hy := eq_of_heq hy, subst y, exact hy‚ÇÅ }
rw mem_image at hj
rcases hj with ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©
rcases sigma.mk.inj_iff.mp hy‚ÇÇ with ‚ü®rfl, hy‚ü©
replace hy := eq_of_heq hy
subst y
exact hy‚ÇÅ
intro hx
{ intro hx, use i, rw mem_image, exact ‚ü®f i x, hx, rfl‚ü© }
use i
rw mem_image
exact ‚ü®f i x, hx, rfl‚ü©
intros
simp [continuous_within_at, nhds_within_restrict'' s h]
intros
rw continuous_iff_continuous_on_univ
apply continuous_on.if; simp; assumption
apply continuous_on.if; simp
apply continuous_on.if
simp
assumption
simp
assumption
simp
assumption
intros
haveI := mem_closure_iff_nhds_within_ne_bot.mp hx
exact tendsto_nhds_unique (tendsto_nhds_lim ‚ü®y, hf‚ü©) hf
intros
rw [‚Üê (e.is_image_preimage_prod s).frontier.preimage_eq, frontier_prod_univ_eq, (e.is_image_preimage_prod _).preimage_eq, e.source_eq, preimage_inter]
intros
simp only [ennreal.tendsto_nhds ha, mem_at_top_sets, mem_set_of_eq, filter.eventually]
intros
simpa only [closure_compl, compl_compl] using h.compl.closure.compl
intros
simp only [antilipschitz_with_iff_le_mul_nndist, dist_nndist]
{ simp only [antilipschitz_with_iff_le_mul_nndist, dist_nndist], norm_cast }
norm_cast
intros
simp only [diam_le_iff, ball_image_iff]
intros
simp [mem_closure_iff_inf_edist_zero, inf_dist, ennreal.to_real_eq_zero_iff, inf_edist_ne_top h]
intros
simp only [holder_on_with, lipschitz_on_with, nnreal.coe_one, ennreal.rpow_one]
intros
refine (nhds_basis_ball.tendsto_iff nhds_basis_closed_ball).2 (ŒªŒµ Œµpos, ‚ü®min r (Œµ / max K 1), _, Œª y hy, _‚ü©)
{ simp [hr, div_pos Œµpos, zero_lt_one] }
simp [hr, div_pos Œµpos, zero_lt_one]
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ‚â† 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
calc dist (f y) (f x) ‚â§ K * dist y x : h y (lt_of_lt_of_le hy (min_le_left _ _)) ... ‚â§ max K 1 * dist y x : mul_le_mul_of_nonneg_right (le_max_left K 1) dist_nonneg ... ‚â§ max K 1 * (Œµ / max K 1) : mul_le_mul_of_nonneg_left (le_of_lt (lt_of_lt_of_le hy (min_le_right _ _))) (le_trans zero_le_one (le_max_right K 1)) ... = Œµ : mul_div_cancel' _ A
intros
rcases precise_refinement_set hs _ ho hU with ‚ü®V, hVo, hsV, hVf, hVU‚ü©
rcases exists_is_subordinate_of_locally_finite_of_prop p h01 hs V hVo hVf hsV with ‚ü®f, hfp, hf‚ü©
exact ‚ü®f, hfp, hf.mono hVU‚ü©
intros
cases h.mem with hx hy
simp [joined_in_iff_joined, *] at *
exact h.symm
intros
simp_rw ennreal.tsum_eq_supr_sum
apply lower_semicontinuous_within_at_supr (Œª b, _)
exact lower_semicontinuous_within_at_sum (Œª i hi, h i)
intros
change tX.induced ((coe : s ‚Üí X) ‚àò (set.inclusion ts)) = topological_space.induced (set.inclusion ts) (tX.induced _)
rw ‚Üê induced_compose
intros
apply stalk_to_fiber_surjective
intro t
obtain ‚ü®U, m, s, rfl‚ü© := F.germ_exist _ t
use ‚ü®U, m‚ü©
{ use ‚ü®U, m‚ü©, fsplit, { exact Œª y, F.germ y s, }, { exact ‚ü®prelocal_predicate.sheafify_of ‚ü®s, (Œª _, rfl)‚ü©, rfl‚ü©, }, }
fsplit
{ exact Œª y, F.germ y s, }
exact Œª y, F.germ y s
{ exact ‚ü®prelocal_predicate.sheafify_of ‚ü®s, (Œª _, rfl)‚ü©, rfl‚ü©, }
exact ‚ü®prelocal_predicate.sheafify_of ‚ü®s, (Œª _, rfl)‚ü©, rfl‚ü©
intros
rcases locally_compact_space.local_compact_nhds x U (hU.mem_nhds hx) with ‚ü®K, h1K, h2K, h3K‚ü©
exact ‚ü®K, h3K, mem_interior_iff_mem_nhds.2 h1K, h2K‚ü©
intros
rw [uniform_continuous‚ÇÇ, uncurry_curry]
intros
tauto
intros
rw [uniform_continuous_on, uniform_continuous, univ_prod_univ, principal_univ, inf_top_eq]
intros
assume s hs
rcases comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 hs) with ‚ü®U, U_mem, hU‚ü©
rcases adhs U U_mem with ‚ü®t, t_mem, ht, y, hxy, hy‚ü©
apply mem_of_superset t_mem
exact (Œª z hz, hU (prod_mk_mem_comp_rel hxy (ht $ mk_mem_prod hy hz)) rfl)
intros
rw [odd_eq, nth_even]
refl
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
apply ne_of_vne
rw [val_of_nat_eq_of_is_valid h‚ÇÇ, val_of_nat_eq_of_is_valid h‚ÇÉ]
assumption
intros
rw int.add_comm at h
exact int.le_add_of_sub_left_le h
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
cases n; simp [gcd, mod_self]
cases n
simp [gcd, mod_self]
simp [gcd, mod_self]
intros
cases k.eq_zero_or_pos with k0 kpos
rw [k0, nat.mul_zero, nat.div_zero, nat.div_zero]
{rw [k0, nat.mul_zero, nat.div_zero, nat.div_zero]}
cases n.eq_zero_or_pos with n0 npos
rw [n0, nat.zero_mul, nat.div_zero, nat.zero_div]
{rw [n0, nat.zero_mul, nat.div_zero, nat.zero_div]}
apply le_antisymm
apply (le_div_iff_mul_le _ _ (nat.mul_pos npos kpos)).2
{ apply (le_div_iff_mul_le _ _ (nat.mul_pos npos kpos)).2, rw [nat.mul_comm n k, ‚Üê nat.mul_assoc], apply (le_div_iff_mul_le _ _ npos).1, apply (le_div_iff_mul_le _ _ kpos).1, refl }
rw [nat.mul_comm n k, ‚Üê nat.mul_assoc]
apply (le_div_iff_mul_le _ _ npos).1
apply (le_div_iff_mul_le _ _ kpos).1
refl
apply (le_div_iff_mul_le _ _ kpos).2
{ apply (le_div_iff_mul_le _ _ kpos).2, apply (le_div_iff_mul_le _ _ npos).2, rw [nat.mul_assoc, nat.mul_comm n k], apply (le_div_iff_mul_le _ _ (nat.mul_pos kpos npos)).1, refl }
apply (le_div_iff_mul_le _ _ npos).2
rw [nat.mul_assoc, nat.mul_comm n k]
apply (le_div_iff_mul_le _ _ (nat.mul_pos kpos npos)).1
refl
intros
rw [div_def]
simp [lt_irrefl]
intros
{ ext, refl }
ext
refl
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
nontriviality Œ±
exact (exists_nat_gt x).imp (Œª n, le_of_lt)
intros
refine prod_bij i hi h _ _
intros a1 a2 h1 h2 eq
{intros a1 a2 h1 h2 eq, rw [‚Üêleft_inv a1 h1, ‚Üêleft_inv a2 h2], cc,}
rw [‚Üêleft_inv a1 h1, ‚Üêleft_inv a2 h2]
cc
intros b hb
{intros b hb, use j b hb, use hj b hb, exact (right_inv b hb).symm,}
use j b hb
use hj b hb
exact (right_inv b hb).symm
intros
have : mul_support (Œª x : plift Œ±, (Œª _, 1 : Œ± ‚Üí M) x.down) ‚äÜ (‚àÖ : finset (plift Œ±))
from Œª x h, h rfl
rw [finprod_eq_prod_plift_of_mul_support_subset this, finset.prod_empty]
intros
rw [‚Üê finprod_mem_union_inter' hs ht, disjoint_iff_inter_eq_empty.1 hst, finprod_mem_empty, mul_one]
intros
classical
simp_rw [prod_eq_mul_prod_diff_singleton hi]
refine le_trans _ (mul_le_mul_right' h2i _)
rw [right_distrib]
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]; intros; apply_assumption; assumption
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]; intros; apply_assumption
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]; intros
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'
apply add_le_add; apply mul_le_mul_left'
apply add_le_add
apply mul_le_mul_left'
apply prod_le_prod'
simp only [and_imp, mem_sdiff, mem_singleton]
intros
apply_assumption
assumption
assumption
assumption
assumption
apply mul_le_mul_left'
apply prod_le_prod'
simp only [and_imp, mem_sdiff, mem_singleton]
intros
apply_assumption
assumption
assumption
assumption
assumption
intros
simp only [(two_mul a).symm, mul_eq_zero, two_ne_zero', false_or]
intros
split
{ assume stream_succ_nth_eq, have : int_fract_pair.stream v (n + 1) ‚â† none, by simp [stream_succ_nth_eq], have : ¬¨int_fract_pair.stream v n = none ‚àß ¬¨(‚àÉ ifp, int_fract_pair.stream v n = some ifp ‚àß ifp.fr = 0), by { have not_none_not_fract_zero, from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this, exact (not_or_distrib.elim_left not_none_not_fract_zero) }, cases this with stream_nth_ne_none nth_fr_ne_zero, replace nth_fr_ne_zero : ‚àÄ ifp, int_fract_pair.stream v n = some ifp ‚Üí ifp.fr ‚â† 0, by simpa using nth_fr_ne_zero, obtain ‚ü®ifp_n, stream_nth_eq‚ü© : ‚àÉ ifp_n, int_fract_pair.stream v n = some ifp_n, from option.ne_none_iff_exists'.mp stream_nth_ne_none, existsi ifp_n, have ifp_n_fr_ne_zero : ifp_n.fr ‚â† 0, from nth_fr_ne_zero ifp_n stream_nth_eq, cases ifp_n with _ ifp_n_fr, suffices : int_fract_pair.of ifp_n_fr‚Åª¬π = ifp_succ_n, by simpa [stream_nth_eq, ifp_n_fr_ne_zero], simp only [int_fract_pair.stream, stream_nth_eq, ifp_n_fr_ne_zero, option.some_bind, if_false] at stream_succ_nth_eq, injection stream_succ_nth_eq }
assume stream_succ_nth_eq
have : int_fract_pair.stream v (n + 1) ‚â† none
simp [stream_succ_nth_eq]
simp [stream_succ_nth_eq]
have : ¬¨int_fract_pair.stream v n = none ‚àß ¬¨(‚àÉ ifp, int_fract_pair.stream v n = some ifp ‚àß ifp.fr = 0)
have not_none_not_fract_zero
have not_none_not_fract_zero
{ have not_none_not_fract_zero, from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this, exact (not_or_distrib.elim_left not_none_not_fract_zero) }
{ have not_none_not_fract_zero, from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this, exact (not_or_distrib.elim_left not_none_not_fract_zero) }
from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this
from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this
exact (not_or_distrib.elim_left not_none_not_fract_zero)
exact (not_or_distrib.elim_left not_none_not_fract_zero)
cases this with stream_nth_ne_none nth_fr_ne_zero
replace nth_fr_ne_zero : ‚àÄ ifp, int_fract_pair.stream v n = some ifp ‚Üí ifp.fr ‚â† 0
simpa using nth_fr_ne_zero
simpa using nth_fr_ne_zero
obtain ‚ü®ifp_n, stream_nth_eq‚ü© : ‚àÉ ifp_n, int_fract_pair.stream v n = some ifp_n
from option.ne_none_iff_exists'.mp stream_nth_ne_none
existsi ifp_n
have ifp_n_fr_ne_zero : ifp_n.fr ‚â† 0
from nth_fr_ne_zero ifp_n stream_nth_eq
cases ifp_n with _ ifp_n_fr
suffices : int_fract_pair.of ifp_n_fr‚Åª¬π = ifp_succ_n
simpa [stream_nth_eq, ifp_n_fr_ne_zero]
simpa [stream_nth_eq, ifp_n_fr_ne_zero]
simp only [int_fract_pair.stream, stream_nth_eq, ifp_n_fr_ne_zero, option.some_bind, if_false] at stream_succ_nth_eq
injection stream_succ_nth_eq
rintro ‚ü®‚ü®_‚ü©, ifp_n_props‚ü©
{ rintro ‚ü®‚ü®_‚ü©, ifp_n_props‚ü©, finish [int_fract_pair.stream, ifp_n_props] }
finish [int_fract_pair.stream, ifp_n_props]
intros
induction n_le_m with m n_le_m IH generalizing s
{ refl }
refl
cases s_head_eq : s.head with gp_head
{ cases s_head_eq : s.head with gp_head, case option.none { cases n; simp only [convergents'_aux, s_head_eq] }, case option.some { have : convergents'_aux s (n + 1) = convergents'_aux s n, from convergents'_aux_stable_step_of_terminated terminated_at_n, rw [‚Üêthis], have : s.tail.terminated_at n, by simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n), have : convergents'_aux s.tail m = convergents'_aux s.tail n, from IH this, simp only [convergents'_aux, s_head_eq, this] } }
cases n
cases n; simp only [convergents'_aux, s_head_eq]
case option.none { cases n; simp only [convergents'_aux, s_head_eq] }
simp only [convergents'_aux, s_head_eq]
simp only [convergents'_aux, s_head_eq]
case option.some { have : convergents'_aux s (n + 1) = convergents'_aux s n, from convergents'_aux_stable_step_of_terminated terminated_at_n, rw [‚Üêthis], have : s.tail.terminated_at n, by simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n), have : convergents'_aux s.tail m = convergents'_aux s.tail n, from IH this, simp only [convergents'_aux, s_head_eq, this] }
have : convergents'_aux s (n + 1) = convergents'_aux s n
from convergents'_aux_stable_step_of_terminated terminated_at_n
rw [‚Üêthis]
have : s.tail.terminated_at n
simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n)
simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n)
have : convergents'_aux s.tail m = convergents'_aux s.tail n
from IH this
simp only [convergents'_aux, s_head_eq, this]
intros
{ rw mul_comm, exact mul_div_cancel_left a b0 }
rw mul_comm
exact mul_div_cancel_left a b0
intros
rw [neg_eq_neg_one_mul, mul_div_assoc, ‚Üê neg_eq_neg_one_mul]
intros
rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]
intros
rw [h.inv_left.eq, inv_mul_cancel_right]
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
rw [‚Üêpow_add, nat.add_comm, nat.sub_add_cancel h]
intros
refine ‚ü®pow_eq_zero, _‚ü©
rintros rfl
exact zero_pow hn
intros
induction p with p IH
{ simp }
simp
rw [pow_succ', IH, smul_mul_smul, ‚Üêpow_succ', ‚Üêpow_succ']
{ rw [pow_succ', IH, smul_mul_smul, ‚Üêpow_succ', ‚Üêpow_succ'] }
intros
rw [‚Üê units.coe_map, ‚Üê units.coe_map, ‚Üê units.coe_inv', monoid_hom.map_inv]
intros
rw [div_div_eq_div_mul, div_div_eq_div_mul, mul_comm]
intros
rw [‚Üêimage_subobject_arrow_comp f, category.assoc]
convert comp_zero
rw p
simp
intros
{ ext, simp, }
ext
simp
intros
rw ‚Üê finset.prod_subset h _
apply finset.prod_congr rfl
{ apply finset.prod_congr rfl, intros i hi, congr, symmetry, exact mul_indicator_of_mem hi _ }
intros i hi
congr
symmetry
exact mul_indicator_of_mem hi _
refine Œª i hi hn, _
{ refine Œª i hi hn, _, convert hg i, exact mul_indicator_of_not_mem hn _ }
convert hg i
exact mul_indicator_of_not_mem hn _
intros
{ ext, refl, }
ext
refl
intros
rw [‚Üê matrix.diagonal_one, matrix.diagonal_neg, matrix.from_blocks_diagonal]
refl
intros
have h : ‚ÅÖI, N‚ÅÜ ‚äî ‚ÅÖI, N'‚ÅÜ ‚â§ ‚ÅÖI, N ‚äî N'‚ÅÜ
rw sup_le_iff
{ rw sup_le_iff, split; apply mono_lie_right; [exact le_sup_left, exact le_sup_right], }
split
split; apply mono_lie_right; [exact le_sup_left, exact le_sup_right]
split; apply mono_lie_right
apply mono_lie_right
exact le_sup_left
apply mono_lie_right
exact le_sup_right
suffices : ‚ÅÖI, N ‚äî N'‚ÅÜ ‚â§ ‚ÅÖI, N‚ÅÜ ‚äî ‚ÅÖI, N'‚ÅÜ
exact le_antisymm this h
{ exact le_antisymm this h, }
clear h
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ‚ü®x, ‚ü®n, hn‚ü©, h‚ü©
erw lie_submodule.mem_sup
erw lie_submodule.mem_sup at hn
rcases hn with ‚ü®n‚ÇÅ, hn‚ÇÅ, n‚ÇÇ, hn‚ÇÇ, hn'‚ü©
use ‚ÅÖ(x : L), (‚ü®n‚ÇÅ, hn‚ÇÅ‚ü© : N)‚ÅÜ
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
use ‚ÅÖ(x : L), (‚ü®n‚ÇÇ, hn‚ÇÇ‚ü© : N')‚ÅÜ
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
simp [‚Üê h, ‚Üê hn']
intros
obtain ‚ü®k, hM‚ü© := hM
unfreezingI { obtain ‚ü®k, hM‚ü© := hM, }
use k
intros x
ext m
rw [linear_map.pow_apply, linear_map.zero_apply, ‚Üê @lie_submodule.mem_bot R L M, ‚Üê hM]
exact iterate_to_endomorphism_mem_lower_central_series R L M x m k
intros
rw [add_comm, derived_series_of_ideal_add I 1 k, abelian_iff_derived_one_eq_bot]
intros
rintros ‚ü®y, hy‚ü©
erw mem_range at hy
obtain ‚ü®x, rfl‚ü© := hy
use x
simp only [subtype.mk_eq_mk, range_restrict_apply]
intros
simp only [‚Üê coe_to_submodule_eq_iff, lie_ideal.coe_to_lie_subalgebra_to_submodule, submodule.exists_lie_submodule_coe_eq_iff L]
exact iff.rfl
intros
refine iff.intro (Œª h x hx, h ‚ñ∏ rfl) _
intro h
set u' : ‚Ü•(E.sol_space) := ‚ü®u, hu‚ü©
set v' : ‚Ü•(E.sol_space) := ‚ü®v, hv‚ü©
change u'.val = v'.val
suffices h' : u' = v'
from h' ‚ñ∏ rfl
rw [‚Üê E.to_init.to_equiv.apply_eq_iff_eq, linear_equiv.coe_to_equiv]
ext x
exact_mod_cast h (mem_range.mpr x.2)
intros
rw [‚Üêneg_neg c, neg_smul, neg_pos]
exact smul_neg_iff_of_pos (neg_pos_of_neg hc)
intros
rw [‚Üê neg_sub, abv.map_neg]
intros
rw [inv_mul_le_iff h, mul_comm]
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_lt_mul_of_neg_right h (one_div_neg.2 hc)
intros
rw [‚Üê mul_two, mul_div_cancel a two_ne_zero]
intros
rw [‚Üê mul_lt_mul_iff_left b, mul_inv_cancel_left]
intros
rw [‚Üê inv_mul_lt_iff_lt_mul, mul_comm]
intros
obtain ‚ü®y, hy‚ü© := decidable.exists_ne (1 : Œ±)
cases hy.lt_or_lt
{ exact ‚ü®y‚Åª¬π, one_lt_inv'.mpr h‚ü© }
exact ‚ü®y‚Åª¬π, one_lt_inv'.mpr h‚ü©
{ exact ‚ü®y, h‚ü© }
exact ‚ü®y, h‚ü©
intros
rw mul_nonneg_iff
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a; have := le_total 0 b; have := le_total 0 c; itauto
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a; have := le_total 0 b; have := le_total 0 c
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a; have := le_total 0 b
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a
iterate 3 { rw mul_nonneg_iff }
rw mul_nonneg_iff
rw mul_nonneg_iff
have := le_total 0 a
have := le_total 0 b
have := le_total 0 c
itauto
intros
simp only [‚Üê not_le, inv_of_nonneg]
intros
simpa only [sub_eq_add_neg] using h.neg_nsmul n x
intros
ext1 y
{ ext1 y, rw [mem_inv, mem_singleton_iff, mem_singleton_iff, inv_eq_iff_inv_eq, eq_comm], }
rw [mem_inv, mem_singleton_iff, mem_singleton_iff, inv_eq_iff_inv_eq, eq_comm]
intros
simpa using nat_degree_multiset_prod' (s.1.map f) (by simpa using h)
intros
rw [‚Üê coe_commutes, coe_mul_eq_smul]
intros
rcases ua with ‚ü®a, rfl‚ü©
exact a.is_smul_regular M
intros
convert dvd_add (hxy.mul_left a) (hab.mul_right y)
rw [mul_sub_left_distrib, mul_sub_right_distrib]
simp only [sub_eq_add_neg, add_assoc, neg_add_cancel_left]
intros
ext
rcases mk_alg_hom_surjective S s x with ‚ü®x, rfl‚ü©
exact (alg_hom.congr_fun w x : _)
intros
{ subst h, dsimp, simp, }
subst h
dsimp
simp
intros
rw [‚Üê is_open_compl_iff, is_open_iff, compl_compl]
intros
dsimp [Œ¥, œÉ]
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_œÉ_succ, op_id, X.map_id]
intros
dsimp [Œ¥, œÉ]
{ dsimp [Œ¥, œÉ], simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_œÉ_of_le H] }
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_œÉ_of_le H]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
funext v i
apply p.congr (composition.ones_blocks_fun _ _)
intros j hjn hj1
obtain rfl : j = 0
linarith
{ linarith }
refine congr_arg v _
rw [fin.ext_iff, fin.coe_cast_le, composition.ones_embedding, fin.coe_mk]
intros
refine ‚ü®Œª H, by rw H, Œª H, _‚ü©
rcases u with ‚ü®a, b‚ü©
rcases v with ‚ü®a', b'‚ü©
dsimp at H
have h : a = a'
ext1
{ ext1, have : map list.sum (of_fn (Œª (i : fin (composition.length a)), (b i).blocks)) = map list.sum (of_fn (Œª (i : fin (composition.length a')), (b' i).blocks)), by rw H, simp only [map_of_fn] at this, change of_fn (Œª (i : fin (composition.length a)), (b i).blocks.sum) = of_fn (Œª (i : fin (composition.length a')), (b' i).blocks.sum) at this, simpa [composition.blocks_sum, composition.of_fn_blocks_fun] using this }
have : map list.sum (of_fn (Œª (i : fin (composition.length a)), (b i).blocks)) = map list.sum (of_fn (Œª (i : fin (composition.length a')), (b' i).blocks))
rw H
rw H
simp only [map_of_fn] at this
change of_fn (Œª (i : fin (composition.length a)), (b i).blocks.sum) = of_fn (Œª (i : fin (composition.length a')), (b' i).blocks.sum) at this
simpa [composition.blocks_sum, composition.of_fn_blocks_fun] using this
induction h
simp only [true_and, eq_self_iff_true, heq_iff_eq]
ext i : 2
have : nth_le (of_fn (Œª (i : fin (composition.length a)), (b i).blocks)) i (by simp [i.is_lt]) = nth_le (of_fn (Œª (i : fin (composition.length a)), (b' i).blocks)) i (by simp [i.is_lt]) := nth_le_of_eq H _
rwa [nth_le_of_fn, nth_le_of_fn] at this
intros
simpa only [div_eq_mul_inv] using htu.mul hvw.inv
intros
{ convert is_o_pow_pow h, simp only [pow_one] }
convert is_o_pow_pow h
simp only [pow_one]
intros
{ unfold is_O, exact exists_congr (Œª _, is_O_with_neg_left) }
unfold is_O
exact exists_congr (Œª _, is_O_with_neg_left)
intros
convert hc.mul (has_strict_deriv_at_const x d)
rw [mul_zero, add_zero]
intros
{ rw ‚Üê has_deriv_within_at_univ at *, exact hc.pow }
rw ‚Üê has_deriv_within_at_univ at *
exact hc.pow
intros
simp only [deriv, fderiv_const_add]
intros
simp only [sub_eq_add_neg, differentiable_within_at_add_const_iff]
intros
rw [‚Üê differentiable_within_at_univ, ‚Üê differentiable_within_at_univ, iso.comp_differentiable_within_at_iff]
intros
simp only [mem_closure_iff_nhds_within_ne_bot, ne_bot_iff, ne.def, not_not] at h
simp [has_fderiv_within_at, has_fderiv_at_filter, h, is_o, is_O_with]
intros
refine h.is_O_image_sub_norm_mul_norm_sub.trans_is_o (is_o.of_norm_right _)
refine is_o_iff_exists_eq_mul.2 ‚ü®Œª y, ‚à•y - (x, x)‚à•, _, eventually_eq.rfl‚ü©
refine (continuous_id.sub continuous_const).norm.tendsto' _ _ _
rw [_root_.id, sub_self, norm_zero]
intros
apply to_implicit_function_of_complemented
intros
ext x
rw [‚Üê iterated_deriv_within_univ]
convert iterated_deriv_within_eq_iterate unique_diff_on_univ (mem_univ x)
simp [deriv_within_univ]
ext x
by_cases h : x ‚â§ 0
{ simp [exp_neg_inv_glue, f_aux, h] }
simp [exp_neg_inv_glue, f_aux, h]
simp [h, exp_neg_inv_glue, f_aux, ne_of_gt (not_le.1 h), P_aux]
{ simp [h, exp_neg_inv_glue, f_aux, ne_of_gt (not_le.1 h), P_aux] }
intros
simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at
intros
{ convert has_ftaylor_series_up_to_on_pi, ext, refl }
convert has_ftaylor_series_up_to_on_pi
ext
refl
intros
rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]
{ rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply], refl }
refl
intros
rcases h with ‚ü®c, hc, li, hg‚ü©
rcases linear_isometry_complex (li.to_linear_isometry_equiv rfl) with ‚ü®a, ha‚ü©
let rot := c ‚Ä¢ (a : ‚ÑÇ) ‚Ä¢ continuous_linear_map.id ‚ÑÇ ‚ÑÇ
cases ha
refine or.intro_left _ ‚ü®rot, _‚ü©
{ refine or.intro_left _ ‚ü®rot, _‚ü©, ext1, simp only [coe_restrict_scalars', hg, ‚Üê li.coe_to_linear_isometry_equiv, ha, pi.smul_apply, continuous_linear_map.smul_apply, rotation_apply, continuous_linear_map.id_apply, smul_eq_mul], }
ext1
simp only [coe_restrict_scalars', hg, ‚Üê li.coe_to_linear_isometry_equiv, ha, pi.smul_apply, continuous_linear_map.smul_apply, rotation_apply, continuous_linear_map.id_apply, smul_eq_mul]
refine or.intro_right _ ‚ü®rot, _‚ü©
{ refine or.intro_right _ ‚ü®rot, _‚ü©, ext1, rw [continuous_linear_map.coe_comp', hg, ‚Üê li.coe_to_linear_isometry_equiv, ha], simp only [coe_restrict_scalars', function.comp_app, pi.smul_apply, linear_isometry_equiv.coe_trans, conj_lie_apply, rotation_apply, continuous_linear_equiv.coe_apply, conj_cle_apply], simp only [continuous_linear_map.smul_apply, continuous_linear_map.id_apply, smul_eq_mul, conj_conj], }
ext1
rw [continuous_linear_map.coe_comp', hg, ‚Üê li.coe_to_linear_isometry_equiv, ha]
simp only [coe_restrict_scalars', function.comp_app, pi.smul_apply, linear_isometry_equiv.coe_trans, conj_lie_apply, rotation_apply, continuous_linear_equiv.coe_apply, conj_cle_apply]
simp only [continuous_linear_map.smul_apply, continuous_linear_map.id_apply, smul_eq_mul, conj_conj]
intros
refine ‚ü®Œª h z hz, _, (open_segment_subset_segment ùïú x y).trans‚ü©
obtain rfl | hxz := eq_or_ne x z
{ exact hx }
exact hx
obtain rfl | hyz := eq_or_ne y z
{ exact hy }
exact hy
exact h (mem_open_segment_of_ne_left_right ùïú hxz hyz hz)
intros
rw sUnion_eq_Union
exact (directed_on_iff_directed.1 hdir).convex_Union (Œª A, hc A.2)
intros
let k := (min_card_finset_of_mem_convex_hull hx).card - 1
have hk : (min_card_finset_of_mem_convex_hull hx).card = k + 1
exact (nat.succ_pred_eq_of_pos (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm
{ exact (nat.succ_pred_eq_of_pos (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm }
classical
by_contra
obtain ‚ü®p, hp‚ü© := mem_convex_hull_erase h (mem_min_card_finset_of_mem_convex_hull hx)
have contra := min_card_finset_of_mem_convex_hull_card_le_card hx (set.subset.trans (finset.erase_subset ‚Üëp (min_card_finset_of_mem_convex_hull hx)) (min_card_finset_of_mem_convex_hull_subseteq hx)) hp
rw [‚Üê not_lt] at contra
apply contra
erw [card_erase_of_mem p.2, hk]
exact lt_add_one _
intros
split
rintro hc t h x ‚ü®hxs, hxt‚ü©
{ rintro hc t h x ‚ü®hxs, hxt‚ü©, refine hc {x | ‚Üëx ‚àà t} ‚ü®x, hxs‚ü© _, rw subtype.coe_image_of_subset h, exact hxt }
refine hc {x | ‚Üëx ‚àà t} ‚ü®x, hxs‚ü© _
rw subtype.coe_image_of_subset h
exact hxt
intros hc t x h
{ intros hc t x h, rw ‚Üêsubtype.coe_injective.mem_set_image, exact hc (t.image coe) (subtype.coe_image_subset s t) ‚ü®x.prop, h‚ü© }
rw ‚Üêsubtype.coe_injective.mem_set_image
exact hc (t.image coe) (subtype.coe_image_subset s t) ‚ü®x.prop, h‚ü©
intros
refine (emetric.diam_le $ Œª x hx y hy, _).antisymm (emetric.diam_mono $ subset_convex_hull ‚Ñù s)
rcases convex_hull_exists_dist_ge2 hx hy with ‚ü®x', hx', y', hy', H‚ü©
rw edist_dist
apply le_trans (ennreal.of_real_le_of_real H)
rw ‚Üê edist_dist
exact emetric.edist_le_diam_of_mem hx' hy'
intros
convert inner_eq_norm_mul_iff using 2; simp [hx, hy]
{ convert inner_eq_norm_mul_iff using 2; simp [hx, hy] }
convert inner_eq_norm_mul_iff using 2
simp [hx, hy]
simp [hx, hy]
simp [hx, hy]
intros
{ simp [sub_eq_add_neg, inner_add_left, inner_neg_left] }
simp [sub_eq_add_neg, inner_add_left, inner_neg_left]
intros
{ rw [‚Üê neg_one_smul ùïú x, inner_smul_left], simp }
rw [‚Üê neg_one_smul ùïú x, inner_smul_left]
simp
intros
{ have h := @inner_self_eq_norm_sq ‚Ñù F _ _ x, simpa using h }
have h := @inner_self_eq_norm_sq ‚Ñù F _ _ x
simpa using h
intros
rw [to_euclidean.to_homeomorph.nhds_eq_comap]
exact metric.nhds_basis_ball.comap _
intros
simp [explicit_cokernel_œÄ, explicit_cokernel_iso]
intros
ext
{ ext, refl }
refl
intros
rw [dist_eq_norm, sub_zero]
intros
rw [‚Üê dist_zero_right, dist_self]
intros
rw [div_eq_inv_mul, ‚Üêsmul_eq_mul, inv_eq_one_div]
exact exp_series_apply_eq x n
intros
rw [‚Üê coe_nnnorm, int.nnnorm_coe_units, nnreal.coe_one]
intros
{ ext, simp [mem_ker] }
ext
simp [mem_ker]
intros
have hx : 0 < ‚à•x‚à• := (norm_pos_iff.mpr h)
haveI : nontrivial (ùïú ‚àô x) := submodule.nontrivial_span_singleton h
exact continuous_linear_map.homothety_norm _ (Œª y, homothety_inverse _ hx _ (to_span_nonzero_singleton_homothety ùïú x h) _)
intros
rw [‚Üê inverse_unit (units.one_sub t h), units.coe_one_sub]
simp [log]
intros
rw [‚Üê exp_le_exp, exp_log h, exp_log h‚ÇÅ]
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
have := P.is_equivalent_at_top_lead.tendsto_nhds h
{ have := P.is_equivalent_at_top_lead.tendsto_nhds h, by_cases hP : P.leading_coeff = 0, { simp only [hP, zero_mul, tendsto_const_nhds_iff] at this, refine ‚ü®trans hP this, by simp [leading_coeff_eq_zero.1 hP]‚ü© }, { rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this, exact this.symm } }
by_cases hP : P.leading_coeff = 0
simp only [hP, zero_mul, tendsto_const_nhds_iff] at this
{ simp only [hP, zero_mul, tendsto_const_nhds_iff] at this, refine ‚ü®trans hP this, by simp [leading_coeff_eq_zero.1 hP]‚ü© }
refine ‚ü®trans hP this, by simp [leading_coeff_eq_zero.1 hP]‚ü©
rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this
{ rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this, exact this.symm }
exact this.symm
refine P.is_equivalent_at_top_lead.symm.tendsto_nhds _
{ refine P.is_equivalent_at_top_lead.symm.tendsto_nhds _, have : P.nat_degree = 0 := nat_degree_eq_zero_iff_degree_le_zero.2 h.2, simp only [h.1, this, pow_zero, mul_one], exact tendsto_const_nhds }
have : P.nat_degree = 0 := nat_degree_eq_zero_iff_degree_le_zero.2 h.2
simp only [h.1, this, pow_zero, mul_one]
exact tendsto_const_nhds
intros
nth_rewrite 0 ‚Üê real.coe_to_nnreal x hx
rw [‚Üênnreal.coe_rpow, real.to_nnreal_coe]
intros
simpa using rpow_sub_nat hx y 1
intros
rw [rpow_def_of_pos hx, exp_le_one_iff, mul_nonpos_iff, log_nonneg_iff hx, log_nonpos_iff hx]
intros
simp [arctan_eq_arcsin, neg_div]
intros
simp only [div_eq_mul_inv, ennreal.inv_pow] at hu
refine cauchy_seq_of_edist_le_geometric 2‚Åª¬π C _ hC hu
simp [ennreal.one_lt_two]
intros
rw [add_def, neg_sub', add_neg]
intros
rw [transfer_nat_trans_self_symm_comp, gf, transfer_nat_trans_self_symm_id]
intros
symmetry
{ symmetry, erw [‚Üêiso.hom_comp_eq_id (e.unit_iso.app _), unit_inverse_comp], refl }
erw [‚Üêiso.hom_comp_eq_id (e.unit_iso.app _), unit_inverse_comp]
refl
intros
classical
apply finset.induction_on O
{ exact ‚ü®is_filtered.nonempty.some, (by rintros - ‚ü®‚ü©)‚ü©, }
exact ‚ü®is_filtered.nonempty.some, (by rintros - ‚ü®‚ü©)‚ü©
rintros X O' nm ‚ü®S', w'‚ü©
{ rintros X O' nm ‚ü®S', w'‚ü©, use max X S', rintros Y mY, by_cases h : X = Y, { subst h, exact ‚ü®left_to_max _ _‚ü©, }, { exact ‚ü®(w' (by finish)).some ‚â´ right_to_max _ _‚ü©, }, }
use max X S'
rintros Y mY
by_cases h : X = Y
{ subst h, exact ‚ü®left_to_max _ _‚ü©, }
subst h
exact ‚ü®left_to_max _ _‚ü©
{ exact ‚ü®(w' (by finish)).some ‚â´ right_to_max _ _‚ü©, }
exact ‚ü®(w' (by finish)).some ‚â´ right_to_max _ _‚ü©
intros
cases F
cases F; refl
refl
intros
ext
ext; apply category.comp_id
apply category.comp_id
intros
simp
intros
dsimp [is_colimit_whisker_equiv]
apply P.hom_ext
intro j
simp
dsimp
dsimp
simp
intros
dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]
{ dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso], tidy, }
tidy
intros
haveI : has_colimit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_colimit_equivalence_comp e.symm
apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm
intros
simp
intros
simp [biproduct.Œπ_œÄ, h]
intros
{ ext, simp, }
ext
simp
intros
{ rw [‚Üêimage.fac f], apply epi_comp, }
rw [‚Üêimage.fac f]
apply epi_comp
intros
{ ext, simp [h‚ÇÅ], }
ext
simp [h‚ÇÅ]
intros
apply eq_lift_of_comp_eq
tidy
intros
{ dsimp [limit.mk], simp, }
dsimp [limit.mk]
simp
intros
rw [‚Üêtensor_right_iff, comp_tensor_id, ‚Üêcancel_mono (Œ±_ X Y (ùüô_ C)).hom, assoc, associator_naturality, ‚Üêtriangle_assoc, ‚Üêtriangle, id_tensor_comp, pentagon_assoc, ‚Üêassociator_naturality, tensor_id]
intros
simp only [lax_monoidal_functor.left_unitality]
slice_rhs 2 3 { rw ‚Üêcomp_tensor_id, simp, }
simp
intros
ext
{ ext, simp only [right_dual_iso, iso.refl_hom, right_adjoint_mate_id] }
simp only [right_dual_iso, iso.refl_hom, right_adjoint_mate_id]
intros
have := f.w; tidy
have := f.w
tidy
intros
dsimp [lift_f_zero, lift_f_one]
simp
intros
split
intro h
{ intro h, apply le_antisymm, { intros Y f hf, rw ‚Üê J‚ÇÅ.covers_iff_mem_of_closed h, apply hf }, { apply J‚ÇÅ.le_close } }
apply le_antisymm
intros Y f hf
{ intros Y f hf, rw ‚Üê J‚ÇÅ.covers_iff_mem_of_closed h, apply hf }
rw ‚Üê J‚ÇÅ.covers_iff_mem_of_closed h
apply hf
{ apply J‚ÇÅ.le_close }
apply J‚ÇÅ.le_close
intro e
{ intro e, rw ‚Üê e, apply J‚ÇÅ.close_is_closed }
rw ‚Üê e
apply J‚ÇÅ.close_is_closed
intros
{ ext, simp, }
ext
simp
intros
{ ext, simpa using i.2.le }
ext
simpa using i.2.le
intros
haveI := classical.dec_eq Œ≤
let r' := Œª a, univ.filter (Œª b, r a b)
have h : ‚àÄ (A : finset Œ±), (univ.filter (Œª (b : Œ≤), ‚àÉ a ‚àà A, r a b)) = (A.bUnion r')
intro A
{ intro A, ext b, simp, }
ext b
simp
have h' : ‚àÄ (f : Œ± ‚Üí Œ≤) x, r x (f x) ‚Üî f x ‚àà r' x
{ simp, }
simp
simp_rw [h, h']
apply finset.all_card_le_bUnion_card_iff_exists_injective
intros
simp [degree]
intros
obtain ‚ü®t, ht‚ü© := finset.min_of_mem (mem_image_of_mem (Œª v, G.degree v) (mem_univ v))
have := finset.min_le_of_mem (mem_image_of_mem _ (mem_univ v)) ht
rw option.mem_def at ht
rwa [min_degree, ht, option.get_or_else_some]
intros
rw ‚Üêcard_neighbor_set_eq_degree
exact set.card_le_of_subset (G'.neighbor_set_subset v)
intros
let G‚ÇÅ : (Œ± √ó list œÉ) √ó ‚Ñï √ó ‚Ñï ‚Üí option œÉ := Œª p, let a := p.1.1, IH := p.1.2, n := p.2.1, m := p.2.2 in (IH.nth m).bind $ Œª s, (IH.nth m.unpair.1).bind $ Œª s‚ÇÅ, (IH.nth m.unpair.2).map $ Œª s‚ÇÇ, cond n.bodd (cond n.div2.bodd (rf a (of_nat code m) s) (pc a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s‚ÇÅ s‚ÇÇ)) (cond n.div2.bodd (co a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s‚ÇÅ s‚ÇÇ) (pr a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s‚ÇÅ s‚ÇÇ))
have : primrec G‚ÇÅ
refine option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _
{ refine option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _, refine option_bind ((list_nth.comp (snd.comp fst) (fst.comp $ primrec.unpair.comp (snd.comp snd))).comp fst) _, refine option_map ((list_nth.comp (snd.comp fst) (snd.comp $ primrec.unpair.comp (snd.comp snd))).comp $ fst.comp fst) _, have a := fst.comp (fst.comp $ fst.comp $ fst.comp fst), have n := fst.comp (snd.comp $ fst.comp $ fst.comp fst), have m := snd.comp (snd.comp $ fst.comp $ fst.comp fst), have m‚ÇÅ := fst.comp (primrec.unpair.comp m), have m‚ÇÇ := snd.comp (primrec.unpair.comp m), have s := snd.comp (fst.comp fst), have s‚ÇÅ := snd.comp fst, have s‚ÇÇ := snd, exact (nat_bodd.comp n).cond ((nat_bodd.comp $ nat_div2.comp n).cond (hrf.comp $ a.pair (((primrec.of_nat code).comp m).pair s)) (hpc.comp $ a.pair (((primrec.of_nat code).comp m‚ÇÅ).pair $ ((primrec.of_nat code).comp m‚ÇÇ).pair $ s‚ÇÅ.pair s‚ÇÇ))) (primrec.cond (nat_bodd.comp $ nat_div2.comp n) (hco.comp $ a.pair (((primrec.of_nat code).comp m‚ÇÅ).pair $ ((primrec.of_nat code).comp m‚ÇÇ).pair $ s‚ÇÅ.pair s‚ÇÇ)) (hpr.comp $ a.pair (((primrec.of_nat code).comp m‚ÇÅ).pair $ ((primrec.of_nat code).comp m‚ÇÇ).pair $ s‚ÇÅ.pair s‚ÇÇ))) }
refine option_bind ((list_nth.comp (snd.comp fst) (fst.comp $ primrec.unpair.comp (snd.comp snd))).comp fst) _
refine option_map ((list_nth.comp (snd.comp fst) (snd.comp $ primrec.unpair.comp (snd.comp snd))).comp $ fst.comp fst) _
have a := fst.comp (fst.comp $ fst.comp $ fst.comp fst)
have n := fst.comp (snd.comp $ fst.comp $ fst.comp fst)
have m := snd.comp (snd.comp $ fst.comp $ fst.comp fst)
have m‚ÇÅ := fst.comp (primrec.unpair.comp m)
have m‚ÇÇ := snd.comp (primrec.unpair.comp m)
have s := snd.comp (fst.comp fst)
have s‚ÇÅ := snd.comp fst
have s‚ÇÇ := snd
exact (nat_bodd.comp n).cond ((nat_bodd.comp $ nat_div2.comp n).cond (hrf.comp $ a.pair (((primrec.of_nat code).comp m).pair s)) (hpc.comp $ a.pair (((primrec.of_nat code).comp m‚ÇÅ).pair $ ((primrec.of_nat code).comp m‚ÇÇ).pair $ s‚ÇÅ.pair s‚ÇÇ))) (primrec.cond (nat_bodd.comp $ nat_div2.comp n) (hco.comp $ a.pair (((primrec.of_nat code).comp m‚ÇÅ).pair $ ((primrec.of_nat code).comp m‚ÇÇ).pair $ s‚ÇÅ.pair s‚ÇÇ)) (hpr.comp $ a.pair (((primrec.of_nat code).comp m‚ÇÅ).pair $ ((primrec.of_nat code).comp m‚ÇÇ).pair $ s‚ÇÅ.pair s‚ÇÇ)))
let G : Œ± ‚Üí list œÉ ‚Üí option œÉ := Œª a IH, IH.length.cases (some (z a)) $ Œª n, n.cases (some (s a)) $ Œª n, n.cases (some (l a)) $ Œª n, n.cases (some (r a)) $ Œª n, G‚ÇÅ ((a, IH), n, n.div2.div2)
have : primrec‚ÇÇ G := (nat_cases (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) $ nat_cases snd (option_some_iff.2 (hs.comp (fst.comp fst))) $ nat_cases snd (option_some_iff.2 (hl.comp (fst.comp $ fst.comp fst))) $ nat_cases snd (option_some_iff.2 (hr.comp (fst.comp $ fst.comp $ fst.comp fst))) (this.comp $ ((fst.pair snd).comp $ fst.comp $ fst.comp $ fst.comp $ fst).pair $ snd.pair $ nat_div2.comp $ nat_div2.comp snd))
refine ((nat_strong_rec (Œª a n, F a (of_nat code n)) this.to‚ÇÇ $ Œª a n, _).comp primrec.id $ encode_iff.2 hc).of_eq (Œª a, by simp)
simp
cases n with n
iterate 4 {cases n with n, {simp [of_nat_code_eq, of_nat_code]; refl}}
{simp [of_nat_code_eq, of_nat_code]; refl}
cases n with n
{simp [of_nat_code_eq, of_nat_code]; refl}
cases n with n
{simp [of_nat_code_eq, of_nat_code]; refl}
cases n with n
simp [of_nat_code_eq, of_nat_code]
simp [of_nat_code_eq, of_nat_code]; refl
{simp [of_nat_code_eq, of_nat_code]; refl}
refl
simp [G]
rw [list.length_map, list.length_range]
let m := n.div2.div2
show G‚ÇÅ ((a, (list.range (n+4)).map (Œª n, F a (of_nat code n))), n, m) = some (F a (of_nat code (n+4)))
have hm : m < n + 4
simp [nat.div2_val, m]
simp [nat.div2_val, m]
simp [nat.div2_val, m]; from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
simp [nat.div2_val, m]; from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
have m1 : m.unpair.1 < n + 4
from lt_of_le_of_lt m.unpair_left_le hm
have m2 : m.unpair.2 < n + 4
from lt_of_le_of_lt m.unpair_right_le hm
simp [G‚ÇÅ]
simp [list.nth_map, list.nth_range, hm, m1, m2]
change of_nat code (n+4) with of_nat_code (n+4)
simp [of_nat_code]
cases n.bodd; cases n.div2.bodd; refl
cases n.bodd; cases n.div2.bodd
cases n.bodd
cases n.div2.bodd
refl
refl
cases n.div2.bodd
refl
refl
intros
simp [many_one_equiv]
intros
cases L‚ÇÇ with a L‚ÇÇ
refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ [] (some Œì'.Cons) L‚ÇÉ (by rintro _ ‚ü®‚ü©) ‚ü®rfl, rfl‚ü©)) (trans_gen.head rfl (trans_gen.head rfl _))
{ refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ [] (some Œì'.Cons) L‚ÇÉ (by rintro _ ‚ü®‚ü©) ‚ü®rfl, rfl‚ü©)) (trans_gen.head rfl (trans_gen.head rfl _)), convert unrev_ok, simp, refl }
convert unrev_ok
simp
refl
refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ (tr_nat a) (some Œì'.cons) (tr_list L‚ÇÇ ++ Œì'.Cons :: L‚ÇÉ) (tr_nat_nat_end _) ‚ü®rfl, by simp‚ü©)) (trans_gen.head rfl (trans_gen.head rfl _))
{ refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ (tr_nat a) (some Œì'.cons) (tr_list L‚ÇÇ ++ Œì'.Cons :: L‚ÇÉ) (tr_nat_nat_end _) ‚ü®rfl, by simp‚ü©)) (trans_gen.head rfl (trans_gen.head rfl _)), simp, refine trans_gen.trans (clear_ok (split_at_pred_eq _ _ (tr_list L‚ÇÇ) (some Œì'.Cons) L‚ÇÉ (Œª x h, (to_bool_ff (tr_list_ne_Cons _ _ h))) ‚ü®rfl, by simp‚ü©)) _, convert unrev_ok, simp [list.reverse_core_eq] }
simp
refine trans_gen.trans (clear_ok (split_at_pred_eq _ _ (tr_list L‚ÇÇ) (some Œì'.Cons) L‚ÇÉ (Œª x h, (to_bool_ff (tr_list_ne_Cons _ _ h))) ‚ü®rfl, by simp‚ü©)) _
convert unrev_ok
simp [list.reverse_core_eq]
intros
cases n; simp only [tape.nth, tape.right‚ÇÄ, int.coe_nat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons, list_blank.tail_cons]
cases n
simp only [tape.nth, tape.right‚ÇÄ, int.coe_nat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons, list_blank.tail_cons]
simp only [tape.nth, tape.right‚ÇÄ, int.coe_nat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons, list_blank.tail_cons]
intros
simp [fst,bimap_bimap]
intros
simp only [fold_map,traverse_map]
intros
induction xs generalizing b; simp! [*]; cases b; simp! [to_list,to_array]
induction xs generalizing b; simp! [*]; cases b
induction xs generalizing b; simp! [*]
induction xs generalizing b
simp! [*]
simp! [*]
cases b
simp! [to_list,to_array]
intros
simpa [h] using mono.le p cb n
intros
simp [seq_right_eq, seq_eq_done, map_eq_done, and.comm, and.assoc]
intros
simp [eof, guard_eq_done, remaining_eq_done, nat.sub_eq_zero_iff_le, and_comm, and_assoc]
intros
{ introI, exact hne (of_done h) }
introI
exact hne (of_done h)
intros
rw [‚Üê of_real_rat_cast, of_real_im]
intros
simp [bit0]
intros
refine quotient.induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ (Œª x‚ÇÅ x‚ÇÇ, _)
simp only [sum_add_hom, add_monoid_hom.finset_sum_apply, quotient.lift_on_mk, add_monoid_hom.coe_mk, add_monoid_hom.flip_apply]
exact finset.sum_comm
intros
split
split; intros h‚ÇÇ x
intros h‚ÇÇ x
{ rw [‚Üêf.right_inv x], apply h.mp, apply h‚ÇÇ }
rw [‚Üêf.right_inv x]
apply h.mp
apply h‚ÇÇ
intros h‚ÇÇ x
apply h.mpr
apply h‚ÇÇ
intros
simp [equiv.symm_apply_eq]
intros
rw [‚Üê h.image_eq]
rintros y ‚ü®x, hx, rfl‚ü©
have hx' := hx
rw hs at hx'
rw [e.left_inv hx.1, Heq hx, e'.left_inv hx'.1]
intros
{ cases e, refl }
cases e
refl
intros
{ ext, simp }
ext
simp
intros
ext i
by_cases h : i = 0
{ rw h, refl }
rw h
refl
set j := pred i h with ji
have : i = j.succ
rw [ji, succ_pred]
rw [ji, succ_pred]
rw [this, cons_succ]
by_cases h' : j.val < n
set k := cast_lt j h' with jk
{ set k := cast_lt j h' with jk, have : j = k.cast_succ, by rw [jk, cast_succ_cast_lt], rw [this, ‚Üê cast_succ_fin_succ], simp }
have : j = k.cast_succ
rw [jk, cast_succ_cast_lt]
rw [jk, cast_succ_cast_lt]
rw [this, ‚Üê cast_succ_fin_succ]
simp
rw [eq_last_of_not_lt h', succ_last]
simp
intros
rcases i with ‚ü®i, hi‚ü©
rw [subtype.coe_mk]
induction i using nat.strong_induction_on with i h
refine le_antisymm (forall_lt_iff_le.1 $ Œª j hj, _) (forall_lt_iff_le.1 $ Œª j hj, _)
have := e.symm.lt_iff_lt.2 (mk_lt_of_lt_coe hj)
{ have := e.symm.lt_iff_lt.2 (mk_lt_of_lt_coe hj), rw e.symm_apply_apply at this, convert this, simpa using h _ this (e.symm _).is_lt }
rw e.symm_apply_apply at this
convert this
simpa using h _ this (e.symm _).is_lt
rwa [‚Üê h j hj (hj.trans hi), ‚Üê lt_iff_coe_lt_coe, e.lt_iff_lt]
{ rwa [‚Üê h j hj (hj.trans hi), ‚Üê lt_iff_coe_lt_coe, e.lt_iff_lt] }
intros
simp only [mem_sdiff, h, not_true, not_false_iff, and_false]
intros
rw [sdiff_eq_self, subset_empty, disjoint_iff_inter_eq_empty]
intros
rw [sup', ‚Üêwith_bot.some_eq_coe, option.some_get]
intros
simp [insert_val_of_not_mem ha, noncomm_prod]
intros
let l := s.sort (‚â§)
apply le_antisymm
have : l.nth_le ((s.sort (‚â§)).length - 1) h ‚àà s := (finset.mem_sort (‚â§)).1 (list.nth_le_mem l _ h)
{ have : l.nth_le ((s.sort (‚â§)).length - 1) h ‚àà s := (finset.mem_sort (‚â§)).1 (list.nth_le_mem l _ h), exact s.le_max' _ this }
exact s.le_max' _ this
have : s.max' H ‚àà l := (finset.mem_sort (‚â§)).mpr (s.max'_mem H)
{ have : s.max' H ‚àà l := (finset.mem_sort (‚â§)).mpr (s.max'_mem H), obtain ‚ü®i, i_lt, hi‚ü© : ‚àÉ i (hi : i < l.length), l.nth_le i hi = s.max' H := list.mem_iff_nth_le.1 this, rw ‚Üê hi, have : i ‚â§ l.length - 1 := nat.le_pred_of_lt i_lt, exact (s.sort_sorted (‚â§)).rel_nth_le_of_le _ _ (nat.le_pred_of_lt i_lt) }
obtain ‚ü®i, i_lt, hi‚ü© : ‚àÉ i (hi : i < l.length), l.nth_le i hi = s.max' H := list.mem_iff_nth_le.1 this
rw ‚Üê hi
have : i ‚â§ l.length - 1 := nat.le_pred_of_lt i_lt
exact (s.sort_sorted (‚â§)).rel_nth_le_of_le _ _ (nat.le_pred_of_lt i_lt)
intros
ext s
by_cases hs : s = a
rw [hs, add_apply, erase_same, erase_same, erase_same, add_zero]
{ rw [hs, add_apply, erase_same, erase_same, erase_same, add_zero] }
rw [add_apply, erase_ne hs, erase_ne hs, erase_ne hs, add_apply]
intros
rw ‚Üê fintype.card_coe at h
rcases nonempty_of_card_le h with ‚ü®f‚ü©
exact ‚ü®f.trans (embedding.subtype _), by simp [set.range_subset_iff]‚ü©
intros
rcases exists_seq_of_forall_finset_exists P r h with ‚ü®f, hf, hf'‚ü©
refine ‚ü®f, hf, Œª m n hmn, _‚ü©
rcases lt_trichotomy m n with h|rfl|h
{ exact hf' m n h }
exact hf' m n h
{ exact (hmn rfl).elim }
exact (hmn rfl).elim
apply symm
{ apply symm, exact hf' n m h }
exact hf' n m h
intros
classical
rw ‚Üênot_iff_not
push_neg
rw [not_nontrivial_iff_subsingleton, card_le_one_iff_subsingleton]
intros
apply finset.prod_eq_mul a b h‚ÇÅ (Œª x _ hx, h‚ÇÇ x hx)
apply finset.prod_eq_mul a b h‚ÇÅ (Œª x _ hx, h‚ÇÇ x hx); exact Œª hc, (hc (finset.mem_univ _)).elim
exact Œª hc, (hc (finset.mem_univ _)).elim
exact Œª hc, (hc (finset.mem_univ _)).elim
intros
refine ‚ü®Œª h, is_unit_eq_one_or h, Œª h, _‚ü©
rcases h with rfl | rfl
{ exact is_unit_one }
exact is_unit_one
{ exact is_unit_one.neg }
exact is_unit_one.neg
intros
{ rw [sq, sq], exact nat_abs_le_iff_mul_self_le }
rw [sq, sq]
exact nat_abs_le_iff_mul_self_le
intros
rw [mul_comm, int.mul_div_assoc _ h, mul_comm]
intros
rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]
rw [nat_abs_of_nat, nat.div_self H]
intros
rw [even_add, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
cases l; refl
cases l
refl
refl
intros
induction l; simp *
induction l
simp *
simp *
intros
simpa [‚Üêlength_eq_zero] using nat.sub_eq_zero_of_le h
intros
revert a; induction l; intros; [refl, simp only [*, map, foldl]]
revert a; induction l; intros
revert a; induction l
revert a
induction l
intros
refl
intros
simp only [*, map, foldl]
intros
induction l; [refl, simp only [*, list.join, map, prod_append, prod_cons]]
induction l
refl
simp only [*, list.join, map, prod_append, prod_cons]
intros
induction l with x l
{ exfalso, exact lt_irrefl _ h }
exfalso
exact lt_irrefl _ h
by_cases h' : f x < g x
{ by_cases h' : f x < g x, exact ‚ü®x, mem_cons_self _ _, h'‚ü©, rcases l_ih _ with ‚ü®y, h1y, h2y‚ü©, refine ‚ü®y, mem_cons_of_mem x h1y, h2y‚ü©, simp at h, exact lt_of_add_lt_add_left (lt_of_lt_of_le h $ add_le_add_right (le_of_not_gt h') _) }
exact ‚ü®x, mem_cons_self _ _, h'‚ü©
rcases l_ih _ with ‚ü®y, h1y, h2y‚ü©
refine ‚ü®y, mem_cons_of_mem x h1y, h2y‚ü©
simp at h
exact lt_of_add_lt_add_left (lt_of_lt_of_le h $ add_le_add_right (le_of_not_gt h') _)
intros
induction l; [refl, simp only [*, pmap, map]]; split; refl
induction l; [refl, simp only [*, pmap, map]]; split
induction l; [refl, simp only [*, pmap, map]]
induction l
refl
simp only [*, pmap, map]
split
refl
refl
intros
simp only [reduce_option, filter_map, id.def]
intros
simp [-add_comm]
intros
rw [permutations_aux, permutations_aux.rec]
intros
rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]
rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]; rintro b h' rfl; exact h h'
rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]; rintro b h' rfl
rintro b h' rfl
exact h h'
intros
simp only [concat_eq_append, last_append]
intros
cases pairwise_cons.1 p with r p'
clear p
induction p' with b l r' p IH generalizing a
exact chain.nil
{exact chain.nil}
simp only [chain_cons, forall_mem_cons] at r
exact chain_cons.2 ‚ü®r.1, IH r'‚ü©
intros
obtain ‚ü®n, hn, rfl‚ü© := nth_le_of_mem hx
simp only [next_nth_le, prev_nth_le, h, nat.mod_add_mod]
cases l with hd tl
{ simp }
simp
have : n < 1 + tl.length := by simpa [add_comm] using hn
{ have : n < 1 + tl.length := by simpa [add_comm] using hn, simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this] }
simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this]
intros
induction h with l' h y l' h hm
{ exact mem_cons_self _ _ }
exact mem_cons_self _ _
{ exact mem_cons_of_mem _ hm }
exact mem_cons_of_mem _ hm
intros
dsimp [Ico]; simp [nat.add_sub_cancel_left]
dsimp [Ico]
simp [nat.add_sub_cancel_left]
intros
induction l‚ÇÅ with a l‚ÇÅ ih generalizing l‚ÇÇ
{ exact h }
exact h
apply nodup_insert
exact ih h
intros
refine (pairwise_pmap h).2 (pairwise.imp_of_mem _ hl)
intros
apply hS
assumption
intros
obtain ‚ü®n, rfl‚ü© := h
obtain ‚ü®m, rfl‚ü© := h'
rw rotate_rotate
use (n + m)
intros
rw [rotate_eq_rotate', rotate_eq_rotate', rotate'_cons_succ]
intros
rw [sublists', sublists'_aux]; simp only [sublists'_aux_eq_sublists', map_id, append_nil]; refl
rw [sublists', sublists'_aux]; simp only [sublists'_aux_eq_sublists', map_id, append_nil]
rw [sublists', sublists'_aux]
simp only [sublists'_aux_eq_sublists', map_id, append_nil]
refl
intros
{ ext, apply neg_dot_product }
ext
apply neg_dot_product
intros
ext
{ ext, refl }
refl
intros
dsimp [bit1]; by_cases h : i = j; simp [h]
dsimp [bit1]; by_cases h : i = j
dsimp [bit1]
by_cases h : i = j
simp [h]
simp [h]
intros
{ ext, simp [mul_apply, ring_hom.map_sum], }
ext
simp [mul_apply, ring_hom.map_sum]
intros
ext a b
simp only [mul_apply, std_basis_matrix, boole_mul]
by_cases h‚ÇÅ : i = a; by_cases h‚ÇÇ : k = b; simp [h‚ÇÅ, h‚ÇÇ]
by_cases h‚ÇÅ : i = a; by_cases h‚ÇÇ : k = b
by_cases h‚ÇÅ : i = a
by_cases h‚ÇÇ : k = b
simp [h‚ÇÅ, h‚ÇÇ]
simp [h‚ÇÅ, h‚ÇÇ]
by_cases h‚ÇÇ : k = b
simp [h‚ÇÅ, h‚ÇÇ]
simp [h‚ÇÅ, h‚ÇÇ]
intros
ext ‚ü®i, k‚ü© ‚ü®j, k'‚ü©
simp only [block_diagonal'_apply, diagonal]
split_ifs; finish
split_ifs
finish
finish
finish
finish
finish
finish
intros
rw vec_alt0_append
intros
rw [‚Üê to_matrix_trans, single_trans_single_of_ne hb, to_matrix_bot]
intros
induction s with l a b
{ induction s with l a b, exact list.sizeof_lt_sizeof_of_mem hx, refl }
exact list.sizeof_lt_sizeof_of_mem hx
refl
intros
split_ifs with h; simp only [h, multiset.countp_cons_of_pos, add_zero, multiset.countp_cons_of_neg, not_false_iff]
split_ifs with h
simp only [h, multiset.countp_cons_of_pos, add_zero, multiset.countp_cons_of_neg, not_false_iff]
simp only [h, multiset.countp_cons_of_pos, add_zero, multiset.countp_cons_of_neg, not_false_iff]
intros
rw [‚Üê rel_flip, rel_cons_left]
apply exists_congr
assume a
apply exists_congr
assume as'
rw [rel_flip, flip]
intros
simp [hc.comm]
intros
rw [‚Üê coeff_X_pow, pow_one]
intros
{ ext1, apply map_C }
ext1
apply map_C
intros
rw succ_le_iff
intros
rw [subsingleton.elim h1 (le_trans (le_succ n) h2), le_rec_on_trans (le_succ n) h2, le_rec_on_succ']
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
rcases n_dvd with ‚ü®k, rfl‚ü©
have : n ‚â† 0
rintro rfl
{rintro rfl, simpa using n_nonzero}
simpa using n_nonzero
rw nat.mul_div_cancel_left _ (pos_iff_ne_zero.2 this)
rw [nat.cast_mul, mul_div_cancel_left _ n_nonzero]
intros
rw [choose_eq_factorial_div_factorial hk, choose_eq_factorial_div_factorial (nat.sub_le _ _), nat.sub_sub_self hk, mul_comm]
intros
classical
rw [sum_powerset_neg_one_pow_card, if_neg]
rw [‚Üê ne.def, ‚Üê nonempty_iff_ne_empty]
apply h0
intros
induction L with d L ih
{ refl, }
refl
dsimp [of_digits]
{ dsimp [of_digits], dsimp [nat.modeq] at *, conv_lhs { rw [nat.add_mod, nat.mul_mod, h, ih], }, conv_rhs { rw [nat.add_mod, nat.mul_mod], }, }
dsimp [nat.modeq] at *
conv_lhs { rw [nat.add_mod, nat.mul_mod, h, ih], }
conv_rhs { rw [nat.add_mod, nat.mul_mod], }
intros
rw [gcd_comm, gcd_gcd_self_right_right]
intros
simp [coprime]
intros
rw [log, if_neg (Œª h : b ‚â§ n ‚àß 1 < b, h.1.not_lt hnb)]
intros
by_cases h : a < b; simp [mkpair, h]
by_cases h : a < b
simp [mkpair, h]
exact le_trans (le_mul_self _) (nat.le_add_right _ _)
simp [mkpair, h]
intros
rcases even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©
rcases even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©; use k
use k
simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm
{ simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm }
use k
simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self]
{ simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self] }
intros
{ rw ‚Üê h, exact not_prime_mul h‚ÇÅ h‚ÇÇ }
rw ‚Üê h
exact not_prime_mul h‚ÇÅ h‚ÇÇ
intros
cases x; simp only [pmap, none_bind, some_bind, pbind]
{ cases x; simp only [pmap, none_bind, some_bind, pbind] }
cases x
simp only [pmap, none_bind, some_bind, pbind]
simp only [pmap, none_bind, some_bind, pbind]
intros
cases o; simp [to_list, eq_comm]
cases o
simp [to_list, eq_comm]
simp [to_list, eq_comm]
intros
cases t; refl
cases t
refl
refl
intros
rw nat.dist_comm; exact H.dist_le
rw nat.dist_comm
exact H.dist_le
intros
rw [‚Üê dest_mk x,h,dest_mk]
intros
cases p; reflexivity
cases p
reflexivity
intros
dsimp [start, v, xgcd_type.a, xgcd_type.b, w, z]
rw [one_mul, one_mul, zero_mul, zero_mul, zero_add, add_zero]
rw [‚Üê nat.pred_eq_sub_one, ‚Üê nat.pred_eq_sub_one]
rw [nat.succ_pred_eq_of_pos a.pos, nat.succ_pred_eq_of_pos b.pos]
intros
simp [bit0, add_mul]
intros
apply coeff_eq_zero_of_degree_lt
by_cases hp : p = 0
{ subst hp, exact with_bot.bot_lt_coe n }
subst hp
exact with_bot.bot_lt_coe n
{ rwa [degree_eq_nat_degree hp, with_bot.coe_lt_coe] }
rwa [degree_eq_nat_degree hp, with_bot.coe_lt_coe]
intros
simp [(monic_X_pow n).degree_mul]
intros
by_cases hp : p = 0
{ rw hp, exact le_top }
rw hp
exact le_top
rw trailing_degree_eq_nat_trailing_degree hp
{ rw trailing_degree_eq_nat_trailing_degree hp, exact le_trailing_degree_of_ne_zero h }
exact le_trailing_degree_of_ne_zero h
intros
convert iterate_derivative_smul a p k; apply C_mul'
convert iterate_derivative_smul a p k
apply C_mul'
apply C_mul'
intros
simp [erase_lead_coeff, hi]
intros
nontriviality R
apply nat_degree_mul'
simp [hp.leading_coeff, hq.leading_coeff]
intros
rw [reverse, reverse, reflect_neg, nat_degree_neg]
intros
rw [taylor_coeff, hasse_deriv_one]
intros
lift b to ‚Ñï using le_of_lt hb0
norm_cast at hb0 h
rw [‚Üê rat.mk_eq_div, ‚Üê rat.mk_pnat_eq a b hb0, rat.mk_pnat_num, pnat.mk_coe, h.gcd_eq_one, int.coe_nat_one, int.div_one]
intros
rw [‚Üê mk_zero, mk_lt]; exact iff_of_eq (congr_arg pos (sub_zero f))
rw [‚Üê mk_zero, mk_lt]
exact iff_of_eq (congr_arg pos (sub_zero f))
intros
simp [ennreal.to_real]
intros
induction n with n ihn
simp
{ simp }
rw [pow_succ, mul_eq_top, ihn]
fsplit
rintro (‚ü®-,rfl,h0‚ü©|‚ü®rfl,h0‚ü©); exact ‚ü®rfl, n.succ_ne_zero‚ü©
rintro (‚ü®-,rfl,h0‚ü©|‚ü®rfl,h0‚ü©)
{ rintro (‚ü®-,rfl,h0‚ü©|‚ü®rfl,h0‚ü©); exact ‚ü®rfl, n.succ_ne_zero‚ü© }
exact ‚ü®rfl, n.succ_ne_zero‚ü©
exact ‚ü®rfl, n.succ_ne_zero‚ü©
rintro ‚ü®rfl, -‚ü©
{ rintro ‚ü®rfl, -‚ü©, exact or.inr ‚ü®rfl, pow_ne_zero n top_ne_zero‚ü© }
exact or.inr ‚ü®rfl, pow_ne_zero n top_ne_zero‚ü©
intros
apply lt_of_le_of_ne (ereal.neg_le_of_neg_le h.le)
assume H
rw [‚Üê H, ereal.neg_neg] at h
exact lt_irrefl _ h
intros
simpa only [sub_eq_add_neg, cast_neg] using h.add_rat (-q)
intros
rw [‚Üê nnreal.coe_lt_coe, nnreal.coe_div]; exact half_lt_self (bot_lt_iff_ne_bot.2 h)
rw [‚Üê nnreal.coe_lt_coe, nnreal.coe_div]
exact half_lt_self (bot_lt_iff_ne_bot.2 h)
intros
rw [sign, if_pos hr]
intros
simp_rw [sqrt, ‚Üê nnreal.coe_mul, nnreal.coe_eq, real.to_nnreal_mul hx, nnreal.sqrt_mul]
intros
induction n; simp [*, tail_congr]
induction n
simp [*, tail_congr]
simp [*, tail_congr]
intros
rw [‚Üê ite_compl, ite_inter_self]
intros
rw [diff_subset_iff, ‚Üê image_union, union_diff_self]
exact image_subset f (subset_union_right t s)
intros
apply subset.antisymm
{ rintros _ ‚ü®b, rfl‚ü©, simp }
rintros _ ‚ü®b, rfl‚ü©
simp
rintros ‚ü®x, y‚ü© (rfl|_)
{ rintros ‚ü®x, y‚ü© (rfl|_), exact mem_range_self y }
exact mem_range_self y
intros
{ ext, simp }
ext
simp
intros
ext
{ ext, simp [pi] }
simp [pi]
intros
ext c
split
rintros ‚ü®a, b, ha, h1b|h2b, rfl‚ü©;[left, right]; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
rintros ‚ü®a, b, ha, h1b|h2b, rfl‚ü©;[left, right]
rintros ‚ü®a, b, ha, h1b|h2b, rfl‚ü©
{ rintros ‚ü®a, b, ha, h1b|h2b, rfl‚ü©;[left, right]; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü© }
left
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
right
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©); refine ‚ü®_, _, ‚Äπ_‚Ä∫, _, rfl‚ü©; simp [mem_union, *]
rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©); refine ‚ü®_, _, ‚Äπ_‚Ä∫, _, rfl‚ü©
rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©)
{ rintro (‚ü®_, _, _, _, rfl‚ü©|‚ü®_, _, _, _, rfl‚ü©); refine ‚ü®_, _, ‚Äπ_‚Ä∫, _, rfl‚ü©; simp [mem_union, *] }
refine ‚ü®_, _, ‚Äπ_‚Ä∫, _, rfl‚ü©
simp [mem_union, *]
refine ‚ü®_, _, ‚Äπ_‚Ä∫, _, rfl‚ü©
simp [mem_union, *]
intros
{ rw ‚Üê image_prod, exact (hs.prod ht).image _ }
rw ‚Üê image_prod
exact (hs.prod ht).image _
intros
classical
rw [fintype.card_of_subtype (set.to_finset p·∂ú), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]
rw [fintype.card_of_subtype (set.to_finset p·∂ú), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]; intros; simp; refl
rw [fintype.card_of_subtype (set.to_finset p·∂ú), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]; intros; simp
rw [fintype.card_of_subtype (set.to_finset p·∂ú), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]; intros
intros
simp
refl
intros
simp
refl
intros
refine (h‚ÇÅ.congr _).union_union (h‚ÇÇ.congr _)
exacts [(piecewise_eq_on s f‚ÇÅ f‚ÇÇ).symm.mono (inter_subset_right _ _), (piecewise_eq_on_compl s f‚ÇÅ f‚ÇÇ).symm.mono (inter_subset_right _ _)]
intros
simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm]
simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm]; ac_refl
ac_refl
intros
simp_rw [set.disjoint_iff_inter_eq_empty, Ico_inter_Ico, Ico_eq_empty_iff, inf_eq_min, sup_eq_max, not_lt]
intros
simp
intros
simp [‚Üê Ici_inter_Iio, h]
intros
{ rw ‚Üê Icc_self, exact ord_connected_Icc }
rw ‚Üê Icc_self
exact ord_connected_Icc
intros
simp only [interval, preimage_neg_Icc, min_neg_neg, max_neg_neg]
intros
simp [set.not_disjoint_iff, set.nonempty_def]
intros
haveI : nonempty s := hs.to_subtype
simp [bInter_eq_Inter, ‚Üê Inter_inter]
intros
cases x; refl
cases x
refl
intros
cases s
change a ‚àà b ::‚Çò s_val ‚Üî a = b ‚à® a ‚àà s_val
simp
intros
cases v; cases i; cases j; simp [vector.update_nth, vector.nth_eq_nth_le, list.nth_le_update_nth_of_ne (fin.vne_of_ne h)]
cases v; cases i; cases j
cases v; cases i
cases v
cases i
cases j
simp [vector.update_nth, vector.nth_eq_nth_le, list.nth_le_update_nth_of_ne (fin.vne_of_ne h)]
intros
simp [val]
intros
cases n
calc a * a‚Åª¬π = a * int.sign a : rfl ... = a.nat_abs : by rw [int.mul_sign, int.nat_cast_eq_coe_nat] ... = a.val.gcd 0 : by rw nat.gcd_zero_right; refl
{ calc a * a‚Åª¬π = a * int.sign a : rfl ... = a.nat_abs : by rw [int.mul_sign, int.nat_cast_eq_coe_nat] ... = a.val.gcd 0 : by rw nat.gcd_zero_right; refl }
set k := n.succ
{ set k := n.succ, calc a * a‚Åª¬π = a * a‚Åª¬π + k * nat.gcd_b (val a) k : by rw [nat_cast_self, zero_mul, add_zero] ... = ‚Üë(‚Üëa.val * nat.gcd_a (val a) k + k * nat.gcd_b (val a) k) : by { push_cast, rw nat_cast_zmod_val, refl } ... = nat.gcd a.val k : (congr_arg coe (nat.gcd_eq_gcd_ab a.val k)).symm, }
calc a * a‚Åª¬π = a * a‚Åª¬π + k * nat.gcd_b (val a) k : by rw [nat_cast_self, zero_mul, add_zero] ... = ‚Üë(‚Üëa.val * nat.gcd_a (val a) k + k * nat.gcd_b (val a) k) : by { push_cast, rw nat_cast_zmod_val, refl } ... = nat.gcd a.val k : (congr_arg coe (nat.gcd_eq_gcd_ab a.val k)).symm
intros
cases n; simp
{ cases n; simp }
cases n
simp
simp
intros
split
split; simp
simp
simp
intros
refine ae_all_iff.2 (Œª k, _)
refine (hf.ae_mem_imp_frequently_image_mem (hf.measurable.iterate k hs)).mono (Œª x hx hk, _)
rw [‚Üê map_add_at_top_eq_nat k, frequently_map]
refine (hx hk).mono (Œª n hn, _)
rwa [add_comm, iterate_add_apply]
intros
apply_instance
intros
rw power_basis.finrank (adjoin.power_basis hx : _)
refl
intros
{ convert is_alg_closed.splits (p.map f), simp [splits_map_iff] }
convert is_alg_closed.splits (p.map f)
simp [splits_map_iff]
intros
let œà := alg_equiv.of_injective_field (is_scalar_tower.to_alg_hom F p.splitting_field E)
change ‚Üë(œà (œà.symm _)) = œï x
rw alg_equiv.apply_symm_apply œà
change œï (roots_equiv_roots p E ((roots_equiv_roots p E).symm x)) = œï x
rw equiv.apply_symm_apply (roots_equiv_roots p E)
intros
rw [‚Üê expand_C, expand_inj hp, expand_C]
intros
change i with ((ring_hom.id _).comp i) at h
rw [‚Üê splits_map_iff]
rw [‚Üê splits_map_iff i] at h
exact splits_of_splits_id _ h
intros
unfold angle
rw [inner_zero_left, zero_div, real.arccos_zero]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ‚Üê vsub_sub_vsub_cancel_right]
exact norm_sub_eq_abs_sub_norm_of_angle_eq_zero h
intros
change ‚àÉ r : ‚Ñù, ‚àÄ i, (Œª x, dist x p = r) (s.points i) at hr
conv at hr { congr, funext, rw ‚Üêset.forall_range_iff }
rw exists_dist_eq_iff_exists_dist_orthogonal_projection_eq (subset_affine_span ‚Ñù _) p at hr
cases hr with r hr
exact s.eq_circumcenter_of_dist_eq (orthogonal_projection_mem p) (Œª i, hr _ (set.mem_range_self i))
intros
filter_upwards [is_open.mem_nhds (ext_chart_preimage_open_of_open I c is_open_ball) ‚ü®hs, hd‚ü©]
rintro z ‚ü®hzs, hzd : _ < _‚ü©
exact f.one_of_dist_le hzs hzd.le
intros
ext
{ ext, rw hxs.eq h h.mdifferentiable_within_at.has_mfderiv_within_at }
rw hxs.eq h h.mdifferentiable_within_at.has_mfderiv_within_at
intros
rw [‚Üê has_mfderiv_within_at_univ, has_mfderiv_within_at_iff_has_fderiv_within_at, has_fderiv_within_at_univ]
intros
rw [ext_chart_at, local_equiv.trans_source, I.source_eq, preimage_univ, inter_univ]
intros
rw times_cont_mdiff_within_at_iff'' at *
exact ‚ü®hf.1.prod hg.1, hf.2.prod hg.2‚ü©
intros
intros x hx y hy h
simp only [embedding_pi_tangent_coe, funext_iff] at h
obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := prod.mk.inj_iff.1 (h (f.ind x hx))
rw [f.apply_ind x hx] at h‚ÇÇ
rw [‚Üê h‚ÇÇ, f.apply_ind x hx, one_smul, one_smul] at h‚ÇÅ
have := f.mem_ext_chart_at_source_of_eq_one h‚ÇÇ.symm
exact (ext_chart_at I (f.c _)).inj_on (f.mem_ext_chart_at_ind_source x hx) this h‚ÇÅ
intros
rw sup_eq_con_gen; refl
rw sup_eq_con_gen
refl
intros
convert @abelianization.lift.of (free_group Œ±) _ (multiplicative Œ≤) _ _ _
convert free_group.lift.of.symm
intros
induction L with hd1 tl1 ih
case list.nil { constructor }
constructor
case list.cons { dsimp, revert ih, generalize htl : reduce tl1 = TL, intro ih, cases TL with hd2 tl2, case list.nil { exact red.cons_cons ih }, case list.cons { dsimp, by_cases h : hd1.fst = hd2.fst ‚àß hd1.snd = bnot (hd2.snd), { rw [if_pos h], transitivity, { exact red.cons_cons ih }, { cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red } }, { rw [if_neg h], exact red.cons_cons ih } } }
dsimp
revert ih
generalize htl : reduce tl1 = TL
intro ih
cases TL with hd2 tl2
case list.nil { exact red.cons_cons ih }
exact red.cons_cons ih
case list.cons { dsimp, by_cases h : hd1.fst = hd2.fst ‚àß hd1.snd = bnot (hd2.snd), { rw [if_pos h], transitivity, { exact red.cons_cons ih }, { cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red } }, { rw [if_neg h], exact red.cons_cons ih } }
dsimp
by_cases h : hd1.fst = hd2.fst ‚àß hd1.snd = bnot (hd2.snd)
rw [if_pos h]
{ rw [if_pos h], transitivity, { exact red.cons_cons ih }, { cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red } }
transitivity
exact red.cons_cons ih
{ exact red.cons_cons ih }
cases hd1
{ cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red }
cases hd2
cases h
dsimp at *
subst_vars
exact red.step.cons_bnot_rev.to_red
rw [if_neg h]
{ rw [if_neg h], exact red.cons_cons ih }
exact red.cons_cons ih
intros
suffices : ‚àÄ H‚ÇÅ H‚ÇÇ : subgroup G, ‚ÅÖH‚ÇÅ, H‚ÇÇ‚ÅÜ ‚â§ ‚ÅÖH‚ÇÇ, H‚ÇÅ‚ÅÜ
exact le_antisymm (this _ _) (this _ _)
{ exact le_antisymm (this _ _) (this _ _) }
intros H‚ÇÅ H‚ÇÇ
rw general_commutator_le
intros p hp q hq
have h : (p * q * p‚Åª¬π * q‚Åª¬π)‚Åª¬π ‚àà ‚ÅÖH‚ÇÇ, H‚ÇÅ‚ÅÜ := subset_closure ‚ü®q, hq, p, hp, by group‚ü©
convert inv_mem ‚ÅÖH‚ÇÇ, H‚ÇÅ‚ÅÜ h
group
intros
rw [smul_mul_assoc, mul_smul_comm, ‚Üê smul_assoc, smul_eq_mul]
intros
rw mul_equiv_of_localizations_left_inv
intros
rw [f.eq, localization.r_iff_exists]
intros
rw [powers_equiv_powers, equiv.trans_apply, equiv.trans_apply, fin_equiv_powers_symm_apply, ‚Üê equiv.eq_symm_apply, fin_equiv_powers_symm_apply]
simp [h]
intros
rw [parts_partition, filter_add, multiset.filter_eq_self.2 (Œª _, two_le_of_mem_cycle_type), multiset.filter_eq_nil.2 (Œª a h, _), add_zero]
rw multiset.eq_of_mem_repeat h
dec_trivial
intros
simp [cycle_factors_finset_eq_empty_iff]
intros
simp only [set.sup_eq_union, set.le_eq_subset]
induction l with y l hl generalizing l'
{ simp }
simp
cases l' with z l'
{ cases l' with z l', { simp }, { intro x, simp only [set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply], intro hx, by_cases h : x ‚àà {x | (zip_with swap l l').prod x ‚â† x}, { specialize hl l' h, refine set.mem_union.elim hl (Œª hm, _) (Œª hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢, simp [hm] } }, { simp only [not_not, set.mem_set_of_eq] at h, simp only [h, set.mem_set_of_eq] at hx, rw swap_apply_ne_self_iff at hx, rcases hx with ‚ü®hyz, rfl|rfl‚ü©; simp } } }
{ simp }
simp
intro x
{ intro x, simp only [set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply], intro hx, by_cases h : x ‚àà {x | (zip_with swap l l').prod x ‚â† x}, { specialize hl l' h, refine set.mem_union.elim hl (Œª hm, _) (Œª hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢, simp [hm] } }, { simp only [not_not, set.mem_set_of_eq] at h, simp only [h, set.mem_set_of_eq] at hx, rw swap_apply_ne_self_iff at hx, rcases hx with ‚ü®hyz, rfl|rfl‚ü©; simp } }
simp only [set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply]
intro hx
by_cases h : x ‚àà {x | (zip_with swap l l').prod x ‚â† x}
specialize hl l' h
{ specialize hl l' h, refine set.mem_union.elim hl (Œª hm, _) (Œª hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢, simp [hm] } }
refine set.mem_union.elim hl (Œª hm, _) (Œª hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢, simp [hm] }
refine set.mem_union.elim hl (Œª hm, _) (Œª hm, _)
{ simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢, simp [hm] }
simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢
{ simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ‚ä¢, simp [hm] }
simp [hm]
simp only [not_not, set.mem_set_of_eq] at h
{ simp only [not_not, set.mem_set_of_eq] at h, simp only [h, set.mem_set_of_eq] at hx, rw swap_apply_ne_self_iff at hx, rcases hx with ‚ü®hyz, rfl|rfl‚ü©; simp }
simp only [h, set.mem_set_of_eq] at hx
rw swap_apply_ne_self_iff at hx
rcases hx with ‚ü®hyz, rfl|rfl‚ü©; simp
rcases hx with ‚ü®hyz, rfl|rfl‚ü©
simp
simp
intros
simp [equiv_functor.map]
intros
simp_rw [finset.ext_iff, mem_support, not_iff_not, (inv_eq_iff_eq).trans eq_comm, iff_self, imp_true_iff]
intros
ext
ext; simp [map]
simp [map]
simp [map]
intros
rw [mem_alternating_group, sign_prod_list_swap hl, ‚Üê units.coe_eq_one, units.coe_pow, units.coe_neg_one, nat.neg_one_pow_eq_one_iff_even]
dec_trivial
intros
{ ext, simp, }
ext
simp
intros
simp only [mrange_inl, mrange_inr, prod_bot_sup_bot_prod, top_prod_top]
intros
{ ext p, simp [homothety_apply] }
ext p
simp [homothety_apply]
intros
rw [direction_eq_vector_span, vector_span_def]
repeat { rw [direction_eq_vector_span, vector_span_def] }
rw [direction_eq_vector_span, vector_span_def]
rw [direction_eq_vector_span, vector_span_def]
exact vector_span_mono k h
intros
simp [h]
intros
simp_rw [collinear_iff_dim_le_one, dim_submodule_le_one_iff', submodule.le_span_singleton_iff]
split
rintro ‚ü®v‚ÇÄ, hv‚ü©
{ rintro ‚ü®v‚ÇÄ, hv‚ü©, use v‚ÇÄ, intros p hp, obtain ‚ü®r, hr‚ü© := hv (p -·µ• p‚ÇÄ) (vsub_mem_vector_span k hp h), use r, rw eq_vadd_iff_vsub_eq, exact hr.symm }
use v‚ÇÄ
intros p hp
obtain ‚ü®r, hr‚ü© := hv (p -·µ• p‚ÇÄ) (vsub_mem_vector_span k hp h)
use r
rw eq_vadd_iff_vsub_eq
exact hr.symm
rintro ‚ü®v, hp‚ÇÄv‚ü©
{ rintro ‚ü®v, hp‚ÇÄv‚ü©, use v, intros w hw, have hs : vector_span k s ‚â§ k ‚àô v, { rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, set.subset_def], intros x hx, rw [set_like.mem_coe, submodule.mem_span_singleton], rw set.mem_image at hx, rcases hx with ‚ü®p, hp, rfl‚ü©, rcases hp‚ÇÄv p hp with ‚ü®r, rfl‚ü©, use r, simp }, have hw' := set_like.le_def.1 hs hw, rwa submodule.mem_span_singleton at hw' }
use v
intros w hw
have hs : vector_span k s ‚â§ k ‚àô v
rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, set.subset_def]
{ rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, set.subset_def], intros x hx, rw [set_like.mem_coe, submodule.mem_span_singleton], rw set.mem_image at hx, rcases hx with ‚ü®p, hp, rfl‚ü©, rcases hp‚ÇÄv p hp with ‚ü®r, rfl‚ü©, use r, simp }
intros x hx
rw [set_like.mem_coe, submodule.mem_span_singleton]
rw set.mem_image at hx
rcases hx with ‚ü®p, hp, rfl‚ü©
rcases hp‚ÇÄv p hp with ‚ü®r, rfl‚ü©
use r
simp
have hw' := set_like.le_def.1 hs hw
rwa submodule.mem_span_singleton at hw'
intros
rw [midpoint, point_reflection_apply, line_map_apply, vadd_vsub, vadd_vadd, ‚Üê add_smul, ‚Üê two_mul, mul_inv_of_self, one_smul, vsub_vadd]
intros
{ rw add_comm, exact f.map_swap_add v hij }
rw add_comm
exact f.map_swap_add v hij
intros
use [0, x, submodule.mem_span_singleton_self x]
intros H
rw [eq_comm, submodule.mk_eq_zero] at H
exact h H
intros
{ ext, simp }
ext
simp
intros
split
intros h
{ intros h, use 0, rw [‚Üê set_like.mem_coe, f.range_coe], exact ‚ü®‚ü®0, map_zero f‚ü©, h‚ü©, }
use 0
rw [‚Üê set_like.mem_coe, f.range_coe]
exact ‚ü®‚ü®0, map_zero f‚ü©, h‚ü©
rintros ‚ü®y, h‚ÇÅ, h‚ÇÇ‚ü©
{ rintros ‚ü®y, h‚ÇÅ, h‚ÇÇ‚ü©, rw set_like.le_def, intros z hz, simp only [mem_ker, set_like.mem_coe] at hz, rw [‚Üê set_like.mem_coe, f.range_coe, set.mem_range] at h‚ÇÅ, obtain ‚ü®x, hx‚ü© := h‚ÇÅ, have hx' : x ‚àà p, { exact h‚ÇÇ hx, }, have hxz : z + x ‚àà p, { apply h‚ÇÇ, simp [hx, hz], }, suffices : z + x - x ‚àà p, { simpa only [this, add_sub_cancel], }, exact p.sub_mem hxz hx', }
rw set_like.le_def
intros z hz
simp only [mem_ker, set_like.mem_coe] at hz
rw [‚Üê set_like.mem_coe, f.range_coe, set.mem_range] at h‚ÇÅ
obtain ‚ü®x, hx‚ü© := h‚ÇÅ
have hx' : x ‚àà p
exact h‚ÇÇ hx
{ exact h‚ÇÇ hx, }
have hxz : z + x ‚àà p
apply h‚ÇÇ
{ apply h‚ÇÇ, simp [hx, hz], }
simp [hx, hz]
suffices : z + x - x ‚àà p
simpa only [this, add_sub_cancel]
{ simpa only [this, add_sub_cancel], }
exact p.sub_mem hxz hx'
intros
{ rw ‚Üê b.coe_repr_symm, exact b.repr.apply_symm_apply v }
rw ‚Üê b.coe_repr_symm
exact b.repr.apply_symm_apply v
intros
simp [basis.constr_apply, b.repr_self]
intros
rw [dual_basis, basis.map_apply, basis.coe_dual_basis, ‚Üê to_dual_def hB, linear_equiv.apply_symm_apply, basis.coord_apply, basis.repr_self, finsupp.single_apply]
intros
simp only [bilin_form.comp_left, bilin_form.to_matrix'_comp, to_matrix'_id, matrix.mul_one]
intros
letI := classical.dec_eq (basis.of_vector_space_index K V)
apply tensor_product.ext
apply (basis.of_vector_space K V).dual_basis.ext
intro j
apply linear_map.ext_ring
rw [linear_map.compr‚ÇÇ_apply, linear_map.compr‚ÇÇ_apply, tensor_product.mk_apply]
simp only [linear_map.coe_comp, function.comp_app, linear_equiv.coe_to_linear_map]
rw [rid_tmul, one_smul, lid_symm_apply]
simp only [linear_equiv.coe_to_linear_map, linear_map.ltensor_tmul, coevaluation_apply_one]
rw [tensor_product.tmul_sum, linear_equiv.map_sum]
simp only [assoc_symm_tmul]
rw [linear_map.map_sum]
simp only [linear_map.rtensor_tmul, contract_left_apply]
simp only [basis.coe_dual_basis, basis.coord_apply, basis.repr_self_apply, tensor_product.ite_tmul]
rw [finset.sum_ite_eq']
simp only [finset.mem_univ, if_true]
intros
fapply card_le_of_surjective' R
{ exact b.repr.to_linear_map.comp (finsupp.total w M R coe), }
exact b.repr.to_linear_map.comp (finsupp.total w M R coe)
apply surjective.comp
{ apply surjective.comp, apply linear_equiv.surjective, rw [‚Üêlinear_map.range_eq_top, finsupp.range_total], simpa using s, }
apply linear_equiv.surjective
rw [‚Üêlinear_map.range_eq_top, finsupp.range_total]
simpa using s
intros
rw ‚Üêfintype.card_coe
exact fintype_card_le_finrank_of_linear_independent h
intros
rw [‚Üê s.finrank_quotient_add_finrank, add_comm]
exact nat.lt_add_of_zero_lt_left _ _ (finrank_pos_iff.mpr (quotient.nontrivial_of_lt_top _ h))
intros
simp only [finsupp.total_apply, finsupp.total_apply, finsupp.sum, f.map_sum, f.map_smul]
intros
simp [linear_independent_subtype_disjoint]
intros
simp [linear_independent, linear_map.ker_eq_bot']
intros
let b2 : m ‚Üí ‚Ñï := Œª i, ‚Üë(b i)
simp_rw to_square_block_det''
rw fin.prod_univ_eq_prod_range (Œª (k : ‚Ñï), (M.to_square_block' b2 k).det) n
apply det_of_block_triangular_matrix
{ intros i j hij, exact h i j (fin.coe_fin_lt.mp hij) }
intros i j hij
exact h i j (fin.coe_fin_lt.mp hij)
{ intro i, exact fin.is_lt (b i) }
intro i
exact fin.is_lt (b i)
intros
ext i j
simp only [mul_apply, circulant, mul_comm]
refine fintype.sum_equiv ((equiv.sub_left i).trans (equiv.add_right j)) _ _ _
intro x
congr' 2
{ simp }
simp
simp only [equiv.coe_add_right, function.comp_app, equiv.coe_trans, equiv.sub_left_apply]
{ simp only [equiv.coe_add_right, function.comp_app, equiv.coe_trans, equiv.sub_left_apply], abel }
abel
intros
simp [det_update_row_add, det_update_row_smul, det_zero_of_row_eq hij ((update_row_self).trans (update_row_ne hij.symm).symm)]
intros
rw ‚Üê(is_symm_from_blocks_iff.1 h).2.1
exact ha.from_blocks hd
intros
split
split; intros; ext i
split; intros
intros
ext i
{ apply (cramer_map_is_linear A i).1 }
apply (cramer_map_is_linear A i).1
intros
ext i
{ apply (cramer_map_is_linear A i).2 }
apply (cramer_map_is_linear A i).2
intros
simp [module.algebra_map_End_eq_smul_id, linear_map.to_matrix_id]
intros
revert m'
refine finset.induction_on t (by simp) _
assume i t hit Hrec m'
have A : (insert i t).piecewise (m + m') m' = update (t.piecewise (m + m') m') i (m i + m' i) := t.piecewise_insert _ _ _
have B : update (t.piecewise (m + m') m') i (m' i) = t.piecewise (m + m') m'
ext j
{ ext j, by_cases h : j = i, { rw h, simp [hit] }, { simp [h] } }
by_cases h : j = i
{ rw h, simp [hit] }
rw h
simp [hit]
{ simp [h] }
simp [h]
let m'' := update m' i (m i)
have C : update (t.piecewise (m + m') m') i (m i) = t.piecewise (m + m'') m''
ext j
{ ext j, by_cases h : j = i, { rw h, simp [m'', hit] }, { by_cases h' : j ‚àà t; simp [h, hit, m'', h'] } }
by_cases h : j = i
{ rw h, simp [m'', hit] }
rw h
simp [m'', hit]
by_cases h' : j ‚àà t; simp [h, hit, m'', h']
{ by_cases h' : j ‚àà t; simp [h, hit, m'', h'] }
by_cases h' : j ‚àà t
simp [h, hit, m'', h']
simp [h, hit, m'', h']
rw [A, f.map_add, B, C, finset.sum_powerset_insert hit, Hrec, Hrec, add_comm]
congr' 1
apply finset.sum_congr rfl (Œªs hs, _)
have : (insert i s).piecewise m m' = s.piecewise m m''
ext j
{ ext j, by_cases h : j = i, { rw h, simp [m'', finset.not_mem_of_mem_powerset_of_not_mem hs hit] }, { by_cases h' : j ‚àà s; simp [h, m'', h'] } }
by_cases h : j = i
{ rw h, simp [m'', finset.not_mem_of_mem_powerset_of_not_mem hs hit] }
rw h
simp [m'', finset.not_mem_of_mem_powerset_of_not_mem hs hit]
by_cases h' : j ‚àà s; simp [h, m'', h']
{ by_cases h' : j ‚àà s; simp [h, m'', h'] }
by_cases h' : j ‚àà s
simp [h, m'', h']
simp [h, m'', h']
rw this
intros
by_cases j = i
{ rw [h, update_same, update_same] }
rw [h, update_same, update_same]
{ rw [update_noteq h, update_noteq h] }
rw [update_noteq h, update_noteq h]
intros
ext x
ext x; simp [(‚ü®0, zero_mem _‚ü© : ‚àÉ x, x ‚àà p)]
simp [(‚ü®0, zero_mem _‚ü© : ‚àÉ x, x ‚àà p)]
intros
simp [of_is_compl]
intros
classical
induction s using finset.induction with a s has ih h
{ simp, }
simp
{ simp [finset.sum_insert has, add_tmul, ih], }
simp [finset.sum_insert has, add_tmul, ih]
intros
rw [@iff_def a, @iff_def b]; exact and_congr imp_not_comm decidable.not_imp_comm
rw [@iff_def a, @iff_def b]
exact and_congr imp_not_comm decidable.not_imp_comm
intros
{ext, refl}
ext
refl
intros
induction h
exact ih‚ÇÅ a
case refl_trans_gen.refl { exact ih‚ÇÅ a }
case refl_trans_gen.tail : b c hab hbc ih { exact ih‚ÇÉ hab (single hbc) ih (ih‚ÇÇ hbc) }
intros
simpa only [max_def] using hf.piecewise (measurable_set_le hg hf) hg
intros
simp_rw [integrable, hf.of_uncurry_left.ae_measurable, true_and]
exact measurable_set_lt (measurable.lintegral_prod_right hf.ennnorm) measurable_const
intros
have A : ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª z, hf.mk f z ‚àÇ(Œº.prod ŒΩ) := lintegral_congr_ae hf.ae_eq_mk
have B : ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´‚Åª x, ‚à´‚Åª y, hf.mk f (x, y) ‚àÇŒΩ ‚àÇŒº
apply lintegral_congr_ae
{ apply lintegral_congr_ae, filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk], assume a ha, exact lintegral_congr_ae ha }
filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk]
assume a ha
exact lintegral_congr_ae ha
rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]
apply_instance
intros
refine lintegral_le_of_forall_fin_meas_le' hm (Œº s * ‚à•x‚à•‚Çä) _ (Œª t ht hŒºt, _)
{ exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal, }
exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal
refine (set_lintegral_nnnorm_condexp_ind_smul_le hm hs hŒºs x ht hŒºt).trans _
refine ennreal.mul_le_mul _ le_rfl
exact measure_mono (set.inter_subset_left _ _)
intros
simp [has_finite_integral_iff_norm]
intros
rw [mem_‚Ñíp, snorm_one_eq_lintegral_nnnorm]
exact ‚ü®ae_measurable.ennreal_to_real hfm, has_finite_integral_to_real_of_lintegral_ne_top hfi‚ü©
intros
{ convert edist_to_Lp_to_Lp f 0 hf zero_mem_‚Ñíp, simp }
convert edist_to_Lp_to_Lp f 0 hf zero_mem_‚Ñíp
simp
intros
refine ‚ü®Œª hfg, ‚ü®_, _‚ü©, Œª h, h.1.add h.2‚ü©
rw ‚Üê indicator_add_eq_left h
{ rw ‚Üê indicator_add_eq_left h, exact hfg.indicator (measurable_set_support hf) }
exact hfg.indicator (measurable_set_support hf)
rw ‚Üê indicator_add_eq_right h
{ rw ‚Üê indicator_add_eq_right h, exact hfg.indicator (measurable_set_support hg) }
exact hfg.indicator (measurable_set_support hg)
intros
simp only [snorm]
split_ifs
{ exact le_rfl }
exact le_rfl
refine ess_sup_mono_ae (h.mono $ Œª x hx, _)
{ refine ess_sup_mono_ae (h.mono $ Œª x hx, _), exact_mod_cast hx }
exact_mod_cast hx
{ exact snorm'_mono_ae ennreal.to_real_nonneg h }
exact snorm'_mono_ae ennreal.to_real_nonneg h
intros
{ simp only [sub_eq_add_neg, ‚Üê to_Lp_neg, ‚Üê to_Lp_add], refl }
simp only [sub_eq_add_neg, ‚Üê to_Lp_neg, ‚Üê to_Lp_add]
refl
intros
have hf' : f.fin_meas_supp Œº := integrable_iff_fin_meas_supp.1 hf
simp only [‚Üê map_apply g f, lintegral_eq_lintegral]
rw [map_integral f _ hf, map_lintegral, ennreal.to_real_sum]
refine finset.sum_congr rfl (Œªb hb, _)
{ refine finset.sum_congr rfl (Œªb hb, _), rw [smul_eq_mul, to_real_mul, mul_comm] }
rw [smul_eq_mul, to_real_mul, mul_comm]
assume a ha
{ assume a ha, by_cases a0 : a = 0, { rw [a0, hg0, zero_mul], exact with_top.zero_ne_top }, { apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne } }
by_cases a0 : a = 0
{ rw [a0, hg0, zero_mul], exact with_top.zero_ne_top }
rw [a0, hg0, zero_mul]
exact with_top.zero_ne_top
{ apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne }
apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne
{ simp [hg0] }
simp [hg0]
intros
simp only [integrable_on, e.restrict_map, integrable_map_equiv e]
intros
rw [integral_of_le hab, integral_eq_zero_iff_of_nonneg_ae hf hfi.1]
intros
refine set_to_simple_func_congr' T h_add hf ((integrable_congr h).mp hf) _
refine Œª x y hxy, h_zero _ ((measurable_set_fiber f x).inter (measurable_set_fiber g y)) _
rw [eventually_eq, ae_iff] at h
refine measure_mono_null (Œª z, _) h
simp_rw [set.mem_inter_iff, set.mem_set_of_eq, set.mem_preimage, set.mem_singleton_iff]
intro h
rwa [h.1, h.2]
intros
refine measurable_prod.2 _
split
split; { apply measurable_pi_iff.2 (Œª j, _), simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
{ apply measurable_pi_iff.2 (Œª j, _), simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
apply measurable_pi_iff.2 (Œª j, _)
{ apply measurable_pi_iff.2 (Œª j, _), simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply]
intros
funext
{ funext, refl, }
refl
intros
unfold prehaar
rw [div_le_iff]
rw [div_le_iff]; norm_cast
norm_cast
{ apply le_index_mul K‚ÇÄ K hU }
apply le_index_mul K‚ÇÄ K hU
norm_cast
{ exact index_pos K‚ÇÄ hU }
exact index_pos K‚ÇÄ hU
intros
rw [interval, volume_Icc, max_sub_min_eq_abs]
intros
apply ennreal.summable_to_real
rw ‚Üê measure_theory.measure_Union hf‚ÇÇ hf‚ÇÅ
exact ne_of_lt (measure_lt_top _ _)
intros
ext1 s
haveI : nonempty {t : ‚Ñï ‚Üí set Œ± // s ‚äÜ ‚ãÉ i, t i} := ‚ü®‚ü®Œª _, s, subset_Union (Œª _, s) 0‚ü©‚ü©
simp only [smul_apply, of_function_apply, ennreal.tsum_mul_left, pi.smul_apply, smul_eq_mul, infi_subtype', ennreal.infi_mul_left (Œª h, (hc h).elim)]
intros
{ simp only [‚Üê infi_subtype'', infi_apply' _ hs] }
simp only [‚Üê infi_subtype'', infi_apply' _ hs]
intros
rw [union_eq_Union, of_disjoint_Union, tsum_fintype, fintype.sum_bool, cond, cond]
exacts [Œª b, bool.cases_on b hB hA, pairwise_disjoint_on_bool.2 h]
intros
induction h_in_pi with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
{ apply h_meas_S _ h_s, }
apply h_meas_S _ h_s
{ apply measurable_set.inter h_s h_u, }
apply measurable_set.inter h_s h_u
simp [bernoulli]
intros
rw proper_divisors
simp
intros
rw ‚Üês_mod_mod
convert int.mod_lt _ _
refine (abs_of_nonneg _).symm
{ refine (abs_of_nonneg _).symm, simp only [sub_nonneg, ge_iff_le], exact_mod_cast nat.one_le_two_pow p, }
simp only [sub_nonneg, ge_iff_le]
exact_mod_cast nat.one_le_two_pow p
{ exact mersenne_int_ne_zero p w, }
exact mersenne_int_ne_zero p w
intros
dsimp [mersenne]
calc 0 < 2^1 - 1 : by norm_num ... ‚â§ 2^p - 1 : nat.pred_le_pred (nat.pow_le_pow_of_le_right (nat.succ_pos 1) h)
intros
rw lt_iff_le_and_ne; simp [norm_le_one z, nonunits, is_unit_iff]
rw lt_iff_le_and_ne
simp [norm_le_one z, nonunits, is_unit_iff]
intros
rw [sub_eq_add_neg, ‚Üêpadic_norm.neg p r]; apply padic_norm.nonarchimedean
rw [sub_eq_add_neg, ‚Üêpadic_norm.neg p r]
apply padic_norm.nonarchimedean
intros
unfold has_norm.norm
apply_mod_cast add_eq_max_of_ne'
intro h'
apply h
unfold has_norm.norm
exact_mod_cast h'
intros
intro x
apply dense_range_nat_cast.induction_on x
{ exact is_closed_closure, }
exact is_closed_closure
intro a
{ intro a, change (a.cast : ‚Ñ§_[p]) with (a : ‚Ñ§).cast, apply subset_closure, exact set.mem_range_self _ }
change (a.cast : ‚Ñ§_[p]) with (a : ‚Ñ§).cast
apply subset_closure
exact set.mem_range_self _
intros
injection (pell_zd_add _ m n) with _ h; repeat {rw ‚Üê int.coe_nat_add at h <|> rw ‚Üê int.coe_nat_mul at h}; exact int.coe_nat_inj h
injection (pell_zd_add _ m n) with _ h; repeat {rw ‚Üê int.coe_nat_add at h <|> rw ‚Üê int.coe_nat_mul at h}
injection (pell_zd_add _ m n) with _ h
repeat {rw ‚Üê int.coe_nat_add at h <|> rw ‚Üê int.coe_nat_mul at h}
rw ‚Üê int.coe_nat_add at h
rw ‚Üê int.coe_nat_mul at h
exact int.coe_nat_inj h
intros
rwa [pythagorean_triple_comm]
intros
induction x; induction y; refl
induction x; induction y
induction x
induction y
refl
refl
induction y
refl
refl
intros
simp [to_complex_def]
intros
{ ext x y, exact H x y }
ext x y
exact H x y
intros
rw [sup_comm, sup_sdiff_left]
intros
rw [sdiff_sdiff_left, sup_comm, sdiff_sdiff_left]
intros
{ rw disjoint_iff, exact h.inf_left_eq_bot_iff }
rw disjoint_iff
exact h.inf_left_eq_bot_iff
intros
simp [(‚â§)]
intros
rw [insert_eq, upper_bounds_union, upper_bounds_singleton]
intros
simp only [‚Üê Inf_range, Inf_eq_bot, set.exists_range_iff]
intros
rw [‚Üê infi_subtype'', infi_range']
intros
rw [‚Üê e.comap_at_top, map_comap_of_surjective e.surjective]
intros
rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]
rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]; refl
refl
intros
simp [filter.frequently, hl.eventually_iff]
intros
simp [filter.frequently, -not_eventually, not_forall]
intros
simpa only [set.prod_subset_iff] using @mem_prod_iff Œ± Œ≤ p f g
intros
simp only [bInter_eq_Inter]
haveI := hS.to_encodable
exact eventually_le.countable_Inter (Œª i, h i i.2)
intros
casesI is_empty_or_nonempty Œπ
rw [infi_of_empty f, infi_of_empty, lift'_top, powerset_univ, principal_univ]
{ rw [infi_of_empty f, infi_of_empty, lift'_top, powerset_univ, principal_univ] }
{ exact (lift'_infi $ Œª _ _, (powerset_inter _ _).symm) }
exact (lift'_infi $ Œª _ _, (powerset_inter _ _).symm)
intros
refine hf.seq_le_seq n _ (Œª k hk, _) (Œª k hk, _)
refine hf.seq_le_seq n _ (Œª k hk, _) (Œª k hk, _); simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
intros
simp
intros
rw symm_diff_eq_sup_sdiff_inf
{ rw symm_diff_eq_sup_sdiff_inf, exact sdiff_le }
exact sdiff_le
intros
have h : œï.to_ring_hom.comp (of f) = algebra_map R S := ring_hom.ext_iff.mpr (œï.commutes)
rw [aeval_def, ‚Üêh, ‚Üêring_hom.map_zero œï.to_ring_hom, ‚Üêeval‚ÇÇ_root f, hom_eval‚ÇÇ]
refl
intros
rw [‚Üê finset.card_range n, ‚Üê finset.prod_const]
{ rw [‚Üê finset.card_range n, ‚Üê finset.prod_const], exact is_coprime.prod_right (Œª _ _, H) }
exact is_coprime.prod_right (Œª _ _, H)
intros
rw [‚Üê hsum_smul, sub_smul, one_smul, hsum_sub, ‚Üê hsum_emb_domain (x ‚Ä¢ powers x hx) ‚ü®nat.succ, nat.succ_injective‚ü©, emb_domain_succ_smul_powers]
simp
intros
simp [mem_span_insert, mem_span_singleton', @eq_comm _ _ z]
intros
refine ‚ü®Œª h, _, Œª h, I.mul_mem_left y h‚ü©
obtain ‚ü®y', hy'‚ü© := hy.exists_left_inv
have := I.mul_mem_left y' h
rwa [‚Üê mul_assoc, hy', one_mul] at this
intros
rw [ring_hom.ker, eq_bot_iff, map_le_iff_le_comap]
intros
{ unfold span, rw submodule.span_mul_span, }
unfold span
rw submodule.span_mul_span
intros
obtain ‚ü®p, ‚ü®p_monic, hp‚ü©‚ü© := hx
refine ‚ü®scale_roots p r, ‚ü®(monic_scale_roots_iff r).2 p_monic, _‚ü©‚ü©
convert scale_roots_eval‚ÇÇ_eq_zero f hp
rw [mul_comm x y, ‚Üê mul_assoc, hr, one_mul]
intros
rw [is_maximal_iff_is_maximal_disjoint S y, comap_map_of_is_prime_disjoint (powers y) S I (is_maximal.is_prime hI) ((disjoint_powers_iff_not_mem y (is_maximal.is_prime hI).radical).2 hy)]
exact ‚ü®hI, hy‚ü©
intros
{ unfold has_add.add localization.add, apply lift_on‚ÇÇ_mk }
unfold has_add.add localization.add
apply lift_on‚ÇÇ_mk
intros
rw [lt_top_iff_ne_top, ne_top_iff_finite]
intros
rw [total_degree, finset.sup_le_iff]
refl
intros
obtain ‚ü®n, w‚ü© := monotone_stabilizes_iff_noetherian.mpr I (f.iterate_ker.comp ‚ü®Œª n, n+1, Œª n m w, by linarith‚ü©)
specialize w (2 * n + 1) (by linarith)
dsimp at w
refine ‚ü®n+1, nat.succ_ne_zero _, _‚ü©
rw eq_bot_iff
rintros - ‚ü®h, ‚ü®y, rfl‚ü©‚ü©
rw [mem_bot, ‚Üêlinear_map.mem_ker, w]
erw linear_map.mem_ker at h ‚ä¢
change ((f ^ (n + 1)) * (f ^ (n + 1))) y = 0 at h
rw ‚Üêpow_add at h
convert h using 3
linarith
intros
rw I.radical_eq_jacobson
refine le_antisymm (le_Inf _) (Œª p hp x hx, _)
rintros J ‚ü®hJI, hJ‚ü©
{ rintros J ‚ü®hJI, hJ‚ü©, obtain ‚ü®x, hx‚ü© := (is_maximal_iff_eq_vanishing_ideal_singleton J).1 hJ, refine hx.symm ‚ñ∏ vanishing_ideal_anti_mono (Œª y hy p hp, _), rw [‚Üê mem_vanishing_ideal_singleton_iff, set.mem_singleton_iff.1 hy, ‚Üê hx], refine hJI hp }
obtain ‚ü®x, hx‚ü© := (is_maximal_iff_eq_vanishing_ideal_singleton J).1 hJ
refine hx.symm ‚ñ∏ vanishing_ideal_anti_mono (Œª y hy p hp, _)
rw [‚Üê mem_vanishing_ideal_singleton_iff, set.mem_singleton_iff.1 hy, ‚Üê hx]
refine hJI hp
rw ‚Üê mem_vanishing_ideal_singleton_iff x p
{ rw ‚Üê mem_vanishing_ideal_singleton_iff x p, refine (mem_Inf.mp hp) ‚ü®le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (Œª y hy, hy.symm ‚ñ∏ hx)), mv_polynomial.vanishing_ideal_singleton_is_maximal‚ü© }
refine (mem_Inf.mp hp) ‚ü®le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (Œª y hy, hy.symm ‚ñ∏ hx)), mv_polynomial.vanishing_ideal_singleton_is_maximal‚ü©
intros
rw eq_top_iff
intros v hv
rw submodule.mem_sup
rcases hpq with ‚ü®p', q', hpq'‚ü©
use aeval f (p * p') v
use linear_map.mem_range.2 ‚ü®aeval f p' v, by simp only [linear_map.mul_apply, aeval_mul]‚ü©
use aeval f (q * q') v
use linear_map.mem_range.2 ‚ü®aeval f q' v, by simp only [linear_map.mul_apply, aeval_mul]‚ü©
simpa only [mul_comm p p', mul_comm q q', aeval_one, aeval_add] using congr_arg (Œª p : polynomial R, aeval f p v) hpq'
intros
rw [T_eq_X_mul_T_sub_pol_U, ‚Üêsub_add, sub_self, zero_add]
intros
split
split; intro h
intro h
rcases h with ‚ü®r, rfl‚ü©
{ rcases h with ‚ü®r, rfl‚ü©, rw [content_mul, p.is_primitive_prim_part.dvd_prim_part_iff_dvd hq], exact ‚ü®dvd.intro _ rfl, p.prim_part_dvd.trans (dvd.intro _ rfl)‚ü© }
rw [content_mul, p.is_primitive_prim_part.dvd_prim_part_iff_dvd hq]
exact ‚ü®dvd.intro _ rfl, p.prim_part_dvd.trans (dvd.intro _ rfl)‚ü©
intro h
rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]
{ rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part], exact mul_dvd_mul (ring_hom.map_dvd C h.1) h.2 }
exact mul_dvd_mul (ring_hom.map_dvd C h.1) h.2
intros
intros c hc
classical
rw coeff_monomial at hc
split_ifs at hc with h
{ subst c, exact hn }
subst c
exact hn
{ contradiction }
contradiction
intros
rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_apply, polynomial.aeval_one, algebra_map_smul, algebra.algebra_map_eq_smul_one]
intros
intros p q h
rw power_series.ext_iff at *
intros n
specialize h n
rw [coeff_rescale, coeff_rescale, mul_eq_mul_left_iff] at h
apply h.resolve_right
intro h'
exact ha (pow_eq_zero h')
intros
rw [coeff, finsupp.single_zero, X, mv_power_series.coeff_zero_X]
intros
simp_rw [@eq_comm _ x, ‚Üê mem_span_singleton, span_singleton_generator]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [witt_neg, witt_structure_rat, rename_X, X_in_terms_of_W_zero, map_X, witt_polynomial_zero, ring_hom.map_neg, alg_hom.map_neg, bind‚ÇÅ_X_right, map_witt_structure_int]
intros
use (select_poly P)
rintro R _Rcr x
funext i
apply coeff_select
intros
rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum]
simp only [alg_hom.map_pow, C_pow, alg_hom.map_mul, alg_hom_C]
rw [sum_range_succ_comm, nat.sub_self, pow_zero, pow_one, bind‚ÇÅ_X_right, mul_comm, ‚Üê C_pow, X_in_terms_of_W_aux]
simp only [C_pow, bind‚ÇÅ_X_right, sub_add_cancel]
intros
cases le_total c‚ÇÇ c‚ÇÉ; simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left]
cases le_total c‚ÇÇ c‚ÇÉ
{ cases le_total c‚ÇÇ c‚ÇÉ; simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left] }
simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left]
simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left]
intros
{ rw ‚Üênot_iff_not, simp [bit0], }
rw ‚Üênot_iff_not
simp [bit0]
intros
{cases x, cases y, refl}
cases x
cases y
refl
intros
split
intro heq
{ intro heq, exact first_loses_of_equiv (add_congr (equiv_refl _) heq) (add_self G) }
exact first_loses_of_equiv (add_congr (equiv_refl _) heq) (add_self G)
intro hGHp
{ intro hGHp, split, { rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_trans add_comm_le $ le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self G)) }, { rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self H)) } }
split
rw le_iff_sub_nonneg
{ rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_trans add_comm_le $ le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self G)) }
exact le_trans hGHp.2 (le_trans add_comm_le $ le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self G))
rw le_iff_sub_nonneg
{ rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self H)) }
exact le_trans hGHp.2 (le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self H))
intros
induction l; simp *
induction l
simp *
simp *
intros
simp only [lt_iff_le_and_ne, ordinal.zero_le, true_and, ne.def, eq_comm]
intros
simpa only [not_ball, not_le] using not_congr (@mul_le_of_limit b c a h)
rw lt_def; exact or.inl ‚ü®‚ü®0, zero_lt_one‚ü©, (by split; rintros ‚ü®‚ü©)‚ü©
rw lt_def
exact or.inl ‚ü®‚ü®0, zero_lt_one‚ü©, (by split; rintros ‚ü®‚ü©)‚ü©
dsimp [has_zero.zero, has_neg.neg, neg]
congr
congr; funext i; cases i
congr; funext i
intros
rw lt_def_le
right
use j
intros
simp [smul, nsmul_zero]
intros
simp
intros
rw ‚Üê h.coe; exact a.2
rw ‚Üê h.coe
exact a.2
intros
simp [pow_add]
intros
cc
intros
simpa only [sum_range_one] using (sum_add_tsum_nat_add 1 hf).symm
intros
{ simp only [‚Üê coe_inj, linear_map.prod_ext_iff], refl }
simp only [‚Üê coe_inj, linear_map.prod_ext_iff]
refl
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _)) (pi_univ_Iio_subset a)
exact Iio_mem_nhds (ha i)
intros
simp_rw [mul_comm _ x‚ÇÄ, nhds_eq_map_mul_left_nhds_one hx‚ÇÄ]
intros
rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]
intros
rw [continuous_within_at_Ioi_iff_Ici, continuous_within_at_Iio_iff_Iic, continuous_at_iff_continuous_left_right]
intros
simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]
intros
split
split ; intro h
intro h
rintros U U_op ‚ü®x, x_in‚ü©
{ rintros U U_op ‚ü®x, x_in‚ü©, exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in }
exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in
intro h
intro x
{ intro x, rw mem_closure_iff, intros U U_op x_in, exact h U U_op ‚ü®_, x_in‚ü© }
rw mem_closure_iff
intros U U_op x_in
exact h U U_op ‚ü®_, x_in‚ü©
intros
rw [interior_eq_nhds', mem_set_of_eq]
intros
{ ext, refl }
ext
refl
intros
rw [nhds_prod_eq, mem_prod_iff]
intros
convert inf_mem_subalgebra_closure A f g
apply set_like.ext'
symmetry
erw closure_eq_iff_is_closed
exact h
intros
simp [continuous_within_at, nhds_within_restrict' s h]
intros
haveI := di.comap_nhds_ne_bot; exact hf.lim_eq
haveI := di.comap_nhds_ne_bot
exact hf.lim_eq
intros
rw [ennreal.tsum_eq_supr_nat, filter.liminf_eq_supr_infi_of_nat]
congr
refine funext (Œª n, le_antisymm _ _)
refine le_binfi (Œª i hi, finset.sum_le_sum_of_subset_of_nonneg _ (Œª _ _ _, zero_le _))
{ refine le_binfi (Œª i hi, finset.sum_le_sum_of_subset_of_nonneg _ (Œª _ _ _, zero_le _)), simpa only [finset.range_subset, add_le_add_iff_right] using hi, }
simpa only [finset.range_subset, add_le_add_iff_right] using hi
refine le_trans (infi_le _ n) _
{ refine le_trans (infi_le _ n) _, simp [le_refl n, le_refl ((finset.range n).sum f)], }
simp [le_refl n, le_refl ((finset.range n).sum f)]
intros
simp_rw [ennreal.of_real, ennreal.tsum_coe_eq (nnreal.has_sum_of_real_of_nonneg hf_nonneg hf)]
intros
have : e '' s = e.target ‚à© e.symm ‚Åª¬π' s := e.to_local_equiv.image_eq_target_inter_inv_preimage h
rw this
exact e.continuous_on_symm.preimage_open_of_open e.open_target hs
intros
{ intros s hs, rw image_comp, exact hg _ (hf _ hs) }
intros s hs
rw image_comp
exact hg _ (hf _ hs)
intros
simpa only [div_eq_inv_mul] using nnreal.div_le_of_le_mul' (hf.le_mul_nndist x y)
intros
simpa only [hy.eq, edist_self, add_zero] using hf.edist_inequality h
intros
cases o; simp
cases o
simp
simp
intros
{ rw ‚Üê image_univ, exact hf.ediam_image univ }
rw ‚Üê image_univ
exact hf.ediam_image univ
intros
simp only [lipschitz_with, edist_nndist, dist_nndist]
{ simp only [lipschitz_with, edist_nndist, dist_nndist], norm_cast }
norm_cast
intros
rcases precise_refinement_set hs _ ho hU with ‚ü®V, hVo, hsV, hVf, hVU‚ü©
rcases exists_is_subordinate_of_locally_finite hs V hVo hVf hsV with ‚ü®f, hf‚ü©
exact ‚ü®f, hf.mono hVU‚ü©
intros
cases hxy.mem with hx hy
cases hyz.mem with hx hy
simp [joined_in_iff_joined, *] at *
exact hxy.trans hyz
intros
simp_rw [‚Üê lower_semicontinuous_within_at_univ_iff] at *
exact lower_semicontinuous_within_at_tsum h
intros
split
introI hX
{ introI hX, exact nhds_discrete X }
exact nhds_discrete X
intro h
{ intro h, constructor, apply eq_of_nhds_eq_nhds, simp [h, nhds_bot] }
constructor
apply eq_of_nhds_eq_nhds
simp [h, nhds_bot]
intros
rw ‚Üê sequential_space.sequential_closure_eq_closure
{ rw ‚Üê sequential_space.sequential_closure_eq_closure, exact iff.rfl }
exact iff.rfl
intros
rw ‚Üê is_open_compl_iff
convert ultrafilter_is_open_basic s·∂ú
ext u
exact ultrafilter.compl_mem_iff_not_mem.symm
intros
set Y := ‚ãÇ i, V i
obtain ‚ü®W, hsubW, W_op, hWU‚ü© : ‚àÉ W, Y ‚äÜ W ‚àß is_open W ‚àß W ‚äÜ U
from exists_open_set_nhds hU
suffices : ‚àÉ i, V i ‚äÜ W
rcases this with ‚ü®i, hi‚ü©
{ rcases this with ‚ü®i, hi‚ü©, refine ‚ü®i, set.subset.trans hi hWU‚ü© }
refine ‚ü®i, set.subset.trans hi hWU‚ü©
by_contradiction H
push_neg at H
replace H : ‚àÄ i, (V i ‚à© W·∂ú).nonempty := Œª i, set.inter_compl_nonempty_iff.mpr (H i)
have : (‚ãÇ i, V i ‚à© W·∂ú).nonempty
apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed _ _ H
{ apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed _ _ H, { intro i, exact (hV_cpct i).inter_right W_op.is_closed_compl }, { intro i, apply (hV_closed i).inter W_op.is_closed_compl }, { intros i j, rcases hV i j with ‚ü®k, hki, hkj‚ü©, use k, split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq] ; tauto } }
intro i
{ intro i, exact (hV_cpct i).inter_right W_op.is_closed_compl }
exact (hV_cpct i).inter_right W_op.is_closed_compl
intro i
{ intro i, apply (hV_closed i).inter W_op.is_closed_compl }
apply (hV_closed i).inter W_op.is_closed_compl
intros i j
{ intros i j, rcases hV i j with ‚ü®k, hki, hkj‚ü©, use k, split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq] ; tauto }
rcases hV i j with ‚ü®k, hki, hkj‚ü©
use k
split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq] ; tauto
split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq]
split ; intro x
split
intro x
simp only [and_imp, mem_inter_eq, mem_compl_eq]
tauto
intro x
simp only [and_imp, mem_inter_eq, mem_compl_eq]
tauto
have : ¬¨ (‚ãÇ (i : Œπ), V i) ‚äÜ W
simpa [‚Üê Inter_inter, inter_compl_nonempty_iff]
simpa [‚Üê Inter_inter, inter_compl_nonempty_iff]
contradiction
intros
{ unfold separation_rel, rw h.sInter_sets }
unfold separation_rel
rw h.sInter_sets
intros
cases b; simp
cases b
simp
simp
intros
rw int.add_comm
exact int.sub_left_le_of_le_add h
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
cases n; simp [gcd]
cases n
simp [gcd]
simp [gcd]
intros
rw [‚Üê nat.div_div_eq_div_mul, nat.mul_div_cancel_left _ H]
intros
rw [algebra.smul_def, mul_one, ring_hom.eq_rat_cast]
intros
rw [‚Üê span_mul_span, span_eq, span_eq]
intros
simp
intros
{ rw ‚Üê finprod_one, congr }
rw ‚Üê finprod_one
congr
intros
rw [‚Üê finprod_mem_inter_mul_support f s, ‚Üê finprod_mem_inter_mul_support f t, ‚Üê finprod_mem_union hst hs ht, ‚Üê union_inter_distrib_right, finprod_mem_inter_mul_support]
intros
cases x with j‚ÇÅ x
cases y with j‚ÇÇ y
cases x' with j‚ÇÉ x'
obtain ‚ü®l, f, g, hfg‚ü© := hxx'
simp at hfg
obtain ‚ü®s, Œ±, Œ≤, Œ≥, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := tulip (left_to_max j‚ÇÅ j‚ÇÇ) (right_to_max j‚ÇÅ j‚ÇÇ) (right_to_max j‚ÇÉ j‚ÇÇ) (left_to_max j‚ÇÉ j‚ÇÇ) f g
apply M.mk_eq
use [s, Œ±, Œ≥]
dsimp
simp_rw [monoid_hom.map_mul, ‚Üê comp_apply, ‚Üê F.map_comp, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, F.map_comp, comp_apply, hfg]
intros
induction n
simp
{simp}
rw [function.iterate_succ', pow_succ', pow_mul, function.comp_apply, frobenius_def, n_ih]
intros
{ rw [eq_comm], exact bit0_eq_zero }
rw [eq_comm]
exact bit0_eq_zero
intros
simp only [nth_cont_eq_succ_nth_cont_aux, (continuants_aux_stable_of_terminated (nat.pred_le_iff.elim_left n_le_m) terminated_at_n)]
intros
simpa only [zero_mul, zero_add] using div_add_mod a 0
intros
simp [neg_div]
intros
rw [‚Üê gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add]
{ rw [‚Üê gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add], simp }
simp
intros
rw [div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, mul_assoc, mul_assoc, mul_left_cancel_iff, mul_comm, mul_assoc]
intros
rw [‚Üê mul_assoc, h.inv_mul_cancel]
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
unfold semiconj_by; rw [mul_assoc, inv_mul_self, mul_one]
unfold semiconj_by
rw [mul_assoc, inv_mul_self, mul_one]
intros
{ ext, cases x; refl }
ext
cases x
cases x; refl
refl
refl
intros
rw [‚Üêpow_add, nat.sub_add_cancel h]
intros
rwa [not_iff_not, pow_eq_zero_iff]
intros
simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]
intros
rw [eq_comm, inv_eq_iff, eq_comm]
intros
simpa only [div_eq_mul_inv] using congr_arg ((*) a) u.coe_inv'
intros
rw le_antisymm_iff
split
rw le_inf_iff
{ rw le_inf_iff, split, { rw inv_le_inv_iff, apply le_sup_left, }, { rw inv_le_inv_iff, apply le_sup_right, } }
split
{ rw inv_le_inv_iff, apply le_sup_left, }
rw inv_le_inv_iff
apply le_sup_left
{ rw inv_le_inv_iff, apply le_sup_right, }
rw inv_le_inv_iff
apply le_sup_right
rw ‚Üê inv_le_inv_iff
{ rw ‚Üê inv_le_inv_iff, simp, split, { rw ‚Üê inv_le_inv_iff, simp, }, { rw ‚Üê inv_le_inv_iff, simp, } }
simp
split
{ rw ‚Üê inv_le_inv_iff, simp, }
rw ‚Üê inv_le_inv_iff
simp
{ rw ‚Üê inv_le_inv_iff, simp, }
rw ‚Üê inv_le_inv_iff
simp
intros
ext y
simp only [lie_module.mem_max_triv_submodule, lie_module.mem_ker, ‚Üê lie_skew _ y, neg_eq_zero]
intros
{ ext, refl, }
ext
refl
intros
have h : ‚ÅÖI, N‚ÅÜ ‚äî ‚ÅÖJ, N‚ÅÜ ‚â§ ‚ÅÖI ‚äî J, N‚ÅÜ
rw sup_le_iff
{ rw sup_le_iff, split; apply mono_lie_left; [exact le_sup_left, exact le_sup_right], }
split
split; apply mono_lie_left; [exact le_sup_left, exact le_sup_right]
split; apply mono_lie_left
apply mono_lie_left
exact le_sup_left
apply mono_lie_left
exact le_sup_right
suffices : ‚ÅÖI ‚äî J, N‚ÅÜ ‚â§ ‚ÅÖI, N‚ÅÜ ‚äî ‚ÅÖJ, N‚ÅÜ
exact le_antisymm this h
{ exact le_antisymm this h, }
clear h
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ‚ü®‚ü®x, hx‚ü©, n, h‚ü©
erw lie_submodule.mem_sup
erw lie_submodule.mem_sup at hx
rcases hx with ‚ü®x‚ÇÅ, hx‚ÇÅ, x‚ÇÇ, hx‚ÇÇ, hx'‚ü©
use ‚ÅÖ((‚ü®x‚ÇÅ, hx‚ÇÅ‚ü© : I) : L), (n : N)‚ÅÜ
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
use ‚ÅÖ((‚ü®x‚ÇÇ, hx‚ÇÇ‚ü© : J) : L), (n : N)‚ÅÜ
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
simp [‚Üê h, ‚Üê hx']
intros
{ ext a, exact lie_hom.congr_fun h a, }
ext a
exact lie_hom.congr_fun h a
intros
induction k with k ih
simp only [derived_series_def, comap_incl_self, derived_series_of_ideal_zero]
{ simp only [derived_series_def, comap_incl_self, derived_series_of_ideal_zero], }
simp only [derived_series_def, derived_series_of_ideal_succ] at ‚ä¢ ih
{ simp only [derived_series_def, derived_series_of_ideal_succ] at ‚ä¢ ih, rw ih, exact comap_bracket_incl_of_le I (derived_series_of_ideal_le_self I k) (derived_series_of_ideal_le_self I k), }
rw ih
exact comap_bracket_incl_of_le I (derived_series_of_ideal_le_self I k) (derived_series_of_ideal_le_self I k)
intros
split
{ rintros ‚ü®K, rfl‚ü©, exact K.lie_mem', }
rintros ‚ü®K, rfl‚ü©
exact K.lie_mem'
intros h
{ intros h, use { lie_mem' := h, ..p }, exact lie_subalgebra.coe_to_submodule_mk p _, }
use { lie_mem' := h, ..p }
exact lie_subalgebra.coe_to_submodule_mk p _
intros
simp only [exists_lie_ideal_coe_eq_iff, coe_bracket, mem_of_le]
split
{ intros h' x y hx hy, exact h' ‚ü®x, hx‚ü© ‚ü®y, h hy‚ü© hy, }
intros h' x y hx hy
exact h' ‚ü®x, hx‚ü© ‚ü®y, h hy‚ü© hy
{ rintros h' ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© hy', exact h' x y hx hy', }
rintros h' ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© hy'
exact h' x y hx hy'
intros
rw [mul_comm, inv_mul_le_iff h]
intros
simp only [div_eq_mul_inv, mul_lt_mul_left ha, inv_lt_inv hb hc]
intros
rcases lt_trichotomy a 0 with (ha|rfl|ha)
{ simp [abs_of_neg ha, neg_pos, ha.ne, ha] }
simp [abs_of_neg ha, neg_pos, ha.ne, ha]
{ simp }
simp
{ simp [abs_of_pos ha, ha, ha.ne.symm] }
simp [abs_of_pos ha, ha, ha.ne.symm]
intros
rw [‚Üê mul_lt_mul_iff_left b, mul_one, mul_inv_cancel_left]
intros
simpa only [div_eq_mul_inv] using mul_le_mul_iff_right _
intros
simp only [‚Üê add_comm a, add_lt_add_iff_left ha]
intros
rw [‚Üê neg_nonneg, neg_mul_eq_mul_neg, mul_nonneg_iff, neg_nonneg, neg_nonpos]
intros
haveI := @linear_order.decidable_le Œ± _; exact mul_inv_of_self a ‚ñ∏ decidable.le_mul_of_one_le_left (inv_of_nonneg.2 $ zero_le_one.trans h) h
haveI := @linear_order.decidable_le Œ± _
exact mul_inv_of_self a ‚ñ∏ decidable.le_mul_of_one_le_left (inv_of_nonneg.2 $ zero_le_one.trans h) h
intros
rw [‚Üê sub_nonneg, ‚Üê sub_mul]
exact decidable.ordered_ring.mul_nonneg (sub_nonneg.2 h‚ÇÅ) h‚ÇÇ
intros
simpa only [nsmul_eq_mul] using h.sub_nsmul_eq n
intros
simp * at *
intros
simp only [‚Üê image_smul, image_union]
intros
apply nat_degree_multiset_prod'
suffices : (t.map (Œª f, leading_coeff f)).prod = 1
rw this
{ rw this, simp }
simp
convert prod_repeat (1 : R) t.card
simp only [eq_repeat, multiset.card_map, eq_self_iff_true, true_and]
{ simp only [eq_repeat, multiset.card_map, eq_self_iff_true, true_and], rintros i hi, obtain ‚ü®i, hi, rfl‚ü© := multiset.mem_map.mp hi, apply h, assumption }
rintros i hi
obtain ‚ü®i, hi, rfl‚ü© := multiset.mem_map.mp hi
apply h
assumption
{ simp }
simp
intros
rcases h with ‚ü®s, hs‚ü©
use (-b + s) / (2 * a)
rw quadratic_eq_zero_iff ha hs
simp
intros
rw [coe_mul, coe_mul_eq_smul]
intros
{ rw [is_closed_iff_zero_locus], exact ‚ü®s, rfl‚ü© }
rw [is_closed_iff_zero_locus]
exact ‚ü®s, rfl‚ü©
intros
dsimp [Œ¥, œÉ]
{ dsimp [Œ¥, œÉ], simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_œÉ_of_gt H] }
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_œÉ_of_gt H]
intros
dsimp [Œ¥, œÉ]
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.Œ¥_comp_œÉ_self, op_id, X.map_id]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
convert tendsto_neg_at_top_at_bot.comp (huv.neg.tendsto_at_top $ tendsto_neg_at_bot_at_top.comp hu)
ext
simp
intros
simpa only [pow_one, is_o_norm_right] using @is_o_norm_pow_norm_pow E' _ _ _ h
intros
simpa [is_O, is_O_with] using is_O_fst_prod
intros
simpa [continuous_linear_map.sum_apply] using (has_fderiv_at_filter.sum h).has_deriv_at_filter
intros
simp only [sub_eq_add_neg, differentiable_at_add_const_iff]
intros
rw [differentiable_on, differentiable_on]
simp only [iso.comp_differentiable_within_at_iff]
intros
rcases h with ‚ü®f', hf'‚ü©
exact ‚ü®f', hf'.mono st‚ü©
intros
rw [iterated_deriv_eq_iterate, iterated_deriv_eq_iterate]
{ rw [iterated_deriv_eq_iterate, iterated_deriv_eq_iterate], refl }
refl
intros
rw [‚Üê times_cont_diff_within_at_univ, times_cont_diff_within_at_succ_iff_has_fderiv_within_at]
simp only [nhds_within_univ, exists_prop, mem_univ, insert_eq_of_mem]
split
rintros ‚ü®u, H, f', h_fderiv, h_times_cont_diff‚ü©
{ rintros ‚ü®u, H, f', h_fderiv, h_times_cont_diff‚ü©, rcases mem_nhds_iff.mp H with ‚ü®t, htu, ht, hxt‚ü©, refine ‚ü®f', ‚ü®t, _‚ü©, h_times_cont_diff.times_cont_diff_at H‚ü©, refine ‚ü®mem_nhds_iff.mpr ‚ü®t, subset.rfl, ht, hxt‚ü©, _‚ü©, intros y hyt, refine (h_fderiv y (htu hyt)).has_fderiv_at _, exact mem_nhds_iff.mpr ‚ü®t, htu, ht, hyt‚ü© }
rcases mem_nhds_iff.mp H with ‚ü®t, htu, ht, hxt‚ü©
refine ‚ü®f', ‚ü®t, _‚ü©, h_times_cont_diff.times_cont_diff_at H‚ü©
refine ‚ü®mem_nhds_iff.mpr ‚ü®t, subset.rfl, ht, hxt‚ü©, _‚ü©
intros y hyt
refine (h_fderiv y (htu hyt)).has_fderiv_at _
exact mem_nhds_iff.mpr ‚ü®t, htu, ht, hyt‚ü©
rintros ‚ü®f', ‚ü®u, H, h_fderiv‚ü©, h_times_cont_diff‚ü©
{ rintros ‚ü®f', ‚ü®u, H, h_fderiv‚ü©, h_times_cont_diff‚ü©, refine ‚ü®u, H, f', _, h_times_cont_diff.times_cont_diff_within_at‚ü©, intros x hxu, exact (h_fderiv x hxu).has_fderiv_within_at }
refine ‚ü®u, H, f', _, h_times_cont_diff.times_cont_diff_within_at‚ü©
intros x hxu
exact (h_fderiv x hxu).has_fderiv_within_at
intros
set pr := @continuous_linear_map.proj ùïú _ Œπ F' _ _ _
refine ‚ü®Œª h i, h.continuous_linear_map_comp (pr i), Œª h m hm, _‚ü©
choose u hux p hp using Œª i, h i m hm
exact ‚ü®‚ãÇ i, u i, filter.Inter_mem.2 hux, _, has_ftaylor_series_up_to_on_pi.2 (Œª i, (hp i).mono $ Inter_subset _ _)‚ü©
intros
simpa only [div_eq_mul_inv] using hf.mul (hg.inv hx)
intros
induction n with n IH generalizing x
{ ext m, simp [hL x hx] }
ext m
simp [hL x hx]
have : fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f‚ÇÅ s y) s x = fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) s x := fderiv_within_congr (hs x hx) (Œª y hy, IH hy) (IH hx)
{ have : fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f‚ÇÅ s y) s x = fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) s x := fderiv_within_congr (hs x hx) (Œª y hy, IH hy) (IH hx), ext m, rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this] }
ext m
rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this]
intros
rw [‚Üêadd_smul, h, one_smul]
intros
intros x y hx hy a b ha hb hab
obtain ‚ü®x', hx', rfl‚ü© := mem_image_iff_bex.1 hx
obtain ‚ü®y', hy', rfl‚ü© := mem_image_iff_bex.1 hy
exact ‚ü®a ‚Ä¢ x' + b ‚Ä¢ y', hs hx' hy' ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]‚ü©
intros
apply set.subset.antisymm
intros x hx
{ intros x hx, simp only [exists_prop, set.mem_Union], exact ‚ü®caratheodory.min_card_finset_of_mem_convex_hull hx, caratheodory.min_card_finset_of_mem_convex_hull_subseteq hx, caratheodory.affine_independent_min_card_finset_of_mem_convex_hull hx, caratheodory.mem_min_card_finset_of_mem_convex_hull hx‚ü© }
simp only [exists_prop, set.mem_Union]
exact ‚ü®caratheodory.min_card_finset_of_mem_convex_hull hx, caratheodory.min_card_finset_of_mem_convex_hull_subseteq hx, caratheodory.affine_independent_min_card_finset_of_mem_convex_hull hx, caratheodory.mem_min_card_finset_of_mem_convex_hull hx‚ü©
convert set.Union_subset _
iterate 3 { convert set.Union_subset _, intro }
{ iterate 3 { convert set.Union_subset _, intro }, exact convex_hull_mono ‚Äπ_‚Ä∫ }
intro
convert set.Union_subset _
intro
convert set.Union_subset _
intro
exact convex_hull_mono ‚Äπ_‚Ä∫
intros
obtain i := classical.arbitrary Œπ
use Inter_subset_of_subset i (hAF i).1
rintro x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxF hx
simp_rw mem_Inter at ‚ä¢ hxF
have h := Œª i, (hAF i).2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x (hxF i) hx
exact ‚ü®Œª i, (h i).1, Œª i, (h i).2‚ü©
intros
rw convex_independent_set_iff_inter_convex_hull_subset
split
rintro hs x hxs hx
{ rintro hs x hxs hx, exact (hs _ (set.diff_subset _ _) ‚ü®hxs, hx‚ü©).2 (set.mem_singleton _) }
exact (hs _ (set.diff_subset _ _) ‚ü®hxs, hx‚ü©).2 (set.mem_singleton _)
rintro hs t ht x ‚ü®hxs, hxt‚ü©
{ rintro hs t ht x ‚ü®hxs, hxt‚ü©, by_contra h, exact hs _ hxs (convex_hull_mono (set.subset_diff_singleton ht h) hxt) }
by_contra h
exact hs _ hxs (convex_hull_mono (set.subset_diff_singleton ht h) hxt)
intros
simp only [metric.diam, convex_hull_ediam]
intros
convert inner_lt_norm_mul_iff_real; simp [hx, hy]
{ convert inner_lt_norm_mul_iff_real; simp [hx, hy] }
convert inner_lt_norm_mul_iff_real
simp [hx, hy]
simp [hx, hy]
simp [hx, hy]
intros
{ simp [sub_eq_add_neg, inner_add_right, inner_neg_right] }
simp [sub_eq_add_neg, inner_add_right, inner_neg_right]
intros
rw [‚Üêinner_conj_sym, inner_neg_left]; simp only [ring_hom.map_neg, inner_conj_sym]
rw [‚Üêinner_conj_sym, inner_neg_left]
simp only [ring_hom.map_neg, inner_conj_sym]
intros
simp only [euclidean.dist]
apply @times_cont_diff.dist ‚Ñù
exacts [(@to_euclidean E _ _ _).times_cont_diff.comp hf, (@to_euclidean E _ _ _).times_cont_diff.comp hg, Œª x, to_euclidean.injective.ne (h x)]
intros
simp [explicit_cokernel_œÄ, explicit_cokernel_iso]
intros
{ rw ‚Üê coe_to_isometric, exact isometric.range_eq_univ _, }
rw ‚Üê coe_to_isometric
exact isometric.range_eq_univ _
intros
rw mul_comm
{rw mul_comm, convert norm_mul_le y x}
convert norm_mul_le y x
intros
rw [subsingleton.elim x 0, norm_zero]
intros
rw [‚Üê nat.cast_add, to_nat_add_to_nat_neg_eq_nat_abs, nnreal.coe_nat_abs]
intros
dunfold mk_continuous_multilinear
exact mk_continuous_norm_le _ (le_max_right _ _) _
intros
{ rw [range, add_monoid_hom.mem_range], refl }
rw [range, add_monoid_hom.mem_range]
refl
intros
apply le_cInf (image_norm_nonempty _)
rintros _ ‚ü®n, h, rfl‚ü©
apply norm_nonneg
intros
rcases normed_group.tendsto_nhds_nhds.1 (hf.tendsto 0) 1 zero_lt_one with ‚ü®Œµ, Œµ_pos, hŒµ‚ü©
simp only [sub_zero, f.map_zero] at hŒµ
rcases normed_field.exists_one_lt_norm ùïú with ‚ü®c, hc‚ü©
have : 0 < ‚à•c‚à• / Œµ
from div_pos (zero_lt_one.trans hc) Œµ_pos
refine ‚ü®‚à•c‚à• / Œµ, this, Œª x, _‚ü©
by_cases hx : ‚à•x‚à• = 0
rw [hx, mul_zero]
{ rw [hx, mul_zero], exact le_of_eq (norm_image_of_norm_zero hf hx) }
exact le_of_eq (norm_image_of_norm_zero hf hx)
refine f.bound_of_shell_semi_normed Œµ_pos hc (Œª x hle hlt, _) hx
refine (hŒµ _ hlt).le.trans _
rwa [‚Üê div_le_iff' this, one_div_div]
intros
by_cases hf : summable f
exact ‚ü®Œª h, (e.has_sum.mp ((e.summable.mpr hf).has_sum_iff.mpr h)).tsum_eq, Œª h, (e.has_sum.mpr (hf.has_sum_iff.mpr h)).tsum_eq‚ü©
{ exact ‚ü®Œª h, (e.has_sum.mp ((e.summable.mpr hf).has_sum_iff.mpr h)).tsum_eq, Œª h, (e.has_sum.mpr (hf.has_sum_iff.mpr h)).tsum_eq‚ü© }
have hf' : ¬¨summable (Œª z, e (f z)) := Œª h, hf (e.summable.mp h)
{ have hf' : ¬¨summable (Œª z, e (f z)) := Œª h, hf (e.summable.mp h), rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hf'], exact ‚ü®by { rintro rfl, simp }, Œª H, by simpa using (congr_arg (Œª z, e z) H)‚ü© }
rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hf']
exact ‚ü®by { rintro rfl, simp }, Œª H, by simpa using (congr_arg (Œª z, e z) H)‚ü©
intros
apply weak_dual.continuous_of_continuous_eval
intros z
exact (inclusion_in_double_dual ùïú E z).continuous
simp [log]
intros
simp only [one_div, integral_inv h]
intros
simp only [div_eq_mul_inv, ennreal.inv_pow] at *
rw [mul_assoc, mul_comm]
convert edist_le_of_edist_le_geometric_of_tendsto 2‚Åª¬π C hu ha n
rw [ennreal.one_sub_inv_two, ennreal.inv_inv]
intros
simp [pre]
intros
dsimp [adjointify_Œ∑]
simp
have := Œµ.hom.naturality (F.map (Œ∑.inv.app X))
dsimp at this
rw [this]
clear this
rw [‚Üêassoc _ _ (F.map _)]
have := Œµ.hom.naturality (Œµ.inv.app $ F.obj X)
dsimp at this
rw [this]
clear this
have := (Œµ.app $ F.obj X).hom_inv_id
dsimp at this
rw [this]
clear this
rw [id_comp]
have := (F.map_iso $ Œ∑.app X).hom_inv_id
dsimp at this
rw [this]
intros
ext
ext; simp
simp
intros
rw [‚Üê trans_assoc, symm_self_id, refl_trans]
intros
simp
intros
ext
{ ext, rw [assoc, lim_map_œÄ, limit.lift_œÄ_assoc, limit.lift_œÄ], refl }
rw [assoc, lim_map_œÄ, limit.lift_œÄ_assoc, limit.lift_œÄ]
refl
intros
simp
intros
ext j j'
simp only [discrete.nat_trans_app, limits.is_colimit.Œπ_map, limits.is_limit.map_œÄ, category.assoc, ‚Üêbicone.to_cone_œÄ_app, ‚Üêbiproduct.bicone_œÄ, ‚Üêbicone.to_cocone_Œπ_app, ‚Üêbiproduct.bicone_Œπ]
simp only [biproduct.bicone_Œπ, biproduct.bicone_œÄ, bicone.to_cocone_Œπ_app, bicone.to_cone_œÄ_app]
rw [biproduct.Œπ_œÄ_assoc, biproduct.Œπ_œÄ]
split_ifs
subst h
{ subst h, rw [eq_to_hom_refl, category.id_comp], erw category.comp_id, }
rw [eq_to_hom_refl, category.id_comp]
erw category.comp_id
{ simp, }
simp
intros
{ ext, simp [‚Üê G.map_comp] }
ext
simp [‚Üê G.map_comp]
intros
rw [t.app_zero, t.app_zero]
intros
simp only [lax_monoidal_functor.right_unitality]
slice_rhs 2 3 { rw ‚Üêid_tensor_comp, simp, }
simp
intros
ext
{ ext, simp only [left_dual_iso, iso.refl_hom, left_adjoint_mate_id] }
simp only [left_dual_iso, iso.refl_hom, left_adjoint_mate_id]
intros
apply le_antisymm
refine J‚ÇÅ.le_close_of_is_closed (sieve.pullback_monotone _ (J‚ÇÅ.le_close S)) _
{ refine J‚ÇÅ.le_close_of_is_closed (sieve.pullback_monotone _ (J‚ÇÅ.le_close S)) _, apply J‚ÇÅ.is_closed_pullback _ _ (J‚ÇÅ.close_is_closed _) }
apply J‚ÇÅ.is_closed_pullback _ _ (J‚ÇÅ.close_is_closed _)
intros Z g hg
{ intros Z g hg, change _ ‚àà J‚ÇÅ _, rw ‚Üê sieve.pullback_comp, apply hg }
change _ ‚àà J‚ÇÅ _
rw ‚Üê sieve.pullback_comp
apply hg
intros
{ ext, simp, }
ext
simp
intros
erw [category.id_comp, category.comp_id]
refl
intros
split
rintro rfl
{ rintro rfl, exact Œª i, eq_of_mem_repeat }
exact Œª i, eq_of_mem_repeat
assume H
{ assume H, ext1, have A : c.blocks = repeat 1 c.blocks.length := eq_repeat_of_mem H, have : c.blocks.length = n, by { conv_rhs { rw [‚Üê c.blocks_sum, A] }, simp }, rw [A, this, ones_blocks] }
ext1
have A : c.blocks = repeat 1 c.blocks.length := eq_repeat_of_mem H
have : c.blocks.length = n
conv_rhs { rw [‚Üê c.blocks_sum, A] }
conv_rhs { rw [‚Üê c.blocks_sum, A] }
{ conv_rhs { rw [‚Üê c.blocks_sum, A] }, simp }
{ conv_rhs { rw [‚Üê c.blocks_sum, A] }, simp }
simp
simp
rw [A, this, ones_blocks]
intros
rw ‚Üê composition_as_set_card n
exact fintype.card_congr (composition_equiv n)
intros
rw fintype.card_eq_zero_iff at hn
exactI ‚ü®is_empty_elim, is_empty_elim, is_empty_elim‚ü©
intros
simp [degree]
intros
rcases G.exists_minimal_degree_vertex with ‚ü®v, hv‚ü©
rw hv
apply h
intros
rw ‚Üêcard_neighbor_set_eq_degree
exact fintype.card_congr (coe_neighbor_set_equiv v)
intros
haveI := classical.dec s.dom; exact decidable.partrec.const' s
haveI := classical.dec s.dom
exact decidable.partrec.const' s
intros
letI := primcodable.of_equiv Œ± e; exact encode_iff.1 (show primrec (Œª a, encode (e (e.symm a))), by simp [primrec.encode])
letI := primcodable.of_equiv Œ± e
exact encode_iff.1 (show primrec (Œª a, encode (e (e.symm a))), by simp [primrec.encode])
intros
rw [‚Üê tape.right‚ÇÄ_nth, tape.mk'_right‚ÇÄ]
intros
simp [snd,bimap_bimap]
intros
induction j
cases hij
refine @le_refl _ _ _
cases hij
apply @le_refl _ _ _
apply @le_trans _ _ _ (approx f j_n) _ (j_ih ‚Äπ_‚Ä∫)
apply approx_mono' f
intros
simp! [equiv.traverse,id_bind,id_traverse,functor.map] with functor_norm
intros
{ cases t, apply nat.succ_pos }
cases t
apply nat.succ_pos
intros
rw [‚Üêrev_list_reverse, list.foldl_reverse, rev_list_foldr]
intros
simp [H]
introI
have : remaining buffer.nil 0 = done 0 0 := by simp [remaining_eq_done]
exact absurd (bounded.of_done this) (lt_irrefl _)
intros
simp [str_eq_char_buf, char_buf_iff, ‚Üêstring.to_list_inj, buffer.ext_iff]
intros
simp [seq_right_eq, seq_eq_fail]
intros
simp [foldr_core]
intros
simp [bit1]
intros
rw ‚Üê of_real_inj; simp [cosh_add_sinh]
rw ‚Üê of_real_inj
simp [cosh_add_sinh]
intros
simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]
intros
simp only [‚Üê tan_mul_cos hx, mul_pow, ‚Üê inv_one_add_tan_sq hx, div_eq_mul_inv, one_mul]
intros
rw norm_sq_eq_def
{ rw norm_sq_eq_def, refl }
refl
intros
rw [‚Üê of_real_nat_cast]
{ rw [‚Üê of_real_nat_cast], exact abs_of_nonneg (nat.cast_nonneg n) }
exact abs_of_nonneg (nat.cast_nonneg n)
intros
split
intro h
{ intro h, by_cases hij : i = j, { subst hij, exact or.inl ‚ü®rfl, heq_of_eq (dfinsupp.single_injective h)‚ü©, }, { have h_coe : ‚áë(dfinsupp.single i xi) = dfinsupp.single j xj := congr_arg coe_fn h, have hci := congr_fun h_coe i, have hcj := congr_fun h_coe j, rw dfinsupp.single_eq_same at hci hcj, rw dfinsupp.single_eq_of_ne (ne.symm hij) at hci, rw dfinsupp.single_eq_of_ne (hij) at hcj, exact or.inr ‚ü®hci, hcj.symm‚ü©, }, }
by_cases hij : i = j
subst hij
{ subst hij, exact or.inl ‚ü®rfl, heq_of_eq (dfinsupp.single_injective h)‚ü©, }
exact or.inl ‚ü®rfl, heq_of_eq (dfinsupp.single_injective h)‚ü©
have h_coe : ‚áë(dfinsupp.single i xi) = dfinsupp.single j xj := congr_arg coe_fn h
{ have h_coe : ‚áë(dfinsupp.single i xi) = dfinsupp.single j xj := congr_arg coe_fn h, have hci := congr_fun h_coe i, have hcj := congr_fun h_coe j, rw dfinsupp.single_eq_same at hci hcj, rw dfinsupp.single_eq_of_ne (ne.symm hij) at hci, rw dfinsupp.single_eq_of_ne (hij) at hcj, exact or.inr ‚ü®hci, hcj.symm‚ü©, }
have hci := congr_fun h_coe i
have hcj := congr_fun h_coe j
rw dfinsupp.single_eq_same at hci hcj
rw dfinsupp.single_eq_of_ne (ne.symm hij) at hci
rw dfinsupp.single_eq_of_ne (hij) at hcj
exact or.inr ‚ü®hci, hcj.symm‚ü©
rintros (‚ü®hi, hxi‚ü© | ‚ü®hi, hj‚ü©)
{ rintros (‚ü®hi, hxi‚ü© | ‚ü®hi, hj‚ü©), { subst hi, rw eq_of_heq hxi, }, { rw [hi, hj, dfinsupp.single_zero, dfinsupp.single_zero], }, }
subst hi
{ subst hi, rw eq_of_heq hxi, }
rw eq_of_heq hxi
{ rw [hi, hj, dfinsupp.single_zero, dfinsupp.single_zero], }
rw [hi, hj, dfinsupp.single_zero, dfinsupp.single_zero]
intros
apply equiv.forall_congr
intros
apply equiv.forall_congr
intros
apply h
intros
simp
simp; refl
intros
{ ext, simp }
ext
simp
intros
have h‚ÇÅ : f.to_equiv = g.to_equiv := equiv.ext h
cases f
cases g
congr
{ exact (funext h) }
exact (funext h)
{ exact congr_arg equiv.inv_fun h‚ÇÅ }
exact congr_arg equiv.inv_fun h‚ÇÅ
intros
refl
intros
ext j
by_cases h : j.val < n
have : j ‚â† last n := ne_of_lt h
{ have : j ‚â† last n := ne_of_lt h, simp [h, this, snoc, cast_succ_cast_lt] }
simp [h, this, snoc, cast_succ_cast_lt]
rw eq_last_of_not_lt h
{ rw eq_last_of_not_lt h, simp }
simp
intros
simp [fin.ext_iff]
intros
simp [pi.enum]; refine ‚ü®Œª a h, f a, mem_pi _ _, rfl‚ü©
simp [pi.enum]
refine ‚ü®Œª a h, f a, mem_pi _ _, rfl‚ü©
intros
{ ext x, simp [and_assoc] }
ext x
simp [and_assoc]
intros
cases s; simp only [multiset.card_eq_one, finset.card, ‚Üê val_inj, singleton_val]
cases s
simp only [multiset.card_eq_one, finset.card, ‚Üê val_inj, singleton_val]
intros
{ classical, ext, simp }
classical
ext
simp
intros
refine le_antisymm (max'_le _ _ _ (Œª y hy, _)) (le_max' _ _ (mem_image.mpr ‚ü®_, max'_mem _ _, rfl‚ü©))
obtain ‚ü®x, hx, rfl‚ü© := mem_image.mp hy
exact hf (le_max' _ _ hx)
intros
simp [noncomm_prod, insert_val_of_not_mem ha, multiset.noncomm_prod_cons']
intros
exact_mod_cast @function.support_eq_empty_iff _ _ _ f
intros
rw [unique_ext_iff, unique.eq_default a, unique.eq_default a', single_eq_same, single_eq_same]
intros
rw [‚Üêe.equiv_of_fintype_self_embedding_to_embedding, univ_map_equiv_to_embedding]
intros
rw [finset.card_univ, fintype.card_fin]
intros
haveI : nontrivial Œ± := one_lt_card_iff_nontrivial.1 h
{ haveI : nontrivial Œ± := one_lt_card_iff_nontrivial.1 h, exact exists_ne a }
exact exists_ne a
intros
simp [nat_abs_eq_iff, is_unit_iff]
intros
apply int.mod_eq_mod_iff_mod_sub_eq_zero.mpr
convert int.mul_mod_right 2 (-i)
simp only [two_mul, sub_eq_add_neg]
intros
simp [bit1] with parity_simps
intros
cases l; refl
cases l
refl
refl
intros
refine ‚ü®Œª h, _, drop_eq_nil_of_le‚ü©
induction k with k hk generalizing l
simp only [drop] at h
{ simp only [drop] at h, simp [h] }
simp [h]
cases l
{ cases l, { simp }, { simp only [drop] at h, simpa [nat.succ_le_succ_iff] using hk h } }
{ simp }
simp
simp only [drop] at h
{ simp only [drop] at h, simpa [nat.succ_le_succ_iff] using hk h }
simpa [nat.succ_le_succ_iff] using hk h
intros
revert a; induction l; intros; [refl, simp only [*, map, foldr]]
revert a; induction l; intros
revert a; induction l
revert a
induction l
intros
refl
intros
simp only [*, map, foldr]
intros
induction L with a L ihL
{ exact absurd h (not_mem_nil _) }
exact absurd h (not_mem_nil _)
rw prod_cons
{ rw prod_cons, cases (mem_cons_iff _ _ _).1 h with ha hL, exacts [mul_eq_zero_of_left ha.symm _, mul_eq_zero_of_right _ (ihL hL)] }
cases (mem_cons_iff _ _ _).1 h with ha hL
exacts [mul_eq_zero_of_left ha.symm _, mul_eq_zero_of_right _ (ihL hL)]
intros
cases l with x l
{ contradiction }
contradiction
by_cases h' : f x ‚â§ g x
{ by_cases h' : f x ‚â§ g x, exact ‚ü®x, mem_cons_self _ _, h'‚ü©, rcases exists_lt_of_sum_lt f g _ with ‚ü®y, h1y, h2y‚ü©, exact ‚ü®y, mem_cons_of_mem x h1y, le_of_lt h2y‚ü©, simp at h, exact lt_of_add_lt_add_left (lt_of_le_of_lt h $ add_lt_add_right (lt_of_not_ge h') _) }
exact ‚ü®x, mem_cons_self _ _, h'‚ü©
rcases exists_lt_of_sum_lt f g _ with ‚ü®y, h1y, h2y‚ü©
exact ‚ü®y, mem_cons_of_mem x h1y, le_of_lt h2y‚ü©
simp at h
exact lt_of_add_lt_add_left (lt_of_le_of_lt h $ add_lt_add_right (lt_of_not_ge h') _)
intros
rw [attach, map_pmap]; exact pmap_congr l (Œª a h‚ÇÅ h‚ÇÇ, rfl)
rw [attach, map_pmap]
exact pmap_congr l (Œª a h‚ÇÅ h‚ÇÇ, rfl)
intros
induction l with hd tl hl
{ simp only [reduce_option_nil, map_nil] }
simp only [reduce_option_nil, map_nil]
cases hd; simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl
cases hd
{ cases hd; simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl }
simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl
simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl
intros
simp only [count, countp_pos, exists_prop, exists_eq_right']
intros
obtain ‚ü®xs, rfl‚ü© := h
rw filter_append
exact prefix_append _ _
intros
rw [permutations_aux, permutations_aux.rec]; refl
rw [permutations_aux, permutations_aux.rec]
refl
intros
rw erase_eq_erasep; apply erasep_sublist
rw erase_eq_erasep
apply erasep_sublist
intros
rwa [‚Üê succ_singleton, append_consecutive]; exact nat.le_succ _
rwa [‚Üê succ_singleton, append_consecutive]
exact nat.le_succ _
intros
rw [sublists'_eq_sublists, nodup_map_iff reverse_injective, nodup_sublists, nodup_reverse]
intros
induction L with l L IH
simp only [join, pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_const, and_self]
{simp only [join, pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_const, and_self]}
have : (‚àÄ (x : Œ±), x ‚àà l ‚Üí ‚àÄ (y : Œ±) (x_1 : list Œ±), x_1 ‚àà L ‚Üí y ‚àà x_1 ‚Üí R x y) ‚Üî ‚àÄ (a' : list Œ±), a' ‚àà L ‚Üí ‚àÄ (x : Œ±), x ‚àà l ‚Üí ‚àÄ (y : Œ±), y ‚àà a' ‚Üí R x y := ‚ü®Œª h a b c d e, h c d e a b, Œª h c d e a b, h a b c d e‚ü©
simp only [join, pairwise_append, IH, mem_join, exists_imp_distrib, and_imp, this, forall_mem_cons, pairwise_cons]
simp only [and_assoc, and_comm, and.left_comm]
intros
induction s with y s IH
{ simp }
simp
{ simpa using IH }
simpa using IH
intros
by_cases h : a ‚àà l
{ exact (perm_cons_erase h).subperm }
exact (perm_cons_erase h).subperm
rw [erase_of_not_mem h]
{ rw [erase_of_not_mem h], exact (sublist_cons _ _).subperm }
exact (sublist_cons _ _).subperm
intros
rw [range_eq_range', range_eq_range', range', add_comm, ‚Üê map_add_range']
rw [range_eq_range', range_eq_range', range', add_comm, ‚Üê map_add_range']; congr; exact funext one_add
rw [range_eq_range', range_eq_range', range', add_comm, ‚Üê map_add_range']; congr
congr
exact funext one_add
intros
cases n
cases n; refl
refl
refl
intros
simp [revzip]
intros
{ ext, apply dot_product_neg }
ext
apply dot_product_neg
intros
ext
{ ext, refl }
refl
intros
simp [bit1_apply]
intros
{ ext, apply neg_dot_product }
ext
apply neg_dot_product
intros
rw vec_alt1_append
intros
rw [‚Üê matrix.mul_assoc, single_mul_single]
intros
rw [list.bind, ‚Üê coe_join, list.map_map]; refl
rw [list.bind, ‚Üê coe_join, list.map_map]
refl
intros
simp [countp_eq_card_filter]
intros
rw [fold_eq_foldl, foldl_cons, ‚Üê fold_eq_foldl]
intros
rw [bind‚ÇÅ, map_aeval, algebra_map_eq]
intros
simp [nat.find_greatest, h]
intros
simp only [add_comm, lt_succ_iff]
intros
induction hnm with m hnm ih
intros x y H
{ intros x y H, rwa [le_rec_on_self, le_rec_on_self] at H }
rwa [le_rec_on_self, le_rec_on_self] at H
intros x y H
rw [le_rec_on_succ hnm, le_rec_on_succ hnm] at H
exact ih (Hnext _ H)
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
convert nat.choose_symm (nat.le_add_left _ _)
{ convert nat.choose_symm (nat.le_add_left _ _), rw nat.add_sub_cancel}
rw nat.add_sub_cancel
intros
induction L with d L ih
{ refl, }
refl
dsimp [of_digits]
{ dsimp [of_digits], dsimp [int.modeq] at *, conv_lhs { rw [int.add_mod, int.mul_mod, h, ih], }, conv_rhs { rw [int.add_mod, int.mul_mod], }, }
dsimp [int.modeq] at *
conv_lhs { rw [int.add_mod, int.mul_mod, h, ih], }
conv_rhs { rw [int.add_mod, int.mul_mod], }
intros
rw [lt_iff_le_not_le, le_def, le_def, not_exists]
split
rintro ‚ü®‚ü®hyx, H‚ü©, h‚ü©
{ rintro ‚ü®‚ü®hyx, H‚ü©, h‚ü©, by_cases hx : x.dom, { use hx, intro hy, specialize H hy, specialize h (Œª _, hy), rw not_forall at h, cases h with hx' h, rw not_le at h, exact h }, { specialize h (Œª hx', (hx hx').elim), rw not_forall at h, cases h with hx' h, exact (hx hx').elim } }
by_cases hx : x.dom
use hx
{ use hx, intro hy, specialize H hy, specialize h (Œª _, hy), rw not_forall at h, cases h with hx' h, rw not_le at h, exact h }
intro hy
specialize H hy
specialize h (Œª _, hy)
rw not_forall at h
cases h with hx' h
rw not_le at h
exact h
specialize h (Œª hx', (hx hx').elim)
{ specialize h (Œª hx', (hx hx').elim), rw not_forall at h, cases h with hx' h, exact (hx hx').elim }
rw not_forall at h
cases h with hx' h
exact (hx hx').elim
rintro ‚ü®hx, H‚ü©
{ rintro ‚ü®hx, H‚ü©, exact ‚ü®‚ü®Œª _, hx, Œª hy, (H hy).le‚ü©, Œª hxy h, not_lt_of_le (h _) (H _)‚ü© }
exact ‚ü®‚ü®Œª _, hx, Œª hy, (H hy).le‚ü©, Œª hxy h, not_lt_of_le (h _) (H _)‚ü©
simpa only [nat.cast_zero] using with_top_equiv_coe 0
intros
rw [gcd_comm m n, gcd_gcd_self_left_right]
intros
rw [log, if_neg (Œª h : b ‚â§ n ‚àß 1 < b, h.2.not_le hb)]
intros
simpa using right_le_mkpair n.unpair.1 n.unpair.2
intros
{ obtain ‚ü®k, rfl‚ü© := h, exact succ_pos' }
obtain ‚ü®k, rfl‚ü© := h
exact succ_pos'
intros
obtain ‚ü®a, rfl‚ü© := h
exact factors_subset_right (right_ne_zero_of_mul h')
intros
rw ‚Üê not_lt; exact not_congr cast_lt
rw ‚Üê not_lt
exact not_congr cast_lt
intros
cases x
{ simp }
simp
simp only [pbind, iff_false]
{ simp only [pbind, iff_false], intro h, cases h' x rfl h }
intro h
cases h' x rfl h
intros
rw hl.2.1 at e
rw [hl.2.1, hr.2.1, delta] at h
rcases hr.3.1 with H|‚ü®hr‚ÇÅ, hr‚ÇÇ‚ü©
linarith
{linarith}
suffices H‚ÇÇ
suffices H‚ÇÅ
refine ‚ü®valid'.balance_l_aux v hr.right H‚ÇÅ H‚ÇÇ _, _‚ü©
{ rw e, exact or.inl (valid'.merge_lemma h hr‚ÇÅ) }
rw e
exact or.inl (valid'.merge_lemma h hr‚ÇÅ)
rw [balance_l_eq_balance v.2 hr.2.2.2 H‚ÇÅ H‚ÇÇ, balance_eq_balance' v.3 hr.3.2.2 v.2 hr.2.2.2, size_balance' v.2 hr.2.2.2, e, hl.2.1, hr.2.1]
{ rw [balance_l_eq_balance v.2 hr.2.2.2 H‚ÇÅ H‚ÇÇ, balance_eq_balance' v.3 hr.3.2.2 v.2 hr.2.2.2, size_balance' v.2 hr.2.2.2, e, hl.2.1, hr.2.1], simp [add_comm, add_left_comm] }
simp [add_comm, add_left_comm]
{ rw [e, add_right_comm], rintro ‚ü®‚ü© }
rw [e, add_right_comm]
rintro ‚ü®‚ü©
{ intros _ h‚ÇÅ, rw e, unfold delta at hr‚ÇÇ ‚ä¢, linarith }
intros _ h‚ÇÅ
rw e
unfold delta at hr‚ÇÇ ‚ä¢
linarith
intros
rcases H with rfl | rfl
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr rfl }
exact or.inr rfl
intros
dsimp [single]; split_ifs; simp [*, eq_comm]
dsimp [single]; split_ifs
dsimp [single]
split_ifs
simp [*, eq_comm]
simp [*, eq_comm]
intros
ext i x; cases x; reflexivity
ext i x; cases x
ext i x
cases x
reflexivity
reflexivity
intros
{ dsimp [is_reduced], refl }
dsimp [is_reduced]
refl
intros
induction n with n ih
{ simp, }
simp
conv_lhs { rw pow_succ', }
{ conv_lhs { rw pow_succ', }, rw [mul_assoc, X_mul, ‚Üêmul_assoc, ih, mul_assoc, ‚Üêpow_succ'], }
rw [mul_assoc, X_mul, ‚Üêmul_assoc, ih, mul_assoc, ‚Üêpow_succ']
intros
split_ifs
{ refl }
refl
exact (coeff_eq_zero_of_nat_degree_lt (not_le.1 (Œª w, h (nat.lt_one_add_iff.2 w)))).symm
{ exact (coeff_eq_zero_of_nat_degree_lt (not_le.1 (Œª w, h (nat.lt_one_add_iff.2 w)))).symm, }
intros
rw [subsingleton.elim p 0, nat_degree_zero]
intros
simp only [derivative_apply, eval_sum, eval_pow, eval_C, eval_X, eval_nat_cast, eval_mul]
intros
simp only [erase_lead, erase_zero]
intros
rwa coeff_zero_eq_eval_zero at hp
intros
simp [eval‚ÇÇ_eq_sum]
intros
simp [norm_unit]
intros
by_cases h : q = 0
{ simp [h] }
simp [h]
rw [degree_mul', hp.degree_mul]
{ exact add_comm _ _ }
exact add_comm _ _
rwa [hp.leading_coeff, one_mul, leading_coeff_ne_zero]
{ rwa [hp.leading_coeff, one_mul, leading_coeff_ne_zero] }
intros
rw [monic, leading_coeff_mul' _]; simp [leading_coeff_C b, hp]
rw [monic, leading_coeff_mul' _]
simp [leading_coeff_C b, hp]
simp [leading_coeff_C b, hp]
intros
unfold rev_at_fun
split_ifs with h j
{ exact nat.sub_sub_self h, }
exact nat.sub_sub_self h
exfalso
{ exfalso, apply j, exact nat.sub_le N i, }
apply j
exact nat.sub_le N i
{ refl, }
refl
intros
simp only [taylor_apply, eval_comp, eval_C, eval_X, eval_add]
intros
rw [‚Üê supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
intros
conv_lhs { rw [‚Üê(@num_denom p), ‚Üê(@num_denom q)] }
apply rat.mk_eq
{ exact_mod_cast p.denom_ne_zero }
exact_mod_cast p.denom_ne_zero
{ exact_mod_cast q.denom_ne_zero }
exact_mod_cast q.denom_ne_zero
intros
lift b to ‚Ñï using le_of_lt hb0
norm_cast at hb0 h
rw [‚Üê rat.mk_eq_div, ‚Üê rat.mk_pnat_eq a b hb0, rat.mk_pnat_denom, pnat.mk_coe, h.gcd_eq_one, nat.div_one]
intros
rw [coe_int_eq_of_int, cast_of_int]
apply le_antisymm
rw real.equiv_Cauchy.cardinal_eq
{ rw real.equiv_Cauchy.cardinal_eq, apply mk_quotient_le.trans, apply (mk_subtype_le _).trans_eq, rw [‚Üê power_def, mk_nat, mk_rat, omega_power_omega] }
apply mk_quotient_le.trans
apply (mk_subtype_le _).trans_eq
rw [‚Üê power_def, mk_nat, mk_rat, omega_power_omega]
convert mk_le_of_injective (cantor_function_injective _ _)
{ convert mk_le_of_injective (cantor_function_injective _ _), rw [‚Üêpower_def, mk_bool, mk_nat, two_power_omega], exact 1 / 3, norm_num, norm_num }
rw [‚Üêpower_def, mk_bool, mk_nat, two_power_omega]
exact 1 / 3
norm_num
norm_num
intros
have : mk f = 0 ‚Üî lim_zero (f - 0) := quotient.eq
have : mk f = 0 ‚Üî lim_zero (f - 0) := quotient.eq; rwa sub_zero at this
rwa sub_zero at this
intros
simp [ennreal.to_real, hx_top]
intros
change x + (-0) = x
{ change x + (-0) = x, simp }
simp
intros
unfold st
split_ifs
exact is_st_unique (classical.some_spec h) (is_st_Sup (not_infinite_of_exists_st h))
{ exact is_st_unique (classical.some_spec h) (is_st_Sup (not_infinite_of_exists_st h)) }
cases not_imp_comm.mp exists_st_of_not_infinite h with H H
{ cases not_imp_comm.mp exists_st_of_not_infinite h with H H, { rw (set.ext (Œª i, ‚ü®Œª hi, set.mem_univ i, Œª hi, H i‚ü©) : {y : ‚Ñù | (y : ‚Ñù*) < x} = set.univ), exact real.Sup_univ.symm }, { rw (set.ext (Œª i, ‚ü®Œª hi, false.elim (not_lt_of_lt (H i) hi), Œª hi, false.elim (set.not_mem_empty i hi)‚ü©) : {y : ‚Ñù | (y : ‚Ñù*) < x} = ‚àÖ), exact real.Sup_empty.symm } }
rw (set.ext (Œª i, ‚ü®Œª hi, set.mem_univ i, Œª hi, H i‚ü©) : {y : ‚Ñù | (y : ‚Ñù*) < x} = set.univ)
{ rw (set.ext (Œª i, ‚ü®Œª hi, set.mem_univ i, Œª hi, H i‚ü©) : {y : ‚Ñù | (y : ‚Ñù*) < x} = set.univ), exact real.Sup_univ.symm }
exact real.Sup_univ.symm
rw (set.ext (Œª i, ‚ü®Œª hi, false.elim (not_lt_of_lt (H i) hi), Œª hi, false.elim (set.not_mem_empty i hi)‚ü©) : {y : ‚Ñù | (y : ‚Ñù*) < x} = ‚àÖ)
{ rw (set.ext (Œª i, ‚ü®Œª hi, false.elim (not_lt_of_lt (H i) hi), Œª hi, false.elim (set.not_mem_empty i hi)‚ü©) : {y : ‚Ñù | (y : ‚Ñù*) < x} = ‚àÖ), exact real.Sup_empty.symm }
exact real.Sup_empty.symm
intros
simp only [div_eq_inv_mul, mul_finset_sup]
simpa using half_lt_self zero_ne_one.symm
intros
rw [sign, if_pos hr, if_neg hr.not_lt]
intros
rw [mul_comm, sqrt_mul hy, mul_comm]
intros
induction n
induction n; simp [*, drop]
simp [*, drop]
simp [*, drop]
intros
simp only [productive_iff]; exact forall_congr (Œª n, terminates_congr $ nth_congr h _)
simp only [productive_iff]
exact forall_congr (Œª n, terminates_congr $ nth_congr h _)
intros
simp [set.ite]
intros
ext
{ ext, split, rintro ‚ü®x, h1, h2‚ü©, exact ‚ü®‚ü®x, h1‚ü©, h2‚ü©, rintro ‚ü®‚ü®x, h1‚ü©, h2‚ü©, exact ‚ü®x, h1, h2‚ü© }
split
rintro ‚ü®x, h1, h2‚ü©
exact ‚ü®‚ü®x, h1‚ü©, h2‚ü©
rintro ‚ü®‚ü®x, h1‚ü©, h2‚ü©
exact ‚ü®x, h1, h2‚ü©
intros
{ ext ‚ü®x, y‚ü©, simp }
ext ‚ü®x, y‚ü©
simp
intros
rintro _ ‚ü®a, b, ‚ü®h1a, h2a‚ü©, hb, rfl‚ü©
{ rintro _ ‚ü®a, b, ‚ü®h1a, h2a‚ü©, hb, rfl‚ü©, split; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü© }
split
split; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
intros
rw [diff_eq, inter_comm]
intros
haveI := classical.prop_decidable; exact calc fintype.card (f '' s) = (s.to_finset.image f).card : fintype.card_of_finset' _ (by simp) ... = s.to_finset.card : finset.card_image_of_inj_on (Œª x hx y hy hxy, H x (mem_to_finset.1 hx) y (mem_to_finset.1 hy) hxy) ... = fintype.card s : (fintype.card_of_finset' _ (Œª a, mem_to_finset)).symm
haveI := classical.prop_decidable
exact calc fintype.card (f '' s) = (s.to_finset.image f).card : fintype.card_of_finset' _ (by simp) ... = s.to_finset.card : finset.card_image_of_inj_on (Œª x hx y hy hxy, H x (mem_to_finset.1 hx) y (mem_to_finset.1 hy) hxy) ... = fintype.card s : (fintype.card_of_finset' _ (Œª a, mem_to_finset)).symm
intros
simp only [card_subtype_compl, h]
intros
simp only [eq_on, ‚Üê forall_and_distrib]
refine forall_congr (Œª a, _)
by_cases a ‚àà s
by_cases a ‚àà s; simp *
simp *
simp *
intros
simp
intros
refine ‚ü®Œª h, _, Œª h, Ioi_subset_Ioi h‚ü©
by_contradiction ba
exact lt_irrefl _ (h (not_le.mp ba))
intros
simp
intros
simp [‚Üê Ici_inter_Iic, h]
intros
cases le_total x y; simp only [interval_of_le, interval_of_ge, *]; apply hs.out; assumption
cases le_total x y; simp only [interval_of_le, interval_of_ge, *]; apply hs.out
cases le_total x y; simp only [interval_of_le, interval_of_ge, *]
cases le_total x y
simp only [interval_of_le, interval_of_ge, *]
apply hs.out
assumption
assumption
simp only [interval_of_le, interval_of_ge, *]
apply hs.out
assumption
assumption
intros
simp [sub_eq_add_neg]
intros
simpa using bUnion_range
intros
rw [disjoint.comm, disjoint_left]
intros
rw [inter_comm, ‚Üê bInter_inter hs]
simp [inter_comm]
intros
cases x; refl
cases x
refl
intros
simp [val, int.nat_abs_mul]
intros
conv {to_rhs, rw ‚Üê nat.mod_add_div a n}; simp
conv {to_rhs, rw ‚Üê nat.mod_add_div a n}
simp
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
{ exact fintype.card_fin (n+1) }
exact fintype.card_fin (n+1)
intros
have : ‚àÄ s ‚àà countable_basis Œ±, ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí ‚àÉ·∂† n in at_top, (f^[n] x) ‚àà s
from Œª s hs, h.ae_mem_imp_frequently_image_mem (is_open_of_mem_countable_basis hs).measurable_set
refine ((ae_ball_iff $ countable_countable_basis Œ±).2 this).mono (Œª x hx s hs, _)
rcases (is_basis_countable_basis Œ±).mem_nhds_iff.1 hs with ‚ü®o, hoS, hxo, hos‚ü©
exact (hx o hoS hxo).mono (Œª n hn, hos hn)
intros
cases p.eq_zero_or_pos with hp hp
rw [hp, coe_expand, pow_zero, mul_zero, ‚Üê C_1, eval‚ÇÇ_hom, nat_degree_C]
{ rw [hp, coe_expand, pow_zero, mul_zero, ‚Üê C_1, eval‚ÇÇ_hom, nat_degree_C] }
by_cases hf : f = 0
{ rw [hf, alg_hom.map_zero, nat_degree_zero, zero_mul] }
rw [hf, alg_hom.map_zero, nat_degree_zero, zero_mul]
have hf1 : expand R p f ‚â† 0 := mt (expand_eq_zero hp).1 hf
rw [‚Üê with_bot.coe_eq_coe, ‚Üê degree_eq_nat_degree hf1]
refine le_antisymm ((degree_le_iff_coeff_zero _ _).2 $ Œª n hn, _) _
rw coeff_expand hp
{ rw coeff_expand hp, split_ifs with hpn, { rw coeff_eq_zero_of_nat_degree_lt, contrapose! hn, rw [with_bot.coe_le_coe, ‚Üê nat.div_mul_cancel hpn], exact nat.mul_le_mul_right p hn }, { refl } }
split_ifs with hpn
rw coeff_eq_zero_of_nat_degree_lt
{ rw coeff_eq_zero_of_nat_degree_lt, contrapose! hn, rw [with_bot.coe_le_coe, ‚Üê nat.div_mul_cancel hpn], exact nat.mul_le_mul_right p hn }
contrapose! hn
rw [with_bot.coe_le_coe, ‚Üê nat.div_mul_cancel hpn]
exact nat.mul_le_mul_right p hn
{ refl }
refl
refine le_degree_of_ne_zero _
{ refine le_degree_of_ne_zero _, rw [coeff_expand_mul hp, ‚Üê leading_coeff], exact mt leading_coeff_eq_zero.1 hf }
rw [coeff_expand_mul hp, ‚Üê leading_coeff]
exact mt leading_coeff_eq_zero.1 hf
intros
rw [separable_def, derivative_C, is_coprime_zero_right, is_unit_C]
intros
refine is_glb.of_image (Œª s t, show (s : set K) ‚â§ t ‚Üî s ‚â§ t, from set_like.coe_subset_coe) _
convert is_glb_binfi
exact coe_Inf _
intros
unfold angle
rw [inner_zero_right, zero_div, real.arccos_zero]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ‚Üê vsub_sub_vsub_cancel_right]
exact norm_sub_eq_abs_sub_norm_iff_angle_eq_zero ((Œª he, hp1p2 (vsub_eq_zero_iff_eq.1 he))) (Œª he, hp3p2 (vsub_eq_zero_iff_eq.1 he))
intros
have hr : ‚àÉ r, ‚àÄ i, dist ((s.face h).points i) s.circumcenter = r
use s.circumradius
{ use s.circumradius, simp [face_points] }
simp [face_points]
exact orthogonal_projection_eq_circumcenter_of_exists_dist_eq _ hr
intros
rw [altitude_def, direction_inf_of_mem (self_mem_mk' (s.points i) _) (mem_affine_span ‚Ñù (set.mem_range_self _)), direction_mk', direction_affine_span, direction_affine_span]
intros
have h‚ÇÅ : 0 ‚â§ ‚à•w‚à• ^ 2 + 4 := by nlinarith
suffices : ‚à•(4:‚Ñù) ‚Ä¢ w + (‚à•w‚à• ^ 2 - 4) ‚Ä¢ v‚à• = ‚à•w‚à• ^ 2 + 4
have h‚ÇÇ : ‚à•w‚à• ^ 2 + 4 ‚â† 0 := by nlinarith
{ have h‚ÇÇ : ‚à•w‚à• ^ 2 + 4 ‚â† 0 := by nlinarith, simp only [mem_sphere_zero_iff_norm, norm_smul, real.norm_eq_abs, abs_inv, this, abs_of_nonneg h‚ÇÅ, stereo_inv_fun_aux_apply], field_simp }
simp only [mem_sphere_zero_iff_norm, norm_smul, real.norm_eq_abs, abs_inv, this, abs_of_nonneg h‚ÇÅ, stereo_inv_fun_aux_apply]
field_simp
suffices : ‚à•(4:‚Ñù) ‚Ä¢ w + (‚à•w‚à• ^ 2 - 4) ‚Ä¢ v‚à• ^ 2 = (‚à•w‚à• ^ 2 + 4) ^ 2
have h‚ÇÉ : 0 ‚â§ ‚à•stereo_inv_fun_aux v w‚à• := norm_nonneg _
{ have h‚ÇÉ : 0 ‚â§ ‚à•stereo_inv_fun_aux v w‚à• := norm_nonneg _, simpa [h‚ÇÅ, h‚ÇÉ, -one_pow] using this }
simpa [h‚ÇÅ, h‚ÇÉ, -one_pow] using this
simp [norm_add_sq_real, norm_smul, inner_smul_left, inner_smul_right, inner_left_of_mem_orthogonal_singleton _ hw, mul_pow, real.norm_eq_abs, hv]
ring
intros
rw mdifferentiable.mfderiv_within (mdifferentiable_at_id I) hxs
exact mfderiv_id I
intros
apply has_mfderiv_within_at.mfderiv_within _ hxs
exact h.has_mfderiv_at.has_mfderiv_within_at
intros
simp only [mdifferentiable_within_at] with mfld_simps
exact ‚ü®ŒªH, H.2, ŒªH, ‚ü®H.continuous_within_at, H‚ü©‚ü©
intros
{ rw ext_chart_at_source, exact (chart_at H x).open_source }
rw ext_chart_at_source
exact (chart_at H x).open_source
intros
rw times_cont_mdiff_within_at_iff'' at *
exact ‚ü®hf.1.prod hg.1, hf.2.prod hg.2‚ü©
intros
apply bot_unique
rw [‚Üê (mdifferentiable_chart I (f.c (f.ind x hx))).ker_mfderiv_eq_bot (f.mem_chart_at_ind_source x hx), ‚Üê comp_embedding_pi_tangent_mfderiv]
exact linear_map.ker_le_ker_comp _ _
intros
rw set.ext_iff
simp_rw [mem_left_coset_iff, set_like.mem_coe]
split
intro h
{ intro h, apply (h y).mpr, rw mul_left_inv, exact s.one_mem }
apply (h y).mpr
rw mul_left_inv
exact s.one_mem
intros h z
{ intros h z, rw ‚Üêmul_inv_cancel_right x‚Åª¬π y, rw mul_assoc, exact s.mul_mem_cancel_left h }
rw ‚Üêmul_inv_cancel_right x‚Åª¬π y
rw mul_assoc
exact s.mul_mem_cancel_left h
intros
rw general_commutator_le
intros p hp q hq
exact mul_mem H‚ÇÇ (h.conj_mem q hq p) (inv_mem H‚ÇÇ hq)
intros
ext
ext; refl
refl
intros
by_cases h0 : order_of x = 0
rw [h0, coprime_zero_right] at h
{ rw [h0, coprime_zero_right] at h, exact ‚ü®1, by rw [h, pow_one, pow_one]‚ü© }
exact ‚ü®1, by rw [h, pow_one, pow_one]‚ü©
by_cases h1 : order_of x = 1
exact ‚ü®0, by rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]‚ü©
{ exact ‚ü®0, by rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]‚ü© }
obtain ‚ü®m, hm‚ü© := exists_mul_mod_eq_one_of_coprime h (one_lt_iff_ne_zero_and_ne_one.mpr ‚ü®h0, h1‚ü©)
exact ‚ü®m, by rw [‚Üêpow_mul, pow_eq_mod_order_of, hm, pow_one]‚ü©
intros
rw ‚Üêlength_attach at hn
rw ‚Üênodup_attach at hl
rw cycle_type_eq [l.attach.form_perm]
simp only [map, function.comp_app]
{ simp only [map, function.comp_app], rw [support_form_perm_of_nodup _ hl, card_to_finset, erase_dup_eq_self.mpr hl], { simpa }, { intros x h, simpa [h, nat.succ_le_succ_iff] using hn } }
rw [support_form_perm_of_nodup _ hl, card_to_finset, erase_dup_eq_self.mpr hl]
{ simpa }
simpa
intros x h
{ intros x h, simpa [h, nat.succ_le_succ_iff] using hn }
simpa [h, nat.succ_le_succ_iff] using hn
{ simp }
simp
{ simpa using is_cycle_form_perm hl hn }
simpa using is_cycle_form_perm hl hn
{ simp }
simp
intros
rw [‚Üêsum_cycle_type, h.cycle_type, multiset.sum_singleton]
intros
suffices : f = g ‚Üí (g.is_cycle ‚Üî f.is_cycle)
{ simpa [cycle_factors_finset_eq_finset, eq_comm] }
simpa [cycle_factors_finset_eq_finset, eq_comm]
rintro rfl
exact iff.rfl
intros
intros x hx
have hx' : x ‚àà {x | (zip_with swap l l').prod x ‚â† x} := by simpa using hx
simpa using zip_with_swap_prod_support' _ _ hx'
intros
simp
intros
rw [mem_support, mem_support, ne.def, ne.def, not_iff_not, apply_eq_iff_eq]
intros
rw [mem_alternating_group, bit1, sign_fin_rotate, pow_bit0', int.units_mul_self, one_pow]
intros
split
split; { rintros ‚ü®x, x_in, hx‚ü©, exact ‚ü®x‚Åª¬π, inv_mem K x_in, by simp [hx]‚ü© }
{ rintros ‚ü®x, x_in, hx‚ü©, exact ‚ü®x‚Åª¬π, inv_mem K x_in, by simp [hx]‚ü© }
rintros ‚ü®x, x_in, hx‚ü©
{ rintros ‚ü®x, x_in, hx‚ü©, exact ‚ü®x‚Åª¬π, inv_mem K x_in, by simp [hx]‚ü© }
exact ‚ü®x‚Åª¬π, inv_mem K x_in, by simp [hx]‚ü©
intros
rw ‚Üê set_like.coe_set_eq
simp [set.image_inter hf]
intros
split
intros h x x_in
{ intros h x x_in, rwa [h, mem_bot] at x_in }
rwa [h, mem_bot] at x_in
intros h
{ intros h, ext x, rw mem_bot, exact ‚ü®h x, by { rintros rfl, exact S.one_mem }‚ü© }
ext x
rw mem_bot
exact ‚ü®h x, by { rintros rfl, exact S.one_mem }‚ü©
intros
convert ext_of_direction_eq _ ‚ü®p, mem_affine_span k (set.mem_union_left _ (set.mem_singleton _)), mem_top k V p‚ü©
rw [direction_affine_span, direction_top, vector_span_eq_span_vsub_set_right k ((set.mem_union_left _ (set.mem_singleton _)) : p ‚àà _), eq_top_iff, ‚Üêh]
apply submodule.span_mono
rintros v ‚ü®v', rfl‚ü©
use (v' : V) +·µ• p
simp
intros
cases hn with p hp
rw lt_iff_le_and_exists at h
rcases h with ‚ü®hle, p2, hp2, hp2s1‚ü©
rw set_like.lt_iff_le_and_exists
use [direction_le hle, p2 -·µ• p, vsub_mem_direction hp2 (hle hp)]
intro hm
rw vsub_right_mem_direction_iff_mem hp p2 at hm
exact hp2s1 hm
intros
simp [h]
intros
rcases set.eq_empty_or_nonempty s with rfl | ‚ü®‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©‚ü©
{ simp [collinear_empty] }
simp [collinear_empty]
rw collinear_iff_of_mem k hp‚ÇÅ
{ rw collinear_iff_of_mem k hp‚ÇÅ, split, { exact Œª h, ‚ü®p‚ÇÅ, h‚ü© }, { rintros ‚ü®p, v, hv‚ü©, use v, intros p‚ÇÇ hp‚ÇÇ, rcases hv p‚ÇÇ hp‚ÇÇ with ‚ü®r, rfl‚ü©, rcases hv p‚ÇÅ hp‚ÇÅ with ‚ü®r‚ÇÅ, rfl‚ü©, use r - r‚ÇÅ, simp [vadd_vadd, ‚Üêadd_smul] } }
split
{ exact Œª h, ‚ü®p‚ÇÅ, h‚ü© }
exact Œª h, ‚ü®p‚ÇÅ, h‚ü©
rintros ‚ü®p, v, hv‚ü©
{ rintros ‚ü®p, v, hv‚ü©, use v, intros p‚ÇÇ hp‚ÇÇ, rcases hv p‚ÇÇ hp‚ÇÇ with ‚ü®r, rfl‚ü©, rcases hv p‚ÇÅ hp‚ÇÅ with ‚ü®r‚ÇÅ, rfl‚ü©, use r - r‚ÇÅ, simp [vadd_vadd, ‚Üêadd_smul] }
use v
intros p‚ÇÇ hp‚ÇÇ
rcases hv p‚ÇÇ hp‚ÇÇ with ‚ü®r, rfl‚ü©
rcases hv p‚ÇÅ hp‚ÇÅ with ‚ü®r‚ÇÅ, rfl‚ü©
use r - r‚ÇÅ
simp [vadd_vadd, ‚Üêadd_smul]
intros
rw [midpoint, ‚Üê line_map_apply_one_sub, one_sub_inv_of_two, midpoint]
intros
apply equiv.perm.swap_induction_on' œÉ
{ simp }
simp
intros s x y hxy hI
{ intros s x y hxy hI, simpa [g.map_swap (v ‚àò s) hxy, equiv.perm.sign_swap hxy] using hI, }
simpa [g.map_swap (v ‚àò s) hxy, equiv.perm.sign_swap hxy] using hI
intros
{ ext, simp [linear_equiv_fun_on_fintype], }
ext
simp [linear_equiv_fun_on_fintype]
intros
rw [set_like.ext'_iff, range_coe, top_coe, set.range_iff_surjective]
intros
simpa only [range_eq_map] using submodule.map_smul f _ a h
intros
apply set_like.coe_eq_coe.mp
have : ‚Üë(to_span_nonzero_singleton K M x h 1) = to_span_singleton K M x 1 := rfl
rw [this, to_span_singleton_one, submodule.coe_mk]
intros
ext
{ ext, simp }
simp
intros
{ rw ‚Üê b.coe_repr_symm, exact b.repr.symm_apply_apply x }
rw ‚Üê b.coe_repr_symm
exact b.repr.symm_apply_apply x
intros
rw [b.constr_def S f, linear_map.range_comp, linear_map.range_comp, linear_equiv.range, ‚Üê finsupp.supported_univ, finsupp.lmap_domain_supported, ‚Üêset.image_univ, ‚Üê finsupp.span_image_eq_map_total, set.image_id]
intros
rw [sym, apply_dual_basis_left]
intros
simp only [bilin_form.comp_right, bilin_form.to_matrix'_comp, to_matrix'_id, transpose_one, matrix.one_mul]
intros
{ ext m, exact map_apply_Œπ _ _ _ _ m }
ext m
exact map_apply_Œπ _ _ _ _ m
intros
letI := classical.dec_eq (basis.of_vector_space_index K V)
apply tensor_product.ext
apply linear_map.ext_ring
apply (basis.of_vector_space K V).ext
intro j
rw [linear_map.compr‚ÇÇ_apply, linear_map.compr‚ÇÇ_apply, tensor_product.mk_apply]
simp only [linear_map.coe_comp, function.comp_app, linear_equiv.coe_to_linear_map]
rw [lid_tmul, one_smul, rid_symm_apply]
simp only [linear_equiv.coe_to_linear_map, linear_map.rtensor_tmul, coevaluation_apply_one]
rw [tensor_product.sum_tmul, linear_equiv.map_sum]
simp only [assoc_tmul]
rw [linear_map.map_sum]
simp only [linear_map.ltensor_tmul, contract_left_apply]
simp only [basis.coord_apply, basis.repr_self_apply, tensor_product.tmul_ite]
rw [finset.sum_ite_eq]
simp only [finset.mem_univ, if_true]
intros
{ rw [‚Üê dim_sup_add_dim_inf_eq], exact self_le_add_right _ _ }
rw [‚Üê dim_sup_add_dim_inf_eq]
exact self_le_add_right _ _
intros
simp [finsupp_tensor_finsupp]
intros
refine linear_map.mem_ker.trans _
simp_rw [linear_map.ext_iff, dual_restrict_apply]
exact ‚ü®Œª h w hw, h ‚ü®w, hw‚ü©, Œª h w, h w.1 w.2‚ü©
intros
rw [has_eigenvalue, submodule.ne_bot_iff]
use x
exact h
intros
haveI := hs.fintype; exact of_fintype_basis h
haveI := hs.fintype
exact of_fintype_basis h
intros
rw ‚Üê s.finrank_quotient_add_finrank
{ rw ‚Üê s.finrank_quotient_add_finrank, exact nat.le_add_right _ _ }
exact nat.le_add_right _ _
intros
simp only [‚Üê linear_independent_option', option.cases_on'_none_coe]
intros
dsimp [mk_span_singleton']
rw [‚Üê sub_eq_zero, ‚Üê sub_smul]
apply H
simp only [sub_smul, one_smul, sub_eq_zero]
apply classical.some_spec (mem_span_singleton.1 h)
intros
ext
ext; simp
simp
intros
refine ‚ü®Œª i, A i i, ext $ Œª i j, _‚ü©
obtain rfl | hij := decidable.eq_or_ne i j
{ rw diagonal_apply_eq }
rw diagonal_apply_eq
{ rw [diagonal_apply_ne hij, h hij] }
rw [diagonal_apply_ne hij, h hij]
intros
refine ‚ü®Œª h, _, is_unit_nonsing_inv_det _‚ü©
nontriviality Œ±
casesI is_empty_or_nonempty n
{ simp }
simp
contrapose! h
rw [nonsing_inv_apply_not_is_unit _ h, det_zero]
{ simp }
simp
{ apply_instance }
apply_instance
intros
casesI (subsingleton_or_nontrivial Œ±)
{ simp }
simp
rw [‚Üê@det_one n, ‚Üêcoeff_det_X_add_C_card _ A, leading_coeff]
simp only [matrix.map_one, C_eq_zero, ring_hom.map_one]
cases (nat_degree_det_X_add_C_le 1 A).eq_or_lt with h h
simp only [ring_hom.map_one, matrix.map_one, C_eq_zero] at h
{ simp only [ring_hom.map_one, matrix.map_one, C_eq_zero] at h, rw h }
rw h
have H := coeff_eq_zero_of_nat_degree_lt h
{ have H := coeff_eq_zero_of_nat_degree_lt h, rw coeff_det_X_add_C_card at H, simpa using H }
rw coeff_det_X_add_C_card at H
simpa using H
intros
ext i
{ ext i, rw [‚Üê matrix.to_lin'_apply, linear_map.to_matrix, linear_equiv.trans_apply, matrix.to_lin'_to_matrix', linear_equiv.arrow_congr_apply, v‚ÇÇ.equiv_fun_apply], congr, exact v‚ÇÅ.equiv_fun.symm_apply_apply x }
rw [‚Üê matrix.to_lin'_apply, linear_map.to_matrix, linear_equiv.trans_apply, matrix.to_lin'_to_matrix', linear_equiv.arrow_congr_apply, v‚ÇÇ.equiv_fun_apply]
congr
exact v‚ÇÅ.equiv_fun.symm_apply_apply x
intros
simpa using f.map_piecewise_add m m' finset.univ
intros
{ ext x, simp }
ext x
simp
intros
rw [ker, ‚Üê prod_bot, prod_comap_inl]
intros
simp [of_is_compl]
intros
simp only [basis_fun, basis.coe_of_equiv_fun, linear_equiv.refl_symm, linear_equiv.refl_apply, std_basis_apply]
{ simp only [basis_fun, basis.coe_of_equiv_fun, linear_equiv.refl_symm, linear_equiv.refl_apply, std_basis_apply], congr }
congr
intros
classical
induction s using finset.induction with a s has ih h
{ simp, }
simp
{ simp [finset.sum_insert has, tmul_add, ih], }
simp [finset.sum_insert has, tmul_add, ih]
intros
split; intro h
split
{ split; intro h, { rw h; by_cases b; [left,right]; split; assumption }, { cases h with h h; cases h; split; intro; { contradiction <|> assumption } } }
intro h
rw h; by_cases b; [left,right]; split; assumption
rw h; by_cases b; [left,right]; split
rw h; by_cases b; [left,right]
rw h; by_cases b
{ rw h; by_cases b; [left,right]; split; assumption }
rw h
by_cases b
left
split
assumption
assumption
assumption
assumption
right
split
assumption
assumption
assumption
assumption
intro h
cases h with h h; cases h; split; intro; { contradiction <|> assumption }
cases h with h h; cases h; split; intro
cases h with h h; cases h; split
cases h with h h; cases h
{ cases h with h h; cases h; split; intro; { contradiction <|> assumption } }
cases h with h h
cases h
split
intro
{ contradiction <|> assumption }
intro
assumption
{ contradiction <|> assumption }
cases h
split
intro
{ contradiction <|> assumption }
intro
contradiction
{ contradiction <|> assumption }
intros
{ext, simp}
ext
simp
intros
induction h using relation.refl_trans_gen.head_induction_on
{ left, refl }
left
refl
{ right, existsi _, split; assumption }
right
existsi _
split
split; assumption
assumption
assumption
intros
simpa only [min_def] using hf.piecewise (measurable_set_le hf hg) hg
intros
refine integrable_of_forall_fin_meas_le' hm (Œº s * ‚à•x‚à•‚Çä) (ennreal.mul_lt_top hŒºs ennreal.coe_ne_top) _ _
{ exact Lp.ae_measurable _, }
exact Lp.ae_measurable _
refine Œª t ht hŒºt, (set_lintegral_nnnorm_condexp_ind_smul_le hm hs hŒºs x ht hŒºt).trans _
{ refine Œª t ht hŒºt, (set_lintegral_nnnorm_condexp_ind_smul_le hm hs hŒºs x ht hŒºt).trans _, exact ennreal.mul_le_mul (measure_mono (set.inter_subset_left _ _)) le_rfl, }
exact ennreal.mul_le_mul (measure_mono (set.inter_subset_left _ _)) le_rfl
intros
haveI : fact (m ‚â§ m0) := ‚ü®hm‚ü©
{ haveI : fact (m ‚â§ m0) := ‚ü®hm‚ü©, exact orthogonal_projection_norm_le _, }
exact orthogonal_projection_norm_le _
intros
simp [has_finite_integral, lintegral_const, lt_top_iff_ne_top, or_iff_not_imp_left]
intros
simp only [edist_eq_coe_nnnorm]
intros
simp [snorm, hp_ne_zero, hp_ne_top]
intros
ext1
refine indicator_const_Lp_coe_fn.trans (eventually_eq.trans _ (Lp.coe_fn_add _ _).symm)
refine eventually_eq.trans _ (eventually_eq.add indicator_const_Lp_coe_fn.symm indicator_const_Lp_coe_fn.symm)
rw set.indicator_union_of_disjoint (set.disjoint_iff_inter_eq_empty.mpr hst) _
intros
simp_rw [snorm_ess_sup, ‚Üê of_real_norm_eq_coe_nnnorm]
refine ess_sup_le_of_ae_le (ennreal.of_real C) (hfC.mono (Œª x hx, _))
exact ennreal.of_real_le_of_real hx
intros
have : f =·µê[Œº] f.map (ennreal.to_real ‚àò ennreal.of_real) := h_pos.mono (Œª a h, (ennreal.to_real_of_real h).symm)
rw [‚Üê integral_eq_lintegral' hf]
exacts [integral_congr hf this, ennreal.of_real_zero, Œª b, ennreal.of_real_ne_top]
intros
simp [integrable_on, integrable, has_finite_integral, nnnorm_indicator_eq_indicator_nnnorm, ennreal.coe_indicator, lintegral_indicator _ hs, ae_measurable_indicator_iff hs]
intros
cases le_total a b with hab hab; simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ‚ä¢
cases le_total a b with hab hab
simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ‚ä¢
exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi
{ exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi }
simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ‚ä¢
rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm]
{ rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm] }
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
simp only [sub_smul, ‚Üê set_integral_const]
refine (integral_Iic_sub_Iic _ _).symm
refine (integral_Iic_sub_Iic _ _).symm; simp only [integrable_on_const, measure_lt_top, or_true]
simp only [integrable_on_const, measure_lt_top, or_true]
simp only [integrable_on_const, measure_lt_top, or_true]
intros
rw [measure.restrict_empty, lintegral_zero_measure]
intros
have : ‚àÄ n, ‚à´‚Åª a, F n a ‚àÇŒº = ‚à´‚Åª a, (hF_meas n).mk (F n) a ‚àÇŒº := Œª n, lintegral_congr_ae (hF_meas n).ae_eq_mk
simp_rw this
apply tendsto_lintegral_of_dominated_convergence bound (Œª n, (hF_meas n).measurable_mk) _ h_fin
have : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, (hF_meas n).mk (F n) a = F n a := Œª n, (hF_meas n).ae_eq_mk.symm
{ have : ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, (hF_meas n).mk (F n) a = F n a := Œª n, (hF_meas n).ae_eq_mk.symm, have : ‚àÄ·µê a ‚àÇŒº, ‚àÄ n, (hF_meas n).mk (F n) a = F n a := ae_all_iff.mpr this, filter_upwards [this, h_lim], assume a H H', simp_rw H, exact H' }
have : ‚àÄ·µê a ‚àÇŒº, ‚àÄ n, (hF_meas n).mk (F n) a = F n a := ae_all_iff.mpr this
filter_upwards [this, h_lim]
assume a H H'
simp_rw H
exact H'
assume n
{ assume n, filter_upwards [h_bound n, (hF_meas n).ae_eq_mk], assume a H H', rwa H' at H }
filter_upwards [h_bound n, (hF_meas n).ae_eq_mk]
assume a H H'
rwa H' at H
intros
rw [restrict_with_density hs, lintegral_with_density_eq_lintegral_mul _ hf hg]
intros
refine le_trans (ennreal.lintegral_mul_le_Lp_mul_Lq Œº hpq hf (hg.pow_const _)) _
by_cases hf_zero_rpow : (‚à´‚Åª (a : Œ±), (f a) ^ p ‚àÇŒº) ^ (1 / p) = 0
rw [hf_zero_rpow, zero_mul]
{ rw [hf_zero_rpow, zero_mul], exact zero_le _, }
exact zero_le _
have hf_top_rpow : (‚à´‚Åª (a : Œ±), (f a) ^ p ‚àÇŒº) ^ (1 / p) ‚â† ‚ä§
by_contra h
{ by_contra h, push_neg at h, refine hf_top _, have hp_not_neg : ¬¨ p < 0, by simp [hpq.nonneg], simpa [hpq.pos, hp_not_neg] using h, }
refine hf_top _
have hp_not_neg : ¬¨ p < 0
simp [hpq.nonneg]
simp [hpq.nonneg]
simpa [hpq.pos, hp_not_neg] using h
refine (ennreal.mul_le_mul_left hf_zero_rpow hf_top_rpow).mpr (le_of_eq _)
congr
ext1 a
rw [‚Üêennreal.rpow_mul, hpq.sub_one_mul_conj]
intros
rwa [integral_trim hm hf_meas, restrict_trim hm Œº]
intros
simp_rw [set_to_simple_func, pi.add_apply]
push_cast
simp_rw [pi.add_apply, sum_add_distrib]
intros
induction l with i l ih
{ exact measurable_const }
exact measurable_const
{ exact (measurable_pi_apply i).prod_mk ih }
exact (measurable_pi_apply i).prod_mk ih
intros
{ funext, simp [‚Üê ennreal.coe_eq_coe], }
funext
simp [‚Üê ennreal.coe_eq_coe]
intros
simp only [prehaar]
rw [div_le_div_right]
exact_mod_cast index_mono K‚ÇÇ.2 h hU
exact_mod_cast index_pos K‚ÇÄ hU
intros
let f : E ‚Üí‚Çó[‚Ñù] E := r ‚Ä¢ 1
change measure.map f Œº = _
have hf : f.det ‚â† 0
simp only [mul_one, linear_map.det_smul, ne.def, monoid_hom.map_one]
{ simp only [mul_one, linear_map.det_smul, ne.def, monoid_hom.map_one], assume h, exact hr (pow_eq_zero h) }
assume h
exact hr (pow_eq_zero h)
simp only [map_linear_map_add_haar_eq_smul_add_haar Œº hf, mul_one, linear_map.det_smul, monoid_hom.map_one]
intros
simpa [h] using m.Union s
intros
rw [‚Üê of_union disjoint_diff hA (hB.diff hA), union_diff_cancel h]
apply_instance
intros
by_cases hi : measurable_set i
ext j hj
{ ext j hj, simp [restrict_apply _ hi hj] }
simp [restrict_apply _ hi hj]
{ simp [restrict_not_measurable _ hi] }
simp [restrict_not_measurable _ hi]
intros
apply le_antisymm; apply generate_from_le
apply le_antisymm
apply generate_from_le
exact Œª t h_t, generate_from_measurable_set_of_generate_pi_system t h_t
{ exact Œª t h_t, generate_from_measurable_set_of_generate_pi_system t h_t, }
apply generate_from_le
exact Œª t h_t, measurable_set_generate_from (generate_pi_system.base h_t)
{ exact Œª t h_t, measurable_set_generate_from (generate_pi_system.base h_t), }
intros
simp only [sum_inv, coe_coe, add_zero, insert_eq_cons, add_assoc, map_cons, sum_cons, map_singleton, sum_singleton]
intros
by_cases h0 : n = 0
simp [h0]
{ simp [h0] }
rw [bernoulli, neg_one_pow_eq_pow_mod_two]
cases mod_two_eq_zero_or_one n
simp [h]
{ simp [h] }
simp [bernoulli'_odd_eq_zero (odd_iff.mpr h) (one_lt_iff_ne_zero_and_ne_one.mpr ‚ü®h0, hn‚ü©)]
intros
refine iff.trans _ mul_eq_zero.symm
refine iff.trans _ (or_congr sub_eq_zero add_eq_zero_iff_eq_neg).symm
exact ‚ü®Œªe, by rw ‚Üê e; apply nat_abs_eq, Œªo, by cases o; subst x; simp [nat_abs_of_nat]‚ü©
intros
induction i with i ih
{ dsimp [s, s_zmod], norm_num, }
dsimp [s, s_zmod]
norm_num
{ push_cast [s, s_zmod, ih] }
push_cast [s, s_zmod, ih]
intros
conv in k { rw ‚Üê nat.div_add_mod k (2^n) }
refine nat.modeq.add_right _ _
conv { congr, skip, skip, rw ‚Üê one_mul (k/2^n) }
exact (nat.modeq_sub $ pow_pos (by norm_num : 0 < 2) _).mul_right _
intros
induction k; simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
induction k
simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
intros
wlog hle := le_total (padic_norm p r) (padic_norm p q) using [q r]
have hlt : padic_norm p r < padic_norm p q
from lt_of_le_of_ne hle hne.symm
have : padic_norm p q ‚â§ max (padic_norm p (q + r)) (padic_norm p r)
from calc padic_norm p q = padic_norm p (q + r - r) : by congr; ring ... ‚â§ max (padic_norm p (q + r)) (padic_norm p (-r)) : padic_norm.nonarchimedean p ... = max (padic_norm p (q + r)) (padic_norm p r) : by simp
have hnge : padic_norm p r ‚â§ padic_norm p (q + r)
apply le_of_not_gt
{ apply le_of_not_gt, intro hgt, rw max_eq_right_of_lt hgt at this, apply not_lt_of_ge this, assumption }
intro hgt
rw max_eq_right_of_lt hgt at this
apply not_lt_of_ge this
assumption
have : padic_norm p q ‚â§ padic_norm p (q + r)
rwa [max_eq_left hnge] at this
rwa [max_eq_left hnge] at this
apply _root_.le_antisymm
{ apply padic_norm.nonarchimedean p }
apply padic_norm.nonarchimedean p
rw max_eq_left_of_lt hlt
{ rw max_eq_left_of_lt hlt, assumption }
assumption
intros
unfold has_norm.norm
rw [‚Üê padic_norm_e.eq_padic_norm', ‚Üê padic.cast_eq_of_rat]
intros
simp [nth_hom]; refl
simp [nth_hom]
refl
intros
by_cases hk : k = 0
simp only [pythagorean_triple, hk, zero_mul, zero_add]
{ simp only [pythagorean_triple, hk, zero_mul, zero_add], }
calc (k * x) * (k * x) + (k * y) * (k * y) = k ^ 2 * (x * x + y * y) : by ring ... = k ^ 2 * (z * z) : by rw h.eq ... = (k * z) * (k * z) : by ring
{ calc (k * x) * (k * x) + (k * y) * (k * y) = k ^ 2 * (x * x + y * y) : by ring ... = k ^ 2 * (z * z) : by rw h.eq ... = (k * z) * (k * z) : by ring }
intros
simp [to_complex_def]
intros
{ ext x y, exact H x y }
ext x y
exact H x y
intros
rw [sdiff_sdiff_left, sup_idem]
intros
simp [(<)]; existsi a; refl
simp [(<)]; existsi a
simp [(<)]
intros
rw [insert_eq, lower_bounds_union, lower_bounds_singleton]
intros
rw [infi, Inf_apply, infi, infi, ‚Üê image_eq_range (Œª f : Œ† i, Œ≤ i, f a) (range f), ‚Üê range_comp]
intros
rw [infi, image_eq_range]
intros
rw [hs.sup'_eq_cSup_image, image_id]
intros
cases n
rw [disjointed_zero, eq_comm, inf_eq_left]
{ rw [disjointed_zero, eq_comm, inf_eq_left], simp_rw le_infi_iff, exact Œª i hi, (i.not_lt_zero hi).elim }
simp_rw le_infi_iff
exact Œª i hi, (i.not_lt_zero hi).elim
simp_rw [disjointed_succ, partial_sups_eq_bsupr, sdiff_eq, compl_supr]
congr
ext i
rw nat.lt_succ_iff
intros
rw [‚Üê e.comap_at_top, tendsto_comap_iff]
intros
refine ‚ü®_, (tendsto_at_top_at_top_of_monotone (Œª b‚ÇÅ b‚ÇÇ, (hm b‚ÇÅ b‚ÇÇ).2) hu).comp‚ü©
rw [tendsto_at_top, tendsto_at_top]
exact Œª hc b, (hc (e b)).mono (Œª a, (hm b (f a)).1)
intros
rw countable_iff_exists_surjective_to_subtype Bne at Bcbl
rcases Bcbl with ‚ü®g, gsurj‚ü©
rw infi_subtype'
use (Œª n, g n)
apply le_antisymm
apply le_antisymm; rw le_infi_iff
rw le_infi_iff
{ intro i, apply infi_le_of_le (g i) _, apply le_refl _ }
intro i
apply infi_le_of_le (g i) _
apply le_refl _
rw le_infi_iff
{ intros a, rcases gsurj a with ‚ü®i, rfl‚ü©, apply infi_le }
intros a
rcases gsurj a with ‚ü®i, rfl‚ü©
apply infi_le
intros
simp [filter.frequently, -not_eventually, not_forall]
intros
simp only [Sup_eq_supr, comap_supr, eq_self_iff_true]
intros
refine le_antisymm (le_seq $ Œª s hs t ht, _) (le_seq $ Œª s hs t ht, _)
rcases mem_map_iff_exists_image.1 hs with ‚ü®u, hu, hs‚ü©
{ rcases mem_map_iff_exists_image.1 hs with ‚ü®u, hu, hs‚ü©, refine mem_of_superset _ (set.seq_mono hs subset.rfl), rw ‚Üê set.prod_image_seq_comm, exact seq_mem_seq (image_mem_map ht) hu }
refine mem_of_superset _ (set.seq_mono hs subset.rfl)
rw ‚Üê set.prod_image_seq_comm
exact seq_mem_seq (image_mem_map ht) hu
rcases mem_map_iff_exists_image.1 hs with ‚ü®u, hu, hs‚ü©
{ rcases mem_map_iff_exists_image.1 hs with ‚ü®u, hu, hs‚ü©, refine mem_of_superset _ (set.seq_mono hs subset.rfl), rw set.prod_image_seq_comm, exact seq_mem_seq (image_mem_map ht) hu }
refine mem_of_superset _ (set.seq_mono hs subset.rfl)
rw set.prod_image_seq_comm
exact seq_mem_seq (image_mem_map ht) hu
intros
rcases eventually_prod_iff.1 h with ‚ü®pa, ha, pb, hb, h‚ü©
exact ha.mono (Œª a ha, hb.mono $ Œª b hb, h ha hb)
intros
simp [ne_bot_iff, not_and_distrib]
intros
have h1 : ‚àÄ·∂† a in f, ‚àÄ b, u a b ‚â§ f.limsup (Œª a', u a' b)
rw eventually_countable_forall
rw eventually_countable_forall
{ rw eventually_countable_forall, exact Œª b, ennreal.eventually_le_limsup (Œª a, u a b), }
{ rw eventually_countable_forall, exact Œª b, ennreal.eventually_le_limsup (Œª a, u a b), }
exact Œª b, ennreal.eventually_le_limsup (Œª a, u a b)
exact Œª b, ennreal.eventually_le_limsup (Œª a, u a b)
refine Inf_le (h1.mono (Œª x hx, filter.liminf_le_liminf (filter.eventually_of_forall hx) _))
filter.is_bounded_default
intros
simp only [filter.lift', filter.lift, (‚àò), tendsto_infi, tendsto_principal] at ht ‚ä¢
exact Œª u hu, (ht u hu).mp (hst.mono $ Œª a hst ht, subset.trans hst ht)
intros
simp only [imp_iff_not_or, eventually_or, eventually_not]
intros
refl
intros
refine hf.seq_pos_lt_seq_of_le_of_lt hn _ (Œª k hk, _) (Œª k hk, _)
refine hf.seq_pos_lt_seq_of_le_of_lt hn _ (Œª k hk, _) (Œª k hk, _); simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
intros
have SS : @lattice.to_semilattice_sup Œ± A = @lattice.to_semilattice_sup Œ± B := semilattice_sup.ext H
have II := semilattice_inf.ext H
casesI A
casesI B
injection SS; injection II; congr'
injection SS; injection II
injection SS
injection II
congr'
intros
simp only [‚Üê sup_eq_right, ‚Üê hf.map_sup, h.eq_iff]
intros
simp only [(Œî), sdiff_sdiff_sup_sdiff']
intros
have hl : ((submonoid.closure s) : set Œ±) ‚äÜ list.prod '' { l : list Œ± | ‚àÄ x, x ‚àà l ‚Üí x ‚àà s }
intros x hx
{ intros x hx, rw set_like.mem_coe at hx, refine submonoid.closure_induction hx (Œª x hx, ‚ü®_, Œª y hy, _, list.prod_singleton‚ü©) ‚ü®_, Œª y hy, (list.not_mem_nil _ hy).elim, list.prod_nil‚ü© _, { rwa list.mem_singleton.1 hy }, rintros _ _ ‚ü®l, hl, rfl‚ü© ‚ü®l', hl', rfl‚ü©, refine ‚ü®_, Œª y hy, _, list.prod_append‚ü©, cases list.mem_append.1 hy with hy hy, { exact hl _ hy }, { exact hl' _ hy } }
rw set_like.mem_coe at hx
refine submonoid.closure_induction hx (Œª x hx, ‚ü®_, Œª y hy, _, list.prod_singleton‚ü©) ‚ü®_, Œª y hy, (list.not_mem_nil _ hy).elim, list.prod_nil‚ü© _
{ rwa list.mem_singleton.1 hy }
rwa list.mem_singleton.1 hy
rintros _ _ ‚ü®l, hl, rfl‚ü© ‚ü®l', hl', rfl‚ü©
refine ‚ü®_, Œª y hy, _, list.prod_append‚ü©
cases list.mem_append.1 hy with hy hy
{ exact hl _ hy }
exact hl _ hy
{ exact hl' _ hy }
exact hl' _ hy
apply ((h.partially_well_ordered_on_sublist_forall‚ÇÇ (‚â§)).image_of_monotone_on _).mono hl
intros l1 l2 hl1 hl2 h12
obtain ‚ü®l, hll1, hll2‚ü© := list.sublist_forall‚ÇÇ_iff.1 h12
refine le_trans (list.rel_prod (le_refl 1) (Œª a b ab c d cd, mul_le_mul' ab cd) hll1) _
obtain ‚ü®l', hl'‚ü© := hll2.exists_perm_append
rw [hl'.prod_eq, list.prod_append, ‚Üê mul_one l.prod, mul_assoc, one_mul]
apply mul_le_mul_left'
have hl's := Œª x hx, hl2 x (list.subset.trans (l.subset_append_right _) hl'.symm.subset hx)
clear hl'
induction l' with x1 x2 x3 x4 x5
{ refl }
refl
rw [list.prod_cons, ‚Üê one_mul (1 : Œ±)]
exact mul_le_mul' (hpos x1 (hl's x1 (list.mem_cons_self x1 x2))) (x3 (Œª x hx, hl's x (list.mem_cons_of_mem _ hx)))
intros
suffices : œï.equalizer (lift_hom f (œï (root f)) (aeval_alg_hom_eq_zero f œï)) = ‚ä§
exact (alg_hom.ext (Œª x, (set_like.ext_iff.mp (this) x).mpr algebra.mem_top)).symm
{ exact (alg_hom.ext (Œª x, (set_like.ext_iff.mp (this) x).mpr algebra.mem_top)).symm }
rw [eq_top_iff, ‚Üêadjoin_root_eq_top, algebra.adjoin_le_iff, set.singleton_subset_iff]
exact (@lift_root _ _ _ _ _ _ _ (aeval_alg_hom_eq_zero f œï)).symm
intros
refine ‚ü®_, is_integral.is_algebraic K‚ü©
rintro ‚ü®p, hp, hpx‚ü©
refine ‚ü®_, monic_mul_leading_coeff_inv hp, _‚ü©
rw [‚Üê aeval_def, alg_hom.map_mul, hpx, zero_mul]
intros
refine ‚ü®Œª h, _, is_coprime.pow_left‚ü©
rw [‚Üê finset.card_range m, ‚Üê finset.prod_const] at h
exact h.of_prod_left 0 (finset.mem_range.mpr hm)
intros
haveI : is_fraction_ring C L := is_integral_closure.is_fraction_ring_of_finite_extension A K L C
exact ‚ü®is_integral_closure.is_noetherian_ring A K L C, h.dimension_le_one.is_integral_closure _ L _, (is_integrally_closed_iff L).mpr (Œª x hx, ‚ü®is_integral_closure.mk' C x (is_integral_trans (is_integral_closure.is_integral_algebra A L) _ hx), is_integral_closure.algebra_map_mk' _ _ _‚ü©)‚ü©
intros
simpa only [one_mul, eq_self_iff_true, units.coe_one, pow_one, forall_true_left, nat.cast_one] using add_val_def œñ 1 hœñ 1
intros
split
intro h
{ intro h, apply fractional_ideal.mul_induction_on h, { intros x' hx' y' hy', obtain ‚ü®a, ha‚ü© := (mem_span_singleton S).mp hx', use [a ‚Ä¢ y', submodule.smul_mem I a hy'], rw [‚Üêha, algebra.mul_smul_comm, algebra.smul_mul_assoc] }, { exact ‚ü®0, submodule.zero_mem I, (mul_zero x).symm‚ü© }, { rintros _ _ ‚ü®y, hy, rfl‚ü© ‚ü®y', hy', rfl‚ü©, exact ‚ü®y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm‚ü© }, { rintros r _ ‚ü®y', hy', rfl‚ü©, exact ‚ü®r ‚Ä¢ y', submodule.smul_mem I r hy', (algebra.mul_smul_comm _ _ _).symm ‚ü© } }
apply fractional_ideal.mul_induction_on h
intros x' hx' y' hy'
{ intros x' hx' y' hy', obtain ‚ü®a, ha‚ü© := (mem_span_singleton S).mp hx', use [a ‚Ä¢ y', submodule.smul_mem I a hy'], rw [‚Üêha, algebra.mul_smul_comm, algebra.smul_mul_assoc] }
obtain ‚ü®a, ha‚ü© := (mem_span_singleton S).mp hx'
use [a ‚Ä¢ y', submodule.smul_mem I a hy']
rw [‚Üêha, algebra.mul_smul_comm, algebra.smul_mul_assoc]
rintros _ _ ‚ü®y, hy, rfl‚ü© ‚ü®y', hy', rfl‚ü©
{ rintros _ _ ‚ü®y, hy, rfl‚ü© ‚ü®y', hy', rfl‚ü©, exact ‚ü®y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm‚ü© }
exact ‚ü®y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm‚ü©
rintros ‚ü®y', hy', rfl‚ü©
{ rintros ‚ü®y', hy', rfl‚ü©, exact mul_mem_mul ((mem_span_singleton S).mpr ‚ü®1, one_smul _ _‚ü©) hy' }
exact mul_mem_mul ((mem_span_singleton S).mpr ‚ü®1, one_smul _ _‚ü©) hy'
intros
refine subring.in_closure.rec_on hxs _ _ _ _
{ rw ring_hom.map_one, refl }
rw ring_hom.map_one
refl
rw [ring_hom.map_neg, ring_hom.map_neg, ring_hom.map_one]
{ rw [ring_hom.map_neg, ring_hom.map_neg, ring_hom.map_one], refl }
refl
rintros _ ‚ü®p, hps, rfl‚ü© n ih
{ rintros _ ‚ü®p, hps, rfl‚ü© n ih, rw [ring_hom.map_mul, restriction_of, dif_pos hps, ring_hom.map_mul, map_of, ih] }
rw [ring_hom.map_mul, restriction_of, dif_pos hps, ring_hom.map_mul, map_of, ih]
intros x y ihx ihy
{ intros x y ihx ihy, rw [ring_hom.map_add, ring_hom.map_add, ihx, ihy] }
rw [ring_hom.map_add, ring_hom.map_add, ihx, ihy]
intros
cases is_maximal_iff.1 hI with H‚ÇÅ H‚ÇÇ
rcases mem_span_insert.1 (H‚ÇÇ (span (insert x I)) x (set.subset.trans (subset_insert _ _) subset_span) hx (subset_span (mem_insert _ _))) with ‚ü®y, z, hz, hy‚ü©
refine ‚ü®y, z, _, hy.symm‚ü©
rwa ‚Üê span_eq I
intros
rintros h
rw h at max
rcases max with ‚ü®‚ü®h1, h2‚ü©‚ü©
obtain ‚ü®I, hIbot, hItop‚ü© := not_is_field_iff_exists_ideal_bot_lt_and_lt_top.mp not_field
exact ne_of_lt hItop (h2 I hIbot)
intros
unfold span
{ unfold span, rw [submodule.span_mul_span, set.singleton_mul_singleton], }
rw [submodule.span_mul_span, set.singleton_mul_singleton]
intros
obtain ‚ü®Q, ‚ü®Q_prime, hQ‚ü©‚ü© := exists_ideal_over_prime_of_is_integral' H P hP
haveI : Q.is_prime := Q_prime
exact ‚ü®Q, is_maximal_of_is_integral_of_is_maximal_comap H _ (hQ.symm ‚ñ∏ P_max), hQ‚ü©
intros
rw [add_mk, mk_eq_mk_iff, r_eq_r']
refine (r' M).symm ‚ü®1, _‚ü©
simp only [submonoid.coe_one, submonoid.coe_mul]
ring
intros
rw [restrict_degree, finsupp.mem_supported]
refl
intros
obtain ‚ü®n, ne, w‚ü© := is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot f
rw [linear_map.range_eq_top.mpr (linear_map.iterate_surjective s n), inf_top_eq, linear_map.ker_eq_bot] at w
exact linear_map.injective_of_iterate_injective ne w
intros
simp [degree]
intros
rw ‚Üêcyclotomic'
induction n using nat.strong_induction_on with k hk generalizing Œ∂ hz
obtain hzero | hpos := k.eq_zero_or_pos
{ simp only [hzero, cyclotomic'_zero, cyclotomic_zero] }
simp only [hzero, cyclotomic'_zero, cyclotomic_zero]
have h : ‚àÄ i ‚àà k.proper_divisors, cyclotomic i K = cyclotomic' i K
intros i hi
{ intros i hi, obtain ‚ü®d, hd‚ü© := (nat.mem_proper_divisors.1 hi).1, rw mul_comm at hd, exact hk i (nat.mem_proper_divisors.1 hi).2 (is_primitive_root.pow hpos hz hd) }
obtain ‚ü®d, hd‚ü© := (nat.mem_proper_divisors.1 hi).1
rw mul_comm at hd
exact hk i (nat.mem_proper_divisors.1 hi).2 (is_primitive_root.pow hpos hz hd)
rw [@cyclotomic_eq_X_pow_sub_one_div _ _ _ hpos, cyclotomic'_eq_X_pow_sub_one_div hpos hz, finset.prod_congr (refl k.proper_divisors) h]
intros
apply is_homogeneous_monomial
simp only [finsupp.zero_apply, finset.sum_const_zero]
intros
convert scale_roots_eval‚ÇÇ_eq_zero (algebra_map A S) hr
rw [aeval_def, mk'_spec' _ r s]
intros
dsimp [to_fun_alg_hom]
rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_eq_sum]
intros
rw [inv_eq_inv_aux, coeff_inv_aux n (constant_coeff k œÜ)‚Åª¬π œÜ]
intros
rw ‚Üê inv_of_unit_eq œÜ (h.symm ‚ñ∏ u.ne_zero)
congr' 1
rw [units.ext_iff]
exact h.symm
intros
rw [coeff_X, if_pos rfl]
intros
rw [‚Üê @span_singleton_eq_bot R M, span_singleton_generator]
intros
obtain ‚ü®Œ∂, rfl‚ü© := h.is_unit h0
obtain ‚ü®Œæ, rfl‚ü© := is_unit_of_pow_eq_one Œæ k hŒæ h0
obtain ‚ü®k, rfl‚ü© : ‚àÉ k' : ‚Ñï+, k = k' := ‚ü®‚ü®k, h0‚ü©, rfl‚ü©
simp only [‚Üê units.coe_pow, ‚Üê units.ext_iff]
rw coe_units_iff at h
apply h.eq_pow_of_mem_roots_of_unity
rw [mem_roots_of_unity, units.ext_iff, units.coe_pow, hŒæ, units.coe_one]
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
split
{ rw ‚Üê mk_dvd_mk, apply dvd_of_mem_factors', apply ha0 }
rw ‚Üê mk_dvd_mk
apply dvd_of_mem_factors'
apply ha0
{ apply mem_factors'_of_dvd ha0 }
apply mem_factors'_of_dvd ha0
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [add_zero, ring_hom.map_add, constant_coeff_X]
intros
apply le_antisymm
{ rw [powerlt_le], intros c hc, apply zero_power_le }
rw [powerlt_le]
intros c hc
apply zero_power_le
convert le_powerlt (pos_iff_ne_zero.2 h)
rw [power_zero]
intros
rw [‚Üênot_lt, lt_omega_iff_fintype, not_nonempty_iff, is_empty_fintype]
intros
{ rw [mul_eq_max_of_omega_le_left ha hb', max_eq_left hb] }
rw [mul_eq_max_of_omega_le_left ha hb', max_eq_left hb]
intros
{cases x, cases y, refl}
cases x
cases y
refl
intros
rw [le_zero_iff_zero_le_neg, le_congr (equiv_refl 0) (neg_equiv_self G)]
intros
rw [CNF_rec, dif_pos rfl]; refl
rw [CNF_rec, dif_pos rfl]
refl
intros
induction n with n ih; [rw [nat.cast_zero, add_zero, add_zero], rw [‚Üê nat_cast_succ, add_succ, add_succ, succ_le_succ, ih]]
induction n with n ih
rw [nat.cast_zero, add_zero, add_zero]
rw [‚Üê nat_cast_succ, add_succ, add_succ, succ_le_succ, ih]
intros
simpa only [not_ball, not_le] using not_congr (@limit_le _ h a)
rw lt_def
left
use ‚ü®punit.star, by split; rintro ‚ü® ‚ü©‚ü©
intros
rw lt_def_le at *
rcases hwx with ‚ü®ix, hix‚ü©|‚ü®jw, hjw‚ü©; rcases hyz with ‚ü®iz, hiz‚ü©|‚ü®jy, hjy‚ü©
rcases hwx with ‚ü®ix, hix‚ü©|‚ü®jw, hjw‚ü©
rcases hyz with ‚ü®iz, hiz‚ü©|‚ü®jy, hjy‚ü©
left
{ left, use (left_moves_add x z).symm (sum.inl ix), simp only [add_move_left_inl], calc w + y ‚â§ move_left x ix + y : add_le_add_right hix ... ‚â§ move_left x ix + move_left z iz : add_le_add_left hiz ... ‚â§ move_left x ix + z : add_le_add_left (oz.move_left_le iz) }
use (left_moves_add x z).symm (sum.inl ix)
simp only [add_move_left_inl]
calc w + y ‚â§ move_left x ix + y : add_le_add_right hix ... ‚â§ move_left x ix + move_left z iz : add_le_add_left hiz ... ‚â§ move_left x ix + z : add_le_add_left (oz.move_left_le iz)
left
{ left, use (left_moves_add x z).symm (sum.inl ix), simp only [add_move_left_inl], calc w + y ‚â§ move_left x ix + y : add_le_add_right hix ... ‚â§ move_left x ix + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ‚â§ move_left x ix + z : add_le_add_left hjy }
use (left_moves_add x z).symm (sum.inl ix)
simp only [add_move_left_inl]
calc w + y ‚â§ move_left x ix + y : add_le_add_right hix ... ‚â§ move_left x ix + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ‚â§ move_left x ix + z : add_le_add_left hjy
rcases hyz with ‚ü®iz, hiz‚ü©|‚ü®jy, hjy‚ü©
right
{ right, use (right_moves_add w y).symm (sum.inl jw), simp only [add_move_right_inl], calc move_right w jw + y ‚â§ x + y : add_le_add_right hjw ... ‚â§ x + move_left z iz : add_le_add_left hiz ... ‚â§ x + z : add_le_add_left (oz.move_left_le iz), }
use (right_moves_add w y).symm (sum.inl jw)
simp only [add_move_right_inl]
calc move_right w jw + y ‚â§ x + y : add_le_add_right hjw ... ‚â§ x + move_left z iz : add_le_add_left hiz ... ‚â§ x + z : add_le_add_left (oz.move_left_le iz)
right
{ right, use (right_moves_add w y).symm (sum.inl jw), simp only [add_move_right_inl], calc move_right w jw + y ‚â§ x + y : add_le_add_right hjw ... ‚â§ x + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ‚â§ x + z : add_le_add_left hjy, }
use (right_moves_add w y).symm (sum.inl jw)
simp only [add_move_right_inl]
calc move_right w jw + y ‚â§ x + y : add_le_add_right hjw ... ‚â§ x + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ‚â§ x + z : add_le_add_left hjy
intros
simp [smulg]
intros
simp
intros
simp only [normalize_fin, ‚Üê h] at *; rw [nat.mul_mod, ‚Üê ha, ‚Üê hb, fin.mul_def]
simp only [normalize_fin, ‚Üê h] at *
rw [nat.mul_mod, ‚Üê ha, ‚Üê hb, fin.mul_def]
intros
simpa only [val, length_neg] using val_between_neg
intros
simp [pow_add, mul_assoc]
intros
cc
intros
refine ‚ü®Œª h, h.tendsto_sum_nat, Œª h, _‚ü©
rw tendsto_nhds_unique h hf.has_sum.tendsto_sum_nat
exact hf.has_sum
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _)) (pi_univ_Ioc_subset a b)
exact Ioc_mem_nhds (ha i) (hb i)
intros
simp [frontier]
intros
rw continuous_on_iff_continuous_restrict at hf hg
obtain ‚ü®b, h‚ü© := @intermediate_value_univ‚ÇÇ_eventually‚ÇÇ _ _ _ _ _ _ (subtype.preconnected_space hs) _ _ (comap_coe_ne_bot_of_le_principal hl‚ÇÅ) (comap_coe_ne_bot_of_le_principal hl‚ÇÇ) _ _ hf hg (eventually_comap' he‚ÇÅ) (eventually_comap' he‚ÇÇ)
exact ‚ü®b, b.prop, h‚ü©
intros
simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]
intros
rw ‚Üê (is_closed_closure.preimage hf).closure_eq
exact closure_mono (preimage_mono subset_closure)
intros
fsplit
intros hd ho
{ intros hd ho, exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _) }
exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)
refine Œª ho, dense_iff_inter_open.2 (Œª U hU hne, inter_compl_nonempty_iff.2 $ Œª hUx, _)
{ refine Œª ho, dense_iff_inter_open.2 (Œª U hU hne, inter_compl_nonempty_iff.2 $ Œª hUx, _), obtain rfl : U = {x}, from eq_singleton_iff_nonempty_unique_mem.2 ‚ü®hne, hUx‚ü©, exact ho hU }
obtain rfl : U = {x}
from eq_singleton_iff_nonempty_unique_mem.2 ‚ü®hne, hUx‚ü©
exact ho hU
intros
simp only [‚Üê interior_set_of_eq, is_open_interior]
intros
{ ext, refl }
ext
refl
intros
rw mem_nhds_prod_iff
split
rintros ‚ü®u, Hu, v, Hv, h‚ü©
{ rintros ‚ü®u, Hu, v, Hv, h‚ü©, rcases mem_nhds_iff.1 Hu with ‚ü®u', u'u, u'_open, Hu'‚ü©, rcases mem_nhds_iff.1 Hv with ‚ü®v', v'v, v'_open, Hv'‚ü©, exact ‚ü®u', v', u'_open, Hu', v'_open, Hv', (set.prod_mono u'u v'v).trans h‚ü© }
rcases mem_nhds_iff.1 Hu with ‚ü®u', u'u, u'_open, Hu'‚ü©
rcases mem_nhds_iff.1 Hv with ‚ü®v', v'v, v'_open, Hv'‚ü©
exact ‚ü®u', v', u'_open, Hu', v'_open, Hv', (set.prod_mono u'u v'v).trans h‚ü©
rintros ‚ü®u, v, u_open, au, v_open, bv, huv‚ü©
{ rintros ‚ü®u, v, u_open, au, v_open, bv, huv‚ü©, exact ‚ü®u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv‚ü© }
exact ‚ü®u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv‚ü©
intros
cases f; cases g; congr'; exact funext H
cases f; cases g; congr'
cases f; cases g
cases f
cases g
congr'
exact funext H
intros
rw [nhds_within_inter, inf_eq_right]
{ rw [nhds_within_inter, inf_eq_right], exact nhds_within_le_of_mem h }
exact nhds_within_le_of_mem h
intros
simp only [continuous_within_at, nhds_within_union, tendsto_sup]
intros
rw continuous_iff_continuous_on_univ
exact continuous_on_extend_from (Œª x _, hA x) (by simpa using hf)
intros
intros s hs
cases eq_empty_or_nonempty s with h2s h2s
{ simp_rw [h2s, image_empty, is_closed_empty] }
simp_rw [h2s, image_empty, is_closed_empty]
{ exact h s hs h2s }
exact h s hs h2s
intros
exact_mod_cast hf.mul_le_nndist x y
intros
rw dist_comm z; apply dist_triangle
rw dist_comm z
apply dist_triangle
intros
cases cauchy_iff.1 hf with hf1 hf2
intros Œµ hŒµ
rcases hf2 {x | dist x.1 x.2 < Œµ} (dist_mem_uniformity hŒµ) with ‚ü®t, ‚ü®ht, htsub‚ü©‚ü©
simp at ht
cases ht with N hN
existsi N
intros j hj
rw ‚Üêdist_eq_norm
apply @htsub (f j, f N)
apply set.mk_mem_prod; solve_by_elim [le_refl]
apply set.mk_mem_prod
solve_by_elim [le_refl]
solve_by_elim [le_refl]
intros
simp only [inf_edist, le_infi_iff]
intros
rw [metric.diam, metric.diam, hf.ediam_image]
intros
simp only [lipschitz_on_with, edist_nndist, dist_nndist]
{ simp only [lipschitz_on_with, edist_nndist, dist_nndist], norm_cast }
norm_cast
intros
rw [to_pou_fun, h, zero_mul]
intros
ext z
split
intro h'
{ intro h', rw path_component_symm, exact (h.trans h').symm }
rw path_component_symm
exact (h.trans h').symm
intro h'
{ intro h', rw path_component_symm at h' ‚ä¢, exact h'.trans h }
rw path_component_symm at h' ‚ä¢
exact h'.trans h
intros
simp [upper_semicontinuous_within_at, upper_semicontinuous_at, nhds_within_univ]
intros
simp only [filter.coclosed_compact, infi_and']
refine has_basis_binfi_principal' _ ‚ü®‚àÖ, is_closed_empty, is_compact_empty‚ü©
rintro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©
exact ‚ü®s ‚à™ t, ‚ü®‚ü®hs‚ÇÅ.union ht‚ÇÅ, hs‚ÇÇ.union ht‚ÇÇ‚ü©, compl_subset_compl.2 (subset_union_left _ _), compl_subset_compl.2 (subset_union_right _ _)‚ü©‚ü©
intros
simp [subset_def]; exact forall_congr (Œª a, by simp)
simp [subset_def]
exact forall_congr (Œª a, by simp)
intros
{ ext y, rw mem_ball_symmetry hV, exact iff.rfl }
ext y
rw mem_ball_symmetry hV
exact iff.rfl
intros
simp [uniform_continuous]; exact tendsto_id
simp [uniform_continuous]
exact tendsto_id
intros
simp [uniformity_has_basis_closure.separation_rel]
continuity!
intros
cases b; simp
cases b
simp
simp
intros
rw [int.mul_comm, int.distrib_left]
simp [int.mul_comm]
intros
simp [int.lt_iff_le_and_ne]
split
split; intro h
intro h
cases h with hab hn
{ cases h with hab hn, split, { assumption }, { intro hba, simp [int.le_antisymm hab hba] at *, contradiction } }
split
{ assumption }
assumption
intro hba
{ intro hba, simp [int.le_antisymm hab hba] at *, contradiction }
simp [int.le_antisymm hab hba] at *
contradiction
intro h
cases h with hab hn
{ cases h with hab hn, split, { assumption }, { intro h, simp [*] at * } }
split
{ assumption }
assumption
{ intro h, simp [*] at * }
intro h
simp [*] at *
intros
rw int.add_comm at h
exact int.neg_add_le_left_of_le_add h
intros
simp [join, list.bind]
intros
cases m; simp [gcd]
cases m
simp [gcd]
simp [gcd]
intros
have h‚ÇÅ : f.to_equiv = g.to_equiv := equiv.ext h
cases f
cases g
congr
{ exact (funext h) }
exact (funext h)
{ exact congr_arg equiv.inv_fun h‚ÇÅ }
exact congr_arg equiv.inv_fun h‚ÇÅ
intros
suffices : (‚®Ü i, span R (s i : set A)) * span R t = (‚®Ü i, span R (s i) * span R t)
{ simpa only [span_eq] using this }
simpa only [span_eq] using this
simp_rw [span_mul_span, ‚Üê span_Union, span_mul_span, set.Union_mul]
intros
simp [irreducible_iff]
intros
simp
intros
haveI := classical.dec_eq Œ±
rw [‚Üê prod_union (filter_inter_filter_neg_eq p s).le, filter_union_filter_neg_eq]
intros
have : mul_support (f ‚àò plift.down) ‚äÜ ({plift.up a} : finset (plift Œ±))
intro x
{ intro x, contrapose, simpa [plift.eq_up_iff_down_eq] using ha x.down }
contrapose
simpa [plift.eq_up_iff_down_eq] using ha x.down
rw [finprod_eq_prod_plift_of_mul_support_subset this, finset.prod_singleton]
intros
rw [‚Üê finset.coe_singleton, finprod_mem_coe_finset, finset.prod_singleton]
intros
rcases eq_empty_or_nonempty s with rfl|hs_nonempty
{ simp [h_one] }
simp [h_one]
exact le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul g s hs_nonempty hs
{ exact le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul g s hs_nonempty hs, }
intros
{ ext1, apply w }
ext1
apply w
intros
cases y with j‚ÇÅ y
cases x with j‚ÇÇ x
cases y' with j‚ÇÉ y'
obtain ‚ü®l, f, g, hfg‚ü© := hyy'
simp at hfg
obtain ‚ü®s, Œ±, Œ≤, Œ≥, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := tulip (right_to_max j‚ÇÇ j‚ÇÅ) (left_to_max j‚ÇÇ j‚ÇÅ) (left_to_max j‚ÇÇ j‚ÇÉ) (right_to_max j‚ÇÇ j‚ÇÉ) f g
apply M.mk_eq
use [s, Œ±, Œ≥]
dsimp
simp_rw [monoid_hom.map_mul, ‚Üê comp_apply, ‚Üê F.map_comp, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, F.map_comp, comp_apply, hfg]
intros
rw [‚Üê nsmul_one, card_nsmul_eq_zero]
intros
rw [‚Üêsub_eq_zero, ‚Üêmul_sub, mul_eq_zero, sub_eq_zero] at h
exact_mod_cast h
intros
rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]
{ rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux], exact zero_le_of_continuants_aux_b }
exact zero_le_of_continuants_aux_b
intros
simp only [num_eq_conts_a, (continuants_stable_of_terminated n_le_m terminated_at_n)]
intros
rw [div_neg_eq_neg_div, neg_div, neg_neg]
intros
{ ext, simp [floor_lt, lt_ceil] }
ext
simp [floor_lt, lt_ceil]
intros
rw [‚Üê gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add]
{ rw [‚Üê gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add], simp }
simp
intros
{ rw [geom_sum_def, sum_range_one, pow_zero] }
rw [geom_sum_def, sum_range_one, pow_zero]
intros
rw [‚Üê mul_assoc, h.mul_inv_cancel]
intros
rw [‚Üê f.map_mul, h, f.map_one]
intros
{ ext, cases x; refl }
ext
cases x
cases x; refl
refl
refl
intros
rw [bit1, pow_succ', pow_bit0]
intros
by_cases a0 : 0 ‚â§ a; by_cases b0 : 0 ‚â§ b
by_cases a0 : 0 ‚â§ a
by_cases b0 : 0 ‚â§ b
{ simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0] }
simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0]
exact (lt_irrefl (0 : Œ±) (a0.trans_lt (hle.trans_lt (not_le.mp b0)))).elim
{ exact (lt_irrefl (0 : Œ±) (a0.trans_lt (hle.trans_lt (not_le.mp b0)))).elim }
by_cases b0 : 0 ‚â§ b
any_goals { simp [(not_le.mp a0).le, (not_le.mp b0).le, abs_of_nonpos, add_nonpos, add_comm] }
obtain F := (not_le.mp a0)
have : (abs (a + b) = -a + b ‚Üî b ‚â§ 0) ‚Üî (abs (a + b) = abs a + abs b ‚Üî 0 ‚â§ a ‚àß 0 ‚â§ b ‚à® a ‚â§ 0 ‚àß b ‚â§ 0)
{ simp [a0, b0, abs_of_neg, abs_of_nonneg, F, F.le] }
simp [a0, b0, abs_of_neg, abs_of_nonneg, F, F.le]
refine this.mp ‚ü®Œª h, _, Œª h, by simp only [le_antisymm h b0, abs_of_neg F, add_zero]‚ü©
by_cases ba : a + b ‚â§ 0
refine le_of_eq (eq_zero_of_neg_eq _)
{ refine le_of_eq (eq_zero_of_neg_eq _), rwa [abs_of_nonpos ba, neg_add_rev, add_comm, add_right_inj] at h }
rwa [abs_of_nonpos ba, neg_add_rev, add_comm, add_right_inj] at h
refine (lt_irrefl (0 : Œ±) _).elim
{ refine (lt_irrefl (0 : Œ±) _).elim, rw [abs_of_pos (not_le.mp ba), add_left_inj] at h, rwa eq_zero_of_neg_eq h.symm at F }
rw [abs_of_pos (not_le.mp ba), add_left_inj] at h
rwa eq_zero_of_neg_eq h.symm at F
simp [(not_le.mp a0).le, (not_le.mp b0).le, abs_of_nonpos, add_nonpos, add_comm]
intros
rw [eq_comm, mul_eq_zero]
intros
rw [div_div_eq_mul_div, div_mul_cancel _ hc]
intros
dsimp [prev_d, to_prev]
rcases c.prev j with ‚ü®‚ü©|‚ü®‚ü®j', w‚ü©‚ü©; { dsimp [prev_d, to_prev], simp }
rcases c.prev j with ‚ü®‚ü©|‚ü®‚ü®j', w‚ü©‚ü©
{ dsimp [prev_d, to_prev], simp }
{ dsimp [prev_d, to_prev], simp }
dsimp [prev_d, to_prev]
simp
intros
tidy
intros
rw [‚Üê inv_inv (a‚Åª¬π ‚äî b‚Åª¬π), inv_sup_eq_inv_inf_inv a‚Åª¬π b‚Åª¬π, inv_inv, inv_inv]
intros
haveI : lie_module.is_trivial L I := (lie_module.trivial_iff_le_maximal_trivial R L L I).mpr h
exact lie_ideal.is_lie_abelian_of_trivial R L I
intros
{ ext, refl, }
ext
refl
intros
have h : ‚Öü(2 : R) ‚Ä¢ (1 : matrix l l R) + ‚Öü(2 : R) ‚Ä¢ 1 = 1 := by rw [‚Üê smul_add, ‚Üê (two_smul R _), smul_smul, inv_of_mul_self, one_smul]
erw [matrix.from_blocks_transpose, matrix.from_blocks_smul, matrix.mul_eq_mul, matrix.from_blocks_multiply]
simp [h]
intros
rw le_inf_iff
{ rw le_inf_iff, split; apply mono_lie_right; [exact inf_le_left, exact inf_le_right], }
split
split; apply mono_lie_right; [exact inf_le_left, exact inf_le_right]
split; apply mono_lie_right
apply mono_lie_right
exact inf_le_left
apply mono_lie_right
exact inf_le_right
intros
rw [derived_series_eq_derived_series_of_ideal_comap, map_comap_incl, inf_eq_right]
{ rw [derived_series_eq_derived_series_of_ideal_comap, map_comap_incl, inf_eq_right], apply derived_series_of_ideal_le_self, }
apply derived_series_of_ideal_le_self
intros
rw ‚Üê coe_to_submodule_eq_iff
{ rw ‚Üê coe_to_submodule_eq_iff, exact (K : submodule R L).range_subtype, }
exact (K : submodule R L).range_subtype
intros
apply subsingleton_of_bot_eq_top
ext ‚ü®x, hx‚ü©
change x ‚àà ‚ä• at hx
rw submodule.mem_bot at hx
subst hx
simp only [true_iff, eq_self_iff_true, submodule.mk_eq_zero, lie_submodule.mem_bot]
intros
rw [char_poly, polynomial.is_root.def, polynomial.eval]
simp only [polynomial.eval‚ÇÇ_finset_sum, one_mul, ring_hom.id_apply, polynomial.eval‚ÇÇ_monomial, polynomial.eval‚ÇÇ_sub]
split
intro h
{ intro h, simpa [sub_eq_zero] using h 0 }
simpa [sub_eq_zero] using h 0
intros h n
{ intros h n, simp only [pow_add, sub_eq_zero.mp h, mul_sum], exact sum_congr rfl (Œª _ _, by ring) }
simp only [pow_add, sub_eq_zero.mp h, mul_sum]
exact sum_congr rfl (Œª _ _, by ring)
intros
rw [bit0, add_smul, one_smul]
intros
rw [of, monoid_hom.coe_mk, ‚Üê finsupp.supported_eq_span_single, finsupp.mem_supported]
intros
rw [lt_iff_le_and_ne, ne, eq_comm]; simp [abv_eq_zero abv, abv_nonneg abv]
rw [lt_iff_le_and_ne, ne, eq_comm]
simp [abv_eq_zero abv, abv_nonneg abv]
intros
rw [mul_comm, inv_mul_le_iff' h]
intros
rw [lt_div_iff d0, div_mul_eq_mul_div, div_lt_iff b0]
intros
rw [div_lt_iff (@zero_lt_two Œ± _ _)]
{ rw [div_lt_iff (@zero_lt_two Œ± _ _)], exact lt_mul_of_one_lt_right h one_lt_two }
exact lt_mul_of_one_lt_right h one_lt_two
intros
cases le_total 0 a with h h
calc -abs a = - a : congr_arg (has_neg.neg) (abs_of_nonneg h) ... ‚â§ 0 : neg_nonpos.mpr h ... ‚â§ a : h
{ calc -abs a = - a : congr_arg (has_neg.neg) (abs_of_nonneg h) ... ‚â§ 0 : neg_nonpos.mpr h ... ‚â§ a : h }
calc -abs a = - - a : congr_arg (has_neg.neg) (abs_of_nonpos h) ... ‚â§ a : (neg_neg a).le
{ calc -abs a = - - a : congr_arg (has_neg.neg) (abs_of_nonpos h) ... ‚â§ a : (neg_neg a).le }
intros
rw [‚Üê mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
simp [neg_le_iff_add_nonneg, ‚Üê two_mul, mul_nonneg_iff, zero_le_one, (@zero_lt_two Œ± _ _).not_le]
intros
cases a; simp [mul_def, h]; refl
cases a; simp [mul_def, h]
cases a
simp [mul_def, h]
refl
simp [mul_def, h]
refl
intros
haveI := @linear_order.decidable_le Œ± _; exact lt_of_not_ge (assume h2 : b ‚â• 0, (decidable.mul_nonneg h1 h2).not_lt h)
haveI := @linear_order.decidable_le Œ± _
exact lt_of_not_ge (assume h2 : b ‚â• 0, (decidable.mul_nonneg h1 h2).not_lt h)
intros
simpa only [sub_eq_neg_add] using h.nsmul n (-x)
intros
simp * at *
intros
rw [‚Üê image_smul, image_empty]
intros
simpa using nat_degree_multiset_prod_of_monic (s.1.map f) (by simpa using h)
intros
have : discrim a b c = 0 * 0
rw [h, mul_zero]
rw [h, mul_zero]
rw [quadratic_eq_zero_iff ha this, add_zero, sub_zero, or_self]
intros
{ ext, simp [h], }
ext
simp [h]
intros
apply set.subset.antisymm
rintro x hx t' ‚ü®ht', ht‚ü©
{ rintro x hx t' ‚ü®ht', ht‚ü©, obtain ‚ü®fs, rfl‚ü© : ‚àÉ s, t' = zero_locus s, by rwa [is_closed_iff_zero_locus] at ht', rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht, exact set.subset.trans ht hx }
obtain ‚ü®fs, rfl‚ü© : ‚àÉ s, t' = zero_locus s
rwa [is_closed_iff_zero_locus] at ht'
rwa [is_closed_iff_zero_locus] at ht'
rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht
exact set.subset.trans ht hx
rw (is_closed_zero_locus _).closure_subset_iff
{ rw (is_closed_zero_locus _).closure_subset_iff, exact subset_zero_locus_vanishing_ideal t }
exact subset_zero_locus_vanishing_ideal t
intros
dsimp [Œ¥, œÉ]
{ dsimp [Œ¥, œÉ], simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.œÉ_comp_œÉ H] }
simp only [‚ÜêX.map_comp, ‚Üêop_comp, simplex_category.œÉ_comp_œÉ H]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
ext j
refine p.congr (by simp) (Œª i hi1 hi2, _)
dsimp
congr' 1
convert composition.single_embedding hn ‚ü®i, hi2‚ü©
cases j
have : j_val = 0 := le_bot_iff.1 (nat.lt_succ_iff.1 j_property)
unfold_coes
congr
congr; try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
assumption
simp
intros
convert h.is_o.right_is_O_add
ext
simp
intros
simpa [is_O, is_O_with] using is_O_snd_prod
intros
refine (is_o_iff_tendsto' _).mpr (tendsto_pow_div_pow_at_top_zero hpq)
exact (eventually_gt_at_top 0).mono (Œª x hx hxq, (pow_ne_zero q hx.ne' hxq).elim)
intros
convert (has_deriv_within_at_const x s c).mul hd
rw [zero_mul, zero_add]
intros
simp [has_strict_deriv_at, has_strict_fderiv_at]
intros
simpa [continuous_linear_map.sum_apply] using (has_strict_fderiv_at.sum h).has_strict_deriv_at
intros
refine hf.iterate _ hx n
convert hf.continuous_at
exact hx.symm
intros
simp only [sub_eq_add_neg, differentiable_on_add_const_iff]
intros
rw [‚Üê differentiable_on_univ, ‚Üê differentiable_on_univ]
exact iso.comp_differentiable_on_iff
intros
simp only [differentiable_within_at, has_fderiv_within_at_univ, differentiable_at]
intros
simp [B, is_open_Union, is_open.inter, is_open_A]
intros
simpa only [restrict_apply, add_sub_cancel'_right] using (f'.lipschitz.restrict s).add hf.lipschitz_sub
intros
ext x
{ ext x, rw [iterated_deriv_within, iterated_deriv, iterated_fderiv_within_univ] }
rw [iterated_deriv_within, iterated_deriv, iterated_fderiv_within_univ]
intros
simp [‚Üê times_cont_diff_on_univ, times_cont_diff_on, times_cont_diff_at]
intros
simp only [‚Üê times_cont_diff_on_univ, times_cont_diff_on_pi]
intros
simp only [times_cont_diff_iff_times_cont_diff_at] at *
exact Œª x, (hf x).div (hg x) (h0 x)
intros
induction n with n IH generalizing x
{ ext m, simp }
ext m
simp
have A : fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f (s ‚à© u) y) (s ‚à© u) x = fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) (s ‚à© u) x := fderiv_within_congr (hs x hx) (Œª y hy, IH hy) (IH hx)
{ have A : fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f (s ‚à© u) y) (s ‚à© u) x = fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) (s ‚à© u) x := fderiv_within_congr (hs x hx) (Œª y hy, IH hy) (IH hx), have B : fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) (s ‚à© u) x = fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) s x := fderiv_within_inter (is_open.mem_nhds hu hx.2) ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx)), ext m, rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B] }
have B : fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) (s ‚à© u) x = fderiv_within ùïú (Œª y, iterated_fderiv_within ùïú n f s y) s x := fderiv_within_inter (is_open.mem_nhds hu hx.2) ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx))
ext m
rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B]
intros
apply linear_isometry.re_apply_eq_re_of_add_conj_eq
intro z
apply linear_isometry.im_apply_eq_im h
intros
intros x y hx hy a b ha hb hab
rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
exact hs hx hy ha hb hab
intros
simp only [metric.bounded_iff_ediam_ne_top, convex_hull_ediam]
intros
simp_rw [sum_inner, inner_sum, real_inner_smul_left, real_inner_smul_right, real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two, ‚Üêdiv_sub_div_same, ‚Üêdiv_add_div_same, mul_sub_left_distrib, left_distrib, finset.sum_sub_distrib, finset.sum_add_distrib, ‚Üêfinset.mul_sum, ‚Üêfinset.sum_mul, h‚ÇÅ, h‚ÇÇ, zero_mul, mul_zero, finset.sum_const_zero, zero_add, zero_sub, finset.mul_sum, neg_div, finset.sum_div, mul_div_assoc, mul_assoc]
intros
simp
intros
{ have h := @norm_add_sq ‚Ñù F _ _, simpa using h }
have h := @norm_add_sq ‚Ñù F _ _
simpa using h
intros
rw [to_euclidean.image_symm_eq_preimage, closed_ball_eq_preimage]
intros
ext1
simp [explicit_cokernel_desc, explicit_cokernel_œÄ, explicit_cokernel_iso]
intros
{ ext, refl }
ext
refl
intros
simpa only [nnreal.coe_nat_cast, nnreal.coe_add] using congr_arg (coe : _ ‚Üí ‚Ñù) (to_nat_add_to_nat_neg_eq_nnnorm n)
intros
{ erw add_monoid_hom.map_range, refl }
erw add_monoid_hom.map_range
refl
intros
have : 0 ‚â§ ‚à•mk' S m‚à• := norm_mk_nonneg S m
rw [‚Üê this.le_iff_eq, quotient_norm_mk_eq, real.Inf_le_iff]
simp_rw [zero_add]
calc (‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ r ‚àà (Œª x, ‚à•m + x‚à•) '' (S : set M), r < Œµ) ‚Üî (‚àÄ Œµ > 0, (‚àÉ x ‚àà S, ‚à•m + x‚à• < Œµ)) : by simp [set.bex_image_iff] ... ‚Üî ‚àÄ Œµ > 0, (‚àÉ x ‚àà S, ‚à•m + -x‚à• < Œµ) : _ ... ‚Üî ‚àÄ Œµ > 0, (‚àÉ x ‚àà S, x ‚àà metric.ball m Œµ) : by simp [dist_eq_norm, ‚Üê sub_eq_add_neg, norm_sub_rev] ... ‚Üî m ‚àà closure ‚ÜëS : by simp [metric.mem_closure_iff, dist_comm]
{ calc (‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ r ‚àà (Œª x, ‚à•m + x‚à•) '' (S : set M), r < Œµ) ‚Üî (‚àÄ Œµ > 0, (‚àÉ x ‚àà S, ‚à•m + x‚à• < Œµ)) : by simp [set.bex_image_iff] ... ‚Üî ‚àÄ Œµ > 0, (‚àÉ x ‚àà S, ‚à•m + -x‚à• < Œµ) : _ ... ‚Üî ‚àÄ Œµ > 0, (‚àÉ x ‚àà S, x ‚àà metric.ball m Œµ) : by simp [dist_eq_norm, ‚Üê sub_eq_add_neg, norm_sub_rev] ... ‚Üî m ‚àà closure ‚ÜëS : by simp [metric.mem_closure_iff, dist_comm], apply forall_congr, intro Œµ, apply forall_congr, intro Œµ_pos, rw [‚Üê S.exists_neg_mem_iff_exists_mem], simp }
apply forall_congr
intro Œµ
apply forall_congr
intro Œµ_pos
rw [‚Üê S.exists_neg_mem_iff_exists_mem]
simp
use 0
{ use 0, rintro _ ‚ü®x, x_in, rfl‚ü©, apply norm_nonneg }
rintro _ ‚ü®x, x_in, rfl‚ü©
apply norm_nonneg
rw set.nonempty_image_iff
use [0, S.zero_mem]
intros
simp [to_span_singleton, of_homothety, linear_map.to_span_singleton]
intros
{ refine symm (e.tsum_eq_iff.mpr _), rw e.symm_apply_apply _ }
refine symm (e.tsum_eq_iff.mpr _)
rw e.symm_apply_apply _
intros
refine continuous.le_induced _
apply continuous_pi_iff.mpr
intros z
exact (inclusion_in_double_dual ùïú E z).continuous
intros
rw [‚Üêneg_sub, p.neg]
simp [log]
intros
{ rw ‚Üê log_one, exact log_lt_log_iff h zero_lt_one }
rw ‚Üê log_one
exact log_lt_log_iff h zero_lt_one
intros
simp only [one_div, integral_inv_of_pos ha hb]
intros
rw filter.tendsto_at_top_at_top
intros b
obtain ‚ü®c, hc‚ü© := tendsto_at_top_at_top.mp (tendsto_rpow_at_top hy) b
use c.to_nnreal
intros a ha
exact_mod_cast hc a (real.to_nnreal_le_iff_le_coe.mp ha)
intros
rw [rpow_def_of_nonneg (le_of_lt hx), if_neg (ne_of_gt hx)]
intros
rw [‚Üê abs_sin_eq_sqrt_one_sub_cos_sq, abs_of_nonneg (sin_nonneg_of_nonneg_of_le_pi hl hu)]
rw [‚Üê of_real_sin, real.sin_pi]; simp
rw [‚Üê of_real_sin, real.sin_pi]
simp
intros
rw [tan_add h, tan_mul_I, mul_assoc]
intros
refine (is_o.of_norm_left _).of_norm_right
exact (is_o_pow_pow_of_lt_left (abs_nonneg r‚ÇÅ) h).congr (pow_abs r‚ÇÅ) (pow_abs r‚ÇÇ)
intros
rcases sign_cases_of_C_mul_pow_nonneg (Œª n, dist_nonneg.trans (hu n)) with rfl | ‚ü®C‚ÇÄ, r‚ÇÄ‚ü©
{ simp [has_sum_zero] }
simp [has_sum_zero]
refine has_sum.mul_left C _
{ refine has_sum.mul_left C _, simpa using has_sum_geometric_of_lt_1 r‚ÇÄ hr }
simpa using has_sum_geometric_of_lt_1 r‚ÇÄ hr
intros
ext
ext; refl
refl
intros
rw w
intros
rw [‚Üê trans_assoc, self_symm_id, refl_trans]
intros
cases Œ±; refl
cases Œ±
refl
intros
obviously
intros
apply is_colimit.fac
intros
rw ‚Üêcone_of_hom_of_cone h s
conv_lhs { simp only [hom_of_cone_of_hom] }
apply (cone_of_hom_fac _ _).symm
intros
rw [iso.inv_comp_eq, ‚Üê category.assoc, iso.eq_comp_inv, prod.left_unitor_hom_naturality]
intros
rw biproduct.map_eq_map'
convert limits.is_colimit.Œπ_map _ _ _ _
convert limits.is_colimit.Œπ_map _ _ _ _; refl
refl
refl
refl
refl
refl
refl
refl
refl
refl
refl
intros
{ ext, simp [image.eq_to_iso, image.eq_to_hom], }
ext
simp [image.eq_to_iso, image.eq_to_hom]
intros
{ ext, simp [kernel_zero_iso_source], }
ext
simp [kernel_zero_iso_source]
intros
haveI := t.split_epi_to f; apply_instance
haveI := t.split_epi_to f
apply_instance
intros
rw [t.app_one, t.app_one]
intros
simp only [right_unitor_tensor_inv, category.comp_id, iso.inv_hom_id, category.assoc]
intros
induction g with Y' Z' g e ih
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
{ rw ‚Üê(nat_iso.naturality_1 (lift.is_lift r F H)), dsimp, simp, }
rw ‚Üê(nat_iso.naturality_1 (lift.is_lift r F H))
dsimp
simp
intros
split
intro h
{ intro h, apply J‚ÇÅ.transitive (J‚ÇÅ.top_mem X), intros Y f hf, change J‚ÇÅ.close S f, rwa h }
apply J‚ÇÅ.transitive (J‚ÇÅ.top_mem X)
intros Y f hf
change J‚ÇÅ.close S f
rwa h
intro hS
{ intro hS, rw eq_top_iff, intros Y f hf, apply J‚ÇÅ.pullback_stable _ hS }
rw eq_top_iff
intros Y f hf
apply J‚ÇÅ.pullback_stable _ hS
intros
split
intros t Y‚ÇÅ Y‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ
{ intros t Y‚ÇÅ Y‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ, apply t, apply pullback.condition }
apply t
apply pullback.condition
intros t Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm
{ intros t Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm, rw [‚Üêpullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf‚ÇÅ hf‚ÇÇ, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, pullback.lift_snd] }
rw [‚Üêpullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf‚ÇÅ hf‚ÇÇ, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, pullback.lift_snd]
intros
refine (not_congr eq_ones_iff).trans _
have : ‚àÄ j ‚àà c.blocks, j = 1 ‚Üî j ‚â§ 1 := Œª j hj, by simp [le_antisymm_iff, c.one_le_blocks hj]
simp [this] {contextual := tt}
intros
simp [remove_none.fiber, derangements]
intros
haveI := classical.dec_eq Œπ
specialize ha (s'.image coe)
rw [nonempty.image_iff, finset.card_image_of_injective s' subtype.coe_injective] at ha
by_cases he : s'.nonempty
have ha' : s'.card < (s'.bUnion (Œª x, t x)).card
{ have ha' : s'.card < (s'.bUnion (Œª x, t x)).card, { specialize ha he (Œª h, by { have h' := mem_univ x, rw ‚Üêh at h', simpa using h' }), convert ha using 2, ext x, simp only [mem_image, mem_bUnion, exists_prop, set_coe.exists, exists_and_distrib_right, exists_eq_right, subtype.coe_mk], }, rw ‚Üêerase_bUnion, by_cases hb : a ‚àà s'.bUnion (Œª x, t x), { rw card_erase_of_mem hb, exact nat.le_pred_of_lt ha' }, { rw erase_eq_of_not_mem hb, exact nat.le_of_lt ha' }, }
specialize ha he (Œª h, by { have h' := mem_univ x, rw ‚Üêh at h', simpa using h' })
{ specialize ha he (Œª h, by { have h' := mem_univ x, rw ‚Üêh at h', simpa using h' }), convert ha using 2, ext x, simp only [mem_image, mem_bUnion, exists_prop, set_coe.exists, exists_and_distrib_right, exists_eq_right, subtype.coe_mk], }
convert ha using 2
ext x
simp only [mem_image, mem_bUnion, exists_prop, set_coe.exists, exists_and_distrib_right, exists_eq_right, subtype.coe_mk]
rw ‚Üêerase_bUnion
by_cases hb : a ‚àà s'.bUnion (Œª x, t x)
rw card_erase_of_mem hb
{ rw card_erase_of_mem hb, exact nat.le_pred_of_lt ha' }
exact nat.le_pred_of_lt ha'
rw erase_eq_of_not_mem hb
{ rw erase_eq_of_not_mem hb, exact nat.le_of_lt ha' }
exact nat.le_of_lt ha'
rw [nonempty_iff_ne_empty, not_not] at he
{ rw [nonempty_iff_ne_empty, not_not] at he, subst s', simp }
subst s'
simp
intros
simp [hd v]
intros
obtain ‚ü®t, ht‚ü© := max_of_nonempty (univ_nonempty.image (Œª v, G.degree v))
have ht‚ÇÇ := mem_of_max ht
simp only [mem_image, mem_univ, exists_prop_of_true] at ht‚ÇÇ
rcases ht‚ÇÇ with ‚ü®v, rfl‚ü©
rw option.mem_def at ht
refine ‚ü®v, _‚ü©
rw [max_degree, ht]
refl
intros
obtain ‚ü®_, a, b, c, hx, hlen, hnil, rfl, hb, hc‚ü© := M.eval_from_split hlen rfl
use [a, b, c, hx, hlen, hnil]
intros y hy
rw language.mem_mul at hy
rcases hy with ‚ü® ab, c', hab, hc', rfl ‚ü©
rw language.mem_mul at hab
rcases hab with ‚ü® a', b', ha', hb', rfl ‚ü©
rw set.mem_singleton_iff at ha' hc'
substs ha' hc'
have h := M.eval_from_of_pow hb hb'
rwa [mem_accepts, eval_from_of_append, eval_from_of_append, h, hc]
intros
simp [of, quotient.eq']
intros
rcases v with _|‚ü®_|n, v‚ü©
{ refine ‚ü®none, trans_gen.single _‚ü©, simp, refl }
refine ‚ü®none, trans_gen.single _‚ü©
simp
refl
{ refine ‚ü®some Œì'.cons, trans_gen.single _‚ü©, simp, refl }
refine ‚ü®some Œì'.cons, trans_gen.single _‚ü©
simp
refl
refine ‚ü®none, _‚ü©
simp [tr_nat, num.add_one, num.succ, tr_num]
cases (n:num) with a
simp [tr_pos_num, tr_num, show num.zero.succ' = pos_num.one, from rfl]
{ simp [tr_pos_num, tr_num, show num.zero.succ' = pos_num.one, from rfl], refine trans_gen.head rfl _, convert unrev_ok, simp, refl }
refine trans_gen.head rfl _
convert unrev_ok
simp
refl
simp [tr_num, num.succ']
suffices : ‚àÄ l‚ÇÅ, ‚àÉ l‚ÇÅ' l‚ÇÇ' s', list.reverse_core l‚ÇÅ (tr_pos_num a) = list.reverse_core l‚ÇÅ' l‚ÇÇ' ‚àß reaches‚ÇÅ (TM2.step tr) ‚ü®some (q‚ÇÅ.pred q‚ÇÇ), s, K'.elim (tr_pos_num a.succ ++ Œì'.cons :: tr_list v) l‚ÇÅ c d‚ü© ‚ü®some (unrev q‚ÇÇ), s', K'.elim (l‚ÇÇ' ++ Œì'.cons :: tr_list v) l‚ÇÅ' c d‚ü©
obtain ‚ü®l‚ÇÅ', l‚ÇÇ', s', e, h‚ü© := this []
{ obtain ‚ü®l‚ÇÅ', l‚ÇÇ', s', e, h‚ü© := this [], simp [list.reverse_core] at e, refine h.trans _, convert unrev_ok using 2, simp [e, list.reverse_core_eq] }
simp [list.reverse_core] at e
refine h.trans _
convert unrev_ok using 2
simp [e, list.reverse_core_eq]
induction a with m IH m IH generalizing s
induction a with m IH m IH generalizing s; intro l‚ÇÅ
intro l‚ÇÅ
refine ‚ü®Œì'.bit1 :: l‚ÇÅ, [], some Œì'.cons, rfl, trans_gen.head rfl (trans_gen.single _)‚ü©
{ refine ‚ü®Œì'.bit1 :: l‚ÇÅ, [], some Œì'.cons, rfl, trans_gen.head rfl (trans_gen.single _)‚ü©, simp [tr_pos_num, show pos_num.one.succ = pos_num.one.bit0, from rfl], refl }
simp [tr_pos_num, show pos_num.one.succ = pos_num.one.bit0, from rfl]
refl
intro l‚ÇÅ
obtain ‚ü®l‚ÇÅ', l‚ÇÇ', s', e, h‚ü© := IH (some Œì'.bit0) (Œì'.bit1 :: l‚ÇÅ)
{ obtain ‚ü®l‚ÇÅ', l‚ÇÇ', s', e, h‚ü© := IH (some Œì'.bit0) (Œì'.bit1 :: l‚ÇÅ), refine ‚ü®l‚ÇÅ', l‚ÇÇ', s', e, trans_gen.head _ h‚ü©, simp, refl }
refine ‚ü®l‚ÇÅ', l‚ÇÇ', s', e, trans_gen.head _ h‚ü©
simp
refl
intro l‚ÇÅ
obtain ‚ü®a, l, e, h‚ü© : ‚àÉ a l, tr_pos_num m = a :: l ‚àß nat_end a = ff
{ obtain ‚ü®a, l, e, h‚ü© : ‚àÉ a l, tr_pos_num m = a :: l ‚àß nat_end a = ff, { cases m; refine ‚ü®_, _, rfl, rfl‚ü© }, refine ‚ü®Œì'.bit0 :: l‚ÇÅ, _, some a, rfl, trans_gen.single _‚ü©, simp [tr_pos_num, pos_num.succ, e, h, nat_end, show some Œì'.bit1 ‚â† some Œì'.bit0, from dec_trivial] }
cases m; refine ‚ü®_, _, rfl, rfl‚ü©
{ cases m; refine ‚ü®_, _, rfl, rfl‚ü© }
cases m
refine ‚ü®_, _, rfl, rfl‚ü©
refine ‚ü®_, _, rfl, rfl‚ü©
refine ‚ü®_, _, rfl, rfl‚ü©
refine ‚ü®Œì'.bit0 :: l‚ÇÅ, _, some a, rfl, trans_gen.single _‚ü©
simp [tr_pos_num, pos_num.succ, e, h, nat_end, show some Œì'.bit1 ‚â† some Œì'.bit0, from dec_trivial]
intros
simp [snd,bimap_bimap]
intros
simp [equiv.traverse, traverse_eq_map_id] with functor_norm
simp [equiv.traverse, traverse_eq_map_id] with functor_norm; refl
refl
intros
induction i; simp [*, d_array.iterate_aux]
induction i
simp [*, d_array.iterate_aux]
simp [*, d_array.iterate_aux]
intros
cases b
rw [to_list, to_array, list.to_buffer, append_list_mk_buffer]
congr
{ simpa }
simpa
{ apply array.to_list_to_array }
apply array.to_list_to_array
introI
have : eof buffer.nil 0 = done 0 () := by simp [eof_eq_done]
exact absurd (bounded.of_done this) (lt_irrefl _)
intros
obtain ‚ü®np, a, hp‚ü© := p.exists_done_in_bounds hn
simpa [hp] using h
introI h
have : remaining buffer.nil 0 = done 0 0 := by simp [remaining_eq_done]
replace this : 0 < 0 := prog.of_done this
exact (lt_irrefl _) this
intros
simp [mmap']
intros
simp [foldr_core, and.comm, and.assoc, pure_eq_done]
intros
simp only [add_conj, of_real_mul, of_real_one, of_real_bit0, mul_div_cancel_left (z.re:‚ÑÇ) two_ne_zero']
intros
rw ‚Üê of_real_inj; simp [sinh_add_cosh]
rw ‚Üê of_real_inj
simp [sinh_add_cosh]
intros
simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]
intros
rw [‚Üê cosh_mul_I, add_mul, cosh_add, cosh_mul_I, cosh_mul_I, sinh_mul_I, sinh_mul_I, mul_mul_mul_comm, I_mul_I, mul_neg_one, sub_eq_add_neg]
intros
have h1 : x + 2 * x = 3 * x
ring
ring
rw [‚Üê h1, sin_add x (2 * x)]
simp only [cos_two_mul, sin_two_mul, cos_sq']
have h2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2
ring
ring
rw [h2, cos_sq']
ring
intros
{ simp_rw ext_iff, cc }
simp_rw ext_iff
cc
intros
{ rw [norm_sq_eq_def'], simp [sq] }
rw [norm_sq_eq_def']
simp [sq]
intros
simp
intros
rw [‚Üêsingle_zero i, single_eq_single_iff]
simp
intros
simp [set.subset_def]; exact forall_congr (assume i, not_imp_comm)
simp [set.subset_def]
exact forall_congr (assume i, not_imp_comm)
intros
apply equiv.forall‚ÇÇ_congr
intros
apply equiv.forall_congr
intros
apply h
funext; simp
funext
simp
intros
rw equiv.perm.via_fintype_embedding
convert equiv.perm.extend_domain_apply_image e _ _
intros
simp [map]
intros
rw pred_above_last
intros
{ ext j, simp [init] }
ext j
simp [init]
intros
split
assume H i hi
{ assume H i hi, apply H, exact nat.lt_succ_self _ }
apply H
exact nat.lt_succ_self _
assume H
{ assume H, have A : ‚àÄ i j (h : i < j) (h' : j < n), f ‚ü®i, lt_trans h h'‚ü© < f ‚ü®j, h'‚ü©, { assume i j h h', induction h with k h IH, { exact H _ _ }, { exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _) } }, assume i j hij, convert A (i : ‚Ñï) (j : ‚Ñï) hij j.2; ext; simp only [subtype.coe_eta] }
have A : ‚àÄ i j (h : i < j) (h' : j < n), f ‚ü®i, lt_trans h h'‚ü© < f ‚ü®j, h'‚ü©
assume i j h h'
{ assume i j h h', induction h with k h IH, { exact H _ _ }, { exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _) } }
induction h with k h IH
{ exact H _ _ }
exact H _ _
{ exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _) }
exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _)
assume i j hij
convert A (i : ‚Ñï) (j : ‚Ñï) hij j.2; ext; simp only [subtype.coe_eta]
convert A (i : ‚Ñï) (j : ‚Ñï) hij j.2; ext
convert A (i : ‚Ñï) (j : ‚Ñï) hij j.2
ext
simp only [subtype.coe_eta]
ext
simp only [subtype.coe_eta]
intros
rw [‚Üê coe_inj, coe_insert, coe_sdiff, coe_sdiff, coe_insert]
exact set.insert_diff_of_not_mem s h
intros
{ rw card_le_one, tauto }
rw card_le_one
tauto
intros
{ ext, simp }
ext
simp
intros
rw ‚Üêwith_bot.coe_eq_coe
{ rw ‚Üêwith_bot.coe_eq_coe, simp only [coe_sup', sup_insert, with_bot.coe_sup], }
simp only [coe_sup', sup_insert, with_bot.coe_sup]
intros
refine le_antisymm (min'_le _ _ (mem_image.mpr ‚ü®_, min'_mem _ _, rfl‚ü©)) (le_min' _ _ _ (Œª y hy, _))
obtain ‚ü®x, hx, rfl‚ü© := mem_image.mp hy
exact hf (min'_le _ _ hx)
intros
simp [noncomm_prod, multiset.singleton_eq_cons]
intros
ext a
by_cases a ‚àà set.range f
rcases h with ‚ü®a, rfl‚ü©
{ rcases h with ‚ü®a, rfl‚ü©, rw [map_domain_apply f.injective, emb_domain_apply] }
rw [map_domain_apply f.injective, emb_domain_apply]
rw [map_domain_notin_range, emb_domain_notin_range]; assumption
rw [map_domain_notin_range, emb_domain_notin_range]
{ rw [map_domain_notin_range, emb_domain_notin_range]; assumption }
assumption
assumption
assumption
assumption
intros
change map_domain f (map_range _ _ _) = map_range _ _ _
apply finsupp.induction v
simp only [map_domain_zero, map_range_zero]
{ simp only [map_domain_zero, map_range_zero] }
intros a b v' hv‚ÇÅ hv‚ÇÇ IH
rw [map_range_add, map_domain_add, IH, map_domain_add, map_range_add, map_range_single, map_domain_single, map_domain_single, map_range_single]
rw [map_range_add, map_domain_add, IH, map_domain_add, map_range_add, map_range_single, map_domain_single, map_domain_single, map_range_single]; apply smul_add
apply smul_add
apply smul_add
apply smul_add
apply smul_add
intros
simp only [card_eq_one, support_eq_singleton]
intros
haveI : nontrivial Œ± := one_lt_card_iff_nontrivial.1 h
{ haveI : nontrivial Œ± := one_lt_card_iff_nontrivial.1 h, exact exists_pair_ne Œ± }
exact exists_pair_ne Œ±
intros
have nd := v.nodup (mk_idx n (hash_fn a))
rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ‚ü®u, w, b', hl, hfl‚ü©
simp [hl, list.nodup_append] at nd
refine (v.modify hash_fn u [‚ü®a, b'‚ü©] [‚ü®a, b‚ü©] w hl hfl (list.nodup_singleton _) (Œªa' e, by simp at e; rw e) (Œªa' e1 e2, _) (Œªa' e1 e2, _)).2
refine (v.modify hash_fn u [‚ü®a, b'‚ü©] [‚ü®a, b‚ü©] w hl hfl (list.nodup_singleton _) (Œªa' e, by simp at e; rw e) (Œªa' e1 e2, _) (Œªa' e1 e2, _)).2; { revert e1, simp [-sigma.exists] at e2, subst a', simp [nd] }
{ revert e1, simp [-sigma.exists] at e2, subst a', simp [nd] }
revert e1
{ revert e1, simp [-sigma.exists] at e2, subst a', simp [nd] }
simp [-sigma.exists] at e2
subst a'
simp [nd]
intros
rw [‚Üêunits.coe_mul, units_mul_self, units.coe_one]
intros
have := mul_mod_left 1 a; rwa one_mul at this
have := mul_mod_left 1 a
rwa one_mul at this
intros
rw [‚Üê H2, int.mul_div_cancel' H1]
intros
rw [gcd_comm, gcd_eq_left H]
intros
rcases least_of_bdd b Hb Hinh with ‚ü®n, hn, h2n‚ü©
rcases least_of_bdd b' Hb' Hinh with ‚ü®n', hn', h2n'‚ü©
exact le_antisymm (h2n _ hn') (h2n' _ hn)
intros
convert not_even_bit1 n; exact two_mul n
convert not_even_bit1 n
exact two_mul n
intros
rw [sqrt, ‚Üê nat_abs_mul_self, to_nat_coe_nat, nat.sqrt_eq]
intros
cases l‚ÇÇ
simp only [bag_inter_nil]
{simp only [bag_inter_nil]}
simp only [erase_of_not_mem h, list.bag_inter, if_neg h]
intros
refine ‚ü®_, map_congr‚ü©
intros h x hx
rw [mem_iff_nth_le] at hx
rcases hx with ‚ü®n, hn, rfl‚ü©
rw [nth_le_map_rev f, nth_le_map_rev g]
congr
exact h
intros
induction l with hd tl hl generalizing n
{ simp }
simp
cases n
{ cases n, { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
induction l generalizing a
{ simp }
simp
simp [l_ih, h]
{ simp [l_ih, h] }
intros
induction l with y l IH
{ simp }
simp
specialize IH (Œª x hx, h x (mem_cons_of_mem _ hx))
{ specialize IH (Œª x hx, h x (mem_cons_of_mem _ hx)), have hy : y ‚â§ n := h y (mem_cons_self _ _), simpa [pow_succ] using mul_le_mul' hy IH }
have hy : y ‚â§ n := h y (mem_cons_self _ _)
simpa [pow_succ] using mul_le_mul' hy IH
intros
rw [attach, map_pmap]; exact (pmap_eq_map _ _ _ _).trans (map_id l)
rw [attach, map_pmap]
exact (pmap_eq_map _ _ _ _).trans (map_id l)
intros
induction l with hd tl hl
{ simp only [reduce_option_nil, length] }
simp only [reduce_option_nil, length]
cases hd
{ cases hd, { exact nat.le_succ_of_le hl }, { simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl} }
{ exact nat.le_succ_of_le hl }
exact nat.le_succ_of_le hl
simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl
{ simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl}
intros
rw [count, countp_eq_length_filter, filter_eq_self.2, length_repeat]
rw [count, countp_eq_length_filter, filter_eq_self.2, length_repeat]; exact Œª b m, (eq_of_mem_repeat m).symm
exact Œª b m, (eq_of_mem_repeat m).symm
intros
obtain ‚ü®xs, rfl‚ü© := h
rw filter_append
exact suffix_append _ _
intros
rw [permutations, permutations_aux_nil]
intros
simp [erase_eq_erasep]; exact sublist.erasep h
simp [erase_eq_erasep]
exact sublist.erasep h
intros
cases l; [trivial, exact p.imp H]
cases l
trivial
exact p.imp H
intros
convert (prev_reverse_eq_next l.reverse (nodup_reverse.mpr h) x (mem_reverse.mpr hx)).symm
exact (reverse_reverse l).symm
intros
induction h with l' h z l' h hm
{ simp [ne_nil_of_mem h] }
simp [ne_nil_of_mem h]
{ simp [ne_nil_of_mem h.mem] }
simp [ne_nil_of_mem h.mem]
intros
rw [‚Üê append_consecutive (nat.le_succ n) h, succ_singleton]
rw [‚Üê append_consecutive (nat.le_succ n) h, succ_singleton]; refl
refl
intros
induction t generalizing l‚ÇÅ l‚ÇÇ h; simp [*, perm.erase]
induction t generalizing l‚ÇÅ l‚ÇÇ h
simp [*, perm.erase]
simp [*, perm.erase]
intros
rw [range_eq_range', map_add_range']; refl
rw [range_eq_range', map_add_range']
refl
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
induction L generalizing f
{ induction L generalizing f, {cases mem_singleton.1 h, exact forall‚ÇÇ.nil}, simp only [sections, bind_eq_bind, mem_bind, mem_map] at h, rcases h with ‚ü®_, _, _, _, rfl‚ü©, simp only [*, forall‚ÇÇ_cons, true_and] }
cases mem_singleton.1 h
{cases mem_singleton.1 h, exact forall‚ÇÇ.nil}
exact forall‚ÇÇ.nil
simp only [sections, bind_eq_bind, mem_bind, mem_map] at h
rcases h with ‚ü®_, _, _, _, rfl‚ü©
simp only [*, forall‚ÇÇ_cons, true_and]
induction h with a l f L al fL fs
{ induction h with a l f L al fL fs, {exact or.inl rfl}, simp only [sections, bind_eq_bind, mem_bind, mem_map], exact ‚ü®_, fs, _, al, rfl, rfl‚ü© }
exact or.inl rfl
{exact or.inl rfl}
simp only [sections, bind_eq_bind, mem_bind, mem_map]
exact ‚ü®_, fs, _, al, rfl, rfl‚ü©
intros
induction l‚ÇÅ generalizing l‚ÇÇ i
{ simp [zip_with, (<*>)] }
simp [zip_with, (<*>)]
cases l‚ÇÇ; simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none']
cases l‚ÇÇ
{ cases l‚ÇÇ; simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none'], { cases ((l‚ÇÅ_hd :: l‚ÇÅ_tl).nth i); refl }, { cases i; simp only [option.map_some', nth, option.some_bind', *] } }
simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none']
cases ((l‚ÇÅ_hd :: l‚ÇÅ_tl).nth i); refl
{ cases ((l‚ÇÅ_hd :: l‚ÇÅ_tl).nth i); refl }
cases ((l‚ÇÅ_hd :: l‚ÇÅ_tl).nth i)
refl
refl
simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none']
cases i; simp only [option.map_some', nth, option.some_bind', *]
{ cases i; simp only [option.map_some', nth, option.some_bind', *] }
cases i
simp only [option.map_some', nth, option.some_bind', *]
simp only [option.map_some', nth, option.some_bind', *]
intros
{ ext, apply dot_product_smul }
ext
apply dot_product_smul
intros
ext
{ext, refl}
refl
intros
simp [bit1_apply, h]
intros
{ unfold std_basis_matrix, ext, simp }
unfold std_basis_matrix
ext
simp
intros
ext
simp only [block_diagonal'_apply, pi.neg_apply]
split_ifs; simp
split_ifs
simp
simp
intros
ext i
simp_rw [vec_alt0]
rcases i with ‚ü®‚ü®‚ü© | i, hi‚ü©
{ refl }
refl
{ simp [vec_alt0, nat.add_succ, nat.succ_add] }
simp [vec_alt0, nat.add_succ, nat.succ_add]
intros
dsimp [to_matrix, matrix.mul_apply]
cases h : f i with fi
{ simp [h] }
simp [h]
rw finset.sum_eq_single fi; simp [h, eq_comm] {contextual := tt}
rw finset.sum_eq_single fi
{ rw finset.sum_eq_single fi; simp [h, eq_comm] {contextual := tt} }
simp [h, eq_comm] {contextual := tt}
simp [h, eq_comm] {contextual := tt}
simp [h, eq_comm] {contextual := tt}
intros
haveI : decidable_eq Œ± := classical.dec_eq Œ±
split
assume eq
{ assume eq, by_cases a = b, { subst h, simp * at * }, { have : a ‚àà b ::‚Çò bs, from eq ‚ñ∏ mem_cons_self _ _, have : a ‚àà bs, by simpa [h], rcases exists_cons_of_mem this with ‚ü®cs, hcs‚ü©, simp [h, hcs], have : a ::‚Çò as = b ::‚Çò a ::‚Çò cs, by simp [eq, hcs], have : a ::‚Çò as = a ::‚Çò b ::‚Çò cs, by rwa [cons_swap], simpa using this } }
by_cases a = b
{ subst h, simp * at * }
subst h
simp * at *
have : a ‚àà b ::‚Çò bs
{ have : a ‚àà b ::‚Çò bs, from eq ‚ñ∏ mem_cons_self _ _, have : a ‚àà bs, by simpa [h], rcases exists_cons_of_mem this with ‚ü®cs, hcs‚ü©, simp [h, hcs], have : a ::‚Çò as = b ::‚Çò a ::‚Çò cs, by simp [eq, hcs], have : a ::‚Çò as = a ::‚Çò b ::‚Çò cs, by rwa [cons_swap], simpa using this }
from eq ‚ñ∏ mem_cons_self _ _
have : a ‚àà bs
simpa [h]
simpa [h]
rcases exists_cons_of_mem this with ‚ü®cs, hcs‚ü©
simp [h, hcs]
have : a ::‚Çò as = b ::‚Çò a ::‚Çò cs
simp [eq, hcs]
simp [eq, hcs]
have : a ::‚Çò as = a ::‚Çò b ::‚Çò cs
rwa [cons_swap]
rwa [cons_swap]
simpa using this
assume h
{ assume h, rcases h with ‚ü®eq‚ÇÅ, eq‚ÇÇ‚ü© | ‚ü®h, cs, eq‚ÇÅ, eq‚ÇÇ‚ü©, { simp * }, { simp [*, cons_swap a b] } }
rcases h with ‚ü®eq‚ÇÅ, eq‚ÇÇ‚ü© | ‚ü®h, cs, eq‚ÇÅ, eq‚ÇÇ‚ü©
{ simp * }
simp *
{ simp [*, cons_swap a b] }
simp [*, cons_swap a b]
intros
rw [‚Üê rel_flip, rel_add_left]; simp [rel_flip]
rw [‚Üê rel_flip, rel_add_left]
simp [rel_flip]
intros
refine ‚ü®_, Œª h, le_trans h $ le_cons_self _ _‚ü©
suffices : ‚àÄ {t'} (_ : s ‚â§ t') (_ : a ‚àà t'), a ::‚Çò s ‚â§ t'
exact Œª h, (cons_le_cons_iff a).1 (this h (mem_cons_self _ _))
{ exact Œª h, (cons_le_cons_iff a).1 (this h (mem_cons_self _ _)) }
introv h
revert m
refine le_induction_on h _
introv s m‚ÇÅ m‚ÇÇ
rcases mem_split m‚ÇÇ with ‚ü®r‚ÇÅ, r‚ÇÇ, rfl‚ü©
exact perm_middle.subperm_left.2 ((subperm_cons _).2 $ ((sublist_or_mem_of_sublist s).resolve_right m‚ÇÅ).subperm)
intros
rw foldl_swap
exact foldr_induction' (Œª x y, f y x) (Œª x y z, (H _ _ _).symm) x q p s hpqf px q_s
intros
rw [fold_cons'_right, hc.comm]
intros
apply mv_polynomial.induction_on p; { simp { contextual := tt } }
apply mv_polynomial.induction_on p
{ apply mv_polynomial.induction_on p; { simp { contextual := tt } } }
{ simp { contextual := tt } }
{ simp { contextual := tt } }
simp { contextual := tt }
{ simp { contextual := tt } }
intros
{ rw [hom_bind‚ÇÅ, map_comp_C, ‚Üê eval‚ÇÇ_hom_map_hom], refl }
rw [hom_bind‚ÇÅ, map_comp_C, ‚Üê eval‚ÇÇ_hom_map_hom]
refl
intros
{ contrapose! h, apply coeff_rename_eq_zero _ _ _ h }
contrapose! h
apply coeff_rename_eq_zero _ _ _ h
intros
rw [succ_div, if_pos hba]
intros
simp only [add_comm, add_one_le_iff]
intros
induction hnm with m hnm ih
intros x
{ intros x, use x, rw le_rec_on_self }
use x
rw le_rec_on_self
intros x
rcases Hnext _ x with ‚ü®w, rfl‚ü©
rcases ih w with ‚ü®x, rfl‚ü©
use x
rw le_rec_on_succ
intros
rw [‚Üê cast_zero, cast_lt]
intros
apply choose_symm_of_eq_add
{ apply choose_symm_of_eq_add, rw [add_comm m 1, add_assoc 1 m m, add_comm (2 * m) 1, two_mul m] }
rw [add_comm m 1, add_assoc 1 m m, add_comm (2 * m) 1, two_mul m]
intros
simp_rw [finset.nat.sum_antidiagonal_eq_sum_range_succ (Œª m p, choose n m ‚Ä¢ (x^m * y^p)), _root_.nsmul_eq_mul, cast_comm, h.add_pow]
intros
rw ‚Üê with_top_equiv_le; simp
rw ‚Üê with_top_equiv_le
simp
intros
rcases (prod_dvd_and_dvd_of_dvd_prod $ gcd_dvd_right k (m * n)) with ‚ü®‚ü®‚ü®m', hm'‚ü©, ‚ü®n', hn'‚ü©‚ü©, h‚ü©
replace h : gcd k (m * n) = m' * n' := h
rw h
have hm'n' : m' * n' ‚à£ k := h ‚ñ∏ gcd_dvd_left _ _
apply mul_dvd_mul
have hm'k : m' ‚à£ k := (dvd_mul_right m' n').trans hm'n'
{ have hm'k : m' ‚à£ k := (dvd_mul_right m' n').trans hm'n', exact dvd_gcd hm'k hm' }
exact dvd_gcd hm'k hm'
have hn'k : n' ‚à£ k := (dvd_mul_left n' m').trans hm'n'
{ have hn'k : n' ‚à£ k := (dvd_mul_left n' m').trans hm'n', exact dvd_gcd hn'k hn' }
exact dvd_gcd hn'k hn'
intros
{ rw log, cases b; refl }
rw log
cases b
cases b; refl
refl
refl
intros
rw [even_add, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
cases n
cases n; refl
refl
refl
refl
intros
induction fuel with fuel ih generalizing k
induction fuel with fuel ih generalizing k; rw [min_fac_aux, nat.min_fac_aux]
rw [min_fac_aux, nat.min_fac_aux]
{ rw if_pos, rwa [zero_add, nat.sqrt_lt] at h }
rw if_pos
rwa [zero_add, nat.sqrt_lt] at h
rw [min_fac_aux, nat.min_fac_aux]
rw [‚Üê mul_to_nat]
simp only [cast_lt, dvd_to_nat, ite_cast]
congr' 2
rw ih
rw ih; [congr, convert nat.lt_succ_of_lt h using 1]; simp only [_root_.bit1, _root_.bit0, cast_bit1, cast_succ, nat.succ_eq_add_one, add_assoc, add_left_comm]
rw ih; [congr, convert nat.lt_succ_of_lt h using 1]
congr
simp only [_root_.bit1, _root_.bit0, cast_bit1, cast_succ, nat.succ_eq_add_one, add_assoc, add_left_comm]
convert nat.lt_succ_of_lt h using 1
simp only [_root_.bit1, _root_.bit0, cast_bit1, cast_succ, nat.succ_eq_add_one, add_assoc, add_left_comm]
intros
cases x; simp
{ cases x; simp }
cases x
simp
simp
intros
induction l with ls ll lx lr IHll IHlr generalizing o‚ÇÅ o‚ÇÇ r
{ exact ‚ü®hr, (zero_add _).symm‚ü© }
exact ‚ü®hr, (zero_add _).symm‚ü©
induction r with rs rl rx rr IHrl IHrr generalizing o‚ÇÅ o‚ÇÇ
{ exact ‚ü®hl, rfl‚ü© }
exact ‚ü®hl, rfl‚ü©
rw [merge_node]
split_ifs
cases IHrl (sep.imp $ Œª x h, h.1) (hl.of_lt hr.1.1.to_nil $ sep.imp $ Œª x h, h.2.1) hr.left with v e
{ cases IHrl (sep.imp $ Œª x h, h.1) (hl.of_lt hr.1.1.to_nil $ sep.imp $ Œª x h, h.2.1) hr.left with v e, exact valid'.merge_aux‚ÇÅ hl hr h v e }
exact valid'.merge_aux‚ÇÅ hl hr h v e
cases IHlr hl.right (hr.of_gt hl.1.2.to_nil sep.2.1) sep.2.2 with v e
{ cases IHlr hl.right (hr.of_gt hl.1.2.to_nil sep.2.1) sep.2.2 with v e, have := valid'.merge_aux‚ÇÅ hr.dual hl.dual h_1 v.dual, rw [size_dual, add_comm, size_dual, ‚Üê dual_balance_r, ‚Üê valid'.dual_iff, size_dual, add_comm rs] at this, exact this e }
have := valid'.merge_aux‚ÇÅ hr.dual hl.dual h_1 v.dual
rw [size_dual, add_comm, size_dual, ‚Üê dual_balance_r, ‚Üê valid'.dual_iff, size_dual, add_comm rs] at this
exact this e
refine valid'.glue_aux hl hr sep (or.inr ‚ü®not_lt.1 h_1, not_lt.1 h‚ü©)
{ refine valid'.glue_aux hl hr sep (or.inr ‚ü®not_lt.1 h_1, not_lt.1 h‚ü©) }
intros
rw [‚Üê size_dual, dual_rotate_r, hl.dual.rotate_l_size, size_dual, size_dual, add_comm (size l)]
intros
rw [add_comm, add_comm m]; exact H.add_left _
rw [add_comm, add_comm m]
exact H.add_left _
intros
ext
dsimp [single, pequiv.trans]
split_ifs; simp * at *
split_ifs
simp * at *
simp * at *
intros
ext i x; cases x; reflexivity
ext i x; cases x
ext i x
cases x
reflexivity
reflexivity
intros
rcases multiset.mem_map.mp h with ‚ü®‚ü®p', hp'‚ü©, ‚ü®h_mem, h_eq‚ü©‚ü©
{ rcases multiset.mem_map.mp h with ‚ü®‚ü®p', hp'‚ü©, ‚ü®h_mem, h_eq‚ü©‚ü©, exact h_eq ‚ñ∏ hp' }
exact h_eq ‚ñ∏ hp'
intros
dsimp [is_special, finish] at hs ‚ä¢
rw [add_mul _ _ u.y, add_comm _ (u.x * u.y), ‚Üê hs]
ring
intros
rw [mul_assoc, X_pow_mul, ‚Üêmul_assoc]
intros
simp [sum_def, finset.sum_add_distrib]
intros
induction n with n ih
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
rw [C_mul_X_pow_eq_monomial, leading_coeff_monomial]
intros
simpa only [sub_eq_add_neg, degree_neg q] using degree_add_le p (-q)
intros
rw trailing_degree_eq_nat_trailing_degree hp at H
exact with_top.coe_le_coe.mp H
intros
ext i
simp only [erase_lead_coeff, coeff_monomial, coeff_add, @eq_comm _ _ i]
split_ifs with h
{ subst i, simp only [leading_coeff, zero_add] }
subst i
simp only [leading_coeff, zero_add]
{ exact add_zero _ }
exact add_zero _
intros
simp only [comp, eval‚ÇÇ, ‚Üê monomial_eq_C_mul_X]
exact sum_monomial_eq _
intros
simp
intros
simp only [lifts, lifts_ring, ring_hom.mem_range, ring_hom.mem_srange]
intros
rw [nat_degree_mul', add_comm]
simpa [hp.leading_coeff, leading_coeff_ne_zero]
intros
rw [monic, leading_coeff_mul' _]; simp [leading_coeff_C b, hp]
rw [monic, leading_coeff_mul' _]
simp [leading_coeff_C b, hp]
simp [leading_coeff_C b, hp]
intros
intros a b hab
rw [‚Üê @rev_at_fun_invol N a, hab, rev_at_fun_invol]
intros
rw [nth_roots, mem_roots (X_pow_sub_C_ne_zero hn a), is_root.def, eval_sub, eval_C, eval_pow, eval_X, sub_eq_zero]
intros
rw [taylor_eval, sub_add_cancel]
intros
rw [‚Üê cofix.mk_dest x,h,cofix.mk_dest]
intros
rw ‚Üêabs_repr x
{ rw ‚Üêabs_repr x, cases repr x with a f, rw [‚Üêabs_map], reflexivity }
cases repr x with a f
rw [‚Üêabs_map]
reflexivity
intros
apply and.intro
rw [‚Üê (num_div_eq_of_coprime hb0 h1), h, num_div_eq_of_coprime hd0 h2]
{ rw [‚Üê (num_div_eq_of_coprime hb0 h1), h, num_div_eq_of_coprime hd0 h2] }
rw [‚Üê (denom_div_eq_of_coprime hb0 h1), h, denom_div_eq_of_coprime hd0 h2]
{ rw [‚Üê (denom_div_eq_of_coprime hb0 h1), h, denom_div_eq_of_coprime hd0 h2] }
rw [mk_univ, mk_real]
intros
haveI := classical.prop_decidable
by_contra nk
refine hf (Œª Œµ Œµ0, _)
simp [not_forall] at nk
cases f.cauchy‚ÇÉ (half_pos Œµ0) with i hi
rcases nk _ (half_pos Œµ0) i with ‚ü®j, ij, hj‚ü©
refine ‚ü®j, Œª k jk, _‚ü©
have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add (hi j ij k jk) hj)
rwa [sub_add_cancel, add_halves] at this
intros
{ contrapose! h, exact ennreal.div_le_of_le_mul h }
contrapose! h
exact ennreal.div_le_of_le_mul h
intros
simp [ennreal.of_real, real.to_nnreal_le_to_nnreal h]
intros
simp [ennreal.of_real]
intros
lift x to ‚Ñù
lift y to ‚Ñù
{ simpa using h }
simpa using h
{ simp [hy, ((bot_lt_iff_ne_bot.2 hx).trans_le h).ne'] }
simp [hy, ((bot_lt_iff_ne_bot.2 hx).trans_le h).ne']
{ simp [hx, (h.trans_lt (lt_top_iff_ne_top.2 hy)).ne], }
simp [hx, (h.trans_lt (lt_top_iff_ne_top.2 hy)).ne]
intros
change 0 + (-x) = - x
{ change 0 + (-x) = - x, simp }
simp
intros
unfold st
split_ifs
exact false.elim ((infinite_iff_not_exists_st.mp hi) h)
{ exact false.elim ((infinite_iff_not_exists_st.mp hi) h) }
{ refl }
refl
simp [real.to_nnreal]; refl
simp [real.to_nnreal]
rw [sign, if_neg (lt_irrefl _), if_neg (lt_irrefl _)]
intros
rw [sqrt, real.to_nnreal_inv, nnreal.sqrt_inv, nnreal.coe_inv, sqrt]
intros
apply eq_of_bisim (Œª c1 c2, ‚àÉ s, c1 = destruct (map f s) ‚àß c2 = computation.map (option.map (prod.map f (map f))) (destruct s))
intros c1 c2 h
{ intros c1 c2 h, cases h with s h, rw [h.left, h.right], apply s.cases_on _ (Œª a s, _) (Œª s, _); simp, exact ‚ü®s, rfl, rfl‚ü© }
cases h with s h
rw [h.left, h.right]
apply s.cases_on _ (Œª a s, _) (Œª s, _); simp
apply s.cases_on _ (Œª a s, _) (Œª s, _)
simp
simp
simp
exact ‚ü®s, rfl, rfl‚ü©
{ exact ‚ü®s, rfl, rfl‚ü© }
exact ‚ü®s, rfl, rfl‚ü©
intros
induction n
induction n; simp [*, drop]
simp [*, drop]
simp [*, drop]
intros
simp [set.ite]
intros
apply subset.antisymm
calc f '' (s ‚à© f ‚Åª¬π' t) ‚äÜ f '' s ‚à© (f '' (f‚Åª¬π' t)) : image_inter_subset _ _ _ ... ‚äÜ f '' s ‚à© t : inter_subset_inter_right _ (image_preimage_subset f t)
{ calc f '' (s ‚à© f ‚Åª¬π' t) ‚äÜ f '' s ‚à© (f '' (f‚Åª¬π' t)) : image_inter_subset _ _ _ ... ‚äÜ f '' s ‚à© t : inter_subset_inter_right _ (image_preimage_subset f t) }
rintros _ ‚ü®‚ü®x, h', rfl‚ü©, h‚ü©
{ rintros _ ‚ü®‚ü®x, h', rfl‚ü©, h‚ü©, exact ‚ü®x, ‚ü®h', h‚ü©, rfl‚ü© }
exact ‚ü®x, ‚ü®h', h‚ü©, rfl‚ü©
intros
simp [set.ext_iff, mem_range]
intros
simp [prod_eq]
intros
ext f
{ ext f, simp only [mem_empty_eq, not_forall, iff_false, mem_pi, not_imp], exact ‚ü®i, hs, by simp [ht]‚ü© }
simp only [mem_empty_eq, not_forall, iff_false, mem_pi, not_imp]
exact ‚ü®i, hs, by simp [ht]‚ü©
intros
rintro _ ‚ü®a, b, ha, ‚ü®h1b, h2b‚ü©, rfl‚ü©
{ rintro _ ‚ü®a, b, ha, ‚ü®h1b, h2b‚ü©, rfl‚ü©, split; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü© }
split
split; exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, rfl‚ü©
intros
{ rw union_comm, exact sup_inf_sdiff _ _ }
rw union_comm
exact sup_inf_sdiff _ _
intros
{ rw seq_def, exact hf.bUnion (Œª f _, hs.image _) }
rw seq_def
exact hf.bUnion (Œª f _, hs.image _)
intros
by_contra hinf
change s.infinite at hinf
rcases hinf.exists_subset_card_eq 3 with ‚ü®t, hts, ht‚ü©
let f := t.order_iso_of_fin ht
let x := f 0
let y := f 1
let z := f 2
have := h x (hts x.2) y (hts y.2) z (hts z.2) (f.monotone $ by dec_trivial) (f.monotone $ by dec_trivial)
have key‚ÇÅ : (0 : fin 3) ‚â† 1 := by dec_trivial
have key‚ÇÇ : (1 : fin 3) ‚â† 2 := by dec_trivial
cases this
dsimp only [x, y] at this
{ dsimp only [x, y] at this, exact key‚ÇÅ (f.injective $ subtype.coe_injective this) }
exact key‚ÇÅ (f.injective $ subtype.coe_injective this)
dsimp only [y, z] at this
{ dsimp only [y, z] at this, exact key‚ÇÇ (f.injective $ subtype.coe_injective this) }
exact key‚ÇÇ (f.injective $ subtype.coe_injective this)
intros
simp [eq_on_piecewise, *]
intros
refine ‚ü®Œª h, _, Œª h, Ioi_subset_Ici h‚ü©
by_contradiction ba
obtain ‚ü®c, bc, ca‚ü© : ‚àÉc, b < c ‚àß c < a := exists_between (not_le.mp ba)
exact lt_irrefl _ (ca.trans_le (h bc))
intros
simp [‚Üê Ici_inter_Iic]
intros
simp
intros
simp [‚Üê Ioi_inter_Iio, h, inter_comm]
intros
simpa using bInter_range
intros
simp [set.disjoint_iff, subset_def]; exact iff.rfl
simp [set.disjoint_iff, subset_def]
exact iff.rfl
intros
ext x
split
rintro ‚ü®s, ‚ü®y, rfl‚ü©, ‚ü®s, hs‚ü©, rfl‚ü©
{ rintro ‚ü®s, ‚ü®y, rfl‚ü©, ‚ü®s, hs‚ü©, rfl‚ü©, refine ‚ü®_, hs, _‚ü©, exact (f ‚ü®s, hs‚ü© y).2 }
refine ‚ü®_, hs, _‚ü©
exact (f ‚ü®s, hs‚ü© y).2
rintro ‚ü®s, hs, hx‚ü©
{ rintro ‚ü®s, hs, hx‚ü©, cases hf ‚ü®s, hs‚ü© ‚ü®x, hx‚ü© with y hy, refine ‚ü®_, ‚ü®y, rfl‚ü©, ‚ü®s, hs‚ü©, _‚ü©, exact congr_arg subtype.val hy }
cases hf ‚ü®s, hs‚ü© ‚ü®x, hx‚ü© with y hy
refine ‚ü®_, ‚ü®y, rfl‚ü©, ‚ü®s, hs‚ü©, _‚ü©
exact congr_arg subtype.val hy
intros
{ cases x‚ÇÄ, cases x‚ÇÅ, cases h‚ÇÄ, cases h‚ÇÅ, refl }
cases x‚ÇÄ
cases x‚ÇÅ
cases h‚ÇÄ
cases h‚ÇÅ
refl
intros
casesI n
rw [nat.mod_zero, int.nat_cast_eq_coe_nat]
{ rw [nat.mod_zero, int.nat_cast_eq_coe_nat], exact int.nat_abs_of_nat a, }
exact int.nat_abs_of_nat a
rw ‚Üê fin.of_nat_eq_coe
refl
intros
cases n
simp only [nat.modeq, int.coe_nat_inj', nat.mod_zero, int.nat_cast_eq_coe_nat]
{ simp only [nat.modeq, int.coe_nat_inj', nat.mod_zero, int.nat_cast_eq_coe_nat], }
rw [fin.ext_iff, nat.modeq, ‚Üê val_nat_cast, ‚Üê val_nat_cast]
{ rw [fin.ext_iff, nat.modeq, ‚Üê val_nat_cast, ‚Üê val_nat_cast], exact iff.rfl, }
exact iff.rfl
intros
have := f.lift_of_right_inverse_comp _ (zmod.ring_hom_right_inverse f) ‚ü®g, le_of_eq h‚ü©
rw subtype.coe_mk at this
rw [‚Üêthis, ring_hom.ext_zmod (f.lift_of_right_inverse _ _ _) (ring_hom.id _), ring_hom.id_comp]
intros
cases n
exact conservative.id Œº
{ exact conservative.id Œº }
refine ‚ü®hf.1.iterate _, Œª s hs hs0, _‚ü©
rcases (hf.frequently_ae_mem_and_frequently_image_mem hs hs0).exists with ‚ü®x, hxs, hx‚ü©
rw nat.frequently_at_top_iff_infinite at hx
rcases nat.exists_lt_modeq_of_infinite hx n.succ_pos with ‚ü®k, hk, l, hl, hkl, hn‚ü©
set m := (l - k) / (n + 1)
have : (n + 1) * m = l - k
apply nat.mul_div_cancel'
{ apply nat.mul_div_cancel', exact (nat.modeq_iff_dvd' hkl.le).1 hn }
exact (nat.modeq_iff_dvd' hkl.le).1 hn
refine ‚ü®f^[k] x, hk, m, _, _‚ü©
intro hm
{ intro hm, rw [hm, mul_zero, eq_comm, nat.sub_eq_zero_iff_le] at this, exact this.not_lt hkl }
rw [hm, mul_zero, eq_comm, nat.sub_eq_zero_iff_le] at this
exact this.not_lt hkl
rwa [‚Üê iterate_mul, this, ‚Üê iterate_add_apply, nat.sub_add_cancel]
{ rwa [‚Üê iterate_mul, this, ‚Üê iterate_add_apply, nat.sub_add_cancel], exact hkl.le }
exact hkl.le
intros
simp only [omega_limit_def, mem_Inter, maps_to]
intros y hy u hu
refine map_mem_closure hgc (hy _ (inter_mem hu hg)) (forall_image2_iff.2 $ Œª t ht x hx, _)
calc gb (œï t x) = œï' t (ga x) : ht.2 hx ... ‚àà image2 œï' u s' : mem_image2_of_mem ht.1 (hs hx)
intros
apply_instance
intros
rw alg_hom.card_of_power_basis; simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
rw alg_hom.card_of_power_basis
simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
intros
apply induction_on f
intro a
{ intro a, rw [expand_C, frobenius_def, ‚Üê C_pow, zmod.pow_card], }
rw [expand_C, frobenius_def, ‚Üê C_pow, zmod.pow_card]
simp only [alg_hom.map_add, ring_hom.map_add]
{ simp only [alg_hom.map_add, ring_hom.map_add], intros _ _ hf hg, rw [hf, hg] }
intros _ _ hf hg
rw [hf, hg]
simp only [expand_X, ring_hom.map_mul, alg_hom.map_mul]
{ simp only [expand_X, ring_hom.map_mul, alg_hom.map_mul], intros _ _ hf, rw [hf, frobenius_def], }
intros _ _ hf
rw [hf, frobenius_def]
intros
tfae_have : 1 ‚Üí 2
exact Œª h, order_iso.map_bot (@intermediate_field_equiv_subgroup F _ E _ _ _ h).symm
{ exact Œª h, order_iso.map_bot (@intermediate_field_equiv_subgroup F _ E _ _ _ h).symm }
tfae_have : 1 ‚Üí 3
{ introI _, exact card_aut_eq_finrank F E }
introI _
exact card_aut_eq_finrank F E
tfae_have : 1 ‚Üí 4
{ introI _, exact is_separable_splitting_field F E }
introI _
exact is_separable_splitting_field F E
tfae_have : 2 ‚Üí 1
{ exact of_fixed_field_eq_bot F E }
exact of_fixed_field_eq_bot F E
tfae_have : 3 ‚Üí 1
{ exact of_card_aut_eq_finrank F E }
exact of_card_aut_eq_finrank F E
tfae_have : 4 ‚Üí 1
rintros ‚ü®h, hp1, _‚ü©
{ rintros ‚ü®h, hp1, _‚ü©, exactI of_separable_splitting_field hp1 }
exactI of_separable_splitting_field hp1
tfae_finish
intros
let f : (E ‚âÉ‚Çê[K] E) ‚Üí* (E ‚âÉ‚Çê[F] E) := { to_fun := Œª œï, alg_equiv.of_alg_hom (œï.to_alg_hom.restrict_scalars F) (œï.symm.to_alg_hom.restrict_scalars F) (alg_hom.ext (Œª x, œï.apply_symm_apply x)) (alg_hom.ext (Œª x, œï.symm_apply_apply x)), map_one' := alg_equiv.ext (Œª _, rfl), map_mul' := Œª _ _, alg_equiv.ext (Œª _, rfl) }
refine solvable_of_ker_le_range f (alg_equiv.restrict_normal_hom K) (Œª œï hœï, ‚ü®{commutes' := Œª x, _, .. œï}, alg_equiv.ext (Œª _, rfl)‚ü©)
exact (eq.trans (œï.restrict_normal_commutes K x).symm (congr_arg _ (alg_equiv.ext_iff.mp hœï x)))
intros
rw monoid_hom.injective_iff
intros œï hœï
ext x hx
have key := equiv.perm.ext_iff.mp hœï (roots_equiv_roots p E ‚ü®x, hx‚ü©)
change roots_equiv_roots p E (œï ‚Ä¢ (roots_equiv_roots p E).symm (roots_equiv_roots p E ‚ü®x, hx‚ü©)) = roots_equiv_roots p E ‚ü®x, hx‚ü© at key
rw equiv.symm_apply_apply at key
exact subtype.ext_iff.mp (equiv.injective (roots_equiv_roots p E) key)
intros
have := h.of_mul_left_left
rw derivative_mul at this
exact is_coprime.of_mul_right_left (is_coprime.of_add_mul_left_right this)
intros
rw [dist_left_midpoint p1 p2, dist_right_midpoint p1 p2]
intros
have hs : s‚ÇÅ.circumcenter ‚àà affine_span ‚Ñù (set.range s‚ÇÇ.points) := h ‚ñ∏ s‚ÇÅ.circumcenter_mem_affine_span
have hr : ‚àÄ i, dist (s‚ÇÇ.points i) s‚ÇÅ.circumcenter = s‚ÇÅ.circumradius
intro i
{ intro i, have hi : s‚ÇÇ.points i ‚àà set.range s‚ÇÇ.points := set.mem_range_self _, rw [‚Üêh, set.mem_range] at hi, rcases hi with ‚ü®j, hj‚ü©, rw [‚Üêhj, s‚ÇÅ.dist_circumcenter_eq_circumradius j] }
have hi : s‚ÇÇ.points i ‚àà set.range s‚ÇÇ.points := set.mem_range_self _
rw [‚Üêh, set.mem_range] at hi
rcases hi with ‚ü®j, hj‚ü©
rw [‚Üêhj, s‚ÇÅ.dist_circumcenter_eq_circumradius j]
exact s‚ÇÇ.eq_circumcenter_of_dist_eq hs hr
intros
rw direction_altitude
exact le_trans (vector_span ‚Ñù (s.points '' ‚Üë(finset.univ.erase i))).le_orthogonal_orthogonal (submodule.orthogonal_le inf_le_left)
intros
have h‚ÇÄ : times_cont_diff ‚Ñù ‚ä§ (Œª w : E, ‚à•w‚à• ^ 2) := times_cont_diff_norm_sq
have h‚ÇÅ : times_cont_diff ‚Ñù ‚ä§ (Œª w : E, (‚à•w‚à• ^ 2 + 4)‚Åª¬π)
refine (h‚ÇÄ.add times_cont_diff_const).inv _
{ refine (h‚ÇÄ.add times_cont_diff_const).inv _, intros x, nlinarith }
intros x
nlinarith
have h‚ÇÇ : times_cont_diff ‚Ñù ‚ä§ (Œª w, (4:‚Ñù) ‚Ä¢ w + (‚à•w‚à• ^ 2 - 4) ‚Ä¢ v)
refine (times_cont_diff_const.smul times_cont_diff_id).add _
{ refine (times_cont_diff_const.smul times_cont_diff_id).add _, refine (h‚ÇÄ.sub times_cont_diff_const).smul times_cont_diff_const }
refine (h‚ÇÄ.sub times_cont_diff_const).smul times_cont_diff_const
exact h‚ÇÅ.smul h‚ÇÇ
intros
{ ext1 ‚ü®x, v‚ü©, simp [tangent_map] }
ext1 ‚ü®x, v‚ü©
simp [tangent_map]
intros
simp only [mdifferentiable_within_at, mdifferentiable_at, continuous_within_at_univ] with mfld_simps
intros
simp only [mdifferentiable_at, differentiable_within_at_univ] with mfld_simps
exact ‚ü®ŒªH, H.2, ŒªH, ‚ü®H.continuous_at, H‚ü©‚ü©
intros
simp only [ext_chart_at_source, mem_chart_source]
intros
rw times_cont_mdiff_within_at_iff
refine ‚ü®continuous_within_at_fst, _‚ü©
refine times_cont_diff_within_at_fst.congr (Œª y hy, _) _
simp only with mfld_simps at hy
{ simp only with mfld_simps at hy, simp only [hy] with mfld_simps }
simp only [hy] with mfld_simps
{ simp only with mfld_simps }
simp only with mfld_simps
intros
rw [Sup_eq_con_gen, Sup_image]
congr' with x y
simp only [Sup_image, supr_apply, supr_Prop_eq, exists_prop, rel_eq_coe]
intros
rw set.ext_iff
simp_rw [mem_right_coset_iff, set_like.mem_coe]
split
intro h
{ intro h, apply (h y).mpr, rw mul_right_inv, exact s.one_mem }
apply (h y).mpr
rw mul_right_inv
exact s.one_mem
intros h z
{ intros h z, rw ‚Üêinv_mul_cancel_left y x‚Åª¬π, rw ‚Üêmul_assoc, exact s.mul_mem_cancel_right h }
rw ‚Üêinv_mul_cancel_left y x‚Åª¬π
rw ‚Üêmul_assoc
exact s.mul_mem_cancel_right h
intros
cases b; from step.bnot
cases b
from step.bnot
from step.bnot
intros
rw general_commutator_comm
exact general_commutator_le_right H‚ÇÇ H‚ÇÅ
intros
ext
ext; refl
refl
intros
convert mk'_self' _ _; refl
convert mk'_self' _ _
refl
intros
rw card_eq_one
simp_rw [cycle_type_def, multiset.map_eq_singleton, ‚Üêfinset.singleton_val, finset.val_inj, cycle_factors_finset_eq_singleton_iff]
split
rintro ‚ü®_, _, ‚ü®h, -‚ü©, -‚ü©
{ rintro ‚ü®_, _, ‚ü®h, -‚ü©, -‚ü©, exact h }
exact h
intro h
{ intro h, use [œÉ.support.card, œÉ], simp [h] }
use [œÉ.support.card, œÉ]
simp [h]
intros
refine ‚ü®Œª h, _, is_three_cycle.card_support‚ü©
by_cases h0 : œÉ.cycle_type = 0
rw [‚Üêsum_cycle_type, h0, sum_zero] at h
{ rw [‚Üêsum_cycle_type, h0, sum_zero] at h, exact (ne_of_lt zero_lt_three h).elim }
exact (ne_of_lt zero_lt_three h).elim
obtain ‚ü®n, hn‚ü© := exists_mem_of_ne_zero h0
by_cases h1 : œÉ.cycle_type.erase n = 0
rw [‚Üêsum_cycle_type, ‚Üêcons_erase hn, h1, ‚Üêsingleton_eq_cons, multiset.sum_singleton] at h
{ rw [‚Üêsum_cycle_type, ‚Üêcons_erase hn, h1, ‚Üêsingleton_eq_cons, multiset.sum_singleton] at h, rw [is_three_cycle, ‚Üêcons_erase hn, h1, h, singleton_eq_cons] }
rw [is_three_cycle, ‚Üêcons_erase hn, h1, h, singleton_eq_cons]
obtain ‚ü®m, hm‚ü© := exists_mem_of_ne_zero h1
rw [‚Üêsum_cycle_type, ‚Üêcons_erase hn, ‚Üêcons_erase hm, multiset.sum_cons, multiset.sum_cons] at h
linarith [two_le_of_mem_cycle_type hn, two_le_of_mem_cycle_type (mem_of_mem_erase hm)]
intros
simp
intros
ext z
rw cycle_of_apply
split_ifs with hz hz
{ exact (h.symm.trans hz).cycle_of_apply.symm }
exact (h.symm.trans hz).cycle_of_apply.symm
exact (cycle_of_apply_of_not_same_cycle (mt h.trans hz)).symm
{ exact (cycle_of_apply_of_not_same_cycle (mt h.trans hz)).symm }
intros
{ ext, simp }
ext
simp
intros
refine (zip_with_swap_prod_support' l l.tail).trans _
simpa [finset.subset_iff] using tail_subset l
intros
split
split; id { intros h, classical, rw ‚Üêperm_inv_maps_to_iff_maps_to at h, intro x, cases hx : œÉ x with l r, }
id { intros h, classical, rw ‚Üêperm_inv_maps_to_iff_maps_to at h, intro x, cases hx : œÉ x with l r, }
rintros ‚ü®a, rfl‚ü©
{ rintros ‚ü®a, rfl‚ü©, obtain ‚ü®y, hy‚ü© := h ‚ü®l, rfl‚ü©, rw [‚Üêhx, œÉ.inv_apply_self] at hy, exact absurd hy sum.inl_ne_inr}
obtain ‚ü®y, hy‚ü© := h ‚ü®l, rfl‚ü©
rw [‚Üêhx, œÉ.inv_apply_self] at hy
exact absurd hy sum.inl_ne_inr
{ rintros ‚ü®a, ha‚ü©, exact ‚ü®r, rfl‚ü©, }
rintros ‚ü®a, ha‚ü©
exact ‚ü®r, rfl‚ü©
id { intros h, classical, rw ‚Üêperm_inv_maps_to_iff_maps_to at h, intro x, cases hx : œÉ x with l r, }
intros h
classical
rw ‚Üêperm_inv_maps_to_iff_maps_to at h
intro x
cases hx : œÉ x with l r
{ rintros ‚ü®a, ha‚ü©, exact ‚ü®l, rfl‚ü©, }
rintros ‚ü®a, ha‚ü©
exact ‚ü®l, rfl‚ü©
rintros ‚ü®a, rfl‚ü©
{ rintros ‚ü®a, rfl‚ü©, obtain ‚ü®y, hy‚ü© := h ‚ü®r, rfl‚ü©, rw [‚Üêhx, œÉ.inv_apply_self] at hy, exact absurd hy sum.inr_ne_inl}
obtain ‚ü®y, hy‚ü© := h ‚ü®r, rfl‚ü©
rw [‚Üêhx, œÉ.inv_apply_self] at hy
exact absurd hy sum.inr_ne_inl
intros
refine le_antisymm (support_mul_le _ _) (Œª a, _)
rw [mem_union, mem_support, mem_support, mem_support, mul_apply, ‚Üênot_and_distrib, not_imp_not]
exact (h a).elim (Œª hf h, ‚ü®hf, f.apply_eq_iff_eq.mp (h.trans hf.symm)‚ü©) (Œª hg h, ‚ü®(congr_arg f hg).symm.trans h, hg‚ü©)
intros
ext x
simp only [mem_normalizer_iff, mem_map_equiv]
rw [f.to_equiv.forall_congr]
simp
intros
{ ext, exact mem_closure_singleton.symm }
ext
exact mem_closure_singleton.symm
intros
split
introI h
{ introI h, rcases exists_ne (1 : S) with ‚ü®‚ü®h, h_in‚ü©, h_ne‚ü©, use [h, h_in], intro hyp, apply h_ne, simpa [hyp] }
rcases exists_ne (1 : S) with ‚ü®‚ü®h, h_in‚ü©, h_ne‚ü©
use [h, h_in]
intro hyp
apply h_ne
simpa [hyp]
rintros ‚ü®x, x_in, hx‚ü©
{ rintros ‚ü®x, x_in, hx‚ü©, apply nontrivial_of_ne (‚ü®x, x_in‚ü© : S) 1, intro hyp, apply hx, simpa [has_one.one] using hyp }
apply nontrivial_of_ne (‚ü®x, x_in‚ü© : S) 1
intro hyp
apply hx
simpa [has_one.one] using hyp
intros
rw [set.insert_eq, set.insert_eq, span_union, span_union, affine_span_coe]
intros
rw [centroid, centroid, ‚Üê s.attach_affine_combination_coe]
{ rw [centroid, centroid, ‚Üê s.attach_affine_combination_coe], congr, ext, simp, }
congr
ext
simp
intros
rw collinear_iff_exists_forall_eq_smul_vadd
use [p‚ÇÅ, p‚ÇÇ -·µ• p‚ÇÅ]
intros p hp
rw [set.mem_insert_iff, set.mem_singleton_iff] at hp
cases hp
use 0
{ use 0, simp [hp] }
simp [hp]
use 1
{ use 1, simp [hp] }
simp [hp]
intros
rw [midpoint_comm, affine_equiv.point_reflection_midpoint_left]
intros
{ rw [g.map_perm, smul_smul], simp }
rw [g.map_perm, smul_smul]
simp
intros
simp_rw [set_like.le_def, mem_span_singleton]
intros
rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]
intros
simpa only [range_eq_map] using submodule.map_smul' f _ a
intros
rw [‚Üê to_span_nonzero_singleton_one K M x h, symm_apply_apply]
intros
rw [linear_equiv.range, finsupp.supported_univ]
intros
simp only [B.to_matrix'_comp, transpose_transpose, to_matrix'_to_lin']
intros
ext m
dsimp only [linear_map.comp_apply, alg_hom.comp_apply, alg_hom.to_linear_map_apply, alg_hom.id_apply]
rw [map_apply_Œπ, map_apply_Œπ, map_apply_Œπ, linear_map.comp_apply]
intros
apply uncurry_apply
intros
apply finsupp.induction_linear f
{ simp, }
simp
{ intros f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ, simp [add_tmul, hf‚ÇÅ, hf‚ÇÇ], }
intros f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ
simp [add_tmul, hf‚ÇÅ, hf‚ÇÇ]
intros i' m
{ intros i' m, apply finsupp.induction_linear g, { simp, }, { intros g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ, simp [tmul_add, hg‚ÇÅ, hg‚ÇÇ], }, { intros k' n, simp only [finsupp_tensor_finsupp_single], simp only [finsupp.single, finsupp.coe_mk], split_ifs; finish, } }
apply finsupp.induction_linear g
{ simp, }
simp
{ intros g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ, simp [tmul_add, hg‚ÇÅ, hg‚ÇÇ], }
intros g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ
simp [tmul_add, hg‚ÇÅ, hg‚ÇÇ]
intros k' n
{ intros k' n, simp only [finsupp_tensor_finsupp_single], simp only [finsupp.single, finsupp.coe_mk], split_ifs; finish, }
simp only [finsupp_tensor_finsupp_single]
simp only [finsupp.single, finsupp.coe_mk]
split_ifs; finish
split_ifs
finish
finish
finish
finish
finish
finish
finish
finish
intros
ext œÜ
rw [mem_inf, mem_dual_annihilator, mem_dual_annihilator, mem_dual_annihilator]
split
split; intro h
intro h
refine ‚ü®_, _‚ü©; intros x hx
refine ‚ü®_, _‚ü©
{ refine ‚ü®_, _‚ü©; intros x hx, exact h x (mem_sup.2 ‚ü®x, hx, 0, zero_mem _, add_zero _‚ü©), exact h x (mem_sup.2 ‚ü®0, zero_mem _, x, hx, zero_add _‚ü©) }
intros x hx
exact h x (mem_sup.2 ‚ü®x, hx, 0, zero_mem _, add_zero _‚ü©)
intros x hx
exact h x (mem_sup.2 ‚ü®0, zero_mem _, x, hx, zero_add _‚ü©)
intro h
simp_rw mem_sup
{ simp_rw mem_sup, rintro _ ‚ü®x, hx, y, hy, rfl‚ü©, rw [linear_map.map_add, h.1 _ hx, h.2 _ hy, add_zero] }
rintro _ ‚ü®x, hx, y, hy, rfl‚ü©
rw [linear_map.map_add, h.1 _ hx, h.2 _ hy, add_zero]
intros
rw [eigenspace, linear_map.mem_ker, linear_map.sub_apply, algebra_map_End_apply, sub_eq_zero]
intros
have key : module.rank K ‚Ü•(s ‚äî t) + module.rank K ‚Ü•(s ‚äì t) = module.rank K s + module.rank K t := dim_sup_add_dim_inf_eq s t
rw ‚Üêfinrank_eq_dim at key
repeat { rw ‚Üêfinrank_eq_dim at key }
rw ‚Üêfinrank_eq_dim at key
rw ‚Üêfinrank_eq_dim at key
rw ‚Üêfinrank_eq_dim at key
rw ‚Üêfinrank_eq_dim at key
norm_cast at key
exact key
intros
conv_lhs { rw ‚Üêset.image_id s }
simp_rw ‚Üêexists_prop
exact finsupp.mem_span_image_iff_total R
intros
rcases f with ‚ü®f_dom, f‚ü©
rcases g with ‚ü®g_dom, g‚ü©
change f_dom = g_dom at heq
subst g_dom
have : f = g
from linear_map.ext (Œª x, hle.2 rfl)
subst g
intros
rw ‚Üê det_transpose
exact det_of_upper_triangular _ (Œª (i j : fin n) (hji : j < i), h j i hji)
intros
{ ext i j, simp [one_apply, pi.single_apply, sub_eq_zero] }
ext i j
simp [one_apply, pi.single_apply, sub_eq_zero]
intros
{ intros i j h, simp [ha h, hf] }
intros i j h
simp [ha h, hf]
intros
apply (linear_map.to_matrix v‚ÇÅ v‚ÇÉ).injective
haveI : decidable_eq l := Œª _ _, classical.prop_decidable _
rw linear_map.to_matrix_comp v‚ÇÅ v‚ÇÇ v‚ÇÉ
rw linear_map.to_matrix_to_lin
repeat { rw linear_map.to_matrix_to_lin }
rw linear_map.to_matrix_to_lin
rw linear_map.to_matrix_to_lin
intros
split
ext i j
{ ext i j, have : j = star, by simp only [eq_iff_true_of_subsingleton], simp [to_blocks‚ÇÅ‚ÇÇ, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM] }
have : j = star
simp only [eq_iff_true_of_subsingleton]
simp only [eq_iff_true_of_subsingleton]
simp [to_blocks‚ÇÅ‚ÇÇ, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM]
ext i j
{ ext i j, have : i = star, by simp only [eq_iff_true_of_subsingleton], simp [to_blocks‚ÇÇ‚ÇÅ, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM] }
have : i = star
simp only [eq_iff_true_of_subsingleton]
simp only [eq_iff_true_of_subsingleton]
simp [to_blocks‚ÇÇ‚ÇÅ, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM]
intros
{ ext x, simp }
ext x
simp
intros
rw [ker, ‚Üê prod_bot, prod_comap_inr]
intros
ext x
obtain ‚ü®_, _, rfl, _‚ü© := exists_unique_add_of_is_compl h x
simp [of_is_compl, hœÜ, hœà]
intros
simp [basis_fun]
intros
ext t
simp only [submodule.mem_top, iff_true]
apply t.induction_on
{ exact submodule.zero_mem _, }
exact submodule.zero_mem _
{ intros m n, apply submodule.subset_span, use [m, n], }
intros m n
apply submodule.subset_span
use [m, n]
intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
{ intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ, exact submodule.add_mem _ ht‚ÇÅ ht‚ÇÇ, }
exact submodule.add_mem _ ht‚ÇÅ ht‚ÇÇ
intros
simp only [exists_prop, exists_eq_left]
intros
rw [iff_iff_implies_and_implies a b]
simp only [decidable.imp_iff_not_or, or.comm]
intros
use cases_head
rintro (rfl | ‚ü®c, hac, hcb‚ü©)
{ refl }
refl
{ exact head hac hcb }
exact head hac hcb
intros
{ rw [‚Üê uncurry_curry f] at hf, exact hf.integral_prod_right }
rw [‚Üê uncurry_curry f] at hf
exact hf.integral_prod_right
intros
simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]
intros
rw [condexp_ind_smul, indicator_const_empty]
simp only [coe_fn_coe_base, submodule.coe_zero, continuous_linear_map.map_zero]
intros
by_cases hf : integrable f Œº
calc condexp_L1 hm Œº (c ‚Ä¢ f) = condexp_L1_clm hm Œº ((hf.smul c).to_L1 (c ‚Ä¢ f)) : condexp_L1_eq (hf.smul c) ... = condexp_L1_clm hm Œº (c ‚Ä¢ hf.to_L1 f) : by rw integrable.to_L1_smul' _ hf c ... = c ‚Ä¢ condexp_L1_clm hm Œº (hf.to_L1 f) : condexp_L1_clm_smul c (hf.to_L1 f) ... = c ‚Ä¢ condexp_L1 hm Œº f : by rw condexp_L1_eq hf
{ calc condexp_L1 hm Œº (c ‚Ä¢ f) = condexp_L1_clm hm Œº ((hf.smul c).to_L1 (c ‚Ä¢ f)) : condexp_L1_eq (hf.smul c) ... = condexp_L1_clm hm Œº (c ‚Ä¢ hf.to_L1 f) : by rw integrable.to_L1_smul' _ hf c ... = c ‚Ä¢ condexp_L1_clm hm Œº (hf.to_L1 f) : condexp_L1_clm_smul c (hf.to_L1 f) ... = c ‚Ä¢ condexp_L1 hm Œº f : by rw condexp_L1_eq hf, }
by_cases hc : c = 0
{ by_cases hc : c = 0, { rw [hc, zero_smul, zero_smul, condexp_L1_zero], }, rw [condexp_L1_undef hf, condexp_L1_undef (mt (integrable_smul_iff hc f).mp hf), smul_zero], }
{ rw [hc, zero_smul, zero_smul, condexp_L1_zero], }
rw [hc, zero_smul, zero_smul, condexp_L1_zero]
rw [condexp_L1_undef hf, condexp_L1_undef (mt (integrable_smul_iff hc f).mp hf), smul_zero]
intros
rw [Lp_meas_coe, ‚Üê ennreal.to_real_le_to_real (Lp.snorm_ne_top _) (Lp.snorm_ne_top _), ‚Üê Lp.norm_def, ‚Üê Lp.norm_def, submodule.norm_coe]
exact norm_condexp_L2_le hm f
intros
simp only [has_finite_integral, lintegral_add_measure] at *
exact add_lt_top.2 ‚ü®hŒº, hŒΩ‚ü©
intros
simp_rw [mul_comm, h.const_mul _]
intros
rw [‚Üê integral_inner (integrable_on_Lp_of_measure_ne_top f fact_one_le_two_ennreal.elim hŒºs), L2.inner_indicator_const_Lp_eq_set_integral_inner]
intros
refine ‚ü®Œª hf, _, Œª hf, by simp [hf]‚ü©
rw [norm_def, ennreal.to_real_eq_zero_iff] at hf
cases hf
rw snorm_eq_zero_iff (Lp.ae_measurable f) hp.ne.symm at hf
{ rw snorm_eq_zero_iff (Lp.ae_measurable f) hp.ne.symm at hf, exact subtype.eq (ae_eq_fun.ext (hf.trans ae_eq_fun.coe_fn_zero.symm)), }
exact subtype.eq (ae_eq_fun.ext (hf.trans ae_eq_fun.coe_fn_zero.symm))
{ exact absurd hf (snorm_ne_top f), }
exact absurd hf (snorm_ne_top f)
intros
rw lintegral_rpow_nnnorm_eq_rpow_snorm' hq0_lt
exact ennreal.rpow_lt_top_of_nonneg (le_of_lt hq0_lt) (ne_of_lt hfq)
intros
by_cases hŒº : Œº = 0
{ simp [hŒº] }
simp [hŒº]
haveI : Œº.ae.ne_bot := ae_ne_bot.mpr hŒº
by_cases hp : p = 0
{ simp [hp] }
simp [hp]
have hC : 0 ‚â§ C
from le_trans (norm_nonneg _) hfC.exists.some_spec
have hC' : ‚à•C‚à• = C := by rw [real.norm_eq_abs, abs_eq_self.mpr hC]
have : ‚àÄ·µê x ‚àÇŒº, ‚à•f x‚à• ‚â§ ‚à•(Œª _, C) x‚à•
from hfC.mono (Œª x hx, hx.trans (le_of_eq hC'.symm))
convert snorm_mono_ae this
rw [snorm_const _ hp hŒº, mul_comm, ‚Üê of_real_norm_eq_coe_nnnorm, hC', one_div]
intros
rw [integrable_congr indicator_const_Lp_coe_fn, integrable_indicator_iff hs, integrable_on, integrable_const_iff, lt_top_iff_ne_top]
right
simpa only [set.univ_inter, measurable_set.univ, measure.restrict_apply] using hŒºs
intros
cases le_total a b with hab hab
rw [integral_of_le hab, ‚Üê integral_indicator measurable_set_Ioc, indicator_eq_self.2 h]
rw [integral_of_le hab, ‚Üê integral_indicator measurable_set_Ioc, indicator_eq_self.2 h]; apply_instance
{ rw [integral_of_le hab, ‚Üê integral_indicator measurable_set_Ioc, indicator_eq_self.2 h]; apply_instance }
apply_instance
apply_instance
apply_instance
rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h
{ rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h, simp [h] }
simp [h]
intros
rw measure.restrict_univ
intros
calc ‚à´‚Åª a, ((f+g) a) ^ p ‚àÇŒº ‚â§ ‚à´‚Åª a, ((f + g) a) * ((f + g) a) ^ (p - 1) ‚àÇŒº : begin refine lintegral_mono (Œª a, _), dsimp only, by_cases h_zero : (f + g) a = 0, { rw [h_zero, ennreal.zero_rpow_of_pos hpq.pos], exact zero_le _, }, by_cases h_top : (f + g) a = ‚ä§, { rw [h_top, ennreal.top_rpow_of_pos hpq.sub_one_pos, ennreal.top_mul_top], exact le_top, }, refine le_of_eq _, nth_rewrite 1 ‚Üêennreal.rpow_one ((f + g) a), rw [‚Üêennreal.rpow_add _ _ h_zero h_top, add_sub_cancel'_right], end ... = ‚à´‚Åª (a : Œ±), f a * (f + g) a ^ (p - 1) ‚àÇŒº + ‚à´‚Åª (a : Œ±), g a * (f + g) a ^ (p - 1) ‚àÇŒº : begin have h_add_m : ae_measurable (Œª (a : Œ±), ((f + g) a) ^ (p-1)) Œº, from (hf.add hg).pow_const _, have h_add_apply : ‚à´‚Åª (a : Œ±), (f + g) a * (f + g) a ^ (p - 1) ‚àÇŒº = ‚à´‚Åª (a : Œ±), (f a + g a) * (f + g) a ^ (p - 1) ‚àÇŒº, from rfl, simp_rw [h_add_apply, add_mul], rw lintegral_add' (hf.mul h_add_m) (hg.mul h_add_m), end ... ‚â§ ((‚à´‚Åª a, (f a)^p ‚àÇŒº) ^ (1/p) + (‚à´‚Åª a, (g a)^p ‚àÇŒº) ^ (1/p)) * (‚à´‚Åª a, (f a + g a)^p ‚àÇŒº) ^ (1/q) : begin rw add_mul, exact add_le_add (lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hf (hf.add hg) hf_top) (lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hg (hf.add hg) hg_top), end
intros
rw [‚Üê bUnion_of_singleton s]
exact measurable_set.bUnion hs (Œª b hb, measurable_set_singleton b)
intros
simp only [prehaar]
{ simp only [prehaar], rw [div_self], apply ne_of_gt, exact_mod_cast index_pos K‚ÇÄ hU }
rw [div_self]
apply ne_of_gt
exact_mod_cast index_pos K‚ÇÄ hU
intros
simp [map_map e.symm.measurable e.measurable]
intros
refine ‚ü®Œª h, h.comp_measurable e.measurable, Œª h, _‚ü©
rw [‚Üê (e.map_symm_map : _ = Œº)] at h
convert h.comp_measurable e.symm.measurable
simp [(‚àò)]
intros
rw [‚Üê trimmed, outer_measure.trim_eq_trim_iff]
intros s hs
rw [coe_to_outer_measure, map_apply hf hs, outer_measure.map_apply, coe_to_outer_measure]
intros
by_cases h : ‚àÄi, P (s i)
rw [extend_eq _ (PU h), congr_arg tsum _]
{ rw [extend_eq _ (PU h), congr_arg tsum _], { apply msU h }, funext i, apply extend_eq _ (h i) }
{ apply msU h }
apply msU h
funext i
apply extend_eq _ (h i)
cases not_forall.1 h with i hi
{ cases not_forall.1 h with i hi, exact le_trans (le_infi $ Œª h, hi.elim h) (ennreal.le_tsum i) }
exact le_trans (le_infi $ Œª h, hi.elim h) (ennreal.le_tsum i)
intros
have := supr_apply (Œª b, cond b m‚ÇÅ m‚ÇÇ) s; rwa [supr_bool_eq, supr_bool_eq] at this
have := supr_apply (Œª b, cond b m‚ÇÅ m‚ÇÇ) s
rwa [supr_bool_eq, supr_bool_eq] at this
intros
have : (Œª s : set Œ±, ‚®Ü (h : s.nonempty), m s) = m
ext1 t
{ ext1 t, cases t.eq_empty_or_nonempty with h h; simp [h, empty_not_nonempty, m_empty] }
cases t.eq_empty_or_nonempty with h h
cases t.eq_empty_or_nonempty with h h; simp [h, empty_not_nonempty, m_empty]
simp [h, empty_not_nonempty, m_empty]
simp [h, empty_not_nonempty, m_empty]
simp [bounded_by, this]
intros
refine ext_nonempty (Œª s hs, _)
refine ((comap_mono f).map_infi_le s).antisymm _
simp only [comap_apply, infi_apply' _ hs, infi_apply' _ (hs.image _), le_infi_iff, set.image_subset_iff, preimage_Union]
refine Œª t ht, infi_le_of_le _ (infi_le_of_le ht $ ennreal.tsum_le_tsum $ Œª k, _)
exact infi_le_infi (Œª i, (m i).mono (image_preimage_subset _ _))
intros
rw [‚Üê of_add_of_diff hA hB h, add_sub_cancel']
apply_instance
intros
have h3 : (0:‚Ñö) < 3
norm_num
norm_num
contrapose! H
rw sum_inv_pqr
have h3q := H.trans hpq
have h3r := h3q.trans hqr
calc (p‚Åª¬π + q‚Åª¬π + r‚Åª¬π : ‚Ñö) ‚â§ 3‚Åª¬π + 3‚Åª¬π + 3‚Åª¬π : add_le_add (add_le_add _ _) _ ... = 1 : by norm_num
rw inv_le_inv _ h3; [assumption_mod_cast, norm_num]
all_goals { rw inv_le_inv _ h3; [assumption_mod_cast, norm_num] }
rw inv_le_inv _ h3; [assumption_mod_cast, norm_num]
rw inv_le_inv _ h3
rw inv_le_inv _ h3; [assumption_mod_cast, norm_num]
assumption_mod_cast
norm_num
intros
conv_lhs { rw ‚Üê bS.sum_repr a }
rw [algebra.norm_apply, ‚Üê linear_map.det_to_matrix bS]
simp only [algebra.norm_apply, alg_hom.map_sum, alg_hom.map_smul, linear_equiv.map_sum, linear_equiv.map_smul, algebra.to_matrix_lmul_eq, norm_bound, smul_mul_assoc, ‚Üê mul_pow]
convert matrix.det_sum_smul_le finset.univ _ hy using 3
{ rw [finset.card_univ, smul_mul_assoc, mul_comm] }
rw [finset.card_univ, smul_mul_assoc, mul_comm]
intros i j k
{ intros i j k, apply finset.le_max', exact finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, finset.mem_univ _, rfl‚ü© }
apply finset.le_max'
exact finset.mem_image.mpr ‚ü®‚ü®i, j, k‚ü©, finset.mem_univ _, rfl‚ü©
intros
have : 1 ‚â§ b^p := nat.one_le_pow p b w
push_cast [this]
intros
rw [mersenne, nat.sub_add_cancel]
exact one_le_pow_of_one_le (by norm_num) k
intros
rw [eq_neg_iff_add_eq_zero, ‚Üê padic_val_rat.mul p (inv_ne_zero hq) hq, inv_mul_cancel hq, padic_val_rat.one]
intros
specialize f_compat i j h
rw [‚Üê int.coe_nat_pow, ‚Üê zmod.int_coe_zmod_eq_zero_iff_dvd, int.cast_sub]
dsimp [nth_hom]
rw [‚Üê f_compat, ring_hom.comp_apply]
have : fact (p ^ i > 0) := ‚ü®pow_pos hp_prime.1.pos _‚ü©
have : fact (p ^ j > 0) := ‚ü®pow_pos hp_prime.1.pos _‚ü©
simp only [zmod.cast_id, zmod.cast_hom_apply, sub_self, zmod.nat_cast_val]
unfreezingI { simp only [zmod.cast_id, zmod.cast_hom_apply, sub_self, zmod.nat_cast_val], }
intros
simp
intros
refine ‚ü®_, Œª h, h.mul k‚ü©
simp only [pythagorean_triple]
intro h
rw ‚Üê mul_left_inj' (mul_ne_zero hk hk)
convert h using 1; ring
convert h using 1
ring
ring
intros
rw nonnegg_comm; exact nonnegg_neg_pos
rw nonnegg_comm
exact nonnegg_neg_pos
intros
cases x; cases y; simp [to_complex_def‚ÇÇ]
cases x; cases y
cases x
cases y
simp [to_complex_def‚ÇÇ]
intros
{ rw [sup_sdiff_self_right], exact le_sup_right }
rw [sup_sdiff_self_right]
exact le_sup_right
intros
rw [sdiff_sdiff_comm, sdiff_self, bot_sdiff]
intros
simp [bdd_above, upper_bounds, set.nonempty]
intros
{ change (‚àÉ _, _) ‚Üî _, simp [-eq_iff_iff] }
change (‚àÉ _, _) ‚Üî _
simp [-eq_iff_iff]
intros
rw [‚Üê infi_subtype'', Inf_image']
intros
{ ext x, simp [nat.find_eq_iff, disjointed_eq_inter_compl] }
ext x
simp [nat.find_eq_iff, disjointed_eq_inter_compl]
intros
refine top_unique (Œª s hs x, _)
letI : unique Œ± := ‚ü®‚ü®x‚ü©, Œª y, subsingleton.elim y x‚ü©
rw [at_top, infi_unique, unique.default_eq x, mem_principal] at hs
exact hs left_mem_Ici
intros
refine le_antisymm (le_infi (Œª i, le_principal_iff.2 $ mem_at_top {i})) _
refine le_infi (Œª s, le_principal_iff.2 $ mem_infi_of_Inter s.finite_to_set (Œª i, mem_principal_self _) _)
simp only [subset_def, mem_Inter, set_coe.forall, mem_Ici, finset.le_iff_subset, finset.mem_singleton, finset.subset_iff, forall_eq]
dsimp
exact Œª t, id
intros
cases B.eq_empty_or_nonempty with hB Bnonempty
rw [hB, infi_emptyset]
{ rw [hB, infi_emptyset], use Œª n, i‚ÇÄ, simp [h] }
use Œª n, i‚ÇÄ
simp [h]
{ exact countable_binfi_eq_infi_seq Bcbl Bnonempty f }
exact countable_binfi_eq_infi_seq Bcbl Bnonempty f
intros
simp only [filter_eq_iff, ext_iff, filter.mem_sets]
intros
rw [sup_eq_supr, comap_supr, supr_bool_eq, bool.cond_tt, bool.cond_ff]
intros
refine le_trans (Œª s hs, _) (join_mono $ map_mono hf)
simp only [mem_join, mem_bind', mem_map] at hs ‚ä¢
filter_upwards [hg, hs]
exact Œª x hx hs, hx hs
intros
rw [filter.prod, comap_infi, infi_inf]
{ rw [filter.prod, comap_infi, infi_inf], simp only [filter.prod, eq_self_iff_true] }
simp only [filter.prod, eq_self_iff_true]
intros
simp only [‚Üê filter.mem_sets, supr_sets_eq, iff_self, mem_Inter]
intros
simp only [‚Üê le_principal_iff, (is_compl_principal s).le_left_iff, disjoint, inf_assoc, inf_principal, imp_iff_not_or]
rw [‚Üê disjoint, ‚Üê (is_compl_principal (t ‚à© s·∂ú)).le_right_iff, compl_inter, compl_compl]
refl
intros
rcases lt_trichotomy (f x) (g x) with H|H|H
{ simp only [*, iterate_pos_lt_of_map_lt] }
simp only [*, iterate_pos_lt_of_map_lt]
{ simp only [*, h.iterate_eq_of_map_eq, lt_irrefl] }
simp only [*, h.iterate_eq_of_map_eq, lt_irrefl]
simp only [lt_asymm H, lt_asymm (h.symm.iterate_pos_lt_of_map_lt' hg hf H hn)]
{ simp only [lt_asymm H, lt_asymm (h.symm.iterate_pos_lt_of_map_lt' hg hf H hn)] }
intros
simp only [sup_inf_left, Œªy:Œ±, @sup_comm Œ± _ y x, eq_self_iff_true]
intros
simp only [limsup_eq_infi_supr_of_nat, supr_ge_eq_supr_nat_add]
intros
simp only [lt_iff_le_not_le, hf.le_iff h]
intros
intros x y hxy
rcases trichotomous_of r x y with h | h | h
have := hf h
rw hxy at this
exfalso
exact irrefl_of s (f y) this
exact h
have := hf h
rw hxy at this
exfalso
exact irrefl_of s (f y) this
intros
refine Œª y, (H _).unique _
have := (f‚ÇÅ g).left_ord_continuous (H y)
rw [‚Üê range_comp, ‚Üê (equiv.mul_right g).surjective.range_comp _] at this
simpa [(‚àò)] using this
intros
rw [symm_diff_def, sup_sdiff, sdiff_sdiff_left, sdiff_sdiff_left]
intros
revert g
have h_measM_f : measurable f
from h_meas_f.mono hMf le_rfl
apply measurable.ennreal_induction
intros c s h_s
{ intros c s h_s, apply lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator hMf _ (hMg _ h_s) _ h_meas_f, apply indep_sets_of_indep_sets_of_le_right h_ind, rwa singleton_subset_iff, }
apply lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator hMf _ (hMg _ h_s) _ h_meas_f
apply indep_sets_of_indep_sets_of_le_right h_ind
rwa singleton_subset_iff
{ intros f' g h_univ h_measMg_f' h_measMg_g h_ind_f' h_ind_g', have h_measM_f' : measurable f', from h_measMg_f'.mono hMg le_rfl, have h_measM_g : measurable g, from h_measMg_g.mono hMg le_rfl, simp_rw [pi.add_apply, left_distrib], rw [lintegral_add h_measM_f' h_measM_g, lintegral_add (h_measM_f.mul h_measM_f') (h_measM_f.mul h_measM_g), left_distrib, h_ind_f', h_ind_g'] }
intros f' g h_univ h_measMg_f' h_measMg_g h_ind_f' h_ind_g'
have h_measM_f' : measurable f'
from h_measMg_f'.mono hMg le_rfl
have h_measM_g : measurable g
from h_measMg_g.mono hMg le_rfl
simp_rw [pi.add_apply, left_distrib]
rw [lintegral_add h_measM_f' h_measM_g, lintegral_add (h_measM_f.mul h_measM_f') (h_measM_f.mul h_measM_g), left_distrib, h_ind_f', h_ind_g']
intros f' h_meas_f' h_mono_f' h_ind_f'
{ intros f' h_meas_f' h_mono_f' h_ind_f', have h_measM_f' : ‚àÄ n, measurable (f' n), from Œª n, (h_meas_f' n).mono hMg le_rfl, simp_rw [ennreal.mul_supr], rw [lintegral_supr, lintegral_supr h_measM_f' h_mono_f', ennreal.mul_supr], { simp_rw [‚Üê h_ind_f'], }, { exact Œª n, h_measM_f.mul (h_measM_f' n), }, { exact Œª n m (h_le : n ‚â§ m) a, ennreal.mul_le_mul le_rfl (h_mono_f' h_le a), }, }
have h_measM_f' : ‚àÄ n, measurable (f' n)
from Œª n, (h_meas_f' n).mono hMg le_rfl
simp_rw [ennreal.mul_supr]
rw [lintegral_supr, lintegral_supr h_measM_f' h_mono_f', ennreal.mul_supr]
{ simp_rw [‚Üê h_ind_f'], }
simp_rw [‚Üê h_ind_f']
{ exact Œª n, h_measM_f.mul (h_measM_f' n), }
exact Œª n, h_measM_f.mul (h_measM_f' n)
exact Œª n m (h_le : n ‚â§ m) a, ennreal.mul_le_mul le_rfl (h_mono_f' h_le a)
{ exact Œª n m (h_le : n ‚â§ m) a, ennreal.mul_le_mul le_rfl (h_mono_f' h_le a), }
intros
obtain ‚ü®d, rfl‚ü© := hdvd
exact is_coprime.of_mul_left_left h
intros
rw [add_val_pow, add_val_uniformizer h, nsmul_one]
intros
have h10 : (1 : R) ‚â† 0 := one_ne_zero
have x0 : x ‚â† 0 := ne_zero_of_coeff_ne_zero (right_ne_zero_of_mul_eq_one hr)
refine lt_of_le_of_ne ((add_val Œì R).map_le_sub (ge_of_eq (add_val Œì R).map_one) _) _
simp only [add_valuation.map_mul]
{ simp only [add_valuation.map_mul], rw [add_val_apply_of_ne x0, add_val_apply_of_ne (single_ne_zero h10), add_val_apply_of_ne _, order_C, order_single h10, with_top.coe_zero, zero_add, ‚Üê with_top.coe_add, neg_add_self, with_top.coe_zero], { exact le_refl 0 }, { exact C_ne_zero (left_ne_zero_of_mul_eq_one hr) } }
rw [add_val_apply_of_ne x0, add_val_apply_of_ne (single_ne_zero h10), add_val_apply_of_ne _, order_C, order_single h10, with_top.coe_zero, zero_add, ‚Üê with_top.coe_add, neg_add_self, with_top.coe_zero]
{ exact le_refl 0 }
exact le_refl 0
{ exact C_ne_zero (left_ne_zero_of_mul_eq_one hr) }
exact C_ne_zero (left_ne_zero_of_mul_eq_one hr)
rw [add_val_apply, ‚Üê with_top.coe_zero]
{ rw [add_val_apply, ‚Üê with_top.coe_zero], split_ifs, { apply with_top.coe_ne_top }, rw [ne.def, with_top.coe_eq_coe], intro con, apply coeff_order_ne_zero h, rw [‚Üê con, mul_assoc, sub_coeff, one_coeff, if_pos rfl, C_mul_eq_smul, smul_coeff, smul_eq_mul, ‚Üê add_neg_self x.order, single_mul_coeff_add, one_mul, hr, sub_self] }
split_ifs
{ apply with_top.coe_ne_top }
apply with_top.coe_ne_top
rw [ne.def, with_top.coe_eq_coe]
intro con
apply coeff_order_ne_zero h
rw [‚Üê con, mul_assoc, sub_coeff, one_coeff, if_pos rfl, C_mul_eq_smul, smul_coeff, smul_eq_mul, ‚Üê add_neg_self x.order, single_mul_coeff_add, one_mul, hr, sub_self]
intros
rcases (ring.not_is_field_iff_exists_ideal_bot_lt_and_lt_top.1 non_field) with ‚ü®I, Ibot, Itop‚ü©
split
finish
intro mle
apply @irrefl _ (<) _ (‚ä§ : ideal R)
have : M = ‚ä• := eq_bot_iff.mpr mle
rw this at *
rwa hm.1.2 I Ibot at Itop
intros
refine ‚ü®Œª h, H.ne_top (eq_top_iff.2 _), Œª x y, _‚ü©
replace h := congr_arg (comap f) h
{ replace h := congr_arg (comap f) h, rw [comap_map_of_surjective _ hf, comap_top] at h, exact h ‚ñ∏ sup_le (le_of_eq rfl) hk }
rw [comap_map_of_surjective _ hf, comap_top] at h
exact h ‚ñ∏ sup_le (le_of_eq rfl) hk
refine Œª hxy, (hf x).rec_on (Œª a ha, (hf y).rec_on (Œª b hb, _))
{ refine Œª hxy, (hf x).rec_on (Œª a ha, (hf y).rec_on (Œª b hb, _)), rw [‚Üê ha, ‚Üê hb, ‚Üê ring_hom.map_mul, mem_map_iff_of_surjective _ hf] at hxy, rcases hxy with ‚ü®c, hc, hc'‚ü©, rw [‚Üê sub_eq_zero, ‚Üê ring_hom.map_sub] at hc', have : a * b ‚àà I, { convert I.sub_mem hc (hk (hc' : c - a * b ‚àà f.ker)), abel }, exact (H.mem_or_mem this).imp (Œª h, ha ‚ñ∏ mem_map_of_mem f h) (Œª h, hb ‚ñ∏ mem_map_of_mem f h) }
rw [‚Üê ha, ‚Üê hb, ‚Üê ring_hom.map_mul, mem_map_iff_of_surjective _ hf] at hxy
rcases hxy with ‚ü®c, hc, hc'‚ü©
rw [‚Üê sub_eq_zero, ‚Üê ring_hom.map_sub] at hc'
have : a * b ‚àà I
convert I.sub_mem hc (hk (hc' : c - a * b ‚àà f.ker))
{ convert I.sub_mem hc (hk (hc' : c - a * b ‚àà f.ker)), abel }
abel
exact (H.mem_or_mem this).imp (Œª h, ha ‚ñ∏ mem_map_of_mem f h) (Œª h, hb ‚ñ∏ mem_map_of_mem f h)
intros
simp only [mul_comm, mem_mul_span_singleton]
intros
apply (nat.prime.dvd_mul hp).mp
rw ‚Üê int.nat_abs_mul
exact int.coe_nat_dvd_left.mp h
intros
refine ‚ü®is_localization.injective _ (le_non_zero_divisors_of_no_zero_divisors hM), Œª x, _‚ü©
obtain ‚ü®r, ‚ü®m, hm‚ü©, rfl‚ü© := mk'_surjective M x
obtain ‚ü®n, hn‚ü© := hR.mul_inv_cancel (Œª hm0, hM (hm0 ‚ñ∏ hm) : m ‚â† 0)
exact ‚ü®r * n, by erw [eq_mk'_iff_mul_eq, ‚Üê ring_hom.map_mul, mul_assoc, mul_comm n, hn, mul_one]‚ü©
intros
rw ‚Üê pow_one a
apply pow_dvd_of_le_multiplicity
simpa only [nat.cast_one, enat.pos_iff_one_le] using h
intros
rw [‚Üê sup_eq_left, smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson hN' hIJ hNN, bot_smul, sup_bot_eq]
intros
suffices t : ‚àÉ n : ‚Ñï, ‚àÄ m, n ‚â§ m ‚Üí f (m+1) = ‚ä•
obtain ‚ü®n, w‚ü© := t
{ obtain ‚ü®n, w‚ü© := t, use n+1, rintros (_|m) p, { cases p, }, { apply w, exact nat.succ_le_succ_iff.mp p }, }
use n+1
rintros (_|m) p
{ cases p, }
cases p
apply w
{ apply w, exact nat.succ_le_succ_iff.mp p }
exact nat.succ_le_succ_iff.mp p
obtain ‚ü®n, w‚ü© := monotone_stabilizes_iff_noetherian.mpr I (partial_sups f)
exact ‚ü®n, (Œª m p, eq_bot_of_disjoint_absorbs (h m) ((eq.symm (w (m + 1) (le_add_right p))).trans (w m p)))‚ü©
intros
{ rw ring_hom.map_pow, exact f.2 n }
rw ring_hom.map_pow
exact f.2 n
intros
simp [nat_degree]
intros
simp_rw [degree_lt, submodule.mem_infi, linear_map.mem_ker, degree, finset.sup_lt_iff (with_bot.bot_lt_coe n), mem_support_iff, with_bot.some_eq_coe, with_bot.coe_lt_coe, lt_iff_not_ge', ne, not_imp_not]
{ simp_rw [degree_lt, submodule.mem_infi, linear_map.mem_ker, degree, finset.sup_lt_iff (with_bot.bot_lt_coe n), mem_support_iff, with_bot.some_eq_coe, with_bot.coe_lt_coe, lt_iff_not_ge', ne, not_imp_not], refl }
refl
intros
rintros r ‚ü®q, h‚ü©
exact is_unit_of_mul_eq_one r (q.coeff p.nat_degree) (by rwa [‚Üêcoeff_C_mul, ‚Üêh])
intros
{ have aux := mt (@hœÜ d) hd, classical, rwa not_not at aux }
have aux := mt (@hœÜ d) hd
classical
rwa not_not at aux
intros
apply is_root_of_eval‚ÇÇ_map_eq_zero (is_fraction_ring.injective A K)
refine scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero _
rw mk'_num_denom
exact hr
intros
simp only [inv_fun, eval‚ÇÇ_add]
intros
rw linear_independent_iff
intros p hp
set f : polynomial K := p.sum (Œª i, monomial i) with hf0
have f_def : ‚àÄ (i : fin _), f.coeff i = p i
intro i
{ intro i, simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff], rw [finset.sum_eq_single, if_pos rfl], { intros b _ hb, rw if_neg (mt (Œª h, _) hb), exact fin.coe_injective h }, { intro hi, split_ifs; { exact finsupp.not_mem_support_iff.mp hi } } }
simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff]
rw [finset.sum_eq_single, if_pos rfl]
intros b _ hb
{ intros b _ hb, rw if_neg (mt (Œª h, _) hb), exact fin.coe_injective h }
rw if_neg (mt (Œª h, _) hb)
exact fin.coe_injective h
intro hi
{ intro hi, split_ifs; { exact finsupp.not_mem_support_iff.mp hi } }
split_ifs; { exact finsupp.not_mem_support_iff.mp hi }
split_ifs
{ exact finsupp.not_mem_support_iff.mp hi }
exact finsupp.not_mem_support_iff.mp hi
{ exact finsupp.not_mem_support_iff.mp hi }
have f_def' : ‚àÄ i, f.coeff i = if hi : i < _ then p ‚ü®i, hi‚ü© else 0
intro i
{ intro i, split_ifs with hi, { exact f_def ‚ü®i, hi‚ü© }, simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff], apply finset.sum_eq_zero, rintro ‚ü®j, hj‚ü© -, apply if_neg (mt _ hi), rintro rfl, exact hj }
split_ifs with hi
{ exact f_def ‚ü®i, hi‚ü© }
exact f_def ‚ü®i, hi‚ü©
simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff]
apply finset.sum_eq_zero
rintro ‚ü®j, hj‚ü© -
apply if_neg (mt _ hi)
rintro rfl
exact hj
suffices : f = 0
ext i
{ ext i, rw [‚Üê f_def, this, coeff_zero, finsupp.zero_apply] }
rw [‚Üê f_def, this, coeff_zero, finsupp.zero_apply]
contrapose hp with hf
intro h
have : (minpoly K x).degree ‚â§ f.degree
apply minpoly.degree_le_of_ne_zero K x hf
{ apply minpoly.degree_le_of_ne_zero K x hf, convert h, simp_rw [finsupp.total_apply, aeval_def, hf0, finsupp.sum, eval‚ÇÇ_finset_sum], apply finset.sum_congr rfl, rintro i -, simp only [algebra.smul_def, eval‚ÇÇ_monomial] }
convert h
simp_rw [finsupp.total_apply, aeval_def, hf0, finsupp.sum, eval‚ÇÇ_finset_sum]
apply finset.sum_congr rfl
rintro i -
simp only [algebra.smul_def, eval‚ÇÇ_monomial]
have : ¬¨ (minpoly K x).degree ‚â§ f.degree
apply not_le_of_lt
{ apply not_le_of_lt, rw [degree_eq_nat_degree (minpoly.ne_zero hx), degree_lt_iff_coeff_zero], intros i hi, rw [f_def' i, dif_neg], exact hi.not_lt }
rw [degree_eq_nat_degree (minpoly.ne_zero hx), degree_lt_iff_coeff_zero]
intros i hi
rw [f_def' i, dif_neg]
exact hi.not_lt
contradiction
intros
ext1 n
simp only [coeff_mul, finset.sum_mul, finset.mul_sum, finset.sum_sigma']
refine finset.sum_bij (Œª p _, ‚ü®(p.2.1, p.2.2 + p.1.2), (p.2.2, p.1.2)‚ü©) _ _ _ _
refine finset.sum_bij (Œª p _, ‚ü®(p.2.1, p.2.2 + p.1.2), (p.2.2, p.1.2)‚ü©) _ _ _ _; simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü©
{ rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü©, dsimp only, rintro rfl rfl, simp [add_assoc] }
dsimp only
rintro rfl rfl
simp [add_assoc]
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintros ‚ü®‚ü®a, b‚ü©, ‚ü®c, d‚ü©‚ü©
{ rintros ‚ü®‚ü®a, b‚ü©, ‚ü®c, d‚ü©‚ü©, dsimp only, rintro rfl rfl, apply mul_assoc }
dsimp only
rintro rfl rfl
apply mul_assoc
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintros ‚ü®‚ü®a, b‚ü©, ‚ü®c, d‚ü©‚ü© ‚ü®‚ü®i, j‚ü©, ‚ü®k, l‚ü©‚ü©
{ rintros ‚ü®‚ü®a, b‚ü©, ‚ü®c, d‚ü©‚ü© ‚ü®‚ü®i, j‚ü©, ‚ü®k, l‚ü©‚ü©, dsimp only, rintro rfl rfl - rfl rfl - rfl rfl, refl }
dsimp only
rintro rfl rfl - rfl rfl - rfl rfl
refl
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintro ‚ü®‚ü®i, j‚ü©, ‚ü®k, l‚ü©‚ü©
{ rintro ‚ü®‚ü®i, j‚ü©, ‚ü®k, l‚ü©‚ü©, dsimp only, rintro rfl rfl, refine ‚ü®‚ü®(i + k, l), (i, k)‚ü©, _, _‚ü©; simp [add_assoc] }
dsimp only
rintro rfl rfl
refine ‚ü®‚ü®(i + k, l), (i, k)‚ü©, _, _‚ü©; simp [add_assoc]
refine ‚ü®‚ü®(i + k, l), (i, k)‚ü©, _, _‚ü©
simp [add_assoc]
intros
rw [X_pow_eq, coeff_monomial]
intros
split
intro hŒæ
{ intro hŒæ, obtain ‚ü®i, hik, rfl‚ü© := h.eq_pow_of_mem_roots_of_unity hŒæ.pow_eq_one, rw h.pow_iff_coprime k.pos at hŒæ, exact ‚ü®i, hik, hŒæ, rfl‚ü© }
obtain ‚ü®i, hik, rfl‚ü© := h.eq_pow_of_mem_roots_of_unity hŒæ.pow_eq_one
rw h.pow_iff_coprime k.pos at hŒæ
exact ‚ü®i, hik, hŒæ, rfl‚ü©
{ rintro ‚ü®i, -, hi, rfl‚ü©, exact h.pow_of_coprime i hi }
rintro ‚ü®i, -, hi, rfl‚ü©
exact h.pow_of_coprime i hi
intros
{ rw sub_eq_add_neg, exact s.add_mem hx (s.neg_mem hy) }
rw sub_eq_add_neg
exact s.add_mem hx (s.neg_mem hy)
intros
map_fun_tac
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [sub_zero, ring_hom.map_sub, constant_coeff_X]
intros
let P : ‚Ñï ‚Üí Prop := Œª n, y.coeff n = 0
haveI : decidable_pred P := classical.dec_pred P
set z := mk p (Œª n, if P n then x.coeff n else y.coeff n) with hz
have hx : select P z = x
ext1 n
{ ext1 n, rw [select, coeff_mk, coeff_mk], split_ifs with hn, { refl }, { rw (h n).resolve_right hn } }
rw [select, coeff_mk, coeff_mk]
split_ifs with hn
refl
{ refl }
rw (h n).resolve_right hn
{ rw (h n).resolve_right hn }
have hy : select (Œª i, ¬¨ P i) z = y
ext1 n
{ ext1 n, rw [select, coeff_mk, coeff_mk], split_ifs with hn, { exact hn.symm }, { refl } }
rw [select, coeff_mk, coeff_mk]
split_ifs with hn
exact hn.symm
{ exact hn.symm }
refl
{ refl }
calc (x + y).coeff n = z.coeff n : by rw [‚Üê hx, ‚Üê hy, select_add_select_not P z] ... = x.coeff n + y.coeff n : _
dsimp [z]
split_ifs with hn
{ dsimp [P] at hn, rw [hn, add_zero] }
dsimp [P] at hn
rw [hn, add_zero]
{ rw [(h n).resolve_right hn, zero_add] }
rw [(h n).resolve_right hn, zero_add]
intros
obtain ‚ü®x, rfl‚ü© := witt_vector.truncate_surjective p n‚ÇÉ R x
simp only [truncate_witt_vector_truncate]
intros
apply sum_congr rfl
rintro i -
rw [monomial_eq, finsupp.prod_single_index]
rw pow_zero
intros
convert sup_eq_zero
exact subtype.is_empty_of_false (Œª x, (zero_le _).not_lt)
intros
{ rw [mul_comm, mul_eq_left hb ha ha'] }
rw [mul_comm, mul_eq_left hb ha ha']
intros
{cases x, cases y, refl}
cases x
cases y
refl
intros
have := f.lt_top f.top
rw [show f f.top = f.top, from initial_seg.eq ‚Üëf (initial_seg.refl r) f.top] at this
exact irrefl _ this
intros
simp only [le_antisymm_iff, add_le_add_iff_left]
rw lt_def
left
use punit.star
split
split; rintro ‚ü® ‚ü©
rintro ‚ü® ‚ü©
rintro ‚ü® ‚ü©
intros
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, term, smul, nsmul_add, mul_nsmul]
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
cc
intros
cases f with xs hperm hnodup
generalize h‚ÇÄ : map sigma.fst xs = xs‚ÇÄ
generalize h‚ÇÅ : xs.map (@id ((Œ£ _ : Œ±, Œ±) ‚Üí Œ±) $ @sigma.snd Œ± (Œª _ : Œ±, Œ±)) = xs‚ÇÅ
dsimp [id] at h‚ÇÅ
have hxs : xs = total_function.list.to_finmap' (xs‚ÇÄ.zip xs‚ÇÅ)
rw [‚Üê h‚ÇÄ, ‚Üê h‚ÇÅ, list.to_finmap']
{ rw [‚Üê h‚ÇÄ, ‚Üê h‚ÇÅ, list.to_finmap'], clear h‚ÇÄ h‚ÇÅ xs‚ÇÄ xs‚ÇÅ hperm hnodup, induction xs, case list.nil { simp only [zip_nil_right, map_nil] }, case list.cons : xs_hd xs_tl xs_ih { simp only [true_and, to_sigma, eq_self_iff_true, sigma.eta, zip_cons_cons, list.map], exact xs_ih }, }
clear h‚ÇÄ h‚ÇÅ xs‚ÇÄ xs‚ÇÅ hperm hnodup
induction xs
case list.nil { simp only [zip_nil_right, map_nil] }
simp only [zip_nil_right, map_nil]
case list.cons : xs_hd xs_tl xs_ih { simp only [true_and, to_sigma, eq_self_iff_true, sigma.eta, zip_cons_cons, list.map], exact xs_ih }
simp only [true_and, to_sigma, eq_self_iff_true, sigma.eta, zip_cons_cons, list.map]
exact xs_ih
revert hperm hnodup
rw hxs
intros
apply apply_id_injective
{ rwa [‚Üê h‚ÇÄ, hxs, hperm.nodup_iff], }
rwa [‚Üê h‚ÇÄ, hxs, hperm.nodup_iff]
{ rwa [‚Üê hxs, h‚ÇÄ, h‚ÇÅ] at hperm, }
rwa [‚Üê hxs, h‚ÇÄ, h‚ÇÅ] at hperm
intros
rw [coe_injective.compl_image_eq, compl_range_coe]
intros
simpa only using h.map (add_monoid_hom.mul_left a‚ÇÇ) (continuous_const.mul continuous_id)
intros
suffices : ring.inverse ((((continuous_linear_equiv.units_equiv _ _).symm e) : M ‚ÜíL[R] M)) = inverse ‚Üëe
{ convert this }
convert this
simp
refl
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _)) (pi_univ_Ico_subset a b)
exact Ico_mem_nhds (ha i) (hb i)
intros
simpa only [mul_comm] using hg.at_top_mul hC hf
intros
simp [frontier]
intros
refine subset.antisymm set_of_is_preconnected_subset_of_ordered _
simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp_distrib, forall_and_distrib, mem_union, mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true, is_preconnected_Icc, is_preconnected_Ico, is_preconnected_Ioc, is_preconnected_Ioo, is_preconnected_Ioi, is_preconnected_Iio, is_preconnected_Ici, is_preconnected_Iic, is_preconnected_univ, is_preconnected_empty]
intros
have ha : a ‚àà Ici a := left_mem_Ici
have has : a ‚àà s := mem_of_mem_nhds_within ha hs
refine tendsto_order.2 ‚ü®Œª b hb, _, Œª b hb, _‚ü©
filter_upwards [hs, self_mem_nhds_within]
{ filter_upwards [hs, self_mem_nhds_within], intros x hxs hxa, exact hb.trans_le ((h_mono.le_iff_le has hxs).2 hxa) }
intros x hxs hxa
exact hb.trans_le ((h_mono.le_iff_le has hxs).2 hxa)
rcases hfs b hb with ‚ü®c, hcs, hac, hcb‚ü©
{ rcases hfs b hb with ‚ü®c, hcs, hac, hcb‚ü©, rw [h_mono.lt_iff_lt has hcs] at hac, filter_upwards [hs, Ico_mem_nhds_within_Ici (left_mem_Ico.2 hac)], rintros x hx ‚ü®hax, hxc‚ü©, exact ((h_mono.lt_iff_lt hx hcs).2 hxc).trans_le hcb }
rw [h_mono.lt_iff_lt has hcs] at hac
filter_upwards [hs, Ico_mem_nhds_within_Ici (left_mem_Ico.2 hac)]
rintros x hx ‚ü®hax, hxc‚ü©
exact ((h_mono.lt_iff_lt hx hcs).2 hxc).trans_le hcb
intros
rw [‚Üêpfun.preimage_univ]; exact h _ is_open_univ
rw [‚Üêpfun.preimage_univ]
exact h _ is_open_univ
intros
rw [closure_compl, frontier, diff_eq]
intros
suffices : epi f ‚Üî epi ((forget Top).map f)
{ rw [this, category_theory.epi_iff_surjective], refl }
rw [this, category_theory.epi_iff_surjective]
refl
split
{ apply left_adjoint_preserves_epi adj‚ÇÇ }
apply left_adjoint_preserves_epi adj‚ÇÇ
{ apply faithful_reflects_epi }
apply faithful_reflects_epi
intros
split
rintros ‚ü®h, ‚ü®x‚ü©‚ü©
{ rintros ‚ü®h, ‚ü®x‚ü©‚ü©, exactI ‚ü®x, eq_univ_of_univ_subset $ is_preconnected_univ.subset_connected_component (mem_univ x)‚ü© }
exactI ‚ü®x, eq_univ_of_univ_subset $ is_preconnected_univ.subset_connected_component (mem_univ x)‚ü©
rintros ‚ü®x, h‚ü©
{ rintros ‚ü®x, h‚ü©, haveI : preconnected_space Œ± := ‚ü®by { rw ‚Üê h, exact is_preconnected_connected_component }‚ü©, exact ‚ü®‚ü®x‚ü©‚ü© }
haveI : preconnected_space Œ± := ‚ü®by { rw ‚Üê h, exact is_preconnected_connected_component }‚ü©
exact ‚ü®‚ü®x‚ü©‚ü©
intros
{ rw nhds_prod_eq, exact ha.prod hb }
rw nhds_prod_eq
exact ha.prod hb
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
convert sup_mem_subalgebra_closure A f g
apply set_like.ext'
symmetry
erw closure_eq_iff_is_closed
exact h
intros
rw [‚Üê singleton_union, nhds_within_union, nhds_within_singleton]
intros
haveI := (mem_closure_iff_nhds_within_ne_bot.1 hx)
haveI := (mem_closure_iff_nhds_within_ne_bot.1 hx); exact (mem_closure_of_tendsto h $ mem_of_superset self_mem_nhds_within (subset_preimage_image f s))
exact (mem_closure_of_tendsto h $ mem_of_superset self_mem_nhds_within (subset_preimage_image f s))
intros
rw [local_triv_at, local_triv_apply, coord_change_self]
{ rw [local_triv_at, local_triv_apply, coord_change_self], exact Z.mem_base_set_at b }
exact Z.mem_base_set_at b
intros
ext x
cases x
simp
intros
rw [‚Üê not_iff_not, not_not, not_summable_iff_tendsto_nat_at_top_of_nonneg hf]
intros
rw [e.restr_source, hs.interior_eq]
intros
convert ‚Üêhf.open_iff_image_open.symm
rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
intros
refine ‚ü®Œª H Œµ hŒµ, H _ (dist_mem_uniformity hŒµ), Œª H u hu x hx, _‚ü©
rcases mem_uniformity_dist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©
rcases H Œµ Œµpos x hx with ‚ü®t, ht, Ht‚ü©
exact ‚ü®t, ht, Ht.mono (Œª n hs x hx, hŒµ (hs x hx))‚ü©
intros
rw edist_comm z; apply edist_triangle
rw edist_comm z
apply edist_triangle
intros
simp [Hausdorff_dist]
intros
{ rw ‚Üê image_univ, exact hf.diam_image univ }
rw ‚Üê image_univ
exact hf.diam_image univ
intros
simp [lipschitz_on_with, lipschitz_with]
intros
refine congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ (Œª j hj, _))
rw [ne.def, sub_eq_self] at hj
rw [finset.mem_filter, iff.comm, and_iff_right_iff_imp]
exact flip (ht j) hj
intros
simp_rw [‚Üê upper_semicontinuous_within_at_univ_iff] at *
{ simp_rw [‚Üê upper_semicontinuous_within_at_univ_iff] at *, exact hf.add' hg hcont }
exact hf.add' hg hcont
intros
constructor
rw discrete_topology.eq_bot Y
exact induced_bot hf
intros
rw [stalk_pushforward, germ, colimit.Œπ_map_assoc, colimit.Œπ_pre, whisker_right_app]
erw [category_theory.functor.map_id, category.id_comp]
refl
intros
simp [has_basis_coclosed_compact.mem_iff, and_assoc]
intros
rcases compact_univ.ultrafilter_le_nhds F (by simp) with ‚ü®x, -, h‚ü©
exact le_nhds_Lim ‚ü®x,h‚ü©
intros
cases x
refine mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem) (union_subset _ _)
refine mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem) (union_subset _ _); rintro _ ‚ü®‚ü®_, b‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©
{ refine mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem) (union_subset _ _); rintro _ ‚ü®‚ü®_, b‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©, exact h rfl }
rintro _ ‚ü®‚ü®_, b‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©
exact h rfl
rintro _ ‚ü®‚ü®_, b‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©
refine mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs))) (union_subset _ _)
refine mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs))) (union_subset _ _); rintro _ ‚ü®‚ü®a, _‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©
{ refine mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs))) (union_subset _ _); rintro _ ‚ü®‚ü®a, _‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©, exact h rfl }
rintro _ ‚ü®‚ü®a, _‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©
rintro _ ‚ü®‚ü®a, _‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©
exact h rfl
intros
rw mem_ball_symmetry hV at hx
exact ‚ü®z, hx, hy‚ü©
intros
rw separation_rel_eq_inter_closure
apply is_closed_sInter
rintros _ ‚ü®t, t_in, rfl‚ü©
exact is_closed_closure
intros
simpa using x.2.2
intros
simp [pure_seq_eq_map]
intros
cases b; simp
cases b
simp
simp
intros
have h := int.le_neg_add_of_add_le (int.sub_left_le_of_le_add h)
rwa int.add_comm at h
intros
simp [join, list.bind]
intros
rw [div_def a, if_pos]
split
split ; assumption
assumption
assumption
intros
rw [‚Üêzero_add (p -·µ• p), ‚Üêvadd_vsub_assoc, vadd_vsub]
intros
intros f g w
ext
exact congr_fun w a
intros
suffices : span R (t : set A) * (‚®Ü i, span R (s i)) = (‚®Ü i, span R t * span R (s i))
{ simpa only [span_eq] using this }
simpa only [span_eq] using this
simp_rw [span_mul_span, ‚Üê span_Union, span_mul_span, set.mul_Union]
intros
ext x
{ ext x, simp [mem_bot, -set.singleton_one, submodule.mem_span_singleton, algebra.smul_def] }
simp [mem_bot, -set.singleton_one, submodule.mem_span_singleton, algebra.smul_def]
intros
rw [algebra_map_eq R S A, ring_hom.comp_apply]
intros
classical
{ classical, simp_rw [prod_eq_mul_prod_diff_singleton hi, ‚Üê h1, right_distrib], congr' 2; apply prod_congr rfl; simpa }
simp_rw [prod_eq_mul_prod_diff_singleton hi, ‚Üê h1, right_distrib]
congr' 2; apply prod_congr rfl; simpa
congr' 2; apply prod_congr rfl
congr' 2
apply prod_congr rfl
simpa
apply prod_congr rfl
simpa
intros
split_ifs
haveI : unique p := ‚ü®‚ü®h‚ü©, Œª _, rfl‚ü©
{ haveI : unique p := ‚ü®‚ü®h‚ü©, Œª _, rfl‚ü©, exact finprod_unique f }
exact finprod_unique f
haveI : is_empty p := ‚ü®h‚ü©
{ haveI : is_empty p := ‚ü®h‚ü©, exact finprod_of_is_empty f }
exact finprod_of_is_empty f
intros
simp [@eq_comm _ a]
intros
rw [‚Üê sum_range_id_mul_two n, nat.mul_div_cancel]
rw [‚Üê sum_range_id_mul_two n, nat.mul_div_cancel]; exact dec_trivial
exact dec_trivial
intros
refine le_trans (multiset.le_prod_of_submultiplicative f h_one h_mul _) _
rw multiset.map_map
refl
intros
simpa [w] using nat_mul_inj h
intros
simp [of_h_eq_int_fract_pair_seq1_fst_b, int_fract_pair.of]
intros
simp only [denom_eq_conts_b, (continuants_stable_of_terminated n_le_m terminated_at_n)]
intros
rw of_mul_of
dsimp [has_mul.mul, direct_sum.of, dfinsupp.single_add_hom_apply]
congr' 1
rw zero_add
apply eq_rec_heq
intros
rw [dvd_add_iff_right (h.mul_right _), div_add_mod]
intros
simpa only [div_eq_mul_inv] using (right_distrib a b (c‚Åª¬π)).symm
intros
{ ext, simp [ceil_le, lt_ceil] }
ext
simp [ceil_le, lt_ceil]
intros
let s : subalgebra R (free_algebra R X) := { carrier := C, mul_mem' := h_mul, add_mem' := h_add, algebra_map_mem' := h_grade0, }
let of : X ‚Üí s := subtype.coind (Œπ R) h_grade1
have of_id : alg_hom.id R (free_algebra R X) = s.val.comp (lift R of)
ext
{ ext, simp [of, subtype.coind], }
simp [of, subtype.coind]
convert subtype.prop (lift R of a)
simp [alg_hom.ext_iff] at of_id
exact of_id a
intros
rw [‚Üê gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_cons]
{ rw [‚Üê gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_cons], simp }
simp
intros
simp [geom_sum_def]
intros
rw [mul_eq_one_iff_eq_inv, inv_inv]
intros
simp only [mul_assoc, h.eq]
intros
unfold semiconj_by; rw [units.inv_mul_cancel_right]
unfold semiconj_by
rw [units.inv_mul_cancel_right]
intros
simp only [sq, add_mul_self_eq]
intros
by_cases ab : a ‚â§ b
{ exact abs_add_eq_add_abs_le ab }
exact abs_add_eq_add_abs_le ab
rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ((not_le.mp ab).le), and.comm, @and.comm (b ‚â§ 0 ) _]
{ rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ((not_le.mp ab).le), and.comm, @and.comm (b ‚â§ 0 ) _] }
intros
simp
intros
{ rw div_eq_mul_inv, exact mul_ne_zero ha (inv_ne_zero hb) }
rw div_eq_mul_inv
exact mul_ne_zero ha (inv_ne_zero hb)
intros
rw [‚Üê mul_div_assoc, div_mul_cancel _ hc]
intros
{ dsimp [augment], rcases i with _|i, refl, refl, }
dsimp [augment]
rcases i with _|i
refl
refl
intros
rcases h : c.next i with _ | ‚ü®j,w‚ü©
{ simp [h] }
simp [h]
{ simp [d_from_eq _ w, next_eq _ w] }
simp [d_from_eq _ w, next_eq _ w]
intros
dsimp [prev_d]
rw c.prev_eq_some w
refl
intros
tidy
intros
{ simp only [indicator], split_ifs, { refl }, rw [zero_mul] }
simp only [indicator]
split_ifs
refl
{ refl }
rw [zero_mul]
intros
suffices : ‚ÅÖI, N‚ÅÜ ‚â§ ‚ä•
from le_bot_iff.mp this
rw [lie_ideal_oper_eq_span, lie_submodule.lie_span_le]
rintros m ‚ü®x, n, h‚ü©
rw trivial_lie_zero at h
simp [‚Üê h]
intros
rw le_inf_iff
{ rw le_inf_iff, split; apply mono_lie_left; [exact inf_le_left, exact inf_le_right], }
split
split; apply mono_lie_left; [exact inf_le_left, exact inf_le_right]
split; apply mono_lie_left
apply mono_lie_left
exact inf_le_left
apply mono_lie_left
exact inf_le_right
intros
ext y
simp only [ad_apply, lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, linear_map.coe_comp, lie_subalgebra.coe_bracket, function.comp_app]
intros
rw [‚Üê derived_series_eq_derived_series_of_ideal_map, map_eq_bot_iff, ker_incl, eq_bot_iff]
intros
{ ext, simp only [ideal_range, range_eq_map], refl }
ext
simp only [ideal_range, range_eq_map]
refl
intros
rw [inv_eq_one_div, mul_comm, ‚Üê div_eq_mul_one_div]
exact div_lt_iff' h
intros
rw [le_div_iff d0, div_mul_eq_mul_div, div_le_iff b0]
intros
by_cases h0 : a = 0
{ simp [h0], }
simp [h0]
rw ‚Üê ne.def at h0
{ rw ‚Üê ne.def at h0, exact (half_lt_self (lt_of_le_of_ne ha_nonneg h0.symm)).le, }
exact (half_lt_self (lt_of_le_of_ne ha_nonneg h0.symm)).le
intros
{ rw [‚Üê mul_le_mul_iff_right a], simp }
rw [‚Üê mul_le_mul_iff_right a]
simp
intros
rw [‚Üê mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
simp [neg_lt_iff_pos_add, ‚Üê two_mul, mul_pos_iff, zero_lt_one, (@zero_lt_two Œ± _ _).not_lt]
intros
cases a; simp [mul_def, h]; refl
cases a; simp [mul_def, h]
cases a
simp [mul_def, h]
refl
simp [mul_def, h]
refl
intros
haveI := @linear_order.decidable_le Œ± _; exact lt_of_not_ge (assume h2 : a ‚â• 0, (decidable.mul_nonneg h2 h1).not_lt h)
haveI := @linear_order.decidable_le Œ± _
exact lt_of_not_ge (assume h2 : a ‚â• 0, (decidable.mul_nonneg h2 h1).not_lt h)
intros
rw [‚Üê sub_pos, ‚Üê mul_sub]
exact ordered_ring.mul_pos _ _ h‚ÇÇ (sub_pos.2 h‚ÇÅ)
intros
simpa only [sub_eq_neg_add] using h.nat_mul n (-x)
intros
{ simp only [‚Üê image_smul, image_subset, h] }
simp only [‚Üê image_smul, image_subset, h]
intros
induction t using quotient.induction_on
simpa using coeff_list_prod_of_nat_degree_le _ _ hl
intros
rw [discrim, sq]
obtain ha|rfl|ha : a < 0 ‚à® a = 0 ‚à® 0 < a := lt_trichotomy a 0
have : tendsto (Œª x, (a * x + b) * x + c) at_top at_bot := tendsto_at_bot_add_const_right _ c ((tendsto_at_bot_add_const_right _ b (tendsto_id.neg_const_mul_at_top ha)).at_bot_mul_at_top tendsto_id)
{ have : tendsto (Œª x, (a * x + b) * x + c) at_top at_bot := tendsto_at_bot_add_const_right _ c ((tendsto_at_bot_add_const_right _ b (tendsto_id.neg_const_mul_at_top ha)).at_bot_mul_at_top tendsto_id), rcases (this.eventually (eventually_lt_at_bot 0)).exists with ‚ü®x, hx‚ü©, exact false.elim ((h x).not_lt $ by rwa ‚Üê add_mul) }
rcases (this.eventually (eventually_lt_at_bot 0)).exists with ‚ü®x, hx‚ü©
exact false.elim ((h x).not_lt $ by rwa ‚Üê add_mul)
rcases em (b = 0) with (rfl|hb)
{ rcases em (b = 0) with (rfl|hb), { simp }, { have := h ((-c - 1) / b), rw [mul_div_cancel' _ hb] at this, linarith } }
{ simp }
simp
{ have := h ((-c - 1) / b), rw [mul_div_cancel' _ hb] at this, linarith }
have := h ((-c - 1) / b)
rw [mul_div_cancel' _ hb] at this
linarith
have := calc 4 * a * (a * (-(b / a) * (1 / 2)) * (-(b / a) * (1 / 2)) + b * (-(b / a) * (1 / 2)) + c) = (a * (b / a)) * (a * (b / a)) - 2 * (a * (b / a)) * b + 4 * a * c : by ring ... = -(b * b - 4 * a * c) : by { simp only [mul_div_cancel' b (ne_of_gt ha)], ring }
{ have := calc 4 * a * (a * (-(b / a) * (1 / 2)) * (-(b / a) * (1 / 2)) + b * (-(b / a) * (1 / 2)) + c) = (a * (b / a)) * (a * (b / a)) - 2 * (a * (b / a)) * b + 4 * a * c : by ring ... = -(b * b - 4 * a * c) : by { simp only [mul_div_cancel' b (ne_of_gt ha)], ring }, have ha' : 0 ‚â§ 4 * a, by linarith, have h := (mul_nonneg ha' (h (-(b / a) * (1 / 2)))), rw this at h, rwa ‚Üê neg_nonneg }
have ha' : 0 ‚â§ 4 * a
linarith
linarith
have h := (mul_nonneg ha' (h (-(b / a) * (1 / 2))))
rw this at h
rwa ‚Üê neg_nonneg
intros
cases q‚ÇÅ
cases q‚ÇÇ
congr'
rw [‚Üêq‚ÇÅ_i_mul_j, ‚Üêq‚ÇÇ_i_mul_j]
congr'
intros
{ rw ‚Üê smul_eq_mul at ab, exact ab.of_smul _ }
rw ‚Üê smul_eq_mul at ab
exact ab.of_smul _
intros
intros x y h'
rw ‚Üêsub_eq_zero
refine h _ _
rw [mul_sub, sub_eq_zero, h']
intros
ext x
simp only [mem_zero_locus, set.mem_preimage, comap_as_ideal, set.image_subset_iff]
refl
intros
substs hf hg
intros
have v_eq : v = (Œª i, 0) := subsingleton.elim _ _
have zero_mem : (0 : E) ‚àà emetric.ball (0 : E) r
simp [hf.r_pos]
simp [hf.r_pos]
have : ‚àÄ i ‚â† 0, pf i (Œª j, 0) = 0
assume i hi
{ assume i hi, have : 0 < i := pos_iff_ne_zero.2 hi, exact continuous_multilinear_map.map_coord_zero _ (‚ü®0, this‚ü© : fin i) rfl }
have : 0 < i := pos_iff_ne_zero.2 hi
exact continuous_multilinear_map.map_coord_zero _ (‚ü®0, this‚ü© : fin i) rfl
have A := (hf.has_sum zero_mem).unique (has_sum_single _ this)
simpa [v_eq] using A.symm
intros
rcases huv.exists_pos with ‚ü®c, hc, hcuv‚ü©
rw is_O_with at hcuv
convert tendsto.at_top_div_const hc (tendsto_at_top_mono' l hcuv hu)
ext x
rw mul_div_cancel_left _ hc.ne.symm
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hd.const_mul c
intros
simpa using (has_fderiv_within_at.smul hc hf).has_deriv_within_at
intros
refine hf.iterate _ hx n
convert tendsto_inf.2 ‚ü®hf.continuous_within_at, _‚ü©
exacts [hx.symm, (tendsto_principal_principal.2 hs).mono_left inf_le_right]
intros
simp only [sub_eq_add_neg, differentiable_add_const_iff]
intros
refine ‚ü®Œª H, _, Œª H, iso.has_fderiv_at.comp_has_fderiv_within_at x H‚ü©
have A : f = iso.symm ‚àò (iso ‚àò f)
rw [‚Üê function.comp.assoc, iso.symm_comp_self]
rw [‚Üê function.comp.assoc, iso.symm_comp_self]
{ rw [‚Üê function.comp.assoc, iso.symm_comp_self], refl }
{ rw [‚Üê function.comp.assoc, iso.symm_comp_self], refl }
refl
refl
have B : f' = (iso.symm : F ‚ÜíL[ùïú] E).comp ((iso : E ‚ÜíL[ùïú] F).comp f')
rw [‚Üê continuous_linear_map.comp_assoc, iso.coe_symm_comp_coe, continuous_linear_map.id_comp]
rw [‚Üê continuous_linear_map.comp_assoc, iso.coe_symm_comp_coe, continuous_linear_map.id_comp]
rw [A, B]
exact iso.symm.has_fderiv_at.comp_has_fderiv_within_at x H
intros
simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhds_within_restrict' s ht]
intros
simpa using h.neg.has_fderiv_within_at_nonpos hf.neg hy
intros
simp [times_cont_diff_on_univ.symm, times_cont_diff_on_top]
intros
rw ‚Üê h.zero_eq x hx
{ rw ‚Üê h.zero_eq x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
symmetry
exact continuous_multilinear_map.uncurry0_curry0 _
intros
rw ‚Üê add_image_prod
{ rw ‚Üê add_image_prod, exact (hs.prod ht).is_linear_image is_linear_map.is_linear_map_add }
exact (hs.prod ht).is_linear_image is_linear_map.is_linear_map_add
intros
obtain ‚ü®B, hB‚ü© := hF
refine ‚ü®(sInter_subset_of_mem hB).trans (hAF B hB).1, Œª x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxF hx, _‚ü©
simp_rw mem_sInter at ‚ä¢ hxF
have h := Œª B hB, (hAF B hB).2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x (hxF B hB) hx
exact ‚ü®Œª B hB, (h B hB).1, Œª B hB, (h B hB).2‚ü©
intros
simpa [measure_univ] using hs.smul_integral_mem hsc (is_probability_measure.ne_zero Œº) hf hfi
intros
simp only [inner_add_left, inner_add_right]; ring
simp only [inner_add_left, inner_add_right]
ring
intros
rw [is_R_or_C.ext_iff]; exact ‚ü®by rw [conj_re], by rw [conj_im, inner_self_im_zero, neg_zero]‚ü©
rw [is_R_or_C.ext_iff]
exact ‚ü®by rw [conj_re], by rw [conj_im, inner_self_im_zero, neg_zero]‚ü©
intros
rw closed_ball_eq_image
exact (proper_space.is_compact_closed_ball _ _).image to_euclidean.symm.continuous
intros
exact_mod_cast real.rpow_arith_mean_le_arith_mean_rpow s _ _ (Œª i _, (w i).coe_nonneg) (by exact_mod_cast hw') (Œª i _, (z i).coe_nonneg) hp
intros
convert (vadd_const ùïú (f p)).symm.isometry.comp (hf.comp (vadd_const ùïú p).isometry)
exact funext hg
intros
simpa [dist_eq_norm] using dist_triangle g 0 (-h)
intros
simp [dist_eq_norm]
intros
rw [‚Üê sub_eq_zero, eq_zero_iff_forall_dual_eq_zero ùïú (x - y)]
simp [sub_eq_zero]
intros
obtain ‚ü®_, ‚ü®m : M, H : mk' S m = x, rfl‚ü©, hnorm : ‚à•m‚à• < ‚à•x‚à• + Œµ‚ü© := real.lt_Inf_add_pos (image_norm_nonempty x) hŒµ
subst H
exact ‚ü®m, rfl, hnorm‚ü©
intros
{ ext1, simp [to_span_singleton_apply], }
ext1
simp [to_span_singleton_apply]
intros
rw [ennreal.tsum_eq_supr_nat' (nat.tendsto_pow_at_top_at_top_of_one_lt _root_.one_lt_two)]
refine supr_le (Œª n, (finset.le_sum_condensed hf n).trans (add_le_add_left _ _))
simp only [nsmul_eq_mul, nat.cast_pow, nat.cast_two]
apply ennreal.sum_le_tsum
intros
rw [mem_ball, sub_zero]
simp [log]
intros
rw [‚Üê not_lt, log_neg_iff hx, not_lt]
intros
simp only [one_div, integral_inv_of_neg ha hb]
intros
rw [‚Üê abs_cos_eq_sqrt_one_sub_sin_sq, abs_of_nonneg (cos_nonneg_of_mem_Icc ‚ü®hl, hu‚ü©)]
rw [‚Üê of_real_cos, real.cos_pi]; simp
rw [‚Üê of_real_cos, real.cos_pi]
simp
intros
convert tan_add_mul_I h; exact (re_add_im z).symm
convert tan_add_mul_I h
exact (re_add_im z).symm
intros
have := aux_has_sum_of_le_geometric hr hu
convert dist_le_tsum_of_dist_le_of_tendsto _ hu ‚ü®_, this‚ü© ha n
simp only [pow_add, mul_left_comm C, mul_div_right_comm]
rw [mul_comm]
exact (this.mul_left _).tsum_eq.symm
intros
intros A
refine ‚ü®punit, Œª _, (left_adjoint G).obj A, Œª _, (adjunction.of_right_adjoint G).unit.app A, _‚ü©
intros B h
refine ‚ü®punit.star, ((adjunction.of_right_adjoint G).hom_equiv _ _).symm h, _‚ü©
rw [‚Üêadjunction.hom_equiv_unit, equiv.apply_symm_apply]
intros
suffices : is_iso ((transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ).symm (transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ f))
{ simpa using this }
simpa using this
apply_instance
intros
rw w
intros
{ dsimp [fun_inv_id_assoc], tidy }
dsimp [fun_inv_id_assoc]
tidy
intros
dsimp [coeq‚ÇÉ_hom]
slice_lhs 1 2 { rw coeq_condition f g }
simp only [category.assoc]
intros
rw h
intros
ext
ext; rw [‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_desc, colimit.Œπ_desc]; refl
ext; rw [‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_desc, colimit.Œπ_desc]
rw [‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_desc, colimit.Œπ_desc]
refl
intros
rw [iso.inv_comp_eq, ‚Üê category.assoc, iso.eq_comp_inv, prod.right_unitor_hom_naturality]
intros
{ ext, simp, }
ext
simp
intros
simp [image.pre_comp]
intros
{ simp, refl }
simp
refl
intros
simp only [left_unitor_tensor_inv, assoc, comp_id, hom_inv_id]
intros
intros X S hS
rw ‚Üê presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for
refine ‚ü®_, _‚ü©
rintro x ‚ü®M, hM‚ü© ‚ü®N, hN‚ü© hM‚ÇÇ hN‚ÇÇ
{ rintro x ‚ü®M, hM‚ü© ‚ü®N, hN‚ü© hM‚ÇÇ hN‚ÇÇ, ext, dsimp only [subtype.coe_mk], rw [‚Üê J‚ÇÅ.covers_iff_mem_of_closed hM, ‚Üê J‚ÇÅ.covers_iff_mem_of_closed hN], have q : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ X) (hg : S g), M.pullback g = N.pullback g, { intros Z g hg, apply congr_arg subtype.val ((hM‚ÇÇ g hg).trans (hN‚ÇÇ g hg).symm) }, have MSNS : M ‚äì S = N ‚äì S, { ext Z g, rw [sieve.inter_apply, sieve.inter_apply, and_comm (N g), and_comm], apply and_congr_right, intro hg, rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg] }, split, { intro hf, rw J‚ÇÅ.covers_iff, apply J‚ÇÅ.superset_covering (sieve.pullback_monotone f inf_le_left), rw ‚Üê MSNS, apply J‚ÇÅ.arrow_intersect f M S hf (J‚ÇÅ.pullback_stable _ hS) }, { intro hf, rw J‚ÇÅ.covers_iff, apply J‚ÇÅ.superset_covering (sieve.pullback_monotone f inf_le_left), rw MSNS, apply J‚ÇÅ.arrow_intersect f N S hf (J‚ÇÅ.pullback_stable _ hS) } }
ext
dsimp only [subtype.coe_mk]
rw [‚Üê J‚ÇÅ.covers_iff_mem_of_closed hM, ‚Üê J‚ÇÅ.covers_iff_mem_of_closed hN]
have q : ‚àÄ ‚¶ÉZ : C‚¶Ñ (g : Z ‚ü∂ X) (hg : S g), M.pullback g = N.pullback g
intros Z g hg
{ intros Z g hg, apply congr_arg subtype.val ((hM‚ÇÇ g hg).trans (hN‚ÇÇ g hg).symm) }
apply congr_arg subtype.val ((hM‚ÇÇ g hg).trans (hN‚ÇÇ g hg).symm)
have MSNS : M ‚äì S = N ‚äì S
ext Z g
{ ext Z g, rw [sieve.inter_apply, sieve.inter_apply, and_comm (N g), and_comm], apply and_congr_right, intro hg, rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg] }
rw [sieve.inter_apply, sieve.inter_apply, and_comm (N g), and_comm]
apply and_congr_right
intro hg
rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg]
split
intro hf
{ intro hf, rw J‚ÇÅ.covers_iff, apply J‚ÇÅ.superset_covering (sieve.pullback_monotone f inf_le_left), rw ‚Üê MSNS, apply J‚ÇÅ.arrow_intersect f M S hf (J‚ÇÅ.pullback_stable _ hS) }
rw J‚ÇÅ.covers_iff
apply J‚ÇÅ.superset_covering (sieve.pullback_monotone f inf_le_left)
rw ‚Üê MSNS
apply J‚ÇÅ.arrow_intersect f M S hf (J‚ÇÅ.pullback_stable _ hS)
intro hf
{ intro hf, rw J‚ÇÅ.covers_iff, apply J‚ÇÅ.superset_covering (sieve.pullback_monotone f inf_le_left), rw MSNS, apply J‚ÇÅ.arrow_intersect f N S hf (J‚ÇÅ.pullback_stable _ hS) }
rw J‚ÇÅ.covers_iff
apply J‚ÇÅ.superset_covering (sieve.pullback_monotone f inf_le_left)
rw MSNS
apply J‚ÇÅ.arrow_intersect f N S hf (J‚ÇÅ.pullback_stable _ hS)
intros x hx
{ intros x hx, rw presieve.compatible_iff_sieve_compatible at hx, let M := sieve.bind S (Œª Y f hf, (x f hf).1), have : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) (hf : S f), M.pullback f = (x f hf).1, { intros Y f hf, apply le_antisymm, { rintro Z u ‚ü®W, g, f', hf', (hg : (x f' hf').1 _), c‚ü©, rw [sieve.pullback_eq_top_iff_mem, ‚Üê(show (x (u ‚â´ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))], simp_rw ‚Üê c, rw (show (x (g ‚â´ f') _).1 = _, from congr_arg subtype.val (hx f' g hf')), apply sieve.pullback_eq_top_of_mem _ hg }, { apply sieve.le_pullback_bind S (Œª Y f hf, (x f hf).1) } }, refine ‚ü®‚ü®_, J‚ÇÅ.close_is_closed M‚ü©, _‚ü©, { intros Y f hf, ext1, dsimp, rw [‚Üê J‚ÇÅ.pullback_close, this _ hf], apply le_antisymm (J‚ÇÅ.le_close_of_is_closed (le_refl _) (x f hf).2) (J‚ÇÅ.le_close _) } }
rw presieve.compatible_iff_sieve_compatible at hx
let M := sieve.bind S (Œª Y f hf, (x f hf).1)
have : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) (hf : S f), M.pullback f = (x f hf).1
intros Y f hf
{ intros Y f hf, apply le_antisymm, { rintro Z u ‚ü®W, g, f', hf', (hg : (x f' hf').1 _), c‚ü©, rw [sieve.pullback_eq_top_iff_mem, ‚Üê(show (x (u ‚â´ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))], simp_rw ‚Üê c, rw (show (x (g ‚â´ f') _).1 = _, from congr_arg subtype.val (hx f' g hf')), apply sieve.pullback_eq_top_of_mem _ hg }, { apply sieve.le_pullback_bind S (Œª Y f hf, (x f hf).1) } }
apply le_antisymm
rintro Z u ‚ü®W, g, f', hf', (hg : (x f' hf').1 _), c‚ü©
{ rintro Z u ‚ü®W, g, f', hf', (hg : (x f' hf').1 _), c‚ü©, rw [sieve.pullback_eq_top_iff_mem, ‚Üê(show (x (u ‚â´ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))], simp_rw ‚Üê c, rw (show (x (g ‚â´ f') _).1 = _, from congr_arg subtype.val (hx f' g hf')), apply sieve.pullback_eq_top_of_mem _ hg }
rw [sieve.pullback_eq_top_iff_mem, ‚Üê(show (x (u ‚â´ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))]
simp_rw ‚Üê c
rw (show (x (g ‚â´ f') _).1 = _, from congr_arg subtype.val (hx f' g hf'))
apply sieve.pullback_eq_top_of_mem _ hg
{ apply sieve.le_pullback_bind S (Œª Y f hf, (x f hf).1) }
apply sieve.le_pullback_bind S (Œª Y f hf, (x f hf).1)
refine ‚ü®‚ü®_, J‚ÇÅ.close_is_closed M‚ü©, _‚ü©
intros Y f hf
{ intros Y f hf, ext1, dsimp, rw [‚Üê J‚ÇÅ.pullback_close, this _ hf], apply le_antisymm (J‚ÇÅ.le_close_of_is_closed (le_refl _) (x f hf).2) (J‚ÇÅ.le_close _) }
ext1
dsimp
rw [‚Üê J‚ÇÅ.pullback_close, this _ hf]
apply le_antisymm (J‚ÇÅ.le_close_of_is_closed (le_refl _) (x f hf).2) (J‚ÇÅ.le_close _)
intros
intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm
rw [‚Üê(some_spec (some_spec (some_spec h‚ÇÅ))).2, ‚Üê(some_spec (some_spec (some_spec h‚ÇÇ))).2, ‚Üêassoc, ‚Üêassoc] at comm
dsimp [family_of_elements.sieve_extend]
rw [‚Üê functor_to_types.map_comp_apply, ‚Üê functor_to_types.map_comp_apply]
apply hx _ _ _ _ comm
intros
{ ext, simp, }
ext
simp
intros
rw [le_iff_le_iff_lt_iff_lt, sum_two_pow_lt_iff_lt]
intros
rw set.eq_empty_iff_forall_not_mem
intros f hyp
rw remove_none.mem_fiber at hyp
rcases hyp with ‚ü®F, F_derangement, F_none, _‚ü©
exact F_derangement none F_none
intros
ext i j
obtain (h'|h') := h.zero_or_one i j; simp [h']
obtain (h'|h') := h.zero_or_one i j
simp [h']
simp [h']
intros
obtain ‚ü®t, ht : _ = _‚ü© := finset.max_of_mem (mem_image_of_mem (Œª v, G.degree v) (mem_univ v))
have := finset.le_max_of_mem (mem_image_of_mem _ (mem_univ v)) ht
rwa [max_degree, ht, option.get_or_else_some]
intros
refl
intros
simpa using hf.comp' (partrec'.cons hg partrec'.nil)
intros
simpa [bind_some_eq_map] using @@partrec.bind _ _ _ (Œª a b, part.some (g a b)) hf hg
intros
simp! [(<*>)]
intros
simp [nil]
intros
rcases s with _|_|_; refl
rcases s with _|_|_
refl
refl
refl
intros
conv {to_rhs, rw ‚Üê T.move_right_left}; rw [tape.move_left_nth, add_sub_cancel]
conv {to_rhs, rw ‚Üê T.move_right_left}
rw [tape.move_left_nth, add_sub_cancel]
intros
simp only [to_list_spec,free.map_eq_map,fold_map_hom (free.map.is_monoid_hom f), fold_map_map]
simp only [to_list_spec,free.map_eq_map,fold_map_hom (free.map.is_monoid_hom f), fold_map_map]; refl
{ simp only [to_list_spec,free.map_eq_map,fold_map_hom (free.map.is_monoid_hom f), fold_map_map]; refl }
refl
intros
rw[‚Üêrev_list_reverse, list.length_reverse, rev_list_length]
intros
simp [of_nat]; cases nat.decidable_eq n 0; cases nat.decidable_eq m 0; simp only [to_bool]
simp [of_nat]; cases nat.decidable_eq n 0; cases nat.decidable_eq m 0
simp [of_nat]; cases nat.decidable_eq n 0
simp [of_nat]
cases nat.decidable_eq n 0
cases nat.decidable_eq m 0
simp only [to_bool]
simp only [to_bool]
subst m
{ subst m, have h := le_antisymm h (nat.zero_le _), contradiction }
have h := le_antisymm h (nat.zero_le _)
contradiction
cases nat.decidable_eq m 0
simp only [to_bool]
{ left, refl }
left
refl
simp only [to_bool]
intros
cases l
{ refl }
refl
rw [list.to_buffer, to_list_append_list]
{ rw [list.to_buffer, to_list_append_list], refl }
refl
intros
cases reps
{ exact bounded.foldr_core_zero }
exact bounded.foldr_core_zero
constructor
intros cb n hn
obtain ‚ü®np, errp, hp‚ü© := bounded.exists p hn
simpa [foldr_core_succ_eq_fail, hp] using he cb n np errp
intros
simp [pure_eq_done]
intros
by_cases hp : p; simp [guard, hp, pure_eq_done]
{ by_cases hp : p; simp [guard, hp, pure_eq_done] }
by_cases hp : p
simp [guard, hp, pure_eq_done]
simp [guard, hp, pure_eq_done]
intros
simp [foldr_core, eq_comm]
intros
rw ‚Üê of_real_inj; simp [cosh_sq_sub_sinh_sq]
rw ‚Üê of_real_inj
simp [cosh_sq_sub_sinh_sq]
intros
simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]
intros
rw [exp_add, exp_mul_I]
intros
rw [of_real_alg, zero_smul]
intros
rw [lt_iff_le_and_ne, ne, eq_comm]; simp [norm_sq_nonneg]
rw [lt_iff_le_and_ne, ne, eq_comm]
simp [norm_sq_nonneg]
rw [finrank_eq_card_basis basis_one_I, fintype.card_fin]
intros
rw [filter_single, if_pos h]
intros
ext i
by_cases h : g i ‚â† 0; simp at h; simp [h, hf]
by_cases h : g i ‚â† 0; simp at h
by_cases h : g i ‚â† 0
simp at h
simp [h, hf]
simp at h
simp [h, hf]
intros
{ rw [supr_comm], simp [mem_decode‚ÇÇ] }
rw [supr_comm]
simp [mem_decode‚ÇÇ]
intros
simpa [equiv.perm.via_fintype_embedding, equiv.perm.extend_domain_apply_subtype, h]
intros
rw [inter_comm, e.left_inv_on.image_inter', image_source_eq_target, inter_comm]
intros
have h‚ÇÅ : f.to_equiv = g.to_equiv := equiv.ext h
cases f
cases g
congr
{ exact (funext h) }
exact (funext h)
{ exact congr_arg equiv.inv_fun h‚ÇÅ }
exact congr_arg equiv.inv_fun h‚ÇÅ
intros
simp [pred_above, h]
intros
simp [insert_nth, succ_above_cases]
intros
rw [‚Üê coe_inj, coe_sdiff, coe_sdiff, coe_insert]
exact set.insert_diff_of_mem s h
intros
simp only [filter_not, union_sdiff_of_subset (filter_subset p s)]
intros
simp only [mem_def, bUnion_val, mem_erase_dup, mem_bind, exists_prop]
intros
simpa only [disjoint.comm] using disjoint_bUnion_left t f s
intros
simp
intros
rw [‚Üêwith_bot.coe_le_coe, coe_sup']
{ rw [‚Üêwith_bot.coe_le_coe, coe_sup'], exact sup_le (Œª b h, with_bot.coe_le_coe.2 $ hs b h), }
exact sup_le (Œª b h, with_bot.coe_le_coe.2 $ hs b h)
intros
induction s using finset.strong_induction_on with s ihs
rcases s.eq_empty_or_nonempty with rfl|hne
{ exact h0 }
exact h0
have H : s.max' hne ‚àà s
{ have H : s.max' hne ‚àà s, from max'_mem s hne, rw ‚Üê insert_erase H, exact step _ _ (Œª x, s.lt_max'_of_mem_erase_max' hne) (ihs _ $ erase_ssubset H) }
from max'_mem s hne
rw ‚Üê insert_erase H
exact step _ _ (Œª x, s.lt_max'_of_mem_erase_max' hne) (ihs _ $ erase_ssubset H)
intros
classical
induction s using finset.induction_on with a s ha IH
{ simp }
simp
{ simp [ha, IH] }
simp [ha, IH]
intros
simp only [mem_antidiagonal, add_comm, prod.swap]
intros
rw [‚Üêfunction.embedding.coe_fn_mk f hf, ‚Üêemb_domain_eq_map_domain, prod_emb_domain]
intros
{ ext, simp [equiv_fun_on_fintype], }
ext
simp [equiv_fun_on_fintype]
intros
erw ‚Üêmap_range_comp
have : (f ‚àò (‚Ä¢) c) = ((‚Ä¢) c ‚àò f) := funext hsmul
simp_rw this
apply map_range_comp
rw [function.comp_apply, smul_zero, hf]
intros
simp only [card_eq_one, support_eq_singleton']
intros
split
simp only [pi_finset, mem_map, and_imp, forall_prop_of_true, exists_prop, mem_univ, exists_imp_distrib, mem_pi]
{ simp only [pi_finset, mem_map, and_imp, forall_prop_of_true, exists_prop, mem_univ, exists_imp_distrib, mem_pi], rintro g hg hgf a, rw ‚Üê hgf, exact hg a }
rintro g hg hgf a
rw ‚Üê hgf
exact hg a
simp only [pi_finset, mem_map, forall_prop_of_true, exists_prop, mem_univ, mem_pi]
{ simp only [pi_finset, mem_map, forall_prop_of_true, exists_prop, mem_univ, mem_pi], exact Œª hf, ‚ü®Œª a ha, f a, hf, rfl‚ü© }
exact Œª hf, ‚ü®Œª a ha, f a, hf, rfl‚ü©
intros
symmetry
apply eq_of_subset_of_card_le (subset_univ ({x}))
apply le_of_eq
simp [h, finset.card_univ]
intros
simpa only [fintype.card_fin] using s.card_le_univ
intros
haveI := classical.prop_decidable; exact have ‚àÄ {f : Œ± ‚Üí Œ±}, injective f ‚Üí surjective f, from Œª f hinj x, have h‚ÇÅ : image f univ = univ := eq_of_subset_of_card_le (subset_univ _) ((card_image_of_injective univ hinj).symm ‚ñ∏ le_refl _), have h‚ÇÇ : x ‚àà image f univ := h‚ÇÅ.symm ‚ñ∏ mem_univ _, exists_of_bex (mem_image.1 h‚ÇÇ), ‚ü®this, Œª hsurj, has_left_inverse.injective ‚ü®surj_inv hsurj, left_inverse_of_surjective_of_right_inverse (this (injective_surj_inv _)) (right_inverse_surj_inv _)‚ü©‚ü©
haveI := classical.prop_decidable
exact have ‚àÄ {f : Œ± ‚Üí Œ±}, injective f ‚Üí surjective f, from Œª f hinj x, have h‚ÇÅ : image f univ = univ := eq_of_subset_of_card_le (subset_univ _) ((card_image_of_injective univ hinj).symm ‚ñ∏ le_refl _), have h‚ÇÇ : x ‚àà image f univ := h‚ÇÅ.symm ‚ñ∏ mem_univ _, exists_of_bex (mem_image.1 h‚ÇÇ), ‚ü®this, Œª hsurj, has_left_inverse.injective ‚ü®surj_inv hsurj, left_inverse_of_surjective_of_right_inverse (this (injective_surj_inv _)) (right_inverse_surj_inv _)‚ü©‚ü©
intros
have nd := v.nodup (mk_idx n (hash_fn a))
refine (v.modify hash_fn [] [] [‚ü®a, b‚ü©] (bkts.read hash_fn a) rfl rfl (list.nodup_singleton _) (Œªa' e, by simp at e; rw e) (Œªa', false.elim) (Œªa' e1 e2, _)).2
simp [-sigma.exists] at e2
subst a'
exact Hnc ((contains_aux_iff nd).2 e1)
intros
apply sub_nat_nat_elim m n (Œª m n i, bodd i = bxor m.bodd n.bodd)
apply sub_nat_nat_elim m n (Œª m n i, bodd i = bxor m.bodd n.bodd); intros; simp; cases i.bodd; simp
apply sub_nat_nat_elim m n (Œª m n i, bodd i = bxor m.bodd n.bodd); intros; simp; cases i.bodd
apply sub_nat_nat_elim m n (Œª m n i, bodd i = bxor m.bodd n.bodd); intros; simp
apply sub_nat_nat_elim m n (Œª m n i, bodd i = bxor m.bodd n.bodd); intros
intros
simp
cases i.bodd
simp
simp
intros
simp
cases i.bodd
simp
simp
intros
rw [H2, int.mul_div_cancel_left _ H1]
intros
contrapose! hc
rw [hc.left, hc.right, gcd_zero_right, nat_abs_zero]
intros
simp [sub_eq_add_neg] with parity_simps
intros
rw eq_comm
convert nth_le_reverse l.reverse _ _ _ using 1
{ simp }
simp
{ simpa }
simpa
intros
induction l; [refl, simp only [*, concat_eq_append, cons_append, map, map_append]]; split; refl
induction l; [refl, simp only [*, concat_eq_append, cons_append, map, map_append]]; split
induction l; [refl, simp only [*, concat_eq_append, cons_append, map, map_append]]
induction l
refl
simp only [*, concat_eq_append, cons_append, map, map_append]
split
refl
refl
intros
induction l with hd tl hl generalizing n
exact absurd n.zero_le (not_le_of_lt (by simpa using hn))
{ exact absurd n.zero_le (not_le_of_lt (by simpa using hn)) }
cases n
{ cases n, { simp }, { simp only [nat.succ_lt_succ_iff, list.length] at hn, simpa [list.nth_le, list.drop] using hl hn } }
{ simp }
simp
simp only [nat.succ_lt_succ_iff, list.length] at hn
{ simp only [nat.succ_lt_succ_iff, list.length] at hn, simpa [list.nth_le, list.drop] using hl hn }
simpa [list.nth_le, list.drop] using hl hn
intros
induction l generalizing a
{ simp }
simp
simp [l_ih, h]
{ simp [l_ih, h] }
intros
induction l with hd tl hl
simp only [forall_const, reduce_option_nil, not_mem_nil, forall_prop_of_false, eq_self_iff_true, length, not_false_iff]
{ simp only [forall_const, reduce_option_nil, not_mem_nil, forall_prop_of_false, eq_self_iff_true, length, not_false_iff] }
cases hd
{ cases hd, { simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and, reduce_option_cons_of_none, length, option.is_some_none, iff_false], intro H, have := reduce_option_length_le tl, rw H at this, exact absurd (nat.lt_succ_self _) (not_lt_of_le this) }, { simp only [hl, true_and, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length, option.is_some_some, reduce_option_cons_of_some] } }
simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and, reduce_option_cons_of_none, length, option.is_some_none, iff_false]
{ simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and, reduce_option_cons_of_none, length, option.is_some_none, iff_false], intro H, have := reduce_option_length_le tl, rw H at this, exact absurd (nat.lt_succ_self _) (not_lt_of_le this) }
intro H
have := reduce_option_length_le tl
rw H at this
exact absurd (nat.lt_succ_self _) (not_lt_of_le this)
simp only [hl, true_and, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length, option.is_some_some, reduce_option_cons_of_some]
{ simp only [hl, true_and, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length, option.is_some_some, reduce_option_cons_of_some] }
intros
obtain ‚ü®xs, ys, rfl‚ü© := h
rw [filter_append, filter_append]
exact infix_append _ _ _
intros
rw erase_eq_erasep; exact mem_erasep_of_neg ab.symm
rw erase_eq_erasep
exact mem_erasep_of_neg ab.symm
intros
induction l generalizing m n
case list.nil : m n { simp }
simp
case list.cons : x xs xs_ih m n { cases m; cases n; simp only [disjoint_cons_left, mem_cons_iff, disjoint_cons_right, drop, true_or, eq_self_iff_true, not_true, false_and, disjoint_nil_left, take], { cases h }, cases hl with _ _ h‚ÇÄ h‚ÇÅ, split, { intro h, exact h‚ÇÄ _ (mem_of_mem_drop h) rfl, }, solve_by_elim [le_of_succ_le_succ] { max_depth := 4 } }
intros
subst l‚ÇÅ
intros
cases l; [refl, exact chain_map _]
cases l
refl
exact chain_map _
intros
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem hx
obtain ‚ü®n, rfl‚ü© := id h
rw [next_nth_le _ hn]
simp_rw ‚Üênth_le_rotate' _ n k
rw [next_nth_le _ (h.nodup_iff.mp hn), ‚Üênth_le_rotate' _ n]
simp [add_assoc]
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
cases h with _ hm _ _ hm
{ cases h with _ hm _ _ hm, { exact or.inl ‚ü®rfl, hm‚ü© }, { exact or.inr hm } }
{ exact or.inl ‚ü®rfl, hm‚ü© }
exact or.inl ‚ü®rfl, hm‚ü©
{ exact or.inr hm }
exact or.inr hm
rcases h with ‚ü®rfl|h‚ü©|h
{ rcases h with ‚ü®rfl|h‚ü©|h, { simpa }, { exact h.cons_duplicate } }
{ simpa }
simpa
{ exact h.cons_duplicate }
exact h.cons_duplicate
intros
dsimp [Ico]; rw nat.sub_sub_self h; simp
dsimp [Ico]; rw nat.sub_sub_self h
dsimp [Ico]
rw nat.sub_sub_self h
simp
intros
rw [diff_eq_filter_of_nodup hl‚ÇÅ, mem_filter]
intros
intros s t h
apply insert_nth_injective s.length x
have hl : s.length = t.length := by simpa using congr_arg length h
rw [‚Üênth_le_permutations'_aux s x s.length (by simp), ‚Üênth_le_permutations'_aux t x s.length (by simp [hl])]
simp [h, hl]
intros
induction h generalizing l; simp [*, perm.erase, erase_comm] <|> exact (ih_1 _).trans (ih_2 _)
induction h generalizing l
simp [*, perm.erase, erase_comm]
simp [*, perm.erase, erase_comm]
simp [*, perm.erase, erase_comm]
simp [*, perm.erase, erase_comm]
intros
simp only [range_eq_range', length_range']
intros
rw [nodupkeys_iff_pairwise, pairwise_join, pairwise_map]
refine and_congr (ball_congr $ Œª l h, by simp [nodupkeys_iff_pairwise]) _
apply iff_of_eq
congr' with l‚ÇÅ l‚ÇÇ
simp [keys, disjoint_iff_ne]
intros
unfold_wf
induction xs with y ys
{ simp }
simp
by_cases x = y.1; simp [*, list.sizeof]
{ by_cases x = y.1; simp [*, list.sizeof] }
by_cases x = y.1
simp [*, list.sizeof]
simp [*, list.sizeof]
intros
induction l‚ÇÅ generalizing l‚ÇÇ i
{ simp [zip_with] }
simp [zip_with]
cases l‚ÇÇ; simp only [zip_with, nth, exists_false, and_false, false_and]
cases l‚ÇÇ
{ cases l‚ÇÇ; simp only [zip_with, nth, exists_false, and_false, false_and], cases i; simp *, }
simp only [zip_with, nth, exists_false, and_false, false_and]
simp only [zip_with, nth, exists_false, and_false, false_and]
cases i; simp *
cases i
simp *
simp *
intros
{ ext, apply dot_product_comm }
ext
apply dot_product_comm
intros
ext
{ext, refl}
refl
intros
simpa [dot_product, finset.mul_sum, finset.sum_mul, mul_assoc] using finset.sum_comm
intros
unfold std_basis_matrix
ext
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
simp [sub_eq_add_neg]
intros
simp
intros
ext
ext; simp only [transpose, mem_iff_mem f, to_matrix]; congr
ext; simp only [transpose, mem_iff_mem f, to_matrix]
simp only [transpose, mem_iff_mem f, to_matrix]
intros
simpa [countp_eq_card_filter] using card_le_of_le (filter_le_filter p h)
intros
simp only [singleton_eq_cons, mem_cons, iff_self, or_false, not_mem_zero]
intros
{ rw [‚Üê eval_map, ‚Üê eval_map, map_map], }
rw [‚Üê eval_map, ‚Üê eval_map, map_map]
intros
{ ext1 r, exact eval‚ÇÇ_C f g r }
ext1 r
exact eval‚ÇÇ_C f g r
intros
apply œÜ.induction_on
{ intro a, simp only [constant_coeff_C, rename_C]}
intro a
simp only [constant_coeff_C, rename_C]
intros p q hp hq
{ intros p q hp hq, simp only [hp, hq, ring_hom.map_add, alg_hom.map_add] }
simp only [hp, hq, ring_hom.map_add, alg_hom.map_add]
intros p n hp
{ intros p n hp, simp only [hp, rename_X, constant_coeff_X, ring_hom.map_mul, alg_hom.map_mul] }
simp only [hp, rename_X, constant_coeff_X, ring_hom.map_mul, alg_hom.map_mul]
intros
rw [succ_div, if_neg hba, add_zero]
intros
simp [find_greatest_eq_iff]
intros
rw [‚Üê lt_succ_iff, div_lt_iff_lt_mul _ _ n0, succ_mul, mul_comm]
cases n
cases n0
{cases n0}
exact lt_succ_iff
intros
{ simp only [strong_rec_on'], rw nat.strong_rec' }
simp only [strong_rec_on']
rw nat.strong_rec'
intros
conv {to_rhs, rw [‚Üê nat.mod_add_div n 2, hn, nat.add_sub_cancel_left]}
intros
rw [‚Üê cast_one, cast_lt]
intros
simpa using (add_pow 1 1 n).symm
intros
rw [lt_iff_le_not_le, lt_iff_le_not_le, coe_le_coe, coe_le_coe]
intros
rw ‚Üê with_top_equiv_lt; simp
rw ‚Üê with_top_equiv_lt
simp
intros
split
intro h
{ intro h, exact ‚ü®eq_zero_of_gcd_eq_zero_left h, eq_zero_of_gcd_eq_zero_right h‚ü©, }
exact ‚ü®eq_zero_of_gcd_eq_zero_left h, eq_zero_of_gcd_eq_zero_right h‚ü©
intro h
{ intro h, rw [h.1, h.2], exact nat.gcd_zero_right _ }
rw [h.1, h.2]
exact nat.gcd_zero_right _
intros
refine ‚ü®Œª h, _, Œª h, pow_dvd_pow_of_dvd h _‚ü©
cases nat.eq_zero_or_pos (gcd a b) with g0 g0
{ simp [eq_zero_of_gcd_eq_zero_right g0] }
simp [eq_zero_of_gcd_eq_zero_right g0]
rcases exists_coprime' g0 with ‚ü®g, a', b', g0', co, rfl, rfl‚ü©
rw [mul_pow, mul_pow] at h
replace h := dvd_of_mul_dvd_mul_right (pow_pos g0' _) h
have := pow_dvd_pow a' n0
rw [pow_one, (co.pow n n).eq_one_of_dvd h] at this
simp [eq_one_of_dvd_one this]
intros
induction y using nat.strong_induction_on with y ih generalizing x
cases x
{ exact iff_of_true hy (zero_le _) }
exact iff_of_true hy (zero_le _)
rw log
split_ifs
have b_pos : 0 < b := zero_le_one.trans_lt hb
{ have b_pos : 0 < b := zero_le_one.trans_lt hb, rw [succ_eq_add_one, add_le_add_iff_right, ‚Üêih (y / b) (div_lt_self hy hb) (nat.div_pos h.1 b_pos), le_div_iff_mul_le _ _ b_pos, pow_succ'] }
rw [succ_eq_add_one, add_le_add_iff_right, ‚Üêih (y / b) (div_lt_self hy hb) (nat.div_pos h.1 b_pos), le_div_iff_mul_le _ _ b_pos, pow_succ']
refine iff_of_false (Œª hby, h ‚ü®le_trans _ hby, hb‚ü©) (not_succ_le_zero _)
{ refine iff_of_false (Œª hby, h ‚ü®le_trans _ hby, hb‚ü©) (not_succ_le_zero _), convert pow_mono hb.le (zero_lt_succ x), exact (pow_one b).symm }
convert pow_mono hb.le (zero_lt_succ x)
exact (pow_one b).symm
intros
rw [modeq, zero_mod, dvd_iff_mod_eq_zero]
intros
simp [bit1] with parity_simps
intros
cases b; cases n; refl
cases b; cases n
cases b
cases n
refl
refl
cases n
refl
refl
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x
simp only [not_mem_none, exists_false, pmap, not_false_iff, exists_prop_of_false]
{ simp only [not_mem_none, exists_false, pmap, not_false_iff, exists_prop_of_false] }
split
{ split, { intro h, simp only [pmap] at h, exact ‚ü®x, rfl, h‚ü© }, { rintro ‚ü®a, H, rfl‚ü©, simp only [mem_def] at H, simp only [H, pmap] } }
intro h
{ intro h, simp only [pmap] at h, exact ‚ü®x, rfl, h‚ü© }
simp only [pmap] at h
exact ‚ü®x, rfl, h‚ü©
rintro ‚ü®a, H, rfl‚ü©
{ rintro ‚ü®a, H, rfl‚ü©, simp only [mem_def] at H, simp only [H, pmap] }
simp only [mem_def] at H
simp only [H, pmap]
intros
unfold balance'
split_ifs
{ exact hl.node' hr }
exact hl.node' hr
{ exact hl.rotate_l hr }
exact hl.rotate_l hr
{ exact hl.rotate_r hr }
exact hl.rotate_r hr
{ exact hl.node' hr }
exact hl.node' hr
intros
dsimp [node', size]
generalize_hyp : size r‚ÇÇ = m at H ‚ä¢
rcases H with rfl | rfl
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr rfl }
exact or.inr rfl
intros
rw [eq_some_iff.2 h, bind_some]
intros
ext i j
dsimp [single]
rw [if_pos (subsingleton.elim i a), subsingleton.elim i j, subsingleton.elim b j]
intros
change (v.map (coe : nat.primes ‚Üí ‚Ñï+)).map subtype.val = v.map subtype.val
{ change (v.map (coe : nat.primes ‚Üí ‚Ñï+)).map subtype.val = v.map subtype.val, rw [multiset.map_map], congr }
rw [multiset.map_map]
congr
intros
{ rw dvd_iff, rw nat.gcd_eq_left_iff_dvd, rw ‚Üê coe_inj, simp }
rw dvd_iff
rw nat.gcd_eq_left_iff_dvd
rw ‚Üê coe_inj
simp
intros
let ha : u.r + u.b * u.q = u.a := u.rq_eq
rw [hr, zero_add] at ha
ext
change (u.wp + 1) * u.b + ((u.wp + 1) * u.qp + u.x) * u.b = u.w * u.a + u.x * u.b
{ change (u.wp + 1) * u.b + ((u.wp + 1) * u.qp + u.x) * u.b = u.w * u.a + u.x * u.b, have : u.wp + 1 = u.w := rfl, rw [this, ‚Üê ha, u.qp_eq hr], ring }
have : u.wp + 1 = u.w := rfl
rw [this, ‚Üê ha, u.qp_eq hr]
ring
change u.y * u.b + (u.y * u.qp + u.z) * u.b = u.y * u.a + u.z * u.b
{ change u.y * u.b + (u.y * u.qp + u.z) * u.b = u.y * u.a + u.z * u.b, rw [‚Üê ha, u.qp_eq hr], ring }
rw [‚Üê ha, u.qp_eq hr]
ring
intros
erw [monomial_mul_monomial, mul_one]
intros
fsplit
intro h
{ intro h, apply_fun (Œª p, p.coeff 0) at h, simpa using h, }
apply_fun (Œª p, p.coeff 0) at h
simpa using h
{ rintro rfl, refl, }
rintro rfl
refl
intros
simpa only [C_1, one_mul] using leading_coeff_C_mul_X_pow (1 : R) n
intros
by_cases hp : p = 0
rw [hp, nat_trailing_degree_zero]
{ rw [hp, nat_trailing_degree_zero], exact zero_le _ }
exact zero_le _
rwa [trailing_degree_eq_nat_trailing_degree hp, trailing_degree_eq_nat_trailing_degree hq, with_top.coe_le_coe] at hpq
intros
rw [C_mul_X_pow_eq_monomial, erase_lead_add_monomial_nat_degree_leading_coeff]
intros
simp [comp, (C : R ‚Üí+* _).map_sum]
intros
have A : nat_degree (p.map f) < p.nat_degree.succ := (nat_degree_map_le _ _).trans_lt (nat.lt_succ_self _)
conv_lhs { rw [eval‚ÇÇ_eq_sum], }
rw [sum_over_range' _ _ _ A]
simp only [coeff_map, eval‚ÇÇ_eq_sum, sum_over_range, forall_const, zero_mul, ring_hom.map_zero, function.comp_app, ring_hom.coe_comp]
{ simp only [coeff_map, eval‚ÇÇ_eq_sum, sum_over_range, forall_const, zero_mul, ring_hom.map_zero, function.comp_app, ring_hom.coe_comp] }
{ simp only [forall_const, zero_mul, ring_hom.map_zero] }
simp only [forall_const, zero_mul, ring_hom.map_zero]
intros
simp only [map_alg, aeval_def, eval‚ÇÇ, map, algebra_map_apply, ring_hom.coe_comp]
intros
by_cases h : q = 0
{ simp [h] }
simp [h]
rw [hp.nat_degree_mul' h, polynomial.nat_degree_mul', add_comm]
simpa [hp.leading_coeff, leading_coeff_ne_zero]
intros
simp only [empty_eq_zero, pow_zero, nth_roots, ‚Üê C_1, ‚Üê C_sub, roots_C]
intros
intros f g h
apply_fun taylor (-r) at h
simpa only [taylor_apply, comp_assoc, add_comp, X_comp, C_comp, C_neg, neg_add_cancel_right, comp_X] using h
intros
rw [‚Üê cofix.dest_mk x,h,cofix.dest_mk]
intros
rw ‚Üêabs_repr x
{ rw ‚Üêabs_repr x, cases repr x with a f, rw [‚Üêabs_map, ‚Üêabs_map, ‚Üêabs_map], reflexivity }
cases repr x with a f
rw [‚Üêabs_map, ‚Üêabs_map, ‚Üêabs_map]
reflexivity
intros
by_cases hn : n = 0
subst hn
{ subst hn, simp only [int.cast_zero, euclidean_domain.zero_div] }
simp only [int.cast_zero, euclidean_domain.zero_div]
have : (n : ‚Ñö) ‚â† 0
{ have : (n : ‚Ñö) ‚â† 0, { rwa ‚Üê coe_int_inj at hn }, simp only [int.div_self hn, int.cast_one, ne.def, not_false_iff, div_self this] }
rwa ‚Üê coe_int_inj at hn
{ rwa ‚Üê coe_int_inj at hn }
simp only [int.div_self hn, int.cast_one, ne.def, not_false_iff, div_self this]
intros
cases x with x
induction x using quot.induction_on with x
exact h x
intros
rw [Inf_def, ‚Üê is_lub_neg', neg_neg]
exact real.is_lub_Sup _ h‚ÇÅ.neg h‚ÇÇ.neg
intros
rw [ennreal.of_real, ennreal.of_real, coe_le_coe, real.to_nnreal_le_to_nnreal_iff h]
simp [ennreal.of_real]
intros
conv_lhs { rw [‚Üê ennreal.coe_nat n, ennreal.to_nnreal_coe] }
intros
induction x using ereal.rec
{ simpa using h'x }
simpa using h'x
{ refl }
refl
{ simpa using hx }
simpa using hx
intros
unfold st
split_ifs
{ exact is_st_unique (classical.some_spec h) hxr }
exact is_st_unique (classical.some_spec h) hxr
{ exact false.elim (h ‚ü®r, hxr‚ü©) }
exact false.elim (h ‚ü®r, hxr‚ü©)
simp [real.to_nnreal, max_eq_left (zero_le_one : (0 :‚Ñù) ‚â§ 1)]
simp [real.to_nnreal, max_eq_left (zero_le_one : (0 :‚Ñù) ‚â§ 1)]; refl
intros
rw ‚Üê nnreal.eq_iff
simp only [nnreal.coe_add, nnreal.coe_div, nnreal.coe_mul]
exact div_add_div _ _ (coe_ne_zero.2 hb) (coe_ne_zero.2 hd)
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ‚Ñù)
{ exact (or.inl $ sign_of_neg hn) }
exact (or.inl $ sign_of_neg hn)
{ exact (or.inr $ or.inl $ sign_zero) }
exact (or.inr $ or.inl $ sign_zero)
{ exact (or.inr $ or.inr $ sign_of_pos hp) }
exact (or.inr $ or.inr $ sign_of_pos hp)
intros
rw [division_def, sqrt_mul hx, sqrt_inv, division_def]
intros
unfold blur; congr; exact set.union_eq_self_of_subset_right h
unfold blur; congr
unfold blur
congr
exact set.union_eq_self_of_subset_right h
intros
induction n
induction n; simp [*, drop]
simp [*, drop]
simp [*, drop]
intros
simp [set.ite]
intros
simp only [inter_comm, image_inter_preimage]
intros
by_cases h : p
rw if_pos h
{rw if_pos h, exact subset_union_left _ _}
exact subset_union_left _ _
{rw if_neg h, exact subset_union_right _ _}
rw if_neg h
exact subset_union_right _ _
intros
simp [prod_eq]
intros
simp [classical.skolem, set.nonempty]
intros
apply diff_subset_iff
intros
classical; exact ‚ü®set_fintype s‚ü©
classical
exact ‚ü®set_fintype s‚ü©
intros
refine ‚ü®Œª h, _, Œª h, Iio_subset_Iio h‚ü©
by_contradiction ab
exact lt_irrefl _ (h (not_le.mp ab))
intros
simp [‚Üê Ici_inter_Iio]
intros
simp
intros
simp [‚Üê Ioi_inter_Iic, ‚Üê Ici_inter_Iio, h, inter_comm]
intros
rw ord_connected_iff
intros x hx y hy hxy
rcases eq_or_lt_of_le hxy with rfl|hxy'
simpa
{ simpa }
have := hs x hx y hy hxy'
rw [‚Üê union_diff_cancel Ioo_subset_Icc_self]
simp [*, insert_subset]
intros
simp [add_comm]
intros
rw [disjoint.comm]; exact disjoint_singleton_left
rw [disjoint.comm]
exact disjoint_singleton_left
intros
simp
intros
ext x
rw [mem_Union, mem_Union]
split
{ rintro ‚ü®y, i, rfl‚ü©, exact ‚ü®i, (f i y).2‚ü© }
rintro ‚ü®y, i, rfl‚ü©
exact ‚ü®i, (f i y).2‚ü©
rintro ‚ü®i, hx‚ü©
{ rintro ‚ü®i, hx‚ü©, cases hf i ‚ü®x, hx‚ü© with y hy, exact ‚ü®y, i, congr_arg subtype.val hy‚ü© }
cases hf i ‚ü®x, hx‚ü© with y hy
exact ‚ü®y, i, congr_arg subtype.val hy‚ü©
intros
{ cases x‚ÇÄ, cases x‚ÇÅ, exact psigma.mk.inj_iff }
cases x‚ÇÄ
cases x‚ÇÅ
exact psigma.mk.inj_iff
intros
ext i : 1; cases i; refl
ext i : 1; cases i
ext i : 1
cases i
refl
refl
intros
ext
ext; apply drop_append1
apply drop_append1
intros
rw [nat.coprime, nat.gcd_comm, nat.gcd_rec] at h
rw [mul_inv_eq_gcd, val_nat_cast, h, nat.cast_one]
intros
simp only [set.ext_iff, is_subgroup.mem_trivial]
simp only [set.ext_iff, is_subgroup.mem_trivial]; exact ‚ü®Œª h x, (h x).1, Œª h x, ‚ü®h x, Œª hx, hx.symm ‚ñ∏ hs.to_is_submonoid.one_mem‚ü©‚ü©
exact ‚ü®Œª h x, (h x).1, Œª h x, ‚ü®h x, Œª hx, hx.symm ‚ñ∏ hs.to_is_submonoid.one_mem‚ü©‚ü©
intros
{ rw ‚Üê set.image_univ, exact univ.is_submonoid.image hf }
rw ‚Üê set.image_univ
exact univ.is_submonoid.image hf
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const m) h n
intros
simp only [is_periodic_pt, iterate_mul, hm.is_fixed_pt.iterate n]
intros
apply_instance
intros
letI : fintype (F‚üÆŒ±‚üØ ‚Üí‚Çê[F] F‚üÆŒ±‚üØ) := intermediate_field.fintype_of_alg_hom_adjoin_integral F hŒ±
rw intermediate_field.adjoin.finrank hŒ±
rw ‚Üê intermediate_field.card_alg_hom_adjoin_integral F hŒ± h_sep h_splits
exact fintype.card_congr (alg_equiv_equiv_alg_hom F F‚üÆŒ±‚üØ)
intros
rw pos_iff_ne_zero
intro ndeg_eq_zero
have eq_one : minpoly A x = 1
rw eq_C_of_nat_degree_eq_zero ndeg_eq_zero
{ rw eq_C_of_nat_degree_eq_zero ndeg_eq_zero, convert C_1, simpa only [ndeg_eq_zero.symm] using (monic hx).leading_coeff }
convert C_1
simpa only [ndeg_eq_zero.symm] using (monic hx).leading_coeff
simpa only [eq_one, alg_hom.map_one, one_ne_zero] using aeval A x
intros
simpa only [sub_eq_add_neg, C_neg] using separable_X_add_C (-x)
intros
{ rw mul_comm at h, exact h.of_mul_left }
rw mul_comm at h
exact h.of_mul_left
intros
split
{ intro H, rw [nat_degree_eq_card_roots H, map_id] }
intro H
rw [nat_degree_eq_card_roots H, map_id]
intro hroots
{ intro hroots, apply (splits_iff_exists_multiset (ring_hom.id K)).2, use p.roots, simp only [ring_hom.id_apply, map_id], exact (C_leading_coeff_mul_prod_multiset_X_sub_C hroots).symm }
apply (splits_iff_exists_multiset (ring_hom.id K)).2
use p.roots
simp only [ring_hom.id_apply, map_id]
exact (C_leading_coeff_mul_prod_multiset_X_sub_C hroots).symm
intros
rw [angle_neg_right, angle_self hx, sub_zero]
intros
ext
ext; simp only [times_cont_mdiff_map.comp_apply, coe_mul, pi.mul_apply]
simp only [times_cont_mdiff_map.comp_apply, coe_mul, pi.mul_apply]
intros
refine ((nhds_within_has_basis euclidean.nhds_basis_closed_ball _).restrict_subset (ext_chart_at_target_mem_nhds_within _ _)).to_has_basis' _ _
rintro R ‚ü®hR0, hsub‚ü©
{ rintro R ‚ü®hR0, hsub‚ü©, exact ‚ü®‚ü®‚ü®‚ü®R / 2, R, half_pos hR0, half_lt_self hR0‚ü©‚ü©, hsub‚ü©, trivial, subset.rfl‚ü© }
exact ‚ü®‚ü®‚ü®‚ü®R / 2, R, half_pos hR0, half_lt_self hR0‚ü©‚ü©, hsub‚ü©, trivial, subset.rfl‚ü©
exact Œª f _, inter_mem (mem_nhds_within_of_mem_nhds $ closed_ball_mem_nhds f.R_pos) self_mem_nhds_within
{ exact Œª f _, inter_mem (mem_nhds_within_of_mem_nhds $ closed_ball_mem_nhds f.R_pos) self_mem_nhds_within }
intros
refine ‚ü®continuous_const.continuous_at, _‚ü©
simp only [written_in_ext_chart_at, (‚àò), has_fderiv_within_at_const]
intros
rw [mdifferentiable_within_at, mdifferentiable_within_at, ext_chart_preimage_inter_eq, differentiable_within_at_inter, continuous_within_at_inter ht]
exact ext_chart_preimage_mem_nhds I x ht
intros
simp only [mdifferentiable_on, differentiable_on, mdifferentiable_within_at_iff_differentiable_within_at]
intros
refine I.continuous.comp_continuous_on _
rw ext_chart_at_source
exact (chart_at H x).continuous_on
intros
rw times_cont_mdiff_within_at_iff
refine ‚ü®continuous_within_at_snd, _‚ü©
refine times_cont_diff_within_at_snd.congr (Œª y hy, _) _
simp only with mfld_simps at hy
{ simp only with mfld_simps at hy, simp only [hy] with mfld_simps }
simp only [hy] with mfld_simps
{ simp only with mfld_simps }
simp only with mfld_simps
intros
apply subgroup.normal_closure_le_normal
rintros x ‚ü®p, q, rfl‚ü©
simp [monoid_hom.mem_ker, mul_right_comm (f p) (f q)]
intros
{ ext, exact (left_coset_eq_iff s).symm }
ext
exact (left_coset_eq_iff s).symm
intros
induction H with L1 L' L2 H1 H2 ih
{ refl }
refl
cases H1 with L4 L5 x b
{ cases H1 with L4 L5 x b, exact reduce.not H2 }
exact reduce.not H2
intros
rw [smul_assoc, one_smul]
intros
rw [‚Üêmk'_one, ‚Üêmk'_mul, one_mul]
intros
simp_rw ‚Üê add_order_of_dvd_iff_nsmul_eq_zero
exact ‚ü®Œª h n, by rw h, Œª h, nat.dvd_antisymm ((h _).mpr dvd_rfl) ((h _).mp dvd_rfl)‚ü©
intros
simp_rw [is_p_group, ‚Üêhœï.eq_iff, œï.map_pow, œï.map_one]
exact Œª h, hG (œï h)
intros
rw [‚Üêcard_cycle_type_eq_one, h.cycle_type, card_singleton]
intros
obtain ‚ü®m, rfl‚ü© := exists_add_of_le h
rw [add_comm, support_fin_rotate]
intros
intros x hx
have hx' : x ‚àà {x | form_perm l x ‚â† x} := by simpa using hx
simpa using support_form_perm_le' _ hx'
intros
induction l with hd tl hl
{ simp }
simp
rw [list.pairwise_cons] at h
{ rw [list.pairwise_cons] at h, have : disjoint hd tl.prod := disjoint_prod_right _ h.left, simp [this.support_mul, hl h.right] }
have : disjoint hd tl.prod := disjoint_prod_right _ h.left
simp [this.support_mul, hl h.right]
intros
rw [mrange_eq_map, ‚Üê mrange_inl_sup_mrange_inr, map_sup, map_mrange, coprod_comp_inl, map_mrange, coprod_comp_inr, range_subtype, range_subtype]
intros
classical
by_cases h : ‚àÄ x ‚àà S, x = (1 : M)
left
{ left, exact S.eq_bot_iff_forall.mpr h }
exact S.eq_bot_iff_forall.mpr h
right
{ right, push_neg at h, simpa [nontrivial_iff_exists_ne_one] using h }
push_neg at h
simpa [nontrivial_iff_exists_ne_one] using h
intros
{ ext, simp, }
ext
simp
intros
refine le_antisymm _ _
change (affine_span k ((s1 : set P) ‚à™ s2)).direction ‚â§ _
{ change (affine_span k ((s1 : set P) ‚à™ s2)).direction ‚â§ _, rw ‚Üêmem_coe at hp1, rw [direction_affine_span, vector_span_eq_span_vsub_set_right k (set.mem_union_left _ hp1), submodule.span_le], rintros v ‚ü®p3, hp3, rfl‚ü©, cases hp3, { rw [sup_assoc, sup_comm, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -·µ• p1, vsub_mem_direction hp3 hp1], rw zero_add }, { rw [sup_assoc, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -·µ• p1], rw [and_comm, zero_add], use rfl, rw [‚Üêvsub_add_vsub_cancel p3 p2 p1, submodule.mem_sup], use [p3 -·µ• p2, vsub_mem_direction hp3 hp2, p2 -·µ• p1, submodule.mem_span_singleton_self _] } }
rw ‚Üêmem_coe at hp1
rw [direction_affine_span, vector_span_eq_span_vsub_set_right k (set.mem_union_left _ hp1), submodule.span_le]
rintros v ‚ü®p3, hp3, rfl‚ü©
cases hp3
rw [sup_assoc, sup_comm, set_like.mem_coe, submodule.mem_sup]
{ rw [sup_assoc, sup_comm, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -·µ• p1, vsub_mem_direction hp3 hp1], rw zero_add }
use [0, submodule.zero_mem _, p3 -·µ• p1, vsub_mem_direction hp3 hp1]
rw zero_add
rw [sup_assoc, set_like.mem_coe, submodule.mem_sup]
{ rw [sup_assoc, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -·µ• p1], rw [and_comm, zero_add], use rfl, rw [‚Üêvsub_add_vsub_cancel p3 p2 p1, submodule.mem_sup], use [p3 -·µ• p2, vsub_mem_direction hp3 hp2, p2 -·µ• p1, submodule.mem_span_singleton_self _] }
use [0, submodule.zero_mem _, p3 -·µ• p1]
rw [and_comm, zero_add]
use rfl
rw [‚Üêvsub_add_vsub_cancel p3 p2 p1, submodule.mem_sup]
use [p3 -·µ• p2, vsub_mem_direction hp3 hp2, p2 -·µ• p1, submodule.mem_span_singleton_self _]
refine sup_le (sup_direction_le _ _) _
{ refine sup_le (sup_direction_le _ _) _, rw [direction_eq_vector_span, vector_span_def], exact Inf_le_Inf (Œª p hp, set.subset.trans (set.singleton_subset_iff.2 (vsub_mem_vsub (mem_span_points k p2 _ (set.mem_union_right _ hp2)) (mem_span_points k p1 _ (set.mem_union_left _ hp1)))) hp) }
rw [direction_eq_vector_span, vector_span_def]
exact Inf_le_Inf (Œª p hp, set.subset.trans (set.singleton_subset_iff.2 (vsub_mem_vsub (mem_span_points k p2 _ (set.mem_union_right _ hp2)) (mem_span_points k p1 _ (set.mem_union_left _ hp1)))) hp)
intros
cases h1 with p1 hp1
cases h2 with p2 hp2
rw set_like.lt_iff_le_and_exists
use [sup_direction_le s1 s2, p2 -·µ• p1, vsub_mem_direction ((le_sup_right : s2 ‚â§ s1 ‚äî s2) hp2) ((le_sup_left : s1 ‚â§ s1 ‚äî s2) hp1)]
intro h
rw submodule.mem_sup at h
rcases h with ‚ü®v1, hv1, v2, hv2, hv1v2‚ü©
rw [‚Üêsub_eq_zero, sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm v1, add_assoc, ‚Üêvadd_vsub_assoc, ‚Üêneg_neg v2, add_comm, ‚Üêsub_eq_add_neg, ‚Üêvsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hv1v2
refine set.nonempty.ne_empty _ he
use [v1 +·µ• p1, vadd_mem_of_mem_direction hv1 hp1]
rw hv1v2
exact vadd_mem_of_mem_direction (submodule.neg_mem _ hv2) hp2
intros
simp [centroid_def, affine_combination_apply]
intros
rw [collinear_iff_finrank_le_one, finrank_vector_span_le_iff_not_affine_independent k p (fintype.card_fin 3)]
intros
rw [midpoint_comm, midpoint_vsub_left]
intros
rw [eq_top_iff, le_span_singleton_iff]
finish
intros
simp [basis.equiv]
intros
rw [‚Üê@neg_one_smul R‚ÇÅ _ _, smul_left, neg_one_mul]
intros
erw [symm_comp_of_nondegenerate, linear_equiv.apply_symm_apply (B‚ÇÇ.to_dual b‚ÇÇ) _]
intros
simp only [B.to_matrix'_comp_left, transpose_transpose, to_matrix'_to_lin']
intros
apply uncurry_apply
intros
fapply card_le_of_injective' R
apply finsupp.total
{ apply finsupp.total, exact Œª i, span.repr R w ‚ü®v i, s (mem_range_self i)‚ü©, }
exact Œª i, span.repr R w ‚ü®v i, s (mem_range_self i)‚ü©
intros f g h
{ intros f g h, apply_fun finsupp.total w M R coe at h, simp only [finsupp.total_total, submodule.coe_mk, span.finsupp_total_repr] at h, rw [‚Üêsub_eq_zero, ‚Üêlinear_map.map_sub] at h, exact sub_eq_zero.mp (linear_independent_iff.mp i _ h), }
apply_fun finsupp.total w M R coe at h
simp only [finsupp.total_total, submodule.coe_mk, span.finsupp_total_repr] at h
rw [‚Üêsub_eq_zero, ‚Üêlinear_map.map_sub] at h
exact sub_eq_zero.mp (linear_independent_iff.mp i _ h)
intros
simp [finsupp_tensor_finsupp']
intros
simp_rw [dual_annihilator_comap, mem_comap, mem_dual_annihilator, module.dual.eval_apply]
intros
by_cases n : v = 0
subst n
{ subst n, convert zero_le_one, haveI := subsingleton_of_forall_eq (0 : V) (Œª w, by { obtain ‚ü®c, rfl‚ü© := h w, simp, }), exact finrank_zero_of_subsingleton, }
convert zero_le_one
haveI := subsingleton_of_forall_eq (0 : V) (Œª w, by { obtain ‚ü®c, rfl‚ü© := h w, simp, })
exact finrank_zero_of_subsingleton
{ exact (finrank_eq_one v n h).le, }
exact (finrank_eq_one v n h).le
intros
have h_finrank_inf : finrank K ‚Ü•(s ‚äì t) = 0
rw [disjoint, le_bot_iff] at hdisjoint
{ rw [disjoint, le_bot_iff] at hdisjoint, rw [hdisjoint, finrank_bot] }
rw [hdisjoint, finrank_bot]
apply eq_top_of_finrank_eq
rw ‚Üêhdim
convert s.dim_sup_add_dim_inf_eq t
rw h_finrank_inf
refl
intros
rw [‚Üê linear_independent_equiv (fin_succ_equiv n).symm, linear_independent_option]
convert iff.rfl
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
intros
rw sUnion_eq_Union; exact linear_independent_Union_of_directed hs.directed_coe (by simpa using h)
rw sUnion_eq_Union
exact linear_independent_Union_of_directed hs.directed_coe (by simpa using h)
intros
{ intros i j h, simp [ha h] }
intros i j h
simp [ha h]
intros
rw [matrix.to_lin_mul v‚ÇÅ v‚ÇÇ, linear_map.comp_apply]
intros
dunfold diag
{ dunfold diag, ext, simp [one_apply_eq] }
ext
simp [one_apply_eq]
intros
refine (supr_le $ Œª i, _).antisymm _
rintro _ ‚ü®x, hx : x ‚àà p i, rfl‚ü© j -
{ rintro _ ‚ü®x, hx : x ‚àà p i, rfl‚ü© j -, rcases em (j = i) with rfl|hj; simp * }
rcases em (j = i) with rfl|hj; simp *
rcases em (j = i) with rfl|hj
simp *
simp *
intros x hx
{ intros x hx, rw [‚Üê finset.univ_sum_single x], exact sum_mem_supr (Œª i, mem_map_of_mem (hx i trivial)) }
rw [‚Üê finset.univ_sum_single x]
exact sum_mem_supr (Œª i, mem_map_of_mem (hx i trivial))
intros
ext x
simp only [mem_ker, mem_range]
split
{ rintros ‚ü®y, rfl‚ü©, refl }
rintros ‚ü®y, rfl‚ü©
refl
{ intro h, exact ‚ü®x.fst, prod.ext rfl h.symm‚ü© }
intro h
exact ‚ü®x.fst, prod.ext rfl h.symm‚ü©
intros
rw [range_eq_map, ‚Üê prod_top, prod_map_fst]
intros
rw [std_basis_apply, update_same]
intros
simp
intros
cc
intros
induction ab with b d ab bd IH
{ exact or.inl ac }
exact or.inl ac
rcases IH with IH | IH
{ rcases IH with IH | IH, { rcases cases_head IH with rfl | ‚ü®e, be, ec‚ü©, { exact or.inr (single bd) }, { cases U bd be, exact or.inl ec } }, { exact or.inr (IH.tail bd) } }
rcases cases_head IH with rfl | ‚ü®e, be, ec‚ü©
{ rcases cases_head IH with rfl | ‚ü®e, be, ec‚ü©, { exact or.inr (single bd) }, { cases U bd be, exact or.inl ec } }
{ exact or.inr (single bd) }
exact or.inr (single bd)
{ cases U bd be, exact or.inl ec }
cases U bd be
exact or.inl ec
{ exact or.inr (IH.tail bd) }
exact or.inr (IH.tail bd)
intros
simp_rw [measure.prod, bind_apply hs measurable.map_prod_mk_left, map_apply measurable_prod_mk_left hs]
intros
rcases hf.1 with ‚ü®f', hf'_meas, hf_ae‚ü©
have hf'_integrable : integrable f' Œº
from integrable.congr hf hf_ae
have hf'_zero : ‚àÄ s, measurable_set s ‚Üí 0 ‚â§ ‚à´ x in s, f' x ‚àÇŒº
intros s hs
{ intros s hs, rw set_integral_congr_ae hs (hf_ae.mono (Œª x hx hxs, hx.symm)), exact hf_zero s hs, }
rw set_integral_congr_ae hs (hf_ae.mono (Œª x hx hxs, hx.symm))
exact hf_zero s hs
exact (ae_nonneg_of_forall_set_integral_nonneg_of_finite_measure_of_measurable hf'_meas hf'_integrable hf'_zero).trans hf_ae.symm.le
intros
rcases hfm with ‚ü®f', hf'_meas, hf_ae‚ü©
refine ‚ü®-f', @measurable.neg _ _ _ _ _ m _ hf'_meas, hf_ae.mono (Œª x hx, _)‚ü©
simp_rw pi.neg_apply
rw hx
intros
rw [sub_eq_add_neg, sub_eq_add_neg, condexp_L1_add hf hg.neg, condexp_L1_neg g]
intros
rw [Lp.norm_def, Lp.norm_def, ‚Üê Lp_meas_coe]
refine (ennreal.to_real_le_to_real _ (Lp.snorm_ne_top _)).mpr (snorm_condexp_L2_le hm f)
exact Lp.snorm_ne_top _
intros
simp only [has_finite_integral, lintegral_smul_measure] at *
exact mul_lt_top hc h.ne
intros
rw L2.inner_indicator_const_Lp_eq_inner_set_integral ùïú hs hŒºs (1 : ùïú) f
{ rw L2.inner_indicator_const_Lp_eq_inner_set_integral ùïú hs hŒºs (1 : ùïú) f, simp, }
simp
intros
split
assume h
{ assume h, rw h, exact ae_eq_fun.coe_fn_const _ _ }
rw h
exact ae_eq_fun.coe_fn_const _ _
assume h
{ assume h, ext1, filter_upwards [h, ae_eq_fun.coe_fn_const Œ± (0 : E)], assume a ha h'a, rw ha, exact h'a.symm }
ext1
filter_upwards [h, ae_eq_fun.coe_fn_const Œ± (0 : E)]
assume a ha h'a
rw ha
exact h'a.symm
intros
simp_rw snorm'
rw [‚Üê ennreal.rpow_mul, ‚Üêone_div_mul_one_div]
simp_rw one_div
rw [mul_assoc, inv_mul_cancel hq_pos.ne.symm, mul_one]
congr
ext1 x
simp_rw ‚Üê of_real_norm_eq_coe_nnnorm
rw [real.norm_eq_abs, abs_eq_self.mpr (real.rpow_nonneg_of_nonneg (norm_nonneg _) _), mul_comm, ‚Üê ennreal.of_real_rpow_of_nonneg (norm_nonneg _) hq_pos.le, ennreal.rpow_mul]
intros
filter_upwards [to_simple_func_eq_to_fun (0 : Lp.simple_func E p Œº), Lp.coe_fn_zero E 1 Œº]
assume a h‚ÇÅ h‚ÇÇ
rwa h‚ÇÅ
intros
simpa [mul_comm] using integral_comp_smul_deriv'' hf hff' hf' hg
intros
simpa only [add_comm] using integral_comp_add_right f d
intros
simp only [interval_integral, set_integral_congr_ae (measurable_set_Ioc) h, set_integral_congr_ae (measurable_set_Ioc) h']
intros
convert lintegral_zero_measure _
exact measure.restrict_eq_zero.2 hs'
intros
refine @measurable.ennreal_induction Œ± m (Œª f, ‚à´‚Åª a, f a ‚àÇ(Œº.trim hm) = ‚à´‚Åª a, f a ‚àÇŒº) _ _ _ f hf
intros c s hs
{ intros c s hs, rw [lintegral_indicator _ hs, lintegral_indicator _ (hm s hs), set_lintegral_const, set_lintegral_const], suffices h_trim_s : Œº.trim hm s = Œº s, by rw h_trim_s, exact trim_measurable_set_eq hm hs, }
rw [lintegral_indicator _ hs, lintegral_indicator _ (hm s hs), set_lintegral_const, set_lintegral_const]
suffices h_trim_s : Œº.trim hm s = Œº s
rw h_trim_s
rw h_trim_s
exact trim_measurable_set_eq hm hs
intros f g hfg hf hg hf_prop hg_prop
{ intros f g hfg hf hg hf_prop hg_prop, have h_m := lintegral_add hf hg, have h_m0 := lintegral_add (measurable.mono hf hm le_rfl) (measurable.mono hg hm le_rfl), rwa [hf_prop, hg_prop, ‚Üê h_m0] at h_m, }
have h_m := lintegral_add hf hg
have h_m0 := lintegral_add (measurable.mono hf hm le_rfl) (measurable.mono hg hm le_rfl)
rwa [hf_prop, hg_prop, ‚Üê h_m0] at h_m
intros f hf hf_mono hf_prop
{ intros f hf hf_mono hf_prop, rw lintegral_supr hf hf_mono, rw lintegral_supr (Œª n, measurable.mono (hf n) hm le_rfl) hf_mono, congr, exact funext (Œª n, hf_prop n), }
rw lintegral_supr hf hf_mono
rw lintegral_supr (Œª n, measurable.mono (hf n) hm le_rfl) hf_mono
congr
exact funext (Œª n, hf_prop n)
intros
refine set_integral_mono_ae_restrict hf hg _
{ refine set_integral_mono_ae_restrict hf hg _, rwa [eventually_le, ae_restrict_iff' hs], }
rwa [eventually_le, ae_restrict_iff' hs]
intros
induction l with i l ih
{ induction l with i l ih, exact measurable_set.univ, exact (hs i).prod ih }
exact measurable_set.univ
exact (hs i).prod ih
intros
rw [‚Üê coe_fn_comp_to_finite_measure_eq_coe_fn, finite_measure.ennreal_coe_fn_eq_coe_fn_to_measure]
{ rw [‚Üê coe_fn_comp_to_finite_measure_eq_coe_fn, finite_measure.ennreal_coe_fn_eq_coe_fn_to_measure], refl, }
refl
intros
simp only [prehaar]
rw [div_add_div_same, div_le_div_right]
exact_mod_cast index_union_le K‚ÇÅ K‚ÇÇ hU
exact_mod_cast index_pos K‚ÇÄ hU
intros
rw [‚Üê measure.mk_metric_to_outer_measure, coe_to_outer_measure]
intros
simp only [measure_singleton, measure.restrict_eq_zero]
intros
simp [map_map e.measurable e.symm.measurable]
intros
refine le_infi _
{ refine le_infi _, intro h‚ÇÇ, rw [extend_eq m h‚ÇÅ], exact m_mono h‚ÇÅ h‚ÇÇ hs }
intro h‚ÇÇ
rw [extend_eq m h‚ÇÅ]
exact m_mono h‚ÇÅ h‚ÇÇ hs
intros
simp [bounded_by, of_function_apply]
intros
by_cases hi : measurable_set i
ext j hj
{ ext j hj, simp [restrict_apply _ hi hj] }
simp [restrict_apply _ hi hj]
simp only [restrict_not_measurable _ hi]
{ simp only [restrict_not_measurable _ hi], ext j hj, simp }
ext j hj
simp
intros
rw [filter_apply, set.indicator_apply_eq_zero.mpr (Œª ha', absurd ha' ha), zero_mul]
intros
have h4 : (0:‚Ñö) < 4
norm_num
norm_num
contrapose! H
rw sum_inv_pqr
have h4r := H.trans hqr
simp only [pnat.coe_bit0, nat.cast_bit0, pnat.one_coe, nat.cast_one, coe_coe]
calc (2‚Åª¬π + q‚Åª¬π + r‚Åª¬π : ‚Ñö) ‚â§ 2‚Åª¬π + 4‚Åª¬π + 4‚Åª¬π : add_le_add (add_le_add le_rfl _) _ ... = 1 : by norm_num
rw inv_le_inv _ h4; [assumption_mod_cast, norm_num]
all_goals { rw inv_le_inv _ h4; [assumption_mod_cast, norm_num] }
rw inv_le_inv _ h4
rw inv_le_inv _ h4; [assumption_mod_cast, norm_num]
assumption_mod_cast
norm_num
intros
induction i; push_cast [‚Üêint.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
induction i
push_cast [‚Üêint.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
push_cast [‚Üêint.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
intros
apply ne_of_gt
simp only [gt_iff_lt, sub_pos]
exact_mod_cast nat.one_lt_two_pow p w
intros
rw [div_eq_mul_inv, padic_val_rat.mul p hq (inv_ne_zero hr), padic_val_rat.inv p hr, sub_eq_add_neg]
intros
intros Œµ hŒµ
obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, (p ^ - (‚Üë(k : ‚Ñï) : ‚Ñ§) : ‚Ñö) < Œµ := exists_pow_neg_lt_rat p hŒµ
use k
intros j hj
refine lt_of_le_of_lt _ hk
norm_cast
rw ‚Üê padic_norm.dvd_iff_norm_le
exact_mod_cast pow_dvd_nth_hom_sub f_compat r k j hj
intros
simp
intros
simp [norm]
intros
rw [‚Üê to_complex_zero, to_complex_inj]
intros
{ rw [‚Üê not_le], intro h', apply not_le_of_lt h, exact hf h' }
rw [‚Üê not_le]
intro h'
apply not_le_of_lt h
exact hf h'
intros
{ rw [sup_comm], exact le_sup_sdiff }
rw [sup_comm]
exact le_sup_sdiff
intros
haveI := classical.dec_eq Œ±
haveI : decidable (a ‚â§ ‚ä•) := decidable_of_iff' _ le_bot_iff
simp only [lt_iff_le_not_le, not_iff_not.mpr le_bot_iff, true_and, bot_le]
intros
simp only [‚Üê not_le, is_lub_le_iff h, mem_upper_bounds, not_forall]
intros
{ change (‚àÉ _, _) ‚Üî _, simp [-eq_iff_iff] }
change (‚àÉ _, _) ‚Üî _
simp [-eq_iff_iff]
intros
simp
intros
rintro f n
cases n
{ refl }
refl
{ exact sdiff_le }
exact sdiff_le
intros
simp [at_top_basis.frequently_iff]
intros
simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]
intro a
rcases h' a with ‚ü®b, hb‚ü©
exact eventually.mono (mem_at_top b) (Œª b' hb', le_trans (finset.singleton_subset_iff.2 hb) (h hb'))
intros
refine le_antisymm (le_inf map_comap_le $ le_principal_iff.2 range_mem_map) _
rintro t' ‚ü®t, ht, sub‚ü©
refine mem_inf_principal.2 (mem_of_superset ht _)
rintro _ hxt ‚ü®x, rfl‚ü©
exact sub hxt
intros
simp only [filter.prod, comap_comap, eq_self_iff_true, comap_inf]
intros
simp [ne_bot_iff]
intros
{ ext, simp only [mem_supr, mem_inf_principal] }
ext
simp only [mem_supr, mem_inf_principal]
intros
split
split; intro h
intro h
have hu_zero := eventually_le.trans (eventually_le_limsup u) (eventually_of_forall (Œª _, le_of_eq h))
{ have hu_zero := eventually_le.trans (eventually_le_limsup u) (eventually_of_forall (Œª _, le_of_eq h)), exact hu_zero.mono (Œª x hx, le_antisymm hx (zero_le _)), }
exact hu_zero.mono (Œª x hx, le_antisymm hx (zero_le _))
intro h
rw limsup_congr h
{ rw limsup_congr h, simp_rw [pi.zero_apply, ‚Üêennreal.bot_eq_zero, limsup_const_bot] }
simp_rw [pi.zero_apply, ‚Üêennreal.bot_eq_zero, limsup_const_bot]
intros
simp only [‚Üê sUnion_image, finite_sUnion_mem_iff (his.image s), bex_image_iff]
intros
simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt' hg hf hn)
intros
rw [symm_diff_def, sup_sdiff, sdiff_idem, sdiff_sdiff_self, bot_sup_eq]
intros
apply eq_of_fst_eq_fst
cases eq_or_lt_of_le h1 with heq hlt
{ exact heq }
exact heq
exfalso
exact ne_of_lt (mul_lt_mul_of_lt_of_le hlt h2) ((mem_mul_antidiagonal.1 x.2).1.trans (mem_mul_antidiagonal.1 y.2).1.symm)
intros
revert f
have h_mul_indicator : ‚àÄ g, measurable g ‚Üí measurable (Œª a, g a * T.indicator (Œª x, c) a)
from Œª g h_mg, h_mg.mul (measurable_const.indicator h_meas_T)
apply measurable.ennreal_induction
intros c' s' h_meas_s'
{ intros c' s' h_meas_s', simp_rw [‚Üê inter_indicator_mul], rw [lintegral_indicator _ (measurable_set.inter (hMf _ h_meas_s') (h_meas_T)), lintegral_indicator _ (hMf _ h_meas_s'), lintegral_indicator _ h_meas_T], simp only [measurable_const, lintegral_const, univ_inter, lintegral_const_mul, measurable_set.univ, measure.restrict_apply], ring_nf, congr, rw [mul_comm, h_ind s' T h_meas_s' (set.mem_singleton _)], }
simp_rw [‚Üê inter_indicator_mul]
rw [lintegral_indicator _ (measurable_set.inter (hMf _ h_meas_s') (h_meas_T)), lintegral_indicator _ (hMf _ h_meas_s'), lintegral_indicator _ h_meas_T]
simp only [measurable_const, lintegral_const, univ_inter, lintegral_const_mul, measurable_set.univ, measure.restrict_apply]
ring_nf
congr
rw [mul_comm, h_ind s' T h_meas_s' (set.mem_singleton _)]
intros f' g h_univ h_meas_f' h_meas_g h_ind_f' h_ind_g
{ intros f' g h_univ h_meas_f' h_meas_g h_ind_f' h_ind_g, have h_measM_f' : measurable f', from h_meas_f'.mono hMf le_rfl, have h_measM_g : measurable g, from h_meas_g.mono hMf le_rfl, simp_rw [pi.add_apply, right_distrib], rw [lintegral_add (h_mul_indicator _ h_measM_f') (h_mul_indicator _ h_measM_g), lintegral_add h_measM_f' h_measM_g, right_distrib, h_ind_f', h_ind_g] }
have h_measM_f' : measurable f'
from h_meas_f'.mono hMf le_rfl
have h_measM_g : measurable g
from h_meas_g.mono hMf le_rfl
simp_rw [pi.add_apply, right_distrib]
rw [lintegral_add (h_mul_indicator _ h_measM_f') (h_mul_indicator _ h_measM_g), lintegral_add h_measM_f' h_measM_g, right_distrib, h_ind_f', h_ind_g]
intros f h_meas_f h_mono_f h_ind_f
{ intros f h_meas_f h_mono_f h_ind_f, have h_measM_f : ‚àÄ n, measurable (f n), from Œª n, (h_meas_f n).mono hMf le_rfl, simp_rw [ennreal.supr_mul], rw [lintegral_supr h_measM_f h_mono_f, lintegral_supr, ennreal.supr_mul], { simp_rw [‚Üê h_ind_f] }, { exact Œª n, h_mul_indicator _ (h_measM_f n) }, { exact Œª m n h_le a, ennreal.mul_le_mul (h_mono_f h_le a) le_rfl, }, }
have h_measM_f : ‚àÄ n, measurable (f n)
from Œª n, (h_meas_f n).mono hMf le_rfl
simp_rw [ennreal.supr_mul]
rw [lintegral_supr h_measM_f h_mono_f, lintegral_supr, ennreal.supr_mul]
{ simp_rw [‚Üê h_ind_f] }
simp_rw [‚Üê h_ind_f]
{ exact Œª n, h_mul_indicator _ (h_measM_f n) }
exact Œª n, h_mul_indicator _ (h_measM_f n)
{ exact Œª m n h_le a, ennreal.mul_le_mul (h_mono_f h_le a) le_rfl, }
exact Œª m n h_le a, ennreal.mul_le_mul (h_mono_f h_le a) le_rfl
intros
rw [power_basis_gen, minpoly_root hf]
intros
have hi := (classical.some_spec (exists_prime R)).irreducible
split
contrapose
{ contrapose, intro h, obtain ‚ü®n, ha‚ü© := associated_pow_irreducible h hi, obtain ‚ü®u, rfl‚ü© := ha.symm, rw [mul_comm, add_val_def' u hi n], exact enat.coe_ne_top _ }
intro h
obtain ‚ü®n, ha‚ü© := associated_pow_irreducible h hi
obtain ‚ü®u, rfl‚ü© := ha.symm
rw [mul_comm, add_val_def' u hi n]
exact enat.coe_ne_top _
rintro rfl
{ rintro rfl, exact add_val_zero }
exact add_val_zero
intros
rw [‚Üê add_zero a, mul_single_coeff_add, add_zero]
intros
rw [‚Üêdvd_dvd_iff_associated, le_antisymm_iff, and_comm]
apply and_congr; rw span_singleton_le_span_singleton
apply and_congr
rw span_singleton_le_span_singleton
rw span_singleton_le_span_singleton
intros
have : ideal.span ({a} : set Œ±) ‚â† ‚ä§
intro H
{ intro H, rw ideal.span_singleton_eq_top at H, contradiction }
rw ideal.span_singleton_eq_top at H
contradiction
rcases ideal.exists_le_maximal _ this with ‚ü®I, Imax, H‚ü©
use [I, Imax]
apply H
apply ideal.subset_span
exact set.mem_singleton a
intros
rw [int.coe_nat_dvd_left, int.coe_nat_dvd_left]
exact int.prime.dvd_mul hp h
intros
rw [‚Üê int.nat_cast_eq_coe_nat, coe_power_series, of_power_series_apply_coeff]
intros
{ unfold has_neg.neg localization.neg, apply lift_on_mk }
unfold has_neg.neg localization.neg
apply lift_on_mk
intros
rw [eq_smul_of_le_smul_of_le_jacobson hN hIN hIjac, submodule.bot_smul]
intros
apply coeff_pow_p f n
intros
simp only [monic, leading_coeff, nat_degree_restriction]
rw [‚Üê@coeff_restriction _ _ p]
exact ‚ü®Œª H, by { rw H, refl }, Œª H, subtype.coe_injective H‚ü©
intros
rintro rfl
exact (hp 0 (dvd_zero (C 0))).ne_zero rfl
intros
obtain ‚ü®d, hd‚ü© : ‚àÉ d, coeff d œÜ ‚â† 0 := exists_coeff_ne_zero hœÜ
rw [‚Üê hm hd, ‚Üê hn hd]
intros
suffices : num A r ‚à£ (scale_roots p (denom A r)).coeff 0
simp only [coeff_scale_roots, nat.sub_zero] at this
{ simp only [coeff_scale_roots, nat.sub_zero] at this, haveI := classical.prop_decidable, by_cases hr : num A r = 0, { obtain ‚ü®u, hu‚ü© := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree, rw ‚Üêhu at this, exact units.dvd_mul_right.mp this }, { refine dvd_of_dvd_mul_left_of_no_prime_factors hr _ this, intros q dvd_num dvd_denom_pow hq, apply hq.not_unit, exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow) } }
haveI := classical.prop_decidable
by_cases hr : num A r = 0
obtain ‚ü®u, hu‚ü© := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree
{ obtain ‚ü®u, hu‚ü© := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree, rw ‚Üêhu at this, exact units.dvd_mul_right.mp this }
rw ‚Üêhu at this
exact units.dvd_mul_right.mp this
refine dvd_of_dvd_mul_left_of_no_prime_factors hr _ this
{ refine dvd_of_dvd_mul_left_of_no_prime_factors hr _ this, intros q dvd_num dvd_denom_pow hq, apply hq.not_unit, exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow) }
intros q dvd_num dvd_denom_pow hq
apply hq.not_unit
exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow)
convert dvd_term_of_is_root_of_dvd_terms 0 (num_is_root_scale_roots_of_aeval_eq_zero hr) _
{ rw [pow_zero, mul_one] }
rw [pow_zero, mul_one]
intros j hj
apply dvd_mul_of_dvd_right
convert pow_dvd_pow (num A r) (nat.succ_le_of_lt (bot_lt_iff_ne_bot.mpr hj))
exact (pow_one _).symm
intros
rw [coeff_X_pow, if_pos rfl]
intros
simp only [mem_roots_of_unity, mem_nth_roots k.pos, units.ext_iff, units.coe_one, units.coe_pow]
intros
split
intro hŒæ
{ intro hŒæ, obtain ‚ü®i, hik, rfl‚ü© := h.eq_pow_of_pow_eq_one hŒæ.pow_eq_one h0, rw h.pow_iff_coprime h0 at hŒæ, exact ‚ü®i, hik, hŒæ, rfl‚ü© }
obtain ‚ü®i, hik, rfl‚ü© := h.eq_pow_of_pow_eq_one hŒæ.pow_eq_one h0
rw h.pow_iff_coprime h0 at hŒæ
exact ‚ü®i, hik, hŒæ, rfl‚ü©
{ rintro ‚ü®i, -, hi, rfl‚ü©, exact h.pow_of_coprime i hi }
rintro ‚ü®i, -, hi, rfl‚ü©
exact h.pow_of_coprime i hi
intros
rcases i with ‚ü®_ | _ | _ | _ | i_val, ‚ü®‚ü©‚ü©
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [mul_zero, ring_hom.map_mul, constant_coeff_X]
intros
simp only [init, tail, ‚Üê not_lt, select_add_select_not]
intros
calc witt_structure_rat p Œ¶ n = C (1 / p ^ n : ‚Ñö) * (witt_structure_rat p Œ¶ n * C (p ^ n : ‚Ñö)) : _ ... = _ : by rw witt_structure_rat_rec_aux
rw [mul_left_comm, ‚Üê C_mul, div_mul_cancel, C_1, mul_one]
exact pow_ne_zero _ (nat.cast_ne_zero.2 hp.1.ne_zero)
intros
ext1 x
simp only [truncate_truncate, function.comp_app, ring_hom.coe_comp]
intros
split
intro hbad
{ intro hbad, rw [first_loses_symm G, le_def_lt], split, { intro i, specialize hbad i, exact hbad.2 }, { intro j, exact pempty.elim j } }
rw [first_loses_symm G, le_def_lt]
split
intro i
{ intro i, specialize hbad i, exact hbad.2 }
specialize hbad i
exact hbad.2
intro j
{ intro j, exact pempty.elim j }
exact pempty.elim j
intros hp i
{ intros hp i, rw first_wins_symm, exact (le_def_lt.1 $ (first_loses_symm G).1 hp).1 i }
rw first_wins_symm
exact (le_def_lt.1 $ (first_loses_symm G).1 hp).1 i
intros
rcases zero_or_succ_or_limit b with rfl|‚ü®b,rfl‚ü©|lb
{ exact (lt_irrefl _).elim b0 }
exact (lt_irrefl _).elim b0
{ rw mul_succ, exact add_is_limit _ l }
rw mul_succ
exact add_is_limit _ l
{ exact mul_is_limit l.pos lb }
exact mul_is_limit l.pos lb
rw lt_def
right
use punit.star
split
split; rintro ‚ü® ‚ü©
rintro ‚ü® ‚ü©
exact zero_lt_one
rintro ‚ü® ‚ü©
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
induction x using alexandroff.rec; simp
induction x using alexandroff.rec
simp
simp
intros
simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds
intros
simp only [has_sum, sum_add_distrib]; exact hf.add hg
simp only [has_sum, sum_add_distrib]
exact hf.add hg
intros
simpa only using hf.map (add_monoid_hom.mul_right a‚ÇÇ) (continuous_id.mul continuous_const)
intros
apply has_continuous_mul.of_nhds_one hmul hleft
intros x‚ÇÄ
simp_rw [mul_comm, hleft x‚ÇÄ]
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _)) (pi_univ_Ioo_subset a b)
exact Ioo_mem_nhds (ha i) (hb i)
intros
simpa only [(‚àò), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)
intros
simp [frontier]
intros
haveI := inhabited_of_nonempty hs.to_subtype; exact (surj_on_iff_surjective.2 $ (continuous_on_iff_continuous_restrict.1 hf).surjective htop hbot)
haveI := inhabited_of_nonempty hs.to_subtype
exact (surj_on_iff_surjective.2 $ (continuous_on_iff_continuous_restrict.1 hf).surjective htop hbot)
intros
simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]
intros
suffices : mono f ‚Üî mono ((forget Top).map f)
{ rw [this, category_theory.mono_iff_injective], refl }
rw [this, category_theory.mono_iff_injective]
refl
split
{ apply right_adjoint_preserves_mono adj‚ÇÅ }
apply right_adjoint_preserves_mono adj‚ÇÅ
{ apply faithful_reflects_mono }
apply faithful_reflects_mono
intros
apply subtype.eq
{ apply subtype.eq, funext x, exact congr_fun (completion.extension_comp_coe f.property) x }
funext x
exact congr_fun (completion.extension_comp_coe f.property) x
intros
{ cases ab, exact ha.prod_nhds hb }
cases ab
exact ha.prod_nhds hb
intros
simp
intros
simp
intros
rintros _ ‚ü®x, hx, rfl‚ü©
exact (hf x hx).mem_closure_image hx
intros
{ rw [local_triv_at, ‚Üêbase_set_at], exact Z.mem_base_set_at b, }
rw [local_triv_at, ‚Üêbase_set_at]
exact Z.mem_base_set_at b
intros
simp [mul_comm, ennreal.tsum_mul_left]
intros
rw [‚Üê summable_coe, ‚Üê summable_coe]
exact @summable_nat_add_iff ‚Ñù _ _ _ (Œª i, (f i : ‚Ñù)) k
intros
rw [e.restr_to_local_equiv, hs.interior_eq]
intros
let U := f ‚Åª¬π' {f y}
suffices : x ‚àâ U·∂ú
from not_not.1 this
intro hxV
specialize hs U U·∂ú (hf {f y}) (hf {f y}·∂ú) _ ‚ü®y, ‚ü®hy, rfl‚ü©‚ü© ‚ü®x, ‚ü®hx, hxV‚ü©‚ü©
{ simp only [union_compl_self, subset_univ] }
simp only [union_compl_self, subset_univ]
simpa only [inter_empty, not_nonempty_empty, inter_compl_self] using hs
{ simpa only [inter_empty, not_nonempty_empty, inter_compl_self] using hs }
intros
refine open_embedding_of_embedding_open ‚ü®‚ü®_‚ü©, h‚ÇÇ‚ü© h‚ÇÉ
apply le_antisymm (continuous_iff_le_induced.mp h‚ÇÅ) _
intro s
change is_open _ ‚Üí is_open _
rw is_open_induced_iff
refine Œª hs, ‚ü®f '' s, h‚ÇÉ s hs, _‚ü©
rw preimage_image_eq _ h‚ÇÇ
intros
rw [mul_comm, ‚Üê div_eq_mul_inv]
exact ennreal.div_le_of_le_mul' (hf x y)
intros
rcases eq_empty_or_nonempty s with (rfl|‚ü®x, hx‚ü©)
unfreezingI { rcases eq_empty_or_nonempty s with (rfl|‚ü®x, hx‚ü©) }
{ exact is_compact_empty }
exact is_compact_empty
rcases hb.subset_ball x with ‚ü®r, hr‚ü©
{ rcases hb.subset_ball x with ‚ü®r, hr‚ü©, exact compact_of_is_closed_subset (proper_space.is_compact_closed_ball x r) hc hr }
exact compact_of_is_closed_subset (proper_space.is_compact_closed_ball x r) hc hr
intros
refine ‚ü®Œª H Œµ hŒµ, H _ (dist_mem_uniformity hŒµ), Œª H u hu, _‚ü©
rcases mem_uniformity_dist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©
exact (H Œµ Œµpos).mono (Œª n hs x hx, hŒµ (hs x hx))
intros
rw edist_comm y; apply edist_triangle
rw edist_comm y
apply edist_triangle
intros
change to_GH_space (quot.out p).val = p
rw ‚Üê eq_to_GH_space
exact quot.out_eq p
intros
obtain rfl : ‚Äπmeasurable_space X‚Ä∫ = borel X := borel_space.measurable_eq
unfreezingI { obtain rfl : ‚Äπmeasurable_space X‚Ä∫ = borel X := borel_space.measurable_eq }
rw dimH
intros
convert ‚Üê mem_closure_iff_inf_edist_zero
exact h.closure_eq
intros
simp only [lipschitz_on_with, lipschitz_with, set_coe.forall', restrict, subtype.edist_eq]
intros
letI := topological_space.coinduced œÄ ‚Äπ_‚Ä∫
rcases mem_nhds_iff.mp hs with ‚ü®V, hVs, V_op, mem_V‚ü©
exact mem_nhds_iff.mpr ‚ü®œÄ ‚Åª¬π' V, set.preimage_mono hVs, V_op, mem_V‚ü©
intros
simp [path_component_in, path_component, joined_in, joined, exists_true_iff_nonempty]
intros
simp_rw [‚Üê upper_semicontinuous_within_at_univ_iff] at *
exact upper_semicontinuous_within_at_sum ha
intros
dsimp [stalk_pushforward, stalk_functor]
ext1
tactic.op_induction'
cases j
cases j_val
rw [colimit.Œπ_map_assoc, colimit.Œπ_map, colimit.Œπ_pre, whisker_left_app, whisker_right_app, pushforward.id_hom_app, eq_to_hom_map, eq_to_hom_refl]
dsimp
erw [category_theory.functor.map_id]
intros
simp only [mem_coclosed_compact, compl_subset_comm]
intros
let opens := {U : set Œ± | S·∂ú ‚äÜ U ‚àß is_open U ‚àß U·∂ú.nonempty}
obtain ‚ü®U, ‚ü®Uc, Uo, Ucne‚ü©, h‚ü© := zorn.zorn_subset opens (Œª c hc hz, begin by_cases hcne : c.nonempty, { obtain ‚ü®U‚ÇÄ, hU‚ÇÄ‚ü© := hcne, haveI : nonempty {U // U ‚àà c} := ‚ü®‚ü®U‚ÇÄ, hU‚ÇÄ‚ü©‚ü©, obtain ‚ü®U‚ÇÄcompl, U‚ÇÄopn, U‚ÇÄne‚ü© := hc hU‚ÇÄ, use ‚ãÉ‚ÇÄ c, refine ‚ü®‚ü®_, _, _‚ü©, Œª U hU a ha, ‚ü®U, hU, ha‚ü©‚ü©, { exact Œª a ha, ‚ü®U‚ÇÄ, hU‚ÇÄ, U‚ÇÄcompl ha‚ü© }, { exact is_open_sUnion (Œª _ h, (hc h).2.1) }, { convert_to (‚ãÇ(U : {U // U ‚àà c}), U.1·∂ú).nonempty, { ext, simp only [not_exists, exists_prop, not_and, set.mem_Inter, subtype.forall, set.mem_set_of_eq, set.mem_compl_eq, subtype.val_eq_coe], refl, }, apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed, { rintros ‚ü®U, hU‚ü© ‚ü®U', hU'‚ü©, obtain ‚ü®V, hVc, hVU, hVU'‚ü© := zorn.chain.directed_on hz U hU U' hU', exact ‚ü®‚ü®V, hVc‚ü©, set.compl_subset_compl.mpr hVU, set.compl_subset_compl.mpr hVU'‚ü©, }, { exact Œª U, (hc U.2).2.2, }, { exact Œª U, (is_closed_compl_iff.mpr (hc U.2).2.1).is_compact, }, { exact Œª U, (is_closed_compl_iff.mpr (hc U.2).2.1), } } }, { use S·∂ú, refine ‚ü®‚ü®set.subset.refl _, is_open_compl_iff.mpr hS, _‚ü©, Œª U Uc, (hcne ‚ü®U, Uc‚ü©).elim‚ü©, rw compl_compl, exact hne, } end)
refine ‚ü®U·∂ú, set.compl_subset_comm.mp Uc, Ucne, is_closed_compl_iff.mpr Uo, _‚ü©
intros V' V'sub V'ne V'cls
have : V'·∂ú = U
refine h V'·∂ú ‚ü®_, is_open_compl_iff.mpr V'cls, _‚ü© (set.subset_compl_comm.mp V'sub)
{ refine h V'·∂ú ‚ü®_, is_open_compl_iff.mpr V'cls, _‚ü© (set.subset_compl_comm.mp V'sub), exact set.subset.trans Uc (set.subset_compl_comm.mp V'sub), simp only [compl_compl, V'ne], }
exact set.subset.trans Uc (set.subset_compl_comm.mp V'sub)
simp only [compl_compl, V'ne]
rw [‚Üêthis, compl_compl]
intros
split
refine (@is_open_iff_mem_nhds Œ± _ _).2 (Œª a ha, mem_nhds_uniformity_iff_right.2 _)
{ refine (@is_open_iff_mem_nhds Œ± _ _).2 (Œª a ha, mem_nhds_uniformity_iff_right.2 _), rcases mem_map_iff_exists_image.1 (hs _ ha).1 with ‚ü®t, ht, st‚ü©, refine mem_of_superset ht _, rintro p pt rfl, exact st ‚ü®_, pt, rfl‚ü© rfl }
rcases mem_map_iff_exists_image.1 (hs _ ha).1 with ‚ü®t, ht, st‚ü©
refine mem_of_superset ht _
rintro p pt rfl
exact st ‚ü®_, pt, rfl‚ü© rfl
refine (@is_open_iff_mem_nhds Œ≤ _ _).2 (Œª b hb, mem_nhds_uniformity_iff_right.2 _)
{ refine (@is_open_iff_mem_nhds Œ≤ _ _).2 (Œª b hb, mem_nhds_uniformity_iff_right.2 _), rcases mem_map_iff_exists_image.1 (hs _ hb).2 with ‚ü®t, ht, st‚ü©, refine mem_of_superset ht _, rintro p pt rfl, exact st ‚ü®_, pt, rfl‚ü© rfl }
rcases mem_map_iff_exists_image.1 (hs _ hb).2 with ‚ü®t, ht, st‚ü©
refine mem_of_superset ht _
rintro p pt rfl
exact st ‚ü®_, pt, rfl‚ü© rfl
intros
simpa using x.2.1
intros
cases b; simp
cases b
simp
simp
intros
cases a; cases b; refl
cases a; cases b
cases a
cases b
refl
intros
rw [‚Üê int.add_assoc, int.add_comm a, int.add_assoc]
intros
induction xs; [refl, simp [*, cons_bind]]
induction xs
refl
simp [*, cons_bind]
intros
rw [div_def a, if_neg]
intro h‚ÇÅ
apply not_le_of_gt h‚ÇÄ h‚ÇÅ.right
intros
rw [‚Üêvsub_vadd p1 p2, h, zero_vadd]
intros
{ rw [update_eq_piecewise, sum_piecewise], simp [h] }
rw [update_eq_piecewise, sum_piecewise]
simp [h]
intros
rw [‚Üêprod_union sdiff_disjoint, sdiff_union_of_subset h]
intros
classical
rw ‚Üê prod_filter_ne_one at h
rcases nonempty_of_prod_ne_one h with ‚ü®x, hx‚ü©
exact ‚ü®x, (mem_filter.1 hx).1, (mem_filter.1 hx).2‚ü©
intros
{ subst q, exact finprod_congr hfg }
subst q
exact finprod_congr hfg
intros
rw [insert_eq, finprod_mem_union' _ _ hs, finprod_mem_singleton]
{ rwa disjoint_singleton_left }
rwa disjoint_singleton_left
{ exact (finite_singleton a).inter_of_left _ }
exact (finite_singleton a).inter_of_left _
intros
cases x with j‚ÇÅ x
cases y with j‚ÇÇ y
obtain ‚ü®s, Œ±, Œ≤, h‚ÇÅ, h‚ÇÇ‚ü© := bowtie (left_to_max j‚ÇÅ j‚ÇÇ) f (right_to_max j‚ÇÅ j‚ÇÇ) g
apply M.mk_eq
use [s, Œ±, Œ≤]
dsimp
simp_rw [monoid_hom.map_mul, ‚Üê comp_apply, ‚Üê F.map_comp, h‚ÇÅ, h‚ÇÇ]
intros
rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]
exact (le_of_succ_succ_nth_continuants_aux_b nth_part_denom_eq)
intros
simp only [convergents, (denominators_stable_of_terminated n_le_m terminated_at_n), (numerators_stable_of_terminated n_le_m terminated_at_n)]
intros
simpa only [‚Üê @div_self _ _ b h] using (div_add_div_same b a b).symm
intros
{ ext, simp [floor_lt, le_floor] }
ext
simp [floor_lt, le_floor]
intros
have : 1 - 1 - 0 = 0 := rfl
{ have : 1 - 1 - 0 = 0 := rfl, rw [geom_sum‚ÇÇ_def, sum_range_one, this, pow_zero, pow_zero, mul_one] }
rw [geom_sum‚ÇÇ_def, sum_range_one, this, pow_zero, pow_zero, mul_one]
intros
rw [mul_eq_one_iff_eq_inv, inv_inj]
intros
simp only [‚Üê mul_assoc, h.eq]
intros
unfold semiconj_by; assoc_rw [h.eq, h'.eq]
unfold semiconj_by
assoc_rw [h.eq, h'.eq]
intros
rw [pow_bit0, (commute.refl a).mul_pow]
intros
simp [sq]
intros
refine ‚ü®Œª h, _, nsmul_le_nsmul $ le_of_lt ha‚ü©
by_contra H
exact lt_irrefl _ (lt_of_lt_of_le (nsmul_lt_nsmul ha (not_le.mp H)) h)
intros
simp
intros
simp [div_eq_mul_inv]
intros
rcases h : c.prev j with _ | ‚ü®j,w‚ü©
{ simp [h] }
simp [h]
{ simp [d_to_eq _ w, prev_eq _ w] }
simp [d_to_eq _ w, prev_eq _ w]
intros
dsimp [prev_d]
rcases c.prev j with _|‚ü®j',w‚ü©
{ exact comp_zero.symm, }
exact comp_zero.symm
dsimp [prev_d, hom.prev]
{ dsimp [prev_d, hom.prev], simp, }
simp
intros
{ rw [d_from_eq ((single‚ÇÄ V).obj X) rfl], simp, }
rw [d_from_eq ((single‚ÇÄ V).obj X) rfl]
simp
intros
{ rw [‚Üê set.indicator_indicator], simp [indicator] }
rw [‚Üê set.indicator_indicator]
simp [indicator]
intros
simp only [_root_.eq_bot_iff, lie_ideal_oper_eq_span, lie_submodule.lie_span_le, lie_submodule.bot_coe, set.subset_singleton_iff, set.mem_set_of_eq, exists_imp_distrib]
refine ‚ü®Œª h z x y hz, hz.symm.trans ((lie_subalgebra.coe_bracket _ _ _).symm.trans ((coe_zero_iff_zero _ _).mpr (by apply h.trivial))), Œª h, ‚ü®Œª x y, (coe_zero_iff_zero _ _).mp (h _ x y rfl)‚ü©‚ü©
intros
suffices : ‚ÅÖmap f I‚ÇÅ, map f I‚ÇÇ‚ÅÜ ‚â§ map f ‚ÅÖI‚ÇÅ, I‚ÇÇ‚ÅÜ
exact le_antisymm (map_bracket_le f) this
{ exact le_antisymm (map_bracket_le f) this, }
rw [‚Üê lie_submodule.coe_submodule_le_coe_submodule, coe_map_of_surjective h, lie_submodule.lie_ideal_oper_eq_linear_span, lie_submodule.lie_ideal_oper_eq_linear_span, linear_map.map_span]
apply submodule.span_mono
rintros x ‚ü®‚ü®z‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®z‚ÇÇ, h‚ÇÇ‚ü©, rfl‚ü©
obtain ‚ü®y‚ÇÅ, rfl‚ü© := mem_map_of_surjective h h‚ÇÅ
obtain ‚ü®y‚ÇÇ, rfl‚ü© := mem_map_of_surjective h h‚ÇÇ
use [‚ÅÖ(y‚ÇÅ : L), (y‚ÇÇ : L)‚ÅÜ, y‚ÇÅ, y‚ÇÇ]
apply f.map_lie
intros
rw lie_ideal.derived_series_eq_bot_iff at hI hJ ‚ä¢
rw ‚Üê le_bot_iff
let D := derived_series_of_ideal R L
change D k I = ‚ä• at hI
change D l J = ‚ä• at hJ
calc D (k + l) (I + J) ‚â§ (D k I) + (D l J) : derived_series_of_ideal_add_le_add I J k l ... ‚â§ ‚ä• : by { rw [hI, hJ], simp, }
intros
rw [‚Üê lie_submodule.coe_to_submodule, Inf_coe_to_submodule, submodule.Inf_coe]
ext m
simpa only [mem_Inter, mem_set_of_eq, forall_apply_eq_imp_iff‚ÇÇ, exists_imp_distrib]
intros
simp
intros
rw [‚Üê mul_self_inj_of_nonneg (abv_nonneg abv _) (abv_nonneg abv _), ‚Üê abv_mul abv, ‚Üê abv_mul abv]
rw [‚Üê mul_self_inj_of_nonneg (abv_nonneg abv _) (abv_nonneg abv _), ‚Üê abv_mul abv, ‚Üê abv_mul abv]; simp
simp
intros
rw [inv_mul_lt_iff h, mul_comm]
intros
rw div_le_div_iff (hd.trans_le hbd) hd
{ rw div_le_div_iff (hd.trans_le hbd) hd, exact mul_le_mul hac hbd hd.le hc }
exact mul_le_mul hac hbd hd.le hc
intros
rwa [‚Üê div_sub_div_same, sub_eq_add_neg, add_comm (b/2), ‚Üê add_assoc, ‚Üê sub_eq_add_neg, ‚Üê lt_sub_iff_add_lt, sub_self_div_two, sub_self_div_two, div_lt_div_right (@zero_lt_two Œ± _ _)]
intros
{ rw [‚Üê mul_le_mul_iff_right a], simp }
rw [‚Üê mul_le_mul_iff_right a]
simp
intros
rw [‚Üê mul_le_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
intros
by_cases b ‚â§ a; simp [max_def, h]
by_cases b ‚â§ a
simp [max_def, h]
simp [max_def, h]
intros
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®Œª h', le_of_mul_le_mul_left h' h, Œª h', decidable.mul_le_mul_of_nonneg_left h' h.le‚ü©
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®Œª h', le_of_mul_le_mul_left h' h, Œª h', decidable.mul_le_mul_of_nonneg_left h' h.le‚ü©
intros
rw [‚Üê sub_pos, ‚Üê sub_mul]
exact ordered_ring.mul_pos _ _ (sub_pos.2 h‚ÇÅ) h‚ÇÇ
intros
cases s with l hl
convert coeff_multiset_prod_of_nat_degree_le (l.map f) _ _
{ simp }
simp
{ simp }
simp
{ simpa using h }
simpa using h
intros
have : ‚àÄ x : K, 0 ‚â§ a*x*x + b*x + c := assume x, le_of_lt (h x)
refine lt_of_le_of_ne (discrim_le_zero this) _
assume h'
have := h (-b / (2 * a))
have : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0
rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))]
{ rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))] }
linarith
intros
ext
ext; simp [two_mul]
simp [two_mul]
simp [two_mul]
simp [two_mul]
simp [two_mul]
intros
rw [‚Üê sub_eq_zero, mul_self_sub_mul_self, mul_eq_zero, or_comm, sub_eq_zero, add_eq_zero_iff_eq_neg]
intros
simp only [two_mul, add_mul, mul_add, add_assoc, mul_comm b]
intros
intros x y h'
simp only at h'
rw ‚Üêsub_eq_zero
refine h _ _
rw [sub_mul, sub_eq_zero, h']
intros
{ rw [add_comm a b, add_comm a c], exact rel.add_left h }
rw [add_comm a b, add_comm a c]
exact rel.add_left h
intros
rw add_eq_iff
split
rintro (‚ü®rfl, h‚ü©|‚ü®rfl, h‚ü©)
{ rintro (‚ü®rfl, h‚ü©|‚ü®rfl, h‚ü©), { exact ‚ü®rfl, le_antisymm (le_zero _) h‚ü© }, { exact ‚ü®le_antisymm (le_zero _) h, rfl‚ü© } }
{ exact ‚ü®rfl, le_antisymm (le_zero _) h‚ü© }
exact ‚ü®rfl, le_antisymm (le_zero _) h‚ü©
{ exact ‚ü®le_antisymm (le_zero _) h, rfl‚ü© }
exact ‚ü®le_antisymm (le_zero _) h, rfl‚ü©
rintro ‚ü®rfl, rfl‚ü©
{ rintro ‚ü®rfl, rfl‚ü©, simp }
simp
intros
rw [const_mul, const_congr R rfl (mul_comm g f), const_self]
intros
ext v i
simp [apply_composition, zero_lt_one.trans_le (c.one_le_blocks_fun i), remove_zero_of_pos]
intros
rcases h.exists_pos with ‚ü®C, C‚ÇÄ, hC‚ü©
rw [is_O_with, eventually_cofinite] at hC
rcases (hC.to_finset.image (Œª x, ‚à•f x‚à• / ‚à•g' x‚à•)).exists_le with ‚ü®C', hC'‚ü©
have : ‚àÄ x, C * ‚à•g' x‚à• < ‚à•f x‚à• ‚Üí ‚à•f x‚à• / ‚à•g' x‚à• ‚â§ C'
simpa using hC'
simpa using hC'
refine ‚ü®max C C', lt_max_iff.2 (or.inl C‚ÇÄ), Œª x h‚ÇÄ, _‚ü©
rw [max_mul_of_nonneg _ _ (norm_nonneg _), le_max_iff, or_iff_not_imp_left, not_le]
exact Œª hx, (div_le_iff (norm_pos_iff.2 h‚ÇÄ)).1 (this _ hx)
intros
rw [conformal_at_iff_is_conformal_map_fderiv, is_conformal_map_iff]
intros
convert (has_strict_deriv_at_const _ _).mul hd
rw [zero_mul, zero_add]
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hc.smul hf
intros
induction n with n ihn
{ exact has_strict_fderiv_at_id x }
exact has_strict_fderiv_at_id x
change has_strict_fderiv_at (f^[n] ‚àò f) (f'^(n+1)) x
{ change has_strict_fderiv_at (f^[n] ‚àò f) (f'^(n+1)) x, rw [pow_succ'], refine has_strict_fderiv_at.comp x _ hf, rwa hx }
rw [pow_succ']
refine has_strict_fderiv_at.comp x _ hf
rwa hx
intros
simp only [sub_eq_add_neg, fderiv_within_add_const hxs]
intros
rw [‚Üê has_fderiv_within_at_univ, ‚Üê has_fderiv_within_at_univ, iso.comp_has_fderiv_within_at_iff]
intros
simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhds_within_restrict'' s ht]
intros
rw [iterated_deriv_within_eq_iterated_fderiv_within, ‚Üê continuous_multilinear_map.map_smul_univ]
simp
intros
rcases exists_ratio_has_deriv_at_eq_ratio_slope f f' hab hfc hff' id 1 continuous_id.continuous_on (Œª x hx, has_deriv_at_id x) with ‚ü®c, cmem, hc‚ü©
use [c, cmem]
simp only [_root_.id, pi.one_apply, mul_one] at hc
rw [‚Üê hc, mul_div_cancel_left]
exact ne_of_gt (sub_pos.2 hab)
intros
let c := Œªn:‚Ñï, (2:‚Ñù)^n
let d := Œªn:‚Ñï, (c n)‚Åª¬π ‚Ä¢ (y-x)
refine ‚ü®c, d, filter.univ_mem' (Œªn, h _), _, _‚ü©
show x + d n ‚àà segment ‚Ñù x y
rw segment_eq_image
{ rw segment_eq_image, refine ‚ü®(c n)‚Åª¬π, ‚ü®_, _‚ü©, _‚ü©, { rw inv_nonneg, apply pow_nonneg, norm_num }, { apply inv_le_one, apply one_le_pow_of_one_le, norm_num }, { simp only [d, sub_smul, smul_sub, one_smul], abel } }
refine ‚ü®(c n)‚Åª¬π, ‚ü®_, _‚ü©, _‚ü©
{ rw inv_nonneg, apply pow_nonneg, norm_num }
rw inv_nonneg
apply pow_nonneg
norm_num
norm_num
{ apply inv_le_one, apply one_le_pow_of_one_le, norm_num }
apply inv_le_one
apply one_le_pow_of_one_le
norm_num
{ simp only [d, sub_smul, smul_sub, one_smul], abel }
simp only [d, sub_smul, smul_sub, one_smul]
abel
show filter.tendsto (Œª (n : ‚Ñï), ‚à•c n‚à•) filter.at_top filter.at_top
have : (Œª (n : ‚Ñï), ‚à•c n‚à•) = c
{ have : (Œª (n : ‚Ñï), ‚à•c n‚à•) = c, by { ext n, exact abs_of_nonneg (pow_nonneg (by norm_num) _) }, rw this, exact tendsto_pow_at_top_at_top_of_one_lt (by norm_num) }
ext n
ext n
{ ext n, exact abs_of_nonneg (pow_nonneg (by norm_num) _) }
{ ext n, exact abs_of_nonneg (pow_nonneg (by norm_num) _) }
exact abs_of_nonneg (pow_nonneg (by norm_num) _)
exact abs_of_nonneg (pow_nonneg (by norm_num) _)
rw this
exact tendsto_pow_at_top_at_top_of_one_lt (by norm_num)
show filter.tendsto (Œª (n : ‚Ñï), c n ‚Ä¢ d n) filter.at_top (ùìù (y - x))
have : (Œª (n : ‚Ñï), c n ‚Ä¢ d n) = (Œªn, y - x)
{ have : (Œª (n : ‚Ñï), c n ‚Ä¢ d n) = (Œªn, y - x), { ext n, simp only [d, smul_smul], rw [mul_inv_cancel, one_smul], exact pow_ne_zero _ (by norm_num) }, rw this, apply tendsto_const_nhds }
ext n
{ ext n, simp only [d, smul_smul], rw [mul_inv_cancel, one_smul], exact pow_ne_zero _ (by norm_num) }
simp only [d, smul_smul]
rw [mul_inv_cancel, one_smul]
exact pow_ne_zero _ (by norm_num)
rw this
apply tendsto_const_nhds
intros
simp only [‚Üê times_cont_diff_on_univ, times_cont_diff_on_all_iff_nat]
intros
refine ‚ü®Œª H, H.continuous_on, Œª H, _‚ü©
assume x hx m hm
have : (m : with_top ‚Ñï) = 0 := le_antisymm hm bot_le
rw this
refine ‚ü®insert x s, self_mem_nhds_within, ftaylor_series_within ùïú f s, _‚ü©
rw has_ftaylor_series_up_to_on_zero_iff
exact ‚ü®by rwa insert_eq_of_mem hx, Œª x hx, by simp [ftaylor_series_within]‚ü©
intros
simp only [segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc]
intros
intros x y hx hy a b ha hb hab
obtain ‚ü®x', hx', rfl‚ü© := mem_image_iff_bex.1 hx
obtain ‚ü®y', hy', rfl‚ü© := mem_image_iff_bex.1 hy
refine ‚ü®a ‚Ä¢ x' + b ‚Ä¢ y', hs hx' hy' ha hb hab, _‚ü©
rw [smul_add, smul_add, add_add_add_comm, ‚Üêadd_smul, hab, one_smul]
intros
refine ‚ü®_, Œª hx, ‚ü®singleton_subset_iff.1 hx.1, Œª x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ, hx.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ x rfl‚ü©‚ü©
rintro ‚ü®hxA, hAx‚ü©
use singleton_subset_iff.2 hxA
rintro x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA y (rfl : y = x)
exact hAx x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA
intros
set t := {p : E √ó ‚Ñù | p.1 ‚àà s ‚àß g p.1 ‚â§ p.2}
have ht_conv : convex ‚Ñù t := hg.convex_epigraph
have ht_closed : is_closed t := (hsc.preimage continuous_fst).is_closed_le (hgc.comp continuous_on_fst (subset.refl _)) continuous_on_snd
have ht_mem : ‚àÄ·µê x ‚àÇŒº, (f x, g (f x)) ‚àà t := hfs.mono (Œª x hx, ‚ü®hx, le_rfl‚ü©)
simpa [integral_pair hfi hgi] using (ht_conv.smul_integral_mem ht_closed hŒº ht_mem (hfi.prod_mk hgi)).2
intros
simp only [inner_sub_left, inner_sub_right]; ring
simp only [inner_sub_left, inner_sub_right]
ring
intros
{ simp [sub_eq_add_neg, inner_add_left] }
simp [sub_eq_add_neg, inner_add_left]
intros
{ have h := @norm_add_mul_self ‚Ñù F _ _, simpa using h }
have h := @norm_add_mul_self ‚Ñù F _ _
simpa using h
intros
rw [ball_eq_preimage, ‚Üê to_euclidean.preimage_closure, closure_ball (to_euclidean x) h, closed_ball_eq_preimage]
intros
exact_mod_cast real.arith_mean_le_rpow_mean s _ _ (Œª i _, (w i).coe_nonneg) (by exact_mod_cast hw') (Œª i _, (z i).coe_nonneg) hp
intros
rw [point_reflection_apply, dist_eq_norm_vsub V, vadd_vsub_assoc, bit0]
intros
ext z
simp only [set.mem_preimage, mem_sphere_iff_norm]
abel
intros
{ convert tendsto_iff_dist_tendsto_zero, simp [dist_eq_norm] }
convert tendsto_iff_dist_tendsto_zero
simp [dist_eq_norm]
intros
simpa [comp_range, incl_range, ‚Üê add_monoid_hom.range_eq_map]
intros
obtain ‚ü®n : M, hn : mk' S n = mk' S m, hn' : ‚à•n‚à• < ‚à•mk' S m‚à• + Œµ‚ü© := norm_mk_lt (quotient_add_group.mk' S m) hŒµ
erw [eq_comm, quotient_add_group.eq] at hn
use [- m + n, hn]
rwa [add_neg_cancel_left]
intros
ext1
{ ext1, rw [to_span_singleton_apply, smul_apply, to_span_singleton_apply, smul_comm], }
rw [to_span_singleton_apply, smul_apply, to_span_singleton_apply, smul_comm]
intros
rw [ennreal.tsum_eq_supr_nat' (tendsto_at_top_mono nat.le_succ tendsto_id), two_mul, ‚Üê two_nsmul]
refine supr_le (Œª n, le_trans _ (add_le_add_left (nsmul_le_nsmul_of_le_right (ennreal.sum_le_tsum $ finset.Ico 2 (2^n + 1)) _) _))
simpa using finset.sum_condensed_le hf n
simp [arg, le_refl]
simp [log]
intros
rw [‚Üê not_lt, log_pos_iff hx, not_lt]
intros
refine (is_equivalent_at_top_div P Q).symm.tendsto_nhds _
rw show (P.nat_degree : ‚Ñ§) = Q.nat_degree, by simp [hdeg, nat_degree]
simp [tendsto_const_nhds]
intros
simp [top_rpow_def, h]
intros
{ simp only [cpow_def], split_ifs; simp [*, exp_ne_zero] }
simp only [cpow_def]
split_ifs
split_ifs; simp [*, exp_ne_zero]
simp [*, exp_ne_zero]
simp [*, exp_ne_zero]
simp [*, exp_ne_zero]
intros
simpa only [‚Üê complex.of_real_inj, complex.of_real_sub, complex.of_real_div, complex.of_real_pow, complex.of_real_mul, complex.of_real_tan, complex.of_real_bit0, complex.of_real_one] using complex.tan_two_mul
intros
convert (has_strict_deriv_at_sin x).div (has_strict_deriv_at_cos x) h
rw ‚Üê sin_sq_add_cos_sq x
ring
intros
refine (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h
{ simp }
simp
{ simp [pow_succ, mul_assoc, le_refl] }
simp [pow_succ, mul_assoc, le_refl]
intros
rw [sub_def, ‚Üêcategory.assoc, prod.comp_lift, sub_def]
intros
suffices : is_iso ((transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ) ((transfer_nat_trans_self adj‚ÇÅ adj‚ÇÇ).symm f))
{ simpa using this }
simpa using this
apply_instance
intros
{ convert w (ùüô Y), tidy }
convert w (ùüô Y)
tidy
intros
{ dsimp [fun_inv_id_assoc], tidy }
dsimp [fun_inv_id_assoc]
tidy
intros
dsimp [coeq‚ÇÉ_hom]
slice_lhs 2 4 { rw [‚Üê category.assoc, coeq_condition _ _] }
slice_rhs 2 4 { rw [‚Üê category.assoc, coeq_condition _ _] }
slice_lhs 1 3 { rw [‚Üê category.assoc, coeq_condition _ _] }
simp only [category.assoc]
intros
simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
dsimp
simp
intros
ext
ext; rw [‚Üêassoc, colimit.Œπ_pre, colimit.Œπ_map, ‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_pre]; refl
ext; rw [‚Üêassoc, colimit.Œπ_pre, colimit.Œπ_map, ‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_pre]
rw [‚Üêassoc, colimit.Œπ_pre, colimit.Œπ_map, ‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_pre]
refl
intros
tidy
intros
{ ext, simp, }
ext
simp
intros
rw [‚Üês.w left, parallel_pair_map_left]
intros
simp [image.pre_comp]
intros
{ ext, simp [kernel_iso_of_eq], }
ext
simp [kernel_iso_of_eq]
intros
rw [‚Üêid_tensor_comp_tensor_id, category.assoc, M.one_mul, left_unitor_naturality]
intros
{ rw [comp_inv_eq, assoc, associator_naturality], simp }
rw [comp_inv_eq, assoc, associator_naturality]
simp
intros
letI : is_iso (biprod.map g f) := by { rw [‚Üêbiprod.braiding_map_braiding], apply_instance, }
exact is_iso_left_of_is_iso_biprod_map g f
intros
have h : (generate R) f := ‚ü®_, _, _, hf, id_comp _‚ü©
change P.map (some (some_spec h)).op (x _ _) = x f hf
rw t (some (some_spec h)) (ùüô _) _ hf _
{ simp }
simp
simp_rw [id_comp]
apply (some_spec (some_spec (some_spec h))).2
intros
simp [image_subobject_comp_iso]
intros
apply lt_of_le_of_lt (sum_le_sum_of_subset (Œª t, mem_range.2 ‚àò h‚ÇÅ))
have z := geom_sum_mul_add 1 k
rw [geom_sum, mul_one, one_add_one_eq_two] at z
rw ‚Üê z
apply nat.lt_succ_self
intros
simp [eq_ones_iff_length, le_antisymm_iff, c.length_le]
intros
simp [h.apply_diag i]
intros
by_cases hV : (univ : finset V).nonempty
haveI : nonempty V := univ_nonempty_iff.mp hV
{ haveI : nonempty V := univ_nonempty_iff.mp hV, obtain ‚ü®v, hv‚ü© := G.exists_maximal_degree_vertex, rw hv, apply h }
obtain ‚ü®v, hv‚ü© := G.exists_maximal_degree_vertex
rw hv
apply h
rw not_nonempty_iff_eq_empty at hV
{ rw not_nonempty_iff_eq_empty at hV, rw [max_degree, hV, image_empty], exact zero_le k }
rw [max_degree, hV, image_empty]
exact zero_le k
intros
simp! [(<*>)]
intros
induction c generalizing k v s
refine ‚ü®_, ‚ü®s, rfl‚ü©, trans_gen.single _‚ü©
case zero' : { refine ‚ü®_, ‚ü®s, rfl‚ü©, trans_gen.single _‚ü©, simp }
simp
refine ‚ü®_, ‚ü®none, rfl‚ü©, head_main_ok.trans succ_ok‚ü©
case succ : { refine ‚ü®_, ‚ü®none, rfl‚ü©, head_main_ok.trans succ_ok‚ü© }
case tail : { let o : option Œì' := list.cases_on v none (Œª _ _, some Œì'.cons), refine ‚ü®_, ‚ü®o, rfl‚ü©, _‚ü©, convert clear_ok _, simp, swap, refine split_at_pred_eq _ _ (tr_nat v.head) _ _ (tr_nat_nat_end _) _, cases v; exact ‚ü®rfl, rfl‚ü© }
let o : option Œì' := list.cases_on v none (Œª _ _, some Œì'.cons)
refine ‚ü®_, ‚ü®o, rfl‚ü©, _‚ü©
convert clear_ok _
simp
swap
refine split_at_pred_eq _ _ (tr_nat v.head) _ _ (tr_nat_nat_end _) _
cases v; exact ‚ü®rfl, rfl‚ü©
cases v
exact ‚ü®rfl, rfl‚ü©
exact ‚ü®rfl, rfl‚ü©
case cons : f fs IHf IHfs { obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IHf (cont.cons‚ÇÅ fs v k) v none, refine ‚ü®c, h‚ÇÅ, trans_gen.head rfl $ (move_ok dec_trivial (split_at_pred_ff _)).trans _‚ü©, simp [step_normal], refine (copy_ok _ none [] (tr_list v).reverse _ _).trans _, convert h‚ÇÇ using 2, simp [list.reverse_core_eq, tr_cont_stack] }
case comp : f g IHf IHg { exact IHg (cont.comp f k) v s }
case case : f g IHf IHg { rw step_normal, obtain ‚ü®s', h‚ü© := pred_ok _ _ s v _ _, cases v.head with n, { obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IHf k _ s', exact ‚ü®_, h‚ÇÅ, h.trans h‚ÇÇ‚ü© }, { obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IHg k _ s', exact ‚ü®_, h‚ÇÅ, h.trans h‚ÇÇ‚ü© } }
case fix : f IH { apply IH }
intros
rcases s with _|_|_; unfold tr_stmts‚ÇÅ st_run
rcases s with _|_|_
unfold tr_stmts‚ÇÅ st_run
unfold tr_stmts‚ÇÅ st_run
unfold tr_stmts‚ÇÅ st_run
intros
induction i generalizing T; [refl, simp only [*, tape.move_right_nth, int.coe_nat_succ, iterate_succ]]
induction i generalizing T
refl
simp only [*, tape.move_right_nth, int.coe_nat_succ, iterate_succ]
intros
cases x; simp [sum.traverse, id_map] with functor_norm; refl
cases x; simp [sum.traverse, id_map] with functor_norm
cases x
simp [sum.traverse, id_map] with functor_norm
refl
simp [sum.traverse, id_map] with functor_norm
refl
intros
cases h; subst h; [cases b‚ÇÅ, cases b‚ÇÄ]; simp [to_nat,nat.zero_le]
cases h; subst h; [cases b‚ÇÅ, cases b‚ÇÄ]
cases h; subst h
cases h
subst h
cases b‚ÇÅ
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
subst h
cases b‚ÇÄ
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
intros
{ cases b, simp [to_list] }
cases b
simp [to_list]
intros
contrapose! h
obtain ‚ü®np, err, hp‚ü© := bounded.exists p h
simp [hp]
introI h
have : eof buffer.nil 0 = done 0 () := by simpa [remaining_eq_done]
replace this : 0 < 0 := prog.of_done this
exact (lt_irrefl _) this
intros
by_cases hp : p; simp [guard, hp, eq_comm, pure_eq_done]
{ by_cases hp : p; simp [guard, hp, eq_comm, pure_eq_done] }
by_cases hp : p
simp [guard, hp, eq_comm, pure_eq_done]
simp [guard, hp, eq_comm, pure_eq_done]
intros
simp [foldr_core, and_comm]
intros
rw ‚Üê of_real_inj; simp [cosh_sq]
rw ‚Üê of_real_inj
simp [cosh_sq]
intros
rw [sin_add, cos_mul_I, sin_mul_I, mul_assoc]
intros
rw [‚Üê exp_add_mul_I, re_add_im]
intros
rw [of_real_alg, one_smul]
intros
simp [norm_sq_eq_def']
simp [‚Üê finrank_eq_dim, finrank_real_complex]
intros
have := (lift_add_hom (Œª a, add_monoid_hom.of_map_sub (h a) (h_sub a))).map_sub f g
rw [lift_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply] at this
exact this
intros
rw [filter_single, if_neg h]
intros
simpa [equiv.image_eq_preimage] using (equiv.set.congr e).forall_congr_left'
intros
rwa [equiv.perm.via_fintype_embedding, equiv.perm.extend_domain_apply_not_subtype]
intros
rw [inter_comm, e.left_inv_on.image_inter, image_source_eq_target, inter_comm]
intros
rw [‚Üêmul_one (h 1), ‚Üêh.apply_symm_apply 1, ‚Üêh.map_mul, one_mul]
intros
dsimp [pred_above, succ_above]
rcases p with ‚ü®p, _‚ü©
rcases i with ‚ü®i, _‚ü©
split_ifs
rw dif_neg
{ rw dif_neg, { refl }, { simp_rw [if_pos h], simp only [subtype.mk_lt_mk, not_lt], exact le_of_lt h, }, }
{ refl }
refl
simp_rw [if_pos h]
{ simp_rw [if_pos h], simp only [subtype.mk_lt_mk, not_lt], exact le_of_lt h, }
simp only [subtype.mk_lt_mk, not_lt]
exact le_of_lt h
rw dif_pos
{ rw dif_pos, { refl, }, { simp_rw [if_neg h], exact lt_succ_iff.mpr (not_lt.mp h), }, }
{ refl, }
refl
simp_rw [if_neg h]
{ simp_rw [if_neg h], exact lt_succ_iff.mpr (not_lt.mp h), }
exact lt_succ_iff.mpr (not_lt.mp h)
intros
simp only [insert_nth, succ_above_cases, dif_neg (succ_above_ne _ _)]
by_cases hlt : j.cast_succ < i
rw [dif_pos ((succ_above_lt_iff _ _).2 hlt)]
{ rw [dif_pos ((succ_above_lt_iff _ _).2 hlt)], apply eq_of_heq ((eq_rec_heq _ _).trans _), rw [cast_lt_succ_above hlt] }
apply eq_of_heq ((eq_rec_heq _ _).trans _)
rw [cast_lt_succ_above hlt]
rw [dif_neg (mt (succ_above_lt_iff _ _).1 hlt)]
{ rw [dif_neg (mt (succ_above_lt_iff _ _).1 hlt)], apply eq_of_heq ((eq_rec_heq _ _).trans _), rw [pred_succ_above (le_of_not_lt hlt)] }
apply eq_of_heq ((eq_rec_heq _ _).trans _)
rw [pred_succ_above (le_of_not_lt hlt)]
intros
classical
refine ‚ü®s.filter (‚àà t‚ÇÅ), s.filter (‚àâ t‚ÇÅ), _, _ , _‚ü©
{ simp [filter_union_right, em] }
simp [filter_union_right, em]
{ intro x, simp }
intro x
simp
intro x
{ intro x, simp, intros hx hx‚ÇÇ, refine ‚ü®or.resolve_left (h hx) hx‚ÇÇ, hx‚ÇÇ‚ü© }
simp
intros hx hx‚ÇÇ
refine ‚ü®or.resolve_left (h hx) hx‚ÇÇ, hx‚ÇÇ‚ü©
intros
obtain ‚ü®x, hx, y, hy, hxy‚ü© := finset.one_lt_card.mp hs
by_cases ha : y = a
{ exact ‚ü®x, hx, ne_of_ne_of_eq hxy ha‚ü© }
exact ‚ü®x, hx, ne_of_ne_of_eq hxy ha‚ü©
{ exact ‚ü®y, hy, ha‚ü© }
exact ‚ü®y, hy, ha‚ü©
intros
rw [‚Üê card_union_add_card_inter, disjoint_iff_inter_eq_empty.1 h, card_empty, add_zero]
intros
cases max_of_nonempty (h.image f) with y hy
rcases mem_image.mp (mem_of_max hy) with ‚ü®x, hx, rfl‚ü©
exact ‚ü®x, hx, Œª x' hx', le_max_of_mem (mem_image_of_mem f hx') hy‚ü©
intros
obtain ‚ü®sl, sl', rfl‚ü© := exists_list_nodup_eq s
obtain ‚ü®tl, tl', rfl‚ü© := exists_list_nodup_eq t
rw list.disjoint_to_finset_iff_disjoint at h
simp [sl', tl', noncomm_prod_to_finset, ‚Üêlist.prod_append, ‚Üêlist.to_finset_append, list.nodup_append_of_nodup sl' tl' h]
intros
{ ext, simp }
ext
simp
intros
rw [smul_single, smul_eq_mul, mul_one]
intros
ext
{ ext, simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype], }
simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype]
intros
rw [inter_comm, univ_inter]
intros
rw [‚Üê coe_nonempty, coe_univ, set.nonempty_iff_univ_nonempty]
intros
cases n; simp; refl
cases n; simp
cases n
simp
refl
simp
refl
intros
rw mul_comm; exact int.div_eq_iff_eq_mul_right H H'
rw mul_comm
exact int.div_eq_iff_eq_mul_right H H'
intros
rw [even_sub, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
refine ext_le (by convert h) (Œª n h‚ÇÅ h‚ÇÇ, _)
simp only [nth_le_singleton]
congr
exact eq_bot_iff.mpr (nat.lt_succ_iff.mp h‚ÇÇ)
intros
induction l; [refl, simp only [*, map]]; split; refl
induction l; [refl, simp only [*, map]]; split
induction l; [refl, simp only [*, map]]
induction l
refl
simp only [*, map]
split
refl
refl
intros
induction l generalizing n
case list.nil : n h { simpa using h }
simpa using h
case list.cons : l_hd l_tl l_ih n h { cases n; simp only [mem_cons_iff, drop] at h ‚ä¢, { exact h }, right, apply l_ih h }
cases n; simp only [mem_cons_iff, drop] at h ‚ä¢
cases n
simp only [mem_cons_iff, drop] at h ‚ä¢
{ exact h }
exact h
simp only [mem_cons_iff, drop] at h ‚ä¢
right
apply l_ih h
intros
{ cases L, { simp, refl, }, { simp, }, }
cases L
simp
{ simp, refl, }
refl
simp
{ simp, }
intros
simp only [pmap_eq_map_attach, mem_map, mem_attach, true_and, subtype.exists]
intros
rw [(reduce_option_length_le l).lt_iff_ne, ne, reduce_option_length_eq_iff]
induction l; simp *
induction l
simp *
simp *
rw [eq_comm, ‚Üê option.not_is_some_iff_eq_none, decidable.imp_iff_not_or]
intros
induction s; intros; contradiction
induction s; intros
induction s
contradiction
contradiction
intros
rw [permutations, permutations, map, map_permutations_aux, map]
intros
induction l‚ÇÅ; simp only [nil_union, not_mem_nil, false_or, cons_union, mem_insert_iff, mem_cons_iff, or_assoc, *]
induction l‚ÇÅ
simp only [nil_union, not_mem_nil, false_or, cons_union, mem_insert_iff, mem_cons_iff, or_assoc, *]
simp only [nil_union, not_mem_nil, false_or, cons_union, mem_insert_iff, mem_cons_iff, or_assoc, *]
intros
induction xs with x xs
{ simp only [not_mem_nil, map_nil] }
simp only [not_mem_nil, map_nil]
cases x with a b
{ cases x with a b, simp only [mem_cons_iff, prod.mk.inj_iff, map, prod.swap_prod_mk, prod.exists, xs_ih, and_comm] }
simp only [mem_cons_iff, prod.mk.inj_iff, map, prod.swap_prod_mk, prod.exists, xs_ih, and_comm]
intros
{ rw ‚Üê cons_head'_tail hy at h, exact h.rel_head }
rw ‚Üê cons_head'_tail hy at h
exact h.rel_head
intros
rw [‚Üênext_reverse_eq_prev _ hn, ‚Üênext_reverse_eq_prev _ (h.nodup_iff.mp hn)]
exact is_rotated_next_eq h.reverse (nodup_reverse.mpr hn) _
intros
simp [duplicate_cons_iff, hne.symm]
intros
by_cases n < m
{ rw [eq_cons h], exact chain_succ_range' _ _ }
rw [eq_cons h]
exact chain_succ_range' _ _
{ rw [eq_nil_of_le (le_of_not_gt h)], trivial }
rw [eq_nil_of_le (le_of_not_gt h)]
trivial
intros
simp only [nodup, pairwise_cons, forall_mem_ne]
intros
induction l with hd tl IH
{ simp }
simp
rw list.pairwise_cons
{ rw list.pairwise_cons, split, { intros x hx, by_cases H : hd = x, { rw H, refine hr _ _, simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx }, { exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H } }, { refine IH _ _, { intros x hx, refine hr _ _, rw count_cons, split_ifs, { exact hx.trans (nat.lt_succ_self _) }, { exact hx } }, { intros x hx y hy, exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy) } } }
split
intros x hx
{ intros x hx, by_cases H : hd = x, { rw H, refine hr _ _, simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx }, { exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H } }
by_cases H : hd = x
rw H
{ rw H, refine hr _ _, simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx }
refine hr _ _
simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx
{ exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H }
exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H
refine IH _ _
{ refine IH _ _, { intros x hx, refine hr _ _, rw count_cons, split_ifs, { exact hx.trans (nat.lt_succ_self _) }, { exact hx } }, { intros x hx y hy, exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy) } }
intros x hx
{ intros x hx, refine hr _ _, rw count_cons, split_ifs, { exact hx.trans (nat.lt_succ_self _) }, { exact hx } }
refine hr _ _
rw count_cons
split_ifs
exact hx.trans (nat.lt_succ_self _)
{ exact hx.trans (nat.lt_succ_self _) }
exact hx
{ exact hx }
intros x hx y hy
{ intros x hx y hy, exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy) }
exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy)
intros
induction s with y s IH
{ simp }
simp
simp only [not_or_distrib, mem_cons_iff] at hx
{ simp only [not_or_distrib, mem_cons_iff] at hx, simp only [not_and, exists_eq_right_right, mem_map, permutations'_aux, nodup_cons], refine ‚ü®Œª _, ne.symm hx.left, _‚ü©, rw nodup_map_iff, { exact IH hx.right }, { simp } }
simp only [not_and, exists_eq_right_right, mem_map, permutations'_aux, nodup_cons]
refine ‚ü®Œª _, ne.symm hx.left, _‚ü©
rw nodup_map_iff
{ exact IH hx.right }
exact IH hx.right
{ simp }
simp
intros
induction t generalizing l‚ÇÅ l‚ÇÇ h; simp [*, subperm.erase]
induction t generalizing l‚ÇÅ l‚ÇÇ h
simp [*, subperm.erase]
simp [*, subperm.erase]
intros
rw [‚Üê length_eq_zero, length_range]
intros
rw add_comm n 1; exact (range'_append s n 1).symm
rw add_comm n 1
exact (range'_append s n 1).symm
intros
rw [is_rotated_comm, is_rotated_singleton_iff, eq_comm]
intros
simp [list.nodup_range]
intros
by_cases h : a = a'; simp [h]
by_cases h : a = a'
simp [h]
simp [h]
intros
induction s‚ÇÅ with a l‚ÇÅ h‚ÇÅ s‚ÇÅ IH generalizing l‚ÇÇ
{ exact p.nil_eq }
exact p.nil_eq
have : a ‚àà l‚ÇÇ := p.subset (mem_cons_self _ _)
{ have : a ‚àà l‚ÇÇ := p.subset (mem_cons_self _ _), rcases mem_split this with ‚ü®u‚ÇÇ, v‚ÇÇ, rfl‚ü©, have p' := (perm_cons a).1 (p.trans perm_middle), have := IH p' (pairwise_of_sublist (by simp) s‚ÇÇ), subst l‚ÇÅ, change a::u‚ÇÇ ++ v‚ÇÇ = u‚ÇÇ ++ ([a] ++ v‚ÇÇ), rw ‚Üê append_assoc, congr, have : ‚àÄ (x : Œ±) (h : x ‚àà u‚ÇÇ), x = a := Œª x m, antisymm ((pairwise_append.1 s‚ÇÇ).2.2 _ m a (mem_cons_self _ _)) (h‚ÇÅ _ (by simp [m])), rw [(@eq_repeat _ a (length u‚ÇÇ + 1) (a::u‚ÇÇ)).2, (@eq_repeat _ a (length u‚ÇÇ + 1) (u‚ÇÇ++[a])).2]; split; simp [iff_true_intro this, or_comm] }
rcases mem_split this with ‚ü®u‚ÇÇ, v‚ÇÇ, rfl‚ü©
have p' := (perm_cons a).1 (p.trans perm_middle)
have := IH p' (pairwise_of_sublist (by simp) s‚ÇÇ)
subst l‚ÇÅ
change a::u‚ÇÇ ++ v‚ÇÇ = u‚ÇÇ ++ ([a] ++ v‚ÇÇ)
rw ‚Üê append_assoc
congr
have : ‚àÄ (x : Œ±) (h : x ‚àà u‚ÇÇ), x = a := Œª x m, antisymm ((pairwise_append.1 s‚ÇÇ).2.2 _ m a (mem_cons_self _ _)) (h‚ÇÅ _ (by simp [m]))
rw [(@eq_repeat _ a (length u‚ÇÇ + 1) (a::u‚ÇÇ)).2, (@eq_repeat _ a (length u‚ÇÇ + 1) (u‚ÇÇ++[a])).2]
rw [(@eq_repeat _ a (length u‚ÇÇ + 1) (a::u‚ÇÇ)).2, (@eq_repeat _ a (length u‚ÇÇ + 1) (u‚ÇÇ++[a])).2]; split; simp [iff_true_intro this, or_comm]
rw [(@eq_repeat _ a (length u‚ÇÇ + 1) (a::u‚ÇÇ)).2, (@eq_repeat _ a (length u‚ÇÇ + 1) (u‚ÇÇ++[a])).2]; split
split
simp [iff_true_intro this, or_comm]
simp [iff_true_intro this, or_comm]
split
simp [iff_true_intro this, or_comm]
simp [iff_true_intro this, or_comm]
intros
rw [sublists_aux‚ÇÅ_eq_sublists_aux]; refl
rw [sublists_aux‚ÇÅ_eq_sublists_aux]
refl
intros
cases z
rw [zip, nth_zip_with_eq_some]
split
{ rintro ‚ü®x, y, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ‚ü©, cc }
rintro ‚ü®x, y, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ‚ü©
cc
{ rintro ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©, exact ‚ü®_,_,h‚ÇÄ,h‚ÇÅ,rfl‚ü© }
rintro ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©
exact ‚ü®_,_,h‚ÇÄ,h‚ÇÅ,rfl‚ü©
intros
{ ext, apply dot_product_comm }
ext
apply dot_product_comm
intros
ext
{ext, refl}
refl
intros
simp_rw [dot_product, mul_comm]
intros
{ ext, simp }
ext
simp
intros
ext ‚ü®k, i‚ü© ‚ü®k', j‚ü©
simp only [block_diagonal'_apply, mul_apply, ‚Üê finset.univ_sigma_univ, finset.sum_sigma]
rw fintype.sum_eq_single k
split_ifs; simp
{ split_ifs; simp }
split_ifs
simp
simp
intros j' hj'
{ intros j' hj', exact finset.sum_eq_zero (Œª _ _, by rw [dif_neg hj'.symm, zero_mul]) }
exact finset.sum_eq_zero (Œª _ _, by rw [dif_neg hj'.symm, zero_mul])
intros
ext i
simp_rw [vec_alt1]
rcases i with ‚ü®‚ü®‚ü© | i, hi‚ü©
{ refl }
refl
{ simp [vec_alt1, nat.add_succ, nat.succ_add] }
simp [vec_alt1, nat.add_succ, nat.succ_add]
intros
ext
ext; simp [to_matrix, one_apply]; congr
ext; simp [to_matrix, one_apply]
simp [to_matrix, one_apply]
intros
simp [countp_eq_card_filter]
intros
rw [‚Üê rel_flip, rel_map_left, ‚Üê rel_flip]; refl
rw [‚Üê rel_flip, rel_map_left, ‚Üê rel_flip]
refl
intros
{ rw ‚Üê fin_succ_equiv_eq, refl }
rw ‚Üê fin_succ_equiv_eq
refl
intros
rw [hom_bind‚ÇÅ, eval‚ÇÇ_hom_comp_C]
intros
rw [rename, aeval_monomial, monomial_eq, finsupp.prod_map_domain_index]
{ refl }
refl
{ exact assume n, pow_zero _ }
exact assume n, pow_zero _
{ exact assume n i‚ÇÅ i‚ÇÇ, pow_add _ _ _ }
exact assume n i‚ÇÅ i‚ÇÇ, pow_add _ _ _
intros
simp [vars, degrees_map]
intros
conv { to_rhs, rw ‚Üêmod_add_div n k }
rcases h with ‚ü®t, rfl‚ü©
rw [mul_assoc, add_mul_mod_self_left]
intros
by_cases h : nat.find_greatest P b = 0
cases m
{ cases m, { rwa h }, exact ((find_greatest_eq_zero_iff.1 h) m.zero_lt_succ hmb hm).elim }
rwa h
{ rwa h }
exact ((find_greatest_eq_zero_iff.1 h) m.zero_lt_succ hmb hm).elim
{ exact (find_greatest_eq_iff.1 rfl).2.1 h }
exact (find_greatest_eq_iff.1 rfl).2.1 h
intros
rw [‚Üê cast_one, cast_le]
intros
conv { congr, skip, rw ‚Üê(of_digits_digits b' n) }
rw coe_int_of_digits
apply of_digits_zmodeq' _ _ _ h
intros
conv { to_lhs, rw [‚Üê coe_le_coe, coe_get, coe_get]}
intros
delta lcm; rw [mul_comm, gcd_comm]
delta lcm
rw [mul_comm, gcd_comm]
intros
apply dvd_antisymm
apply nat.coprime.dvd_of_dvd_mul_right (nat.coprime.mul (cop.gcd_left _) (cop.gcd_left _))
{ apply nat.coprime.dvd_of_dvd_mul_right (nat.coprime.mul (cop.gcd_left _) (cop.gcd_left _)), rw ‚Üê h, apply mul_dvd_mul (gcd_dvd _ _).1 (gcd_dvd _ _).1 }
rw ‚Üê h
apply mul_dvd_mul (gcd_dvd _ _).1 (gcd_dvd _ _).1
rw [gcd_comm a _, gcd_comm b _]
{ rw [gcd_comm a _, gcd_comm b _], transitivity c.gcd (a * b), rw [h, gcd_mul_right_right d c], apply gcd_mul_dvd_mul_gcd }
transitivity c.gcd (a * b)
rw [h, gcd_mul_right_right d c]
apply gcd_mul_dvd_mul_gcd
intros
rw [modeq, eq_comm, ‚Üê int.coe_nat_inj', int.coe_nat_mod, int.coe_nat_mod, int.mod_eq_mod_iff_mod_sub_eq_zero, int.dvd_iff_mod_eq_zero]
intros
convert not_even_bit1 n; exact two_mul n
convert not_even_bit1 n
exact two_mul n
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp
cases x
simp
simp
intros
rcases x with _ | _ | x; simp
{ rcases x with _ | _ | x; simp }
rcases x with _ | _ | x
simp
simp
simp
intros
unfold balance'
split_ifs
{ refl }
refl
{ exact hr.rotate_l_size }
exact hr.rotate_l_size
{ exact hl.rotate_r_size }
exact hl.rotate_r_size
{ refl }
refl
intros
rw [‚Üê balance_eq_balance' hl hr sl sr, balance_l_eq_balance sl sr]
intro l0
{ intro l0, rw l0 at H, rcases H with ‚ü®_, ‚ü®‚ü®‚ü©‚ü©|‚ü®‚ü®‚ü©‚ü©, H‚ü© | ‚ü®r', e, H‚ü©, { exact balanced_sz_zero.1 H.symm }, exact le_trans (raised_iff.1 e).1 (balanced_sz_zero.1 H.symm) }
rw l0 at H
rcases H with ‚ü®_, ‚ü®‚ü®‚ü©‚ü©|‚ü®‚ü®‚ü©‚ü©, H‚ü© | ‚ü®r', e, H‚ü©
{ exact balanced_sz_zero.1 H.symm }
exact balanced_sz_zero.1 H.symm
exact le_trans (raised_iff.1 e).1 (balanced_sz_zero.1 H.symm)
intros l1 r1
{ intros l1 r1, rcases H with ‚ü®l', e, H | ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü© | ‚ü®r', e, H | ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü©, { exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos dec_trivial l1 : (0:‚Ñï)<_) }, { exact le_trans H‚ÇÇ (nat.mul_le_mul_left _ (raised_iff.1 e).1) }, { cases raised_iff.1 e, unfold delta, linarith }, { exact le_trans (raised_iff.1 e).1 H‚ÇÇ } }
rcases H with ‚ü®l', e, H | ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü© | ‚ü®r', e, H | ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü©
exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos dec_trivial l1 : (0:‚Ñï)<_)
{ exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos dec_trivial l1 : (0:‚Ñï)<_) }
{ exact le_trans H‚ÇÇ (nat.mul_le_mul_left _ (raised_iff.1 e).1) }
exact le_trans H‚ÇÇ (nat.mul_le_mul_left _ (raised_iff.1 e).1)
{ cases raised_iff.1 e, unfold delta, linarith }
cases raised_iff.1 e
unfold delta
linarith
{ exact le_trans (raised_iff.1 e).1 H‚ÇÇ }
exact le_trans (raised_iff.1 e).1 H‚ÇÇ
intros
ext
simp only [eq_none_iff_forall_not_mem, option.mem_def, f.eq_some_iff] at h
dsimp [pequiv.trans, single]
simp
intros
split_ifs; simp * at *
split_ifs
simp * at *
simp * at *
intros
rw [W_mk, W_rec]
dsimp
rw [Wp_rec_eq]
dsimp only [W_path_dest_left_W_path_cases_on, W_path_dest_right_W_path_cases_on]
congr
congr; ext1 i; cases (f i); refl
congr; ext1 i; cases (f i)
congr; ext1 i
ext1 i
cases (f i)
refl
ext1 i
cases (f i)
refl
intros
let h : (v.prod : ‚Ñï) = ((v.map coe).map coe).prod := (pnat.coe_monoid_hom.map_multiset_prod v.to_pnat_multiset)
rw [multiset.map_map] at h
have : (coe : ‚Ñï+ ‚Üí ‚Ñï) ‚àò (coe : nat.primes ‚Üí ‚Ñï+) = coe := funext (Œª p, rfl)
rw[this] at h
exact h
intros
change u.r - 1 < u.bp
have h‚ÇÄ : (u.r - 1) + 1 = u.r := nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hr)
have h‚ÇÅ : u.r < u.bp + 1 := nat.mod_lt (u.ap + 1) u.bp.succ_pos
rw[‚Üê h‚ÇÄ] at h‚ÇÅ
exact lt_of_succ_lt_succ h‚ÇÅ
intros
induction k with k ih
{ simp, }
simp
{ simp [ih, pow_succ', ‚Üêmul_assoc, add_assoc], }
simp [ih, pow_succ', ‚Üêmul_assoc, add_assoc]
intros
cases i; simp
cases i
simp
simp
intros
simpa only [pow_one] using @leading_coeff_X_pow R _ 1
intros
rw ‚Üê degree_neg q at h
{ rw ‚Üê degree_neg q at h, rw [sub_eq_add_neg, degree_add_eq_left_of_degree_lt h] }
rw [sub_eq_add_neg, degree_add_eq_left_of_degree_lt h]
intros
rw [trailing_degree, support_monomial _ _ ha, inf_singleton, with_top.some_eq_coe]
intros
rw [C_mul_X_pow_eq_monomial, self_sub_monomial_nat_degree_leading_coeff]
intros
rw [‚ÜêC_eq_nat_cast, C_comp]
intros
rw X_pow_eq_monomial
convert eval‚ÇÇ_monomial f x
simp
intros
simp only [‚Üê coeff_nat_degree, coeff_map f, nat_degree_map]
intros
simp [div_X, coeff_C]
intros
simp only [coe_map_ring_hom, lifts, map_alg_eq_map, alg_hom.mem_range, ring_hom.mem_srange]
intros
nontriviality
simp only [‚Üê coeff_one_reverse]
rw reverse_mul; simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]
rw reverse_mul
simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]
simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]
intros
apply taylor_injective r
rw linear_map.map_zero
ext k
simp only [taylor_coeff, h, coeff_zero]
intros
rcases h with ‚ü®c, rfl‚ü©
simp only [mul_comm b, int.mul_div_assoc c (dvd_refl b), int.cast_mul, mul_div_assoc, coe_int_div_self]
intros
refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) _
rw [‚Üê not_lt]
intro h
refine ne_of_lt _ mk_univ_real
have hu : Iio a ‚à™ {a} ‚à™ Ioi a = set.univ
{ convert Iic_union_Ioi, exact Iio_union_right }
convert Iic_union_Ioi
exact Iio_union_right
rw ‚Üê hu
refine lt_of_le_of_lt (mk_union_le _ _) _
refine lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) _
have h2 : (Œª x, a + a - x) '' Ioi a = Iio a
{ convert image_const_sub_Ioi _ _, simp }
convert image_const_sub_Ioi _ _
simp
rw ‚Üê h2
refine add_lt_of_lt (cantor _).le _ h
refine add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) _
rw mk_singleton
exact one_lt_omega.trans (cantor _)
intros
rw [ennreal.of_real, ennreal.of_real, coe_lt_coe, real.to_nnreal_lt_to_nnreal_iff h]
intros
conv_lhs { rw [‚Üê ennreal.of_real_coe_nat n, ennreal.to_real_of_real (nat.cast_nonneg _)] }
intros
by_cases h' : x = ‚ä•
{ simp only [h', bot_le] }
simp only [h', bot_le]
{ simp only [le_refl, coe_to_real h h'] }
simp only [le_refl, coe_to_real h h']
intros
rwa [st_of_is_st hxr]
intros
simpa only [add_zero] using is_st_add hx hy
intros
simp [real.to_nnreal, nnreal.coe_lt_coe.symm, lt_irrefl]
intros
simpa using div_add_div b a one_ne_zero hc
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ‚Ñù)
{ exact (or.inl $ sign_of_neg hn) }
exact (or.inl $ sign_of_neg hn)
{ exact (h rfl).elim }
exact (h rfl).elim
{ exact (or.inr $ sign_of_pos hp) }
exact (or.inr $ sign_of_pos hp)
intros
cases le_or_lt x 0
{ rw [sqrt_eq_zero'.mpr h, div_zero] }
rw [sqrt_eq_zero'.mpr h, div_zero]
rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le]
{ rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le] }
intros
revert h; rw eq_mk_of_mem aq; intro; refl
revert h; rw eq_mk_of_mem aq; intro
revert h; rw eq_mk_of_mem aq
revert h
rw eq_mk_of_mem aq
intro
refl
intros
rw bind_ret; change (Œª x : Œ±, x) with @id Œ±; rw map_id
rw bind_ret; change (Œª x : Œ±, x) with @id Œ±
rw bind_ret
change (Œª x : Œ±, x) with @id Œ±
rw map_id
intros
simp [set.ite]
intros
rw [‚Üêimage_inter_preimage, nonempty_image_iff]
intros
rw range_subset_iff
intro x
by_cases h : p x
simp [if_pos h, mem_union, mem_range_self]
simp [if_neg h, mem_union, mem_range_self]
intros
{ ext ‚ü®x, y‚ü©, simp [and.left_comm, eq_comm] }
ext ‚ü®x, y‚ü©
simp [and.left_comm, eq_comm]
intros
simp [classical.skolem, set.nonempty]
intros
simp
intros
rw [‚Üê image_univ, univ_eq, image_pair]
intros
simp [finset.ext_iff, mem_insert_iff]
intros
by_cases hx : x ‚àà s; simp [hx]
by_cases hx : x ‚àà s
simp [hx]
simp [hx]
intros
rw [inter_comm, Ioc_inter_Ioo_of_right_le h, max_comm]
intros
rw [‚Üêdiff_eq_empty, Iio_diff_Iic, Ioo_eq_empty_iff, not_lt]
intros
simp [‚Üê Ioi_inter_Iic]
intros
simp
intros
simp [‚Üê Ici_inter_Iio, ‚Üê Ioi_inter_Iic, h, inter_comm]
intros
simp_rw [pi_univ_Ioc_update_left hm.1, pi_univ_Ioc_update_right hm.2, ‚Üê union_inter_distrib_right, ‚Üê set_of_or, le_or_lt, set_of_true, univ_inter]
intros
simp
intros
rintro a ‚ü®‚ü®b, hb, eq‚ü©, c, hc, rfl‚ü©; exact h b hb c hc eq
rintro a ‚ü®‚ü®b, hb, eq‚ü©, c, hc, rfl‚ü©
exact h b hb c hc eq
intros
simp
intros
simp
intros
tidy
intros
ext x
ext x; cases x
cases x
intros
simp only [‚Üêcons_head_tail, eq_iff_true_of_subsingleton]
intros
rw [‚Üê nat.cast_add_one, nat_cast_self (n + 1)]
intros
rw [‚Üê @nat.cast_one (zmod 2), zmod.eq_iff_modeq_nat, nat.odd_iff, nat.modeq]
{ rw [‚Üê @nat.cast_one (zmod 2), zmod.eq_iff_modeq_nat, nat.odd_iff, nat.modeq], norm_num }
norm_num
intros
refine {..}; simp
refine {..}
simp
simp
simp
simp
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const m) f.monotone h n
intros
rcases ennreal.exists_nat_mul_gt hs' (measure_ne_top Œº (univ : set Œ±)) with ‚ü®N, hN‚ü©
rcases hf.exists_mem_image_mem_of_volume_lt_mul_volume hs hN with ‚ü®x, hx, m, hm, hmx‚ü©
exact ‚ü®x, hx, m, hm.1.ne', hmx‚ü©
intros
rw [is_periodic_pt, ‚Üê iterate_mul, mul_comm, iterate_mul]
exact hf.is_fixed_pt.iterate m
intros
apply_instance
intros
cases h with t ht
exact ‚ü®t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm‚ü©
intros
have h1 : (X : polynomial K').degree < (X ^ p : polynomial K').degree
rw [degree_X_pow, degree_X]
{ rw [degree_X_pow, degree_X], exact_mod_cast hp }
exact_mod_cast hp
rw [nat_degree_eq_of_degree_eq (degree_sub_eq_left_of_degree_lt h1), nat_degree_X_pow]
intros
have hdegle : (minpoly A (algebra_map A B a)).nat_degree ‚â§ 1
apply with_bot.coe_le_coe.1
{ apply with_bot.coe_le_coe.1, rw [‚Üêdegree_eq_nat_degree (ne_zero (@is_integral_algebra_map A B _ _ _ a)), with_top.coe_one, ‚Üêdegree_X_sub_C a], refine min A (algebra_map A B a) (monic_X_sub_C a) _, simp only [aeval_C, aeval_X, alg_hom.map_sub, sub_self] }
rw [‚Üêdegree_eq_nat_degree (ne_zero (@is_integral_algebra_map A B _ _ _ a)), with_top.coe_one, ‚Üêdegree_X_sub_C a]
refine min A (algebra_map A B a) (monic_X_sub_C a) _
simp only [aeval_C, aeval_X, alg_hom.map_sub, sub_self]
have hdeg : (minpoly A (algebra_map A B a)).degree = 1
apply (degree_eq_iff_nat_degree_eq (ne_zero (@is_integral_algebra_map A B _ _ _ a))).2
{ apply (degree_eq_iff_nat_degree_eq (ne_zero (@is_integral_algebra_map A B _ _ _ a))).2, apply le_antisymm hdegle (nat_degree_pos (@is_integral_algebra_map A B _ _ _ a)) }
apply le_antisymm hdegle (nat_degree_pos (@is_integral_algebra_map A B _ _ _ a))
have hrw := eq_X_add_C_of_degree_eq_one hdeg
simp only [monic (@is_integral_algebra_map A B _ _ _ a), one_mul, monic.leading_coeff, ring_hom.map_one] at hrw
have h0 : (minpoly A (algebra_map A B a)).coeff 0 = -a
have hroot := aeval A (algebra_map A B a)
{ have hroot := aeval A (algebra_map A B a), rw [hrw, add_comm] at hroot, simp only [aeval_C, aeval_X, aeval_add] at hroot, replace hroot := eq_neg_of_add_eq_zero hroot, rw [‚Üêring_hom.map_neg _ a] at hroot, exact (hf hroot) }
rw [hrw, add_comm] at hroot
simp only [aeval_C, aeval_X, aeval_add] at hroot
replace hroot := eq_neg_of_add_eq_zero hroot
rw [‚Üêring_hom.map_neg _ a] at hroot
exact (hf hroot)
rw hrw
simp only [h0, ring_hom.map_neg, sub_eq_add_neg]
intros
rw [separable_def, derivative_mul]
{ rw [separable_def, derivative_mul], exact ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _) }
exact ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)
intros
{ rcases hfg with ‚ü®f', rfl‚ü©, exact separable.of_mul_left hf }
rcases hfg with ‚ü®f', rfl‚ü©
exact separable.of_mul_left hf
intros
rw [angle_comm, angle_self_neg_of_nonzero hx]
intros
let m : P := midpoint ‚Ñù p1 p2
have h1 : p3 -·µ• p1 = (p3 -·µ• m) - (p1 -·µ• m) := (vsub_sub_vsub_cancel_right p3 p1 m).symm
have h2 : p3 -·µ• p2 = (p3 -·µ• m) + (p1 -·µ• m)
rw [left_vsub_midpoint, ‚Üê midpoint_vsub_right, vsub_add_vsub_cancel]
{ rw [left_vsub_midpoint, ‚Üê midpoint_vsub_right, vsub_add_vsub_cancel] }
rw [dist_eq_norm_vsub V p3 p1, dist_eq_norm_vsub V p3 p2, h1, h2] at h
exact (norm_add_eq_norm_sub_iff_angle_eq_pi_div_two (p3 -·µ• m) (p1 -·µ• m)).mp h.symm
intros
rw f.image_eq_inter_preimage_of_subset_support hs
refine continuous_on.preimage_closed_of_closed ((ext_chart_continuous_on_symm _ _).mono f.closed_ball_subset) _ hsc
exact is_closed.inter is_closed_closed_ball I.closed_range
intros
rw [mdifferentiable_within_at, mdifferentiable_within_at, ext_chart_preimage_inter_eq, differentiable_within_at_inter', continuous_within_at_inter' ht]
exact ext_chart_preimage_mem_nhds_within I x ht
intros
simp only [mdifferentiable, differentiable, mdifferentiable_at_iff_differentiable_at]
intros
apply continuous_on.comp (chart_at H x).continuous_on_symm I.continuous_symm.continuous_on
simp [ext_chart_at, local_equiv.trans_target]
intros
split
{ intro h, exact ‚ü®smooth_fst.comp h, smooth_snd.comp h‚ü© }
intro h
exact ‚ü®smooth_fst.comp h, smooth_snd.comp h‚ü©
rintro ‚ü®h_fst, h_snd‚ü©
{ rintro ‚ü®h_fst, h_snd‚ü©, simpa only [prod.mk.eta] using h_fst.prod_mk h_snd, }
simpa only [prod.mk.eta] using h_fst.prod_mk h_snd
intros
rw ‚Üêcon_gen_of_con (c.map_of_surjective f H h hf)
rw ‚Üêcon_gen_of_con (c.map_of_surjective f H h hf); refl
refl
intros
ext
ext; refl
refl
intros
rw [mul_comm, mul_mk'_eq_mk'_of_mul]
intros
simp_rw [‚Üê is_periodic_pt_mul_iff_pow_eq_one, ‚Üê minimal_period_eq_minimal_period_iff, order_of]
intros
refine Œª h, exists.elim (hœï h) (Œª g hg, exists_imp_exists (Œª k hk, _) (hG g))
rw [‚Üêhg, ‚Üêœï.map_pow, hk, œï.map_one]
intros
revert œÑ
apply cycle_induction_on _ œÉ
intro
{ intro, simp }
simp
intros œÉ hœÉ œÑ
{ intros œÉ hœÉ œÑ, rw [hœÉ.cycle_type, hœÉ.is_cycle_conj.cycle_type, card_support_conj] }
rw [hœÉ.cycle_type, hœÉ.is_cycle_conj.cycle_type, card_support_conj]
intros œÉ œÑ hd hc hœÉ hœÑ œÄ
{ intros œÉ œÑ hd hc hœÉ hœÑ œÄ, rw [‚Üê conj_mul, hd.cycle_type, disjoint.cycle_type, hœÉ, hœÑ], intro a, apply (hd (œÄ‚Åª¬π a)).imp _ _; { intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] } }
rw [‚Üê conj_mul, hd.cycle_type, disjoint.cycle_type, hœÉ, hœÑ]
intro a
apply (hd (œÄ‚Åª¬π a)).imp _ _; { intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] }
apply (hd (œÄ‚Åª¬π a)).imp _ _
{ intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] }
{ intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] }
intro h
rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self]
intros
rw [sign_of_cycle_type, h.cycle_type]
refl
intros
induction n with n IH generalizing xs
{ simpa using form_perm_apply_nth_le_zero _ h _ }
simpa using form_perm_apply_nth_le_zero _ h _
rcases xs with (_|‚ü®x, _|‚ü®y, l‚ü©‚ü©)
{ rcases xs with (_|‚ü®x, _|‚ü®y, l‚ü©‚ü©), { simp }, { simp }, { specialize IH (y :: l) (nodup_of_nodup_cons h) _, { simpa [nat.succ_lt_succ_iff] using hn }, simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le], generalize_proofs at IH, rw [IH, swap_apply_of_ne_of_ne, nth_le]; { rintro rfl, simpa [nth_le_mem _ _ _] using h } } }
{ simp }
simp
{ simp }
simp
specialize IH (y :: l) (nodup_of_nodup_cons h) _
{ specialize IH (y :: l) (nodup_of_nodup_cons h) _, { simpa [nat.succ_lt_succ_iff] using hn }, simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le], generalize_proofs at IH, rw [IH, swap_apply_of_ne_of_ne, nth_le]; { rintro rfl, simpa [nth_le_mem _ _ _] using h } }
{ simpa [nat.succ_lt_succ_iff] using hn }
simpa [nat.succ_lt_succ_iff] using hn
simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le]
generalize_proofs at IH
rw [IH, swap_apply_of_ne_of_ne, nth_le]; { rintro rfl, simpa [nth_le_mem _ _ _] using h }
rw [IH, swap_apply_of_ne_of_ne, nth_le]
{ rintro rfl, simpa [nth_le_mem _ _ _] using h }
rintro rfl
{ rintro rfl, simpa [nth_le_mem _ _ _] using h }
simpa [nth_le_mem _ _ _] using h
intros
have h : ‚àÄ n : ‚Ñï, (œÉ * œÑ) ^ n = 1 ‚Üî œÉ ^ n = 1 ‚àß œÑ ^ n = 1 := Œª n, by rw [hœÉœÑ.commute.mul_pow, disjoint.mul_eq_one_iff (hœÉœÑ.pow_disjoint_pow n n)]
exact nat.dvd_antisymm hœÉœÑ.commute.order_of_mul_dvd_lcm (nat.lcm_dvd (order_of_dvd_of_pow_eq_one ((h (order_of (œÉ * œÑ))).mp (pow_order_of_eq_one (œÉ * œÑ))).1) (order_of_dvd_of_pow_eq_one ((h (order_of (œÉ * œÑ))).mp (pow_order_of_eq_one (œÉ * œÑ))).2))
intros
ext ‚ü®a, b‚ü© : 1
suffices : (a ‚àà l ‚àß (l.map (Œª a, prod_extend_right a (œÉ a))).prod (a, b) = (a, œÉ a b)) ‚à® (a ‚àâ l ‚àß (l.map (Œª a, prod_extend_right a (œÉ a))).prod (a, b) = (a, b))
obtain ‚ü®_, prod_eq‚ü© := or.resolve_right this (not_and.mpr (Œª h _, h (mem_l a)))
{ obtain ‚ü®_, prod_eq‚ü© := or.resolve_right this (not_and.mpr (Œª h _, h (mem_l a))), rw [prod_eq, prod_congr_right_apply] }
rw [prod_eq, prod_congr_right_apply]
clear mem_l
induction l with a' l ih
refine or.inr ‚ü®list.not_mem_nil _, _‚ü©
{ refine or.inr ‚ü®list.not_mem_nil _, _‚ü©, rw [list.map_nil, list.prod_nil, one_apply] }
rw [list.map_nil, list.prod_nil, one_apply]
rw [list.map_cons, list.prod_cons, mul_apply]
rcases ih (list.nodup_cons.mp hl).2 with ‚ü®mem_l, prod_eq‚ü© | ‚ü®not_mem_l, prod_eq‚ü©
rcases ih (list.nodup_cons.mp hl).2 with ‚ü®mem_l, prod_eq‚ü© | ‚ü®not_mem_l, prod_eq‚ü©; rw prod_eq
rw prod_eq
refine or.inl ‚ü®list.mem_cons_of_mem _ mem_l, _‚ü©
{ refine or.inl ‚ü®list.mem_cons_of_mem _ mem_l, _‚ü©, rw prod_extend_right_apply_ne _ (Œª (h : a = a'), (list.nodup_cons.mp hl).1 (h ‚ñ∏ mem_l)) }
rw prod_extend_right_apply_ne _ (Œª (h : a = a'), (list.nodup_cons.mp hl).1 (h ‚ñ∏ mem_l))
rw prod_eq
by_cases ha' : a = a'
rw ‚Üê ha' at *
{ rw ‚Üê ha' at *, refine or.inl ‚ü®l.mem_cons_self a, _‚ü©, rw prod_extend_right_apply_eq }
refine or.inl ‚ü®l.mem_cons_self a, _‚ü©
rw prod_extend_right_apply_eq
refine or.inr ‚ü®Œª h, not_or ha' not_mem_l ((list.mem_cons_iff _ _ _).mp h), _‚ü©
{ refine or.inr ‚ü®Œª h, not_or ha' not_mem_l ((list.mem_cons_iff _ _ _).mp h), _‚ü©, rw prod_extend_right_apply_ne _ ha' }
rw prod_extend_right_apply_ne _ ha'
intros
induction l with hd tl hl
{ simp }
simp
rw [list.prod_cons, list.map_cons, list.foldr_cons]
{ rw [list.prod_cons, list.map_cons, list.foldr_cons], refine (support_mul_le hd tl.prod).trans _, exact sup_le_sup (le_refl _) hl }
refine (support_mul_le hd tl.prod).trans _
exact sup_le_sup (le_refl _) hl
intros
induction k with k IH
{ refl }
refl
rw [pow_succ, IH, a_mul_a]
{ rw [pow_succ, IH, a_mul_a], congr' 1, norm_cast, rw nat.one_add }
congr' 1
norm_cast
rw nat.one_add
intros
simp [eq_bot_iff_forall, mem_closure_singleton]
intros
dsimp [lift_of_right_inverse_aux]
rw [‚Üê mul_inv_eq_one, ‚Üê g.map_inv, ‚Üê g.map_mul, ‚Üê g.mem_ker]
apply hg
rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]
simp only [hf _]
intros
convert S.bot_or_nontrivial
rw nontrivial_iff_exists_ne_one
intros
rw [sup_comm, ‚Üêset.union_singleton, ‚Üêcoe_affine_span_singleton k V p2]
change (s ‚äî affine_span k {p2}).direction = _
rw [direction_sup hp1 (mem_affine_span k (set.mem_singleton _)), direction_affine_span]
simp
intros
rw [vector_span_def, vsub_empty, submodule.span_empty]
intros
rw [midpoint_comm, left_vsub_midpoint]
intros
{ ext, simp [mem_span_singleton, eq_comm] }
ext
simp [mem_span_singleton, eq_comm]
intros
apply is_linear_map.mk
intros x y
{ intros x y, simp, cc }
simp
cc
intros x y
{ intros x y, simp [smul_add] }
simp [smul_add]
intros
{ cases x, refl }
cases x
refl
intros
conv_lhs { rw [‚Üê bilin_form.to_lin_apply, comp_symm_comp_of_nondegenerate_apply] }
refl
intros
simp only [B.to_matrix'_comp_right, to_matrix'_to_lin']
intros
{ ext x, exact alg_hom.congr_fun (map_id Q‚ÇÅ) x }
ext x
exact alg_hom.congr_fun (map_id Q‚ÇÅ) x
intros
{ dunfold dual_tensor_hom, rw uncurry_apply, refl, }
dunfold dual_tensor_hom
rw uncurry_apply
refl
intros
{ rw [‚Üê dim_range_add_dim_ker f], exact self_le_add_right _ _ }
rw [‚Üê dim_range_add_dim_ker f]
exact self_le_add_right _ _
intros
{ ext ‚ü®a', b'‚ü©, simp [finsupp.single], split_ifs; finish }
ext ‚ü®a', b'‚ü©
simp [finsupp.single]
split_ifs
split_ifs; finish
finish
finish
finish
finish
finish
finish
intros
{ erw of_is_compl_left_apply _ w, refl }
erw of_is_compl_left_apply _ w
refl
intros
haveI : finite_dimensional K V := finite_dimensional_of_finrank h
rwa finrank_pos_iff at h
intros
haveI : finite_dimensional K V‚ÇÇ := f.finite_dimensional
simpa [‚Üê finrank_eq_dim] using f.lift_dim_eq
intros
ext x y
dsimp [splitting_of_finsupp_surjective]
congr
rw [sum_single_index, one_smul]
{ exact (s (finsupp.single x 1)).some_spec, }
exact (s (finsupp.single x 1)).some_spec
{ rw zero_smul, }
rw zero_smul
intros
rw [fin.snoc_eq_cons_rotate, linear_independent_equiv, linear_independent_fin_cons]
intros
rw bUnion_eq_Union; exact linear_independent_Union_of_directed (directed_comp.2 $ hs.directed_coe) (by simpa using h)
rw bUnion_eq_Union
exact linear_independent_Union_of_directed (directed_comp.2 $ hs.directed_coe) (by simpa using h)
intros
simp
intros
{ intros i j h, simp [ha h, hb h] }
intros i j h
simp [ha h, hb h]
intros
rw [‚Üê matrix.to_lin_alg_equiv_symm, alg_equiv.apply_symm_apply]
intros
ext x
simp only [mem_ker, mem_range]
split
{ rintros ‚ü®y, rfl‚ü©, refl }
rintros ‚ü®y, rfl‚ü©
refl
{ intro h, exact ‚ü®x.snd, prod.ext h.symm rfl‚ü© }
intro h
exact ‚ü®x.snd, prod.ext h.symm rfl‚ü©
intros
rw [range_eq_map, ‚Üê prod_top, prod_map_snd]
intros
{ rintros ‚ü®x‚ü©, exact ‚ü®x, rfl‚ü© }
rintros ‚ü®x‚ü©
exact ‚ü®x, rfl‚ü©
intros
rw [std_basis_apply, update_noteq h]; refl
rw [std_basis_apply, update_noteq h]
refl
intros
simp only [exists_prop]; exact iff.trans (exists_congr $ Œª x, or_and_distrib_right) exists_or_distrib
simp only [exists_prop]
exact iff.trans (exists_congr $ Œª x, or_and_distrib_right) exists_or_distrib
intros
rw [‚Üê not_or_distrib, decidable.not_not]
intros
induction h with b h b c _ bc ab
exact refl_trans_gen.single h
exact refl_trans_gen.tail ab bc
intros
simp only [has_finite_integral, lintegral_prod_of_measurable _ h1f.ennnorm]
have : ‚àÄ x, ‚àÄ·µê y ‚àÇŒΩ, 0 ‚â§ ‚à•f (x, y)‚à• := Œª x, eventually_of_forall (Œª y, norm_nonneg _)
simp_rw [integral_eq_lintegral_of_nonneg_ae (this _) (h1f.norm.comp measurable_prod_mk_left).ae_measurable, ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm]
have : ‚àÄ {p q r : Prop} (h1 : r ‚Üí p), (r ‚Üî p ‚àß q) ‚Üî (p ‚Üí (r ‚Üî q)) := Œª p q r h1, by rw [‚Üê and.congr_right_iff, and_iff_right_of_imp h1]
rw [this]
intro h2f
{ intro h2f, rw lintegral_congr_ae, refine h2f.mp _, apply eventually_of_forall, intros x hx, dsimp only, rw [of_real_to_real], rw [‚Üê lt_top_iff_ne_top], exact hx }
rw lintegral_congr_ae
refine h2f.mp _
apply eventually_of_forall
intros x hx
dsimp only
rw [of_real_to_real]
rw [‚Üê lt_top_iff_ne_top]
exact hx
intro h2f
{ intro h2f, refine ae_lt_top _ h2f.ne, exact h1f.ennnorm.lintegral_prod_right' }
refine ae_lt_top _ h2f.ne
exact h1f.ennnorm.lintegral_prod_right'
intros
apply to_signed_measure_injective
simp [to_signed_measure_neg]
intros
rw condexp_L1_eq hfi
refine eventually_eq.trans _ (integrable.coe_fn_to_L1 hfi)
rw condexp_L1_clm_of_ae_measurable'
exact ae_measurable'.congr hfm (integrable.coe_fn_to_L1 hfi).symm
intros
haveI : fact (m ‚â§ m0) := ‚ü®hm‚ü©
{ haveI : fact (m ‚â§ m0) := ‚ü®hm‚ü©, exact inner_orthogonal_projection_left_eq_right _ f g, }
exact inner_orthogonal_projection_left_eq_right _ f g
intros
simp only [has_finite_integral, lintegral_zero_measure, with_top.zero_lt_top]
intros
{ rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢, exact hf.re, }
rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢
exact hf.re
intros
rw [norm_def, norm_def, snorm_congr_ae (coe_fn_neg _), snorm_neg]
intros
simp_rw [snorm_ess_sup, pi.zero_apply, nnnorm_zero, ennreal.coe_zero, ‚Üêennreal.bot_eq_zero]
exact ess_sup_const_bot
intros
refine (eventually_lift'_powerset' $ Œª s t hst ht, _).2 h
{ refine (eventually_lift'_powerset' $ Œª s t hst ht, _).2 h, exact ht.mono_set hst }
exact ht.mono_set hst
intros
simpa only [integral_of_le hab] using set_integral_mono_ae hf.1 hg.1 h
intros
simpa [mul_comm] using integral_comp_smul_deriv' h h' hg
intros
rw [‚Üê integral_comp_add_right, ‚Üê integral_comp_mul_left _ hc]
intros
have : {x | x ‚â§ a‚ÇÇ} ‚à© Ioc a‚ÇÅ a‚ÇÉ = Ioc a‚ÇÅ a‚ÇÇ
from Iic_inter_Ioc_of_le h.2
rw [integral_of_le h.1, integral_of_le (h.1.trans h.2), integral_indicator, measure.restrict_restrict, this]
exact measurable_set_Iic
apply measurable_set_Iic
all_goals { apply measurable_set_Iic }
exact measurable_set_Iic
apply measurable_set_Iic
all_goals { apply measurable_set_Iic }
intros
rw [lintegral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), lintegral_congr_ae hf.ae_eq_mk, lintegral_trim hm hf.measurable_mk]
intros
simp only [lintegral, measure.sum_apply, f.measurable_set_preimage, ‚Üê finset.tsum_subtype, ‚Üê ennreal.tsum_mul_left]
apply ennreal.tsum_comm
intros
{ ext1 s hs, simp [hs] }
ext1 s hs
simp [hs]
intros
simp only [prehaar]
{ simp only [prehaar], rw [div_add_div_same], congr', exact_mod_cast index_union_eq K‚ÇÅ K‚ÇÇ hU h }
rw [div_add_div_same]
congr'
exact_mod_cast index_union_eq K‚ÇÅ K‚ÇÇ hU h
intros
intros s hs
rw [‚Üê outer_measure.coe_mk_metric, coe_smul, ‚Üê outer_measure.coe_mk_metric]
exact outer_measure.mk_metric_mono_smul hc h0 hle s
intros
contrapose! H
apply sum_measure_le_measure_univ h
exact Œª i hi j hj hij x hx, H i hi j hj hij ‚ü®x, hx‚ü©
intros
rw [‚Üê encodable.Union_decode‚ÇÇ, ‚Üê tsum_Union_decode‚ÇÇ]
exact extend_Union_nat PU (Œª n, encodable.Union_decode‚ÇÇ_cases P0 hm) (mU _ (encodable.Union_decode‚ÇÇ_disjoint_on hd))
{ exact extend_Union_nat PU (Œª n, encodable.Union_decode‚ÇÇ_cases P0 hm) (mU _ (encodable.Union_decode‚ÇÇ_disjoint_on hd)) }
{ exact extend_empty P0 m0 }
exact extend_empty P0 m0
intros
rw [bounded_by_eq_of_function m_empty, of_function_eq s m_mono m_subadd]
intros
rw of_union h hA‚ÇÅ hB‚ÇÅ at hAB
linarith
apply_instance
intros
refine ‚ü®Œª h i, _, Œª h i hi, h i‚ü©
by_cases hi : measurable_set i
{ exact h i hi }
exact h i hi
{ rw [v.not_measurable hi, w.not_measurable hi] }
rw [v.not_measurable hi, w.not_measurable hi]
intros
have h6 : (0:‚Ñö) < 6
norm_num
norm_num
contrapose! H
rw sum_inv_pqr
simp only [pnat.coe_bit0, nat.cast_bit0, pnat.one_coe, nat.cast_bit1, nat.cast_one, pnat.coe_bit1, coe_coe]
calc (2‚Åª¬π + 3‚Åª¬π + r‚Åª¬π : ‚Ñö) ‚â§ 2‚Åª¬π + 3‚Åª¬π + 6‚Åª¬π : add_le_add (add_le_add le_rfl le_rfl) _ ... = 1 : by norm_num
rw inv_le_inv _ h6; [assumption_mod_cast, norm_num]
rw inv_le_inv _ h6
assumption_mod_cast
norm_num
intros
induction l; simp *
induction l
simp *
simp *
intros
cases m
{ apply dvd_zero }
apply dvd_zero
{ simp [mem_divisors.1 h], }
simp [mem_divisors.1 h]
intros
dsimp [lucas_lehmer_residue]
rw s_zmod_eq_s_mod p
split
intro h
{ intro h, simp [zmod.int_coe_zmod_eq_zero_iff_dvd] at h, apply int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h; clear h, apply s_mod_nonneg _ (nat.lt_of_succ_lt w), convert s_mod_lt _ (nat.lt_of_succ_lt w) (p-2), push_cast [nat.one_le_two_pow p], refl, }
simp [zmod.int_coe_zmod_eq_zero_iff_dvd] at h
apply int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h; clear h
apply int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h
clear h
apply s_mod_nonneg _ (nat.lt_of_succ_lt w)
clear h
convert s_mod_lt _ (nat.lt_of_succ_lt w) (p-2)
push_cast [nat.one_le_two_pow p]
refl
{ intro h, rw h, simp, }
intro h
rw h
simp
intros
cases i; dsimp [s_mod]
cases i
dsimp [s_mod]
{ exact sup_eq_left.mp rfl }
exact sup_eq_left.mp rfl
dsimp [s_mod]
{ apply int.mod_nonneg, exact mersenne_int_ne_zero p w }
apply int.mod_nonneg
exact mersenne_int_ne_zero p w
intros
rw [norm_p, inv_eq_one_div, div_lt_iff, one_mul]
{ exact_mod_cast hp.1.one_lt }
exact_mod_cast hp.1.one_lt
{ exact_mod_cast hp.1.pos }
exact_mod_cast hp.1.pos
intros
intros Œµ hŒµ
change _ < _ at hŒµ
use 1
intros j hj
haveI : fact (1 < p^j) := ‚ü®nat.one_lt_pow _ _ (by linarith) hp_prime.1.one_lt‚ü©
simp [nth_hom_seq, nth_hom, zmod.val_one, hŒµ]
intros
simp [norm]
intros
rw [norm, norm_sq]; simp
rw [norm, norm_sq]
simp
intros
rintro rfl
{ rintro rfl, apply (hf.reflect_lt h1).not_le, exact nat.le_of_lt_succ (hf.reflect_lt h2) }
apply (hf.reflect_lt h1).not_le
exact nat.le_of_lt_succ (hf.reflect_lt h2)
intros
simp only [not_bdd_above_iff', not_le]
intros
rw set.sUnion_eq_Union; exact complete_lattice.set_independent_Union_of_directed hs.directed_coe (by simpa using h)
rw set.sUnion_eq_Union
exact complete_lattice.set_independent_Union_of_directed hs.directed_coe (by simpa using h)
intros
simp
intros
{ lift s to finset Œ± using hs, exact finset.nonempty.cSup_mem h }
lift s to finset Œ± using hs
exact finset.nonempty.cSup_mem h
intros
refine (symmetric.pairwise_on disjoint.symm _).2 (Œª m n h, _)
cases n
{ exact (nat.not_lt_zero _ h).elim }
exact (nat.not_lt_zero _ h).elim
exact disjoint_sdiff_self_right.mono_left ((disjointed_le f m).trans (le_partial_sups_of_le f (nat.lt_add_one_iff.1 h)))
intros
simp [at_top_basis_Ioi.frequently_iff]
intros
casesI (is_empty_or_nonempty Œ≤‚ÇÅ).symm
casesI (is_empty_or_nonempty Œ≤‚ÇÇ).symm
simp [at_top, prod_infi_left, prod_infi_right, infi_prod]
{ simp [at_top, prod_infi_left, prod_infi_right, infi_prod], exact infi_comm, }
exact infi_comm
simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]
{ simp only [at_top.filter_eq_bot_of_is_empty, prod_bot] }
simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]
{ simp only [at_top.filter_eq_bot_of_is_empty, bot_prod] }
intros
simpa only [and_assoc] using h.restrict_subset hV
intros
simpa only [div_eq_mul_inv] using h.mul h'.inv
intros
rw [map_comap, inf_eq_left.2 (le_principal_iff.2 hf)]
intros
simp only [filter.prod, comap_comap, (‚àò), inf_comm, prod.fst_swap, eq_self_iff_true, prod.snd_swap, comap_inf]
intros
haveI := I_fin.fintype
refine mem_of_superset (Inter_mem.2 $ Œª i, _) hU
exact mem_infi_of_mem i (hV _)
intros
{ rw [‚Üê empty_mem_iff_bot, mem_inf_principal], refl }
rw [‚Üê empty_mem_iff_bot, mem_inf_principal]
refl
intros
rw [prod_def]; from lift_lift'_same_eq_lift' (assume s, set.monotone_prod monotone_const monotone_id) (assume t, set.monotone_prod monotone_id monotone_const)
rw [prod_def]
from lift_lift'_same_eq_lift' (assume s, set.monotone_prod monotone_const monotone_id) (assume t, set.monotone_prod monotone_id monotone_const)
intros
change ‚àÉ (a : P), ‚àÄ (I : ideal P), a ‚àà (I : set P)
rw ‚Üê set.nonempty_Inter
exact Inter_nonempty
intros
simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt hg hf hn)
intros
simp only [inf_sup_left, Œªy:Œ±, @inf_comm Œ± _ y x, eq_self_iff_true]
intros
rw liminf_eq
refine Sup_le (Œª b hb, _)
have hbx : ‚àÉ·∂† a in f, b ‚â§ x
revert h
{ revert h, rw [‚Üênot_imp_not, not_frequently, not_frequently], exact Œª h, hb.mp (h.mono (Œª a hbx hba hax, hbx (hba.trans hax))), }
rw [‚Üênot_imp_not, not_frequently, not_frequently]
exact Œª h, hb.mp (h.mono (Œª a hbx hba hax, hbx (hba.trans hax)))
exact hbx.exists.some_spec
intros
intro c
apply eq_of_forall_ge_iff
intro z
suffices : (‚àÄ (f ‚àà s) n, (f : _) (c n) ‚â§ z) ‚Üî (‚àÄ n (f ‚àà s), (f : _) (c n) ‚â§ z)
simpa [œâSup_le_iff, hs _ _ _] { contextual := tt }
simpa [œâSup_le_iff, hs _ _ _] { contextual := tt }
exact ‚ü®Œª H n f hf, H f hf n, Œª H f hf n, H n f hf‚ü©
intros
ext x
rw [set.mem_range, nat.order_embedding_of_set]
split
split; intro h
intro h
obtain ‚ü®y, rfl‚ü© := h
{ obtain ‚ü®y, rfl‚ü© := h, simp }
simp
intro h
refine ‚ü®(nat.subtype.order_iso_of_nat s).symm ‚ü®x, h‚ü©, _‚ü©
{ refine ‚ü®(nat.subtype.order_iso_of_nat s).symm ‚ü®x, h‚ü©, _‚ü©, simp only [rel_embedding.coe_trans, rel_embedding.order_embedding_of_lt_embedding_apply, rel_embedding.nat_lt_apply, function.comp_app, order_embedding.subtype_apply], rw [‚Üê subtype.order_iso_of_nat_apply, order_iso.apply_symm_apply, subtype.coe_mk] }
simp only [rel_embedding.coe_trans, rel_embedding.order_embedding_of_lt_embedding_apply, rel_embedding.nat_lt_apply, function.comp_app, order_embedding.subtype_apply]
rw [‚Üê subtype.order_iso_of_nat_apply, order_iso.apply_symm_apply, subtype.coe_mk]
intros
intro y
change is_lub (e ‚Åª¬π' {x | f x ‚â§ y}) (e.symm (g y))
rw [e.is_lub_preimage, e.apply_symm_apply]
exact h y
intros
simp [sdiff_symm_diff]
intros
rw [minpoly_power_basis_gen hf', hf.leading_coeff, inv_one, C.map_one, mul_one]
intros
letI := f.to_algebra
letI := g.to_algebra
letI := (g.comp f).to_algebra
letI : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C
letI : algebra.finite_type A C := h
exact algebra.finite_type.of_restrict_scalars_finite_type A B C
intros
{ ext, exact single_zero_mul_coeff }
ext
exact single_zero_mul_coeff
intros
apply le_antisymm
{ rw span_singleton_le_span_singleton, use a}
rw span_singleton_le_span_singleton
use a
rw span_singleton_le_span_singleton
{ rw span_singleton_le_span_singleton, rw is_unit.mul_right_dvd h2}
rw is_unit.mul_right_dvd h2
intros
rcases ideal.exists_le_maximal J hJ with ‚ü®M, hM1, hM2‚ü©
rwa ‚Üêeq_maximal_ideal hM1
intros
ext
ext; rw [ring_hom.ker, mem_comap, submodule.mem_bot, quotient.eq_zero_iff_mem]
rw [ring_hom.ker, mem_comap, submodule.mem_bot, quotient.eq_zero_iff_mem]
intros
simp only [mul_le, mem_span_singleton_mul, mem_span_singleton]
split
intros h zI hzI
{ intros h zI hzI, exact h x (dvd_refl x) zI hzI }
exact h x (dvd_refl x) zI hzI
rintros h _ ‚ü®z, rfl‚ü© zI hzI
{ rintros h _ ‚ü®z, rfl‚ü© zI hzI, rw [mul_comm x z, mul_assoc], exact J.mul_mem_left _ (h zI hzI) }
rw [mul_comm x z, mul_assoc]
exact J.mul_mem_left _ (h zI hzI)
intros
apply @nat.prime.dvd_of_dvd_pow _ _ k hp
rw ‚Üê int.nat_abs_pow
exact int.coe_nat_dvd_left.mp h
intros
{ ext, simp }
ext
simp
intros
rw [‚Üê not_iff_not, not_finite_iff_forall, not_and_distrib, ne.def, not_not, not_lt, nat.le_zero_iff]
exact ‚ü®Œª h, or_iff_not_imp_right.2 (Œª hb, have ha : a ‚â† 0, from Œª ha, by simpa [ha] using h 1, by_contradiction (Œª ha1 : a ‚â† 1, have ha_gt_one : 1 < a, from lt_of_not_ge (Œª ha', by { clear h, revert ha ha1, dec_trivial! }), not_lt_of_ge (le_of_dvd (nat.pos_of_ne_zero hb) (h b)) (lt_pow_self ha_gt_one b))), Œª h, by cases h; simp *‚ü©
intros
have h : derivative (T R (n + 2)) = (U R (n + 1) - X * U R n) + X * derivative (T R (n + 1)) + 2 * X * U R n - (1 - X ^ 2) * derivative (U R n)
conv_lhs { rw T_eq_X_mul_T_sub_pol_U }
{ conv_lhs { rw T_eq_X_mul_T_sub_pol_U }, simp only [derivative_sub, derivative_mul, derivative_X, derivative_one, derivative_X_pow, one_mul, T_derivative_eq_U], rw [T_eq_U_sub_X_mul_U, nat.cast_bit0, nat.cast_one], ring }
simp only [derivative_sub, derivative_mul, derivative_X, derivative_one, derivative_X_pow, one_mul, T_derivative_eq_U]
rw [T_eq_U_sub_X_mul_U, nat.cast_bit0, nat.cast_one]
ring
calc ((n : polynomial R) + 1) * T R (n + 1) = ((n : polynomial R) + 1 + 1) * (X * U R n + T R (n + 1)) - X * ((n + 1) * U R n) - (X * U R n + T R (n + 1)) : by ring ... = derivative (T R (n + 2)) - X * derivative (T R (n + 1)) - U R (n + 1) : by rw [‚ÜêU_eq_X_mul_U_add_T, ‚ÜêT_derivative_eq_U, ‚Üênat.cast_one, ‚Üênat.cast_add, nat.cast_one, ‚ÜêT_derivative_eq_U (n + 1)] ... = (U R (n + 1) - X * U R n) + X * derivative (T R (n + 1)) + 2 * X * U R n - (1 - X ^ 2) * derivative (U R n) - X * derivative (T R (n + 1)) - U R (n + 1) : by rw h ... = X * U R n - (1 - X ^ 2) * derivative (U R n) : by ring
intros
by_cases h : n ‚àà p.support
{ apply finset.gcd_dvd h }
apply finset.gcd_dvd h
rw [mem_support_iff, not_not] at h
rw h
apply dvd_zero
intros
refine ((eq_cyclotomic_iff hp.pos _).mpr _).symm
simp only [nat.prime.proper_divisors hp, geom_sum_mul, finset.prod_singleton, cyclotomic_one]
intros
symmetry
apply finset.sum_bij (Œª (p : ‚Ñï √ó ‚Ñï) h, (single () p.1, single () p.2))
rintros ‚ü®i,j‚ü© hij
{ rintros ‚ü®i,j‚ü© hij, rw finset.nat.mem_antidiagonal at hij, rw [finsupp.mem_antidiagonal, ‚Üê finsupp.single_add, hij], }
rw finset.nat.mem_antidiagonal at hij
rw [finsupp.mem_antidiagonal, ‚Üê finsupp.single_add, hij]
{ rintros ‚ü®i,j‚ü© hij, refl }
rintros ‚ü®i,j‚ü© hij
refl
rintros ‚ü®i,j‚ü© ‚ü®k,l‚ü© hij hkl
{ rintros ‚ü®i,j‚ü© ‚ü®k,l‚ü© hij hkl, simpa only [prod.mk.inj_iff, finsupp.unique_single_eq_iff] using id }
simpa only [prod.mk.inj_iff, finsupp.unique_single_eq_iff] using id
rintros ‚ü®f,g‚ü© hfg
{ rintros ‚ü®f,g‚ü© hfg, refine ‚ü®(f (), g ()), _, _‚ü©, { rw finsupp.mem_antidiagonal at hfg, rw [finset.nat.mem_antidiagonal, ‚Üê finsupp.add_apply, hfg, finsupp.single_eq_same] }, { rw prod.mk.inj_iff, dsimp, exact ‚ü®finsupp.unique_single f, finsupp.unique_single g‚ü© } }
refine ‚ü®(f (), g ()), _, _‚ü©
rw finsupp.mem_antidiagonal at hfg
{ rw finsupp.mem_antidiagonal at hfg, rw [finset.nat.mem_antidiagonal, ‚Üê finsupp.add_apply, hfg, finsupp.single_eq_same] }
rw [finset.nat.mem_antidiagonal, ‚Üê finsupp.add_apply, hfg, finsupp.single_eq_same]
rw prod.mk.inj_iff
{ rw prod.mk.inj_iff, dsimp, exact ‚ü®finsupp.unique_single f, finsupp.unique_single g‚ü© }
dsimp
exact ‚ü®finsupp.unique_single f, finsupp.unique_single g‚ü©
intros
{ ext, simp }
ext
simp
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [neg_zero, ring_hom.map_neg, constant_coeff_X]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [map_bind‚ÇÅ, map_rename, map_expand, rename_expand, map_witt_polynomial]
have key := (witt_structure_rat_prop p (map (int.cast_ring_hom ‚Ñö) Œ¶) n).symm
apply_fun expand p at key
simp only [expand_bind‚ÇÅ] at key
rw key
clear key
apply eval‚ÇÇ_hom_congr' rfl _ rfl
rintro i hi -
rw [witt_polynomial_vars, finset.mem_range] at hi
simp only [IH i hi]
intros
intro x
obtain ‚ü®x, rfl‚ü© := witt_vector.truncate_surjective p _ R x
exact ‚ü®witt_vector.truncate _ x, truncate_witt_vector_truncate _ _‚ü©
intros
rw [‚Üê not_iff_not, not_nontrivial_iff_subsingleton, ‚Üê le_one_iff_subsingleton]
{ rw [‚Üê not_iff_not, not_nontrivial_iff_subsingleton, ‚Üê le_one_iff_subsingleton], simp }
simp
intros
rw [to_nat_apply_of_lt_omega h, ‚Üê classical.some_spec (lt_omega.1 h)]
intros
{ rw [mul_comm], exact le_mul_left h }
rw [mul_comm]
exact le_mul_left h
intros
rw [first_loses_of_equiv_iff (neg_equiv_self G), ‚Üêno_good_left_moves_iff_first_loses]
refine ‚ü®Œª h i, _, Œª h i, _‚ü©
simpa [first_wins_of_equiv_iff (neg_equiv_self ((-G).move_left i))] using h (left_moves_neg _ i)
{ simpa [first_wins_of_equiv_iff (neg_equiv_self ((-G).move_left i))] using h (left_moves_neg _ i) }
simpa [first_wins_of_equiv_iff (neg_equiv_self (G.move_right i))] using h ((left_moves_neg _).symm i)
{ simpa [first_wins_of_equiv_iff (neg_equiv_self (G.move_right i))] using h ((left_moves_neg _).symm i) }
intros
rw [‚Üênot_lt, typein_lt_typein]
intros
{ cases x, refl }
cases x
refl
split
rintros ‚ü® ‚ü© ‚ü® ‚ü©
{ rintros ‚ü® ‚ü© ‚ü® ‚ü©, exact zero_lt_one }
exact zero_lt_one
split
split; rintro ‚ü® ‚ü©
rintro ‚ü® ‚ü©
{ exact numeric_zero }
exact numeric_zero
rintro ‚ü® ‚ü©
{ exact numeric_one }
exact numeric_one
intros
simp [term]
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
split
intro hc
{ intro hc, rw decomp' f, have := hc.sub continuous_const, exact this, }
rw decomp' f
have := hc.sub continuous_const
exact this
intro hc
{ intro hc, rw decomp f, have := hc.add continuous_const, exact this }
rw decomp f
have := hc.add continuous_const
exact this
intros
simp [has_sum, tendsto_const_nhds]
intros
ext
simp [to_ring_inverse (continuous_linear_equiv.refl R M)]
intros
simpa only [mul_comm] using hg.at_top_mul_neg hC hf
intros
simp [frontier, le_of_lt h, Icc_diff_Ioo_same]
intros
refine continuous_at_right_of_monotone_on_of_exists_between h_mono hs (Œª b hb, _)
rcases (mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset hb).1 hfs with ‚ü®b', ‚ü®hab', hbb'‚ü©, hb'‚ü©
rcases exists_between hab' with ‚ü®c', hc'‚ü©
rcases mem_closure_iff.1 (hb' ‚ü®hc'.1.le, hc'.2‚ü©) (Ioo (f a) b') is_open_Ioo hc' with ‚ü®_, hc, ‚ü®c, hcs, rfl‚ü©‚ü©
exact ‚ü®c, hcs, hc.1, hc.2.trans_le hbb'‚ü©
intros
rw [nhds_eq_comap_uniformity, filter.comap_comap]
refine le_antisymm (filter.map_le_iff_le_comap.1 _) _
assume s hs
{ assume s hs, rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_sub hs with ‚ü®t, ht, hts‚ü©, refine mem_map.2 (mem_of_superset ht _), rintros ‚ü®a, b‚ü©, simpa [subset_def] using hts a b a }
rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_sub hs with ‚ü®t, ht, hts‚ü©
refine mem_map.2 (mem_of_superset ht _)
rintros ‚ü®a, b‚ü©
simpa [subset_def] using hts a b a
assume s hs
{ assume s hs, rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_add hs with ‚ü®t, ht, hts‚ü©, refine ‚ü®_, ht, _‚ü©, rintros ‚ü®a, b‚ü©, simpa [subset_def] using hts 0 (b - a) a }
rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_add hs with ‚ü®t, ht, hts‚ü©
refine ‚ü®_, ht, _‚ü©
rintros ‚ü®a, b‚ü©
simpa [subset_def] using hts 0 (b - a) a
intros
simp [frontier]
intros
simp_rw [is_open_iff_mem_nhds, ‚Üê mem_iff_ultrafilter]
intros
simp [mem_of_superset h]
intros
simp only [continuous_within_at, nhds_within_singleton, tendsto_pure_nhds]
intros
simpa only [mul_comm] using ennreal.tendsto.const_mul hm ha
intros
apply (summable_iff_not_tendsto_nat_at_top_of_nonneg hf).2 (Œª H, _)
rcases exists_lt_of_tendsto_at_top H 0 c with ‚ü®n, -, hn‚ü©
exact lt_irrefl _ (hn.trans_le (h n))
intros
simp [‚Üê has_sum_coe, coe_sum, nnreal.coe_add, ‚Üê has_sum_nat_add_iff k]
intros
apply eq_of_local_equiv_eq
rw restr_to_local_equiv
apply local_equiv.restr_eq_of_source_subset
exact interior_maximal h e.open_source
intros
simp only [@nhds_eq_comap_uniformity Œ±, metric.uniformity_eq_comap_nhds_zero, comap_comap, (‚àò), dist_comm]
intros
rw dist_comm y; apply dist_triangle
rw dist_comm y
apply dist_triangle
intros
simp only [‚Üê tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, nhds_within_univ, mem_univ, forall_const, exists_prop]
intros
have A : ‚àÄa ‚àà s, ‚àÄb ‚àà t, edist a b ‚â§ diam s + edist x y + diam t := Œªa ha b hb, calc edist a b ‚â§ edist a x + edist x y + edist y b : edist_triangle4 _ _ _ _ ... ‚â§ diam s + edist x y + diam t : add_le_add (add_le_add (edist_le_diam_of_mem ha xs) (le_refl _)) (edist_le_diam_of_mem yt hb)
refine diam_le (Œªa ha b hb, _)
cases (mem_union _ _ _).1 ha with h'a h'a
cases (mem_union _ _ _).1 ha with h'a h'a; cases (mem_union _ _ _).1 hb with h'b h'b
cases (mem_union _ _ _).1 hb with h'b h'b
calc edist a b ‚â§ diam s : edist_le_diam_of_mem h'a h'b ... ‚â§ diam s + (edist x y + diam t) : le_self_add ... = diam s + edist x y + diam t : (add_assoc _ _ _).symm
{ calc edist a b ‚â§ diam s : edist_le_diam_of_mem h'a h'b ... ‚â§ diam s + (edist x y + diam t) : le_self_add ... = diam s + edist x y + diam t : (add_assoc _ _ _).symm }
{ exact A a h'a b h'b }
exact A a h'a b h'b
cases (mem_union _ _ _).1 hb with h'b h'b
{ have Z := A b h'b a h'a, rwa [edist_comm] at Z }
have Z := A b h'b a h'a
rwa [edist_comm] at Z
calc edist a b ‚â§ diam t : edist_le_diam_of_mem h'a h'b ... ‚â§ (diam s + edist x y) + diam t : le_add_self
{ calc edist a b ‚â§ diam t : edist_le_diam_of_mem h'a h'b ... ‚â§ (diam s + edist x y) + diam t : le_add_self }
intros
simp only [inf_edist, infi_image, hŒ¶.edist_eq]
intros
simp [Hausdorff_dist]
intros
rw [‚Üê h.range_eq_univ, h.isometry.ediam_range]
intros
rcases f.locally_finite x with ‚ü®U, hU, hf‚ü©
use hf.to_finset
filter_upwards [hU]
intros y hyU
simp only [pi.mul_apply, finset.prod_apply]
apply to_pou_fun_eq_mul_prod
intros j hji hj
exact hf.mem_to_finset.2 ‚ü®y, ‚ü®hj, hyU‚ü©‚ü©
intros
split
split ; rintros ‚ü®x, x_in, h‚ü© ; use [x, x_in]
split ; rintros ‚ü®x, x_in, h‚ü©
rintros ‚ü®x, x_in, h‚ü©
use [x, x_in]
ext y
{ ext y, exact ‚ü®Œª hy, hy.mem.2, h‚ü© }
exact ‚ü®Œª hy, hy.mem.2, h‚ü©
rintros ‚ü®x, x_in, h‚ü©
use [x, x_in]
intros y y_in
{ intros y y_in, rwa ‚Üê h at y_in }
rwa ‚Üê h at y_in
intros
refine ‚ü®Œª h, ‚ü®h.lower_semicontinuous_within_at, h.upper_semicontinuous_within_at‚ü©, _‚ü©
rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
assume v hv
simp only [filter.mem_map]
by_cases Hl : ‚àÉ l, l < f x
rcases exists_Ioc_subset_of_mem_nhds hv Hl with ‚ü®l, lfx, hl‚ü©
{ rcases exists_Ioc_subset_of_mem_nhds hv Hl with ‚ü®l, lfx, hl‚ü©, by_cases Hu : ‚àÉ u, f x < u, { rcases exists_Ico_subset_of_mem_nhds hv Hu with ‚ü®u, fxu, hu‚ü©, filter_upwards [h‚ÇÅ l lfx, h‚ÇÇ u fxu], assume a lfa fau, cases le_or_gt (f a) (f x) with h h, { exact hl ‚ü®lfa, h‚ü© }, { exact hu ‚ü®le_of_lt h, fau‚ü© } }, { simp only [not_exists, not_lt] at Hu, filter_upwards [h‚ÇÅ l lfx], assume a lfa, exact hl ‚ü®lfa, Hu (f a)‚ü© } }
by_cases Hu : ‚àÉ u, f x < u
rcases exists_Ico_subset_of_mem_nhds hv Hu with ‚ü®u, fxu, hu‚ü©
{ rcases exists_Ico_subset_of_mem_nhds hv Hu with ‚ü®u, fxu, hu‚ü©, filter_upwards [h‚ÇÅ l lfx, h‚ÇÇ u fxu], assume a lfa fau, cases le_or_gt (f a) (f x) with h h, { exact hl ‚ü®lfa, h‚ü© }, { exact hu ‚ü®le_of_lt h, fau‚ü© } }
filter_upwards [h‚ÇÅ l lfx, h‚ÇÇ u fxu]
assume a lfa fau
cases le_or_gt (f a) (f x) with h h
{ exact hl ‚ü®lfa, h‚ü© }
exact hl ‚ü®lfa, h‚ü©
{ exact hu ‚ü®le_of_lt h, fau‚ü© }
exact hu ‚ü®le_of_lt h, fau‚ü©
simp only [not_exists, not_lt] at Hu
{ simp only [not_exists, not_lt] at Hu, filter_upwards [h‚ÇÅ l lfx], assume a lfa, exact hl ‚ü®lfa, Hu (f a)‚ü© }
filter_upwards [h‚ÇÅ l lfx]
assume a lfa
exact hl ‚ü®lfa, Hu (f a)‚ü©
simp only [not_exists, not_lt] at Hl
{ simp only [not_exists, not_lt] at Hl, by_cases Hu : ‚àÉ u, f x < u, { rcases exists_Ico_subset_of_mem_nhds hv Hu with ‚ü®u, fxu, hu‚ü©, filter_upwards [h‚ÇÇ u fxu], assume a lfa, apply hu, exact ‚ü®Hl (f a), lfa‚ü© }, { simp only [not_exists, not_lt] at Hu, apply filter.eventually_of_forall, assume a, have : f a = f x := le_antisymm (Hu _) (Hl _), rw this, exact mem_of_mem_nhds hv } }
by_cases Hu : ‚àÉ u, f x < u
rcases exists_Ico_subset_of_mem_nhds hv Hu with ‚ü®u, fxu, hu‚ü©
{ rcases exists_Ico_subset_of_mem_nhds hv Hu with ‚ü®u, fxu, hu‚ü©, filter_upwards [h‚ÇÇ u fxu], assume a lfa, apply hu, exact ‚ü®Hl (f a), lfa‚ü© }
filter_upwards [h‚ÇÇ u fxu]
assume a lfa
apply hu
exact ‚ü®Hl (f a), lfa‚ü©
simp only [not_exists, not_lt] at Hu
{ simp only [not_exists, not_lt] at Hu, apply filter.eventually_of_forall, assume a, have : f a = f x := le_antisymm (Hu _) (Hl _), rw this, exact mem_of_mem_nhds hv }
apply filter.eventually_of_forall
assume a
have : f a = f x := le_antisymm (Hu _) (Hl _)
rw this
exact mem_of_mem_nhds hv
intros
rw [compact_covering, Union_accumulate]
exact (classical.some_spec sigma_compact_space.exists_compact_covering).2
intros
split
split; rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©; split
split; rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
split
{ exact nonneg_of_mul_nonneg_left h‚ÇÅ ha }
exact nonneg_of_mul_nonneg_left h‚ÇÅ ha
{ rwa [le_div_iff ha, mul_comm] }
rwa [le_div_iff ha, mul_comm]
rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
split
{ exact mul_nonneg ha.le h‚ÇÅ }
exact mul_nonneg ha.le h‚ÇÅ
{ rwa [le_div_iff ha, mul_comm] at h‚ÇÇ }
rwa [le_div_iff ha, mul_comm] at h‚ÇÇ
intros
rw tail_eq_drop
refl
intros
rw [cons_append_stream, nil_append_stream, stream.eta]
intros
cases b; simp
cases b
simp
simp
intros
have h := int.add_lt_add_left h a
rwa int.add_neg_cancel_left at h
intros
rw [‚Üê nat_abs_neg, nat_abs_of_nonneg (int.neg_nonneg_of_nonpos H)]
intros
rw nat.add_comm; exact nat.dvd_add_iff_right h
rw nat.add_comm
exact nat.dvd_add_iff_right h
intros
rw [nat.add_comm k n, nat.add_comm k m, nat.add_sub_add_right]
intros
induction s; refl
induction s
refl
intros
{ ext, refl, }
ext
refl
intros
rw [mul_comm]; exact le_mul_right
rw [mul_comm]
exact le_mul_right
intros
simp
intros
rw [range_succ, prod_insert not_mem_range_self]
intros
rw finprod
split_ifs
exacts [finset.prod_induction _ _ hp‚ÇÅ hp‚ÇÄ (Œª i hi, hp‚ÇÇ _), hp‚ÇÄ]
intros
refine finprod_mem_inter_mul_support_eq' _ _ _ (Œª x hx, ‚ü®_, or.inr‚ü©)
rintro (rfl|hxs)
exacts [not_imp_comm.1 h hx, hxs]
intros
{ ext a, simp }
ext a
simp
intros
rw [show (1 : R) = bit1 0, by simp, bit1_eq_bit1]
intros
rw [of_terminated_at_iff_int_fract_pair_seq1_terminated_at, seq.terminated_at, int_fract_pair.nth_seq1_eq_succ_nth_stream]
intros
simp [convergent_eq_num_div_denom, num_eq_conts_a, denom_eq_conts_b, div_one]
intros
simpa only [‚Üê @div_self _ _ b h] using (div_add_div_same a b b).symm
intros
{ ext, simp [ceil_le, le_floor] }
ext
simp [ceil_le, le_floor]
intros
simp [star, has_star.star]
intros
simpa only [div_eq_mul_inv] using Œª a a' h, mul_left_injective (b‚Åª¬π) h
intros
unfold semiconj_by; assoc_rw [hb.eq, ha.eq, mul_assoc]
unfold semiconj_by
assoc_rw [hb.eq, ha.eq, mul_assoc]
intros
rw [bit1, pow_succ', pow_bit0']
intros
refine ‚ü®Œª h, _, nsmul_lt_nsmul ha‚ü©
by_contra H
exact lt_irrefl _ (lt_of_le_of_lt (nsmul_le_nsmul (le_of_lt ha) $ not_lt.mp H) h)
intros
rw [‚Üê mul_one a, ‚Üê h, mul_zero]
intros
rw [div_eq_mul_inv, inv_div, mul_div_cancel' _ ha]
intros
rcases h : c.next i with _ | ‚ü®j,w‚ü©
ext
{ ext, { refl }, { dsimp, simp only [next, h], symmetry, apply zero_of_target_iso_zero, exact X_next_iso_zero _ h } }
{ refl }
refl
dsimp
{ dsimp, simp only [next, h], symmetry, apply zero_of_target_iso_zero, exact X_next_iso_zero _ h }
simp only [next, h]
symmetry
apply zero_of_target_iso_zero
exact X_next_iso_zero _ h
{ ext, refl, dsimp, simp [next, h] }
ext
refl
dsimp
simp [next, h]
intros
cases i
dsimp [d_next]
{ dsimp [d_next], rcases (complex_shape.down ‚Ñï).next 0 with _|‚ü®j,hj‚ü©; dsimp [d_next], { rw [C.shape, zero_comp], dsimp, dec_trivial }, { dsimp at hj, exact (nat.succ_ne_zero _ hj).elim } }
rcases (complex_shape.down ‚Ñï).next 0 with _|‚ü®j,hj‚ü©; dsimp [d_next]
rcases (complex_shape.down ‚Ñï).next 0 with _|‚ü®j,hj‚ü©
dsimp [d_next]
{ rw [C.shape, zero_comp], dsimp, dec_trivial }
rw [C.shape, zero_comp]
dsimp
dec_trivial
dsimp [d_next]
{ dsimp at hj, exact (nat.succ_ne_zero _ hj).elim }
dsimp at hj
exact (nat.succ_ne_zero _ hj).elim
rw d_next_eq
dsimp
refl
intros
conv_rhs { erw [‚Üêquotient_map_out f, ‚Üêquotient_map_out g, ‚Üê(quotient V c).map_comp], }
intros
cases i
{ rw [d_to_eq_zero], simp, }
rw [d_to_eq_zero]
simp
{ rw [d_to_eq ((single‚ÇÄ V).obj X) rfl], simp, }
rw [d_to_eq ((single‚ÇÄ V).obj X) rfl]
simp
intros
simp [neg_eq_pos_inv]
intros
rw ‚Üê map_le_iff_le_comap
exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ map_comap_le map_comap_le)
intros
induction k with k ih
simp only [derived_series_def, derived_series_of_ideal_zero, le_top]
{ simp only [derived_series_def, derived_series_of_ideal_zero, le_top], }
simp only [derived_series_def, derived_series_of_ideal_succ] at ih ‚ä¢
{ simp only [derived_series_def, derived_series_of_ideal_succ] at ih ‚ä¢, exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ ih ih), }
exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ ih ih)
intros
{ ext, simp }
ext
simp
intros
have h : ‚àÄ (N N' : lie_submodule R L M), (N : set M) ‚â§ N' ‚Üî N ‚â§ N'
intros
{ intros, refl }
refl
apply is_glb.of_image h
simp only [Inf_coe]
exact is_glb_binfi
intros
rw f.ideal_range_eq_map
exact lie_ideal.map_mono le_top
intros
rw mk_sol
{ rw mk_sol, simp only [n.is_lt, dif_pos, fin.mk_coe, fin.eta] }
simp only [n.is_lt, dif_pos, fin.mk_coe, fin.eta]
intros
simp
intros
simpa [sub_eq_add_neg, add_assoc] using abv_add abv (a - b) (b - c)
intros
rw [mul_comm, inv_mul_lt_iff h]
intros
rw [le_div_iff hb, one_mul]
intros
{ rw abs_sub_comm, exact max_sub_min_eq_abs' _ _ }
rw abs_sub_comm
exact max_sub_min_eq_abs' _ _
intros
rw [‚Üê mul_le_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
intros
by_cases a ‚â§ b; simp [min_def, h]
by_cases a ‚â§ b
simp [min_def, h]
simp [min_def, h]
intros
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®Œª h', le_of_mul_le_mul_right h' h, Œª h', decidable.mul_le_mul_of_nonneg_right h' h.le‚ü©
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®Œª h', le_of_mul_le_mul_right h' h, Œª h', decidable.mul_le_mul_of_nonneg_right h' h.le‚ü©
intros
simpa only [inv_inv] using h.const_smul a‚Åª¬π
intros
simp only [self_add_conj', two_mul, coe_add]
intros
rw [‚Üêi_mul_j, ‚Üêmul_assoc, i_mul_i, smul_mul_assoc, one_mul]
intros
rw [‚Üê mul_self_eq_mul_self_iff, one_mul]
intros
simp only [neg_eq_neg_one_mul a, neg_eq_neg_one_mul b, rel.mul_right h]
intros
cases Œ±
cases Œ≤
dsimp [presheaf.pushforward_obj] at *
tidy
intros
{ rw [const_mul, const_ext], rw mul_assoc }
rw [const_mul, const_ext]
rw mul_assoc
intros
obtain ‚ü®a, ha, C, hC, hp‚ü© : ‚àÉ (a ‚àà Ioo (0 : ‚Ñù) 1) (C > 0), (‚àÄ y ‚àà metric.ball (0 : E) r', ‚àÄ n, ‚à•f (x + y) - p.partial_sum n y‚à• ‚â§ C * (a * (‚à•y‚à• / r')) ^ n)
from hf.uniform_geometric_approx' h
refine ‚ü®a, ha, C, hC, Œª y hy n, (hp y hy n).trans _‚ü©
have yr' : ‚à•y‚à• < r'
rwa ball_zero_eq at hy
rwa ball_zero_eq at hy
refine mul_le_mul_of_nonneg_left (pow_le_pow_of_le_left _ _ _) hC.lt.le
exacts [mul_nonneg ha.1.le (div_nonneg (norm_nonneg y) r'.coe_nonneg), mul_le_of_le_one_right ha.1.le (div_le_one_of_le yr'.le r'.coe_nonneg)]
intros
ext k
by_cases h : k = c.index j
rw h
{ rw h, let r : fin (c.blocks_fun (c.index j)) ‚Üí fin n := c.embedding (c.index j), simp only [function.update_same], change p (c.blocks_fun (c.index j)) ((function.update v j z) ‚àò r) = _, let j' := c.inv_embedding j, suffices B : (function.update v j z) ‚àò r = function.update (v ‚àò r) j' z, by rw B, suffices C : (function.update v (r j') z) ‚àò r = function.update (v ‚àò r) j' z, by { convert C, exact (c.embedding_comp_inv j).symm }, exact function.update_comp_eq_of_injective _ (c.embedding _).injective _ _ }
let r : fin (c.blocks_fun (c.index j)) ‚Üí fin n := c.embedding (c.index j)
simp only [function.update_same]
change p (c.blocks_fun (c.index j)) ((function.update v j z) ‚àò r) = _
let j' := c.inv_embedding j
suffices B : (function.update v j z) ‚àò r = function.update (v ‚àò r) j' z
rw B
rw B
suffices C : (function.update v (r j') z) ‚àò r = function.update (v ‚àò r) j' z
convert C
convert C
{ convert C, exact (c.embedding_comp_inv j).symm }
{ convert C, exact (c.embedding_comp_inv j).symm }
exact (c.embedding_comp_inv j).symm
exact (c.embedding_comp_inv j).symm
exact function.update_comp_eq_of_injective _ (c.embedding _).injective _ _
simp only [h, function.update_eq_self, function.update_noteq, ne.def, not_false_iff]
{ simp only [h, function.update_eq_self, function.update_noteq, ne.def, not_false_iff], let r : fin (c.blocks_fun k) ‚Üí fin n := c.embedding k, change p (c.blocks_fun k) ((function.update v j z) ‚àò r) = p (c.blocks_fun k) (v ‚àò r), suffices B : (function.update v j z) ‚àò r = v ‚àò r, by rw B, apply function.update_comp_eq_of_not_mem_range, rwa c.mem_range_embedding_iff' }
let r : fin (c.blocks_fun k) ‚Üí fin n := c.embedding k
change p (c.blocks_fun k) ((function.update v j z) ‚àò r) = p (c.blocks_fun k) (v ‚àò r)
suffices B : (function.update v j z) ‚àò r = v ‚àò r
rw B
rw B
apply function.update_comp_eq_of_not_mem_range
rwa c.mem_range_embedding_iff'
intros
simp only [conformal_at_iff', h.fderiv]
intros
simp only [mul_comm u, deriv_mul_const_field]
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hc.smul_const f
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact has_fderiv_within_at.prod hf‚ÇÅ.has_fderiv_within_at hf‚ÇÇ.has_fderiv_within_at
intros
simp only [sub_eq_add_neg, fderiv_add_const]
intros
rw [‚Üê iso.comp_has_fderiv_within_at_iff, ‚Üê continuous_linear_map.comp_assoc, iso.coe_comp_coe_symm, continuous_linear_map.id_comp]
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact h.has_fderiv_at.has_fderiv_within_at
intros
obtain ‚ü®t, hts, ht, xt‚ü© : ‚àÉ t ‚äÜ s, is_open t ‚àß x ‚àà t := _root_.mem_nhds_iff.1 hs
have := is_open.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)
exact mem_of_superset this (image_subset _ hts)
intros
rw [fintype.linear_independent_iff]
push_neg
rcases hextr.exists_multipliers_of_has_strict_fderiv_at hf' hœÜ' with ‚ü®Œõ, Œõ‚ÇÄ, hŒõ, hŒõf‚ü©
refine ‚ü®Œª i, option.elim i Œõ‚ÇÄ Œõ, _, _‚ü©
{ simpa [add_comm] using hŒõf }
simpa [add_comm] using hŒõf
simpa [function.funext_iff, not_and_distrib, or_comm, option.exists] using hŒõ
{ simpa [function.funext_iff, not_and_distrib, or_comm, option.exists] using hŒõ }
intros
simpa using h.neg.has_fderiv_within_at_eq_zero hf.neg hy hy'
intros
{ rw [unique_diff_within_at_iff, tangent_cone_univ], simp }
rw [unique_diff_within_at_iff, tangent_cone_univ]
simp
intros
rw [‚Üê times_cont_diff_on_univ, continuous_iff_continuous_on_univ]
exact times_cont_diff_on_zero
intros
split
intros h
{ intros h, obtain ‚ü®u, H, p, hp‚ü© := h 0 (by norm_num), refine ‚ü®u, _, _‚ü©, { simpa [hx] using H }, { simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp, exact hp.1.mono (inter_subset_right s u) } }
obtain ‚ü®u, H, p, hp‚ü© := h 0 (by norm_num)
refine ‚ü®u, _, _‚ü©
{ simpa [hx] using H }
simpa [hx] using H
simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp
{ simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp, exact hp.1.mono (inter_subset_right s u) }
exact hp.1.mono (inter_subset_right s u)
rintros ‚ü®u, H, hu‚ü©
{ rintros ‚ü®u, H, hu‚ü©, rw ‚Üê times_cont_diff_within_at_inter' H, have h' : x ‚àà s ‚à© u := ‚ü®hx, mem_of_mem_nhds_within hx H‚ü©, exact (times_cont_diff_on_zero.mpr hu).times_cont_diff_within_at h' }
rw ‚Üê times_cont_diff_within_at_inter' H
have h' : x ‚àà s ‚à© u := ‚ü®hx, mem_of_mem_nhds_within hx H‚ü©
exact (times_cont_diff_on_zero.mpr hu).times_cont_diff_within_at h'
intros
simpa [measure_univ] using hg.map_smul_integral_le hgc hsc (is_probability_measure.ne_zero Œº) hfs hfi hgi
intros
{ simp [sub_eq_add_neg, inner_add_right] }
simp [sub_eq_add_neg, inner_add_right]
intros
rw [ball_eq_preimage, ‚Üê image_subset_iff] at h
rcases exists_pos_lt_subset_ball hR (to_euclidean.is_closed_image.2 hs) h with ‚ü®r, hr, hsr‚ü©
exact ‚ü®r, hr, image_subset_iff.1 hsr‚ü©
intros
rw [dist_point_reflection_self', ‚Üê two_smul' ùïú (x -·µ• y), norm_smul, ‚Üê dist_eq_norm_vsub V]
intros
rw [‚Üê rat.norm_cast_real, ‚Üê int.norm_cast_real]
rw [‚Üê rat.norm_cast_real, ‚Üê int.norm_cast_real]; congr' 1; norm_cast
rw [‚Üê rat.norm_cast_real, ‚Üê int.norm_cast_real]; congr' 1
congr' 1
norm_cast
intros
{ rw [tendsto_iff_norm_tendsto_zero], simp only [sub_zero] }
rw [tendsto_iff_norm_tendsto_zero]
simp only [sub_zero]
intros
refine ‚ü®Œª h, _, Œª h, Œª v, _‚ü©
refine op_norm_le_bound _ (zero_le_one) (Œª v, _)
{ refine op_norm_le_bound _ (zero_le_one) (Œª v, _), simpa [one_mul] using h v }
simpa [one_mul] using h v
{ simpa using le_of_op_norm_le f h v }
simpa using le_of_op_norm_le f h v
intros
refine le_of_forall_pos_le_add (Œª Œµ hŒµ, _)
replace hŒµ := half_pos hŒµ
obtain ‚ü®m, rfl, hm : ‚à•m‚à• < ‚à•mk' S m‚à• + Œµ / 2‚ü© := norm_mk_lt x hŒµ
obtain ‚ü®n, rfl, hn : ‚à•n‚à• < ‚à•mk' S n‚à• + Œµ / 2‚ü© := norm_mk_lt y hŒµ
calc ‚à•mk' S m + mk' S n‚à• = ‚à•mk' S (m + n)‚à• : by rw (mk' S).map_add ... ‚â§ ‚à•m + n‚à• : quotient_norm_mk_le S (m + n) ... ‚â§ ‚à•m‚à• + ‚à•n‚à• : norm_add_le _ _ ... ‚â§ ‚à•mk' S m‚à• + ‚à•mk' S n‚à• + Œµ : by linarith
intros
simp only [map_add, add_apply, coe_deriv‚ÇÇ, add_assoc]
intros
rintro a ha x ‚ü®y, hy, hx‚ü©
rw [mem_ball_zero, ‚Üêhx, p.smul]
calc _ ‚â§ p y : mul_le_of_le_one_left (p.nonneg _) ha ... < r : by rwa mem_ball_zero at hy
simp [arg, le_refl, not_le.2 (@zero_lt_one ‚Ñù _ _)]
intros
rcases hx.eq_or_lt with (rfl|hx)
{ simp [le_refl, zero_le_one] }
simp [le_refl, zero_le_one]
exact log_nonpos_iff hx
intros
rw integral_deriv_eq_sub' (Œª x, -cos x); norm_num [continuous_on_sin]
rw integral_deriv_eq_sub' (Œª x, -cos x)
norm_num [continuous_on_sin]
norm_num [continuous_on_sin]
norm_num [continuous_on_sin]
norm_num [continuous_on_sin]
intros
simp [top_rpow_def, asymm h, ne_of_lt h]
intros
nth_rewrite 1 ‚Üêennreal.rpow_one x
exact ennreal.rpow_le_rpow_of_exponent_ge hx h_one_le
intros
simp only [‚Üê rpow_neg_one, ‚Üê rpow_mul hx, mul_comm]
intros
simp only [cpow_def]
split_ifs; simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
split_ifs
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h‚ÇÅ h‚ÇÇ, mul_assoc] at *
intros
rw [‚Üê complex.of_real_ne_zero, complex.of_real_tan, complex.tan_ne_zero_iff]
rw [‚Üê complex.of_real_ne_zero, complex.of_real_tan, complex.tan_ne_zero_iff]; norm_cast
norm_cast
rw [‚Üê cos_pi_div_two_sub, ‚Üê cos_pi_div_three]
congr
ring
intros
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h; simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
intros
rw [sum_range_succ, dist_eq_norm, ‚Üê norm_neg, neg_sub, add_sub_cancel']
exact hf n
intros
rw [sub_def, category.assoc, œÉ_comp, ‚Üêcategory.assoc, prod.lift_map, sub_def]
intros
ext
dsimp
erw [‚Üê adj.hom_equiv_unit, ‚Üê equiv.eq_symm_apply, adj.hom_equiv_counit]
simp
intros
{ convert w (ùüô Y), tidy }
convert w (ùüô Y)
tidy
intros
haveI : mono (limits.prod.lift (ùüô A) f ‚â´ (zero_mul t).hom) := mono_comp _ _
rw [zero_mul_hom, prod.lift_snd] at _inst
haveI: split_epi f := ‚ü®t.to _, t.hom_ext _ _‚ü©
apply is_iso_of_mono_of_split_epi
intros
cases f; cases Œ±; ext; refl
cases f; cases Œ±; ext
cases f; cases Œ±
cases f
cases Œ±
ext
refl
intros
tidy
intros
{ dsimp [inv_fun_id_assoc], tidy }
dsimp [inv_fun_id_assoc]
tidy
intros
let sa := max k‚ÇÅ k‚ÇÇ
let sb := coeq (f‚ÇÅ ‚â´ left_to_max _ _) (g‚ÇÅ ‚â´ right_to_max _ _)
let sc := coeq (f‚ÇÇ ‚â´ left_to_max _ _) (g‚ÇÇ ‚â´ right_to_max _ _)
let sd := max sb sc
let s := coeq ((coeq_hom _ _ : sa ‚ü∂ sb) ‚â´ left_to_max _ _) ((coeq_hom _ _ : sa ‚ü∂ sc) ‚â´ right_to_max _ _)
use s
fsplit
exact left_to_max k‚ÇÅ k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ left_to_max sb sc ‚â´ coeq_hom _ _
fsplit
exact right_to_max k‚ÇÅ k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ right_to_max sb sc ‚â´ coeq_hom _ _
fsplit
slice_lhs 1 3 { rw [‚Üêcategory.assoc, coeq_condition], }
{ slice_lhs 1 3 { rw [‚Üêcategory.assoc, coeq_condition], }, slice_lhs 3 5 { rw [‚Üêcategory.assoc, coeq_condition], }, simp only [category.assoc], }
slice_lhs 3 5 { rw [‚Üêcategory.assoc, coeq_condition], }
simp only [category.assoc]
slice_lhs 3 5 { rw [‚Üêcategory.assoc, coeq_condition], }
{ slice_lhs 3 5 { rw [‚Üêcategory.assoc, coeq_condition], }, slice_lhs 1 3 { rw [‚Üêcategory.assoc, coeq_condition], }, simp only [category.assoc], }
slice_lhs 1 3 { rw [‚Üêcategory.assoc, coeq_condition], }
simp only [category.assoc]
intros
simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
dsimp
simp
intros
ext1
ext1; simp [‚Üê category.assoc]
simp [‚Üê category.assoc]
intros
{ ext, simp [biproduct.matrix], }
ext
simp [biproduct.matrix]
intros
rw [‚Üês.w left, parallel_pair_map_left]
intros
induction w‚ÇÅ
unfreezingI { induction w‚ÇÅ, induction w‚ÇÇ, }
{ unfreezingI { induction w‚ÇÅ, induction w‚ÇÇ, }, ext, simp [kernel_iso_of_eq], }
induction w‚ÇÇ
ext
simp [kernel_iso_of_eq]
intros
tidy
intros
apply eq_desc_of_comp_eq
tidy
intros
rw zero_of_source_iso_zero f i
exact (is_iso_zero_equiv_iso_zero _ _).inv_fun ‚ü®i, j‚ü©
intros
rw [‚Üêtensor_id_comp_id_tensor, category.assoc, M.mul_one, right_unitor_naturality]
intros
{ rw [‚Üêtensor_id, associator_naturality], }
rw [‚Üêtensor_id, associator_naturality]
intros
ext Y f hf
exact extend_agrees t hf
intros
{ ext, simp, }
ext
simp
intros
simp [image_subobject_comp_iso]
intros
conv_rhs { rw [‚Üê c.blocks_sum, ‚Üê of_fn_blocks_fun, sum_of_fn] }
intros
obtain (h|h) := h.zero_or_one i j; simp [h]
{ obtain (h|h) := h.zero_or_one i j; simp [h] }
obtain (h|h) := h.zero_or_one i j
simp [h]
simp [h]
intros
classical
apply finset.card_lt_card
rw finset.ssubset_iff
exact ‚ü®v, by simp, finset.subset_univ _‚ü©
intros
change list.foldl M.to_NFA.step_set {start} s = {list.foldl M.step start s}
induction s with a s ih generalizing start
{ tauto }
tauto
rw [list.foldl, list.foldl]
{ rw [list.foldl, list.foldl], have h : M.to_NFA.step_set {start} a = {M.step start a}, { rw NFA.step_set, finish }, rw h, tauto }
have h : M.to_NFA.step_set {start} a = {M.step start a}
rw NFA.step_set
{ rw NFA.step_set, finish }
finish
rw h
tauto
intros
simp [flip] with functor_norm
intros
cases x
cases x; refl
refl
intros
cases x; refl
cases x
refl
refl
intros
cases i; apply to_list_nth_le
cases i
apply to_list_nth_le
intros
cases b; simp only [of_nat,to_nat]; exact dec_trivial
cases b; simp only [of_nat,to_nat]
cases b
simp only [of_nat,to_nat]
exact dec_trivial
simp only [of_nat,to_nat]
exact dec_trivial
intros
induction l with hd tl hl
{ simp }
simp
apply ext
{ apply ext, simp [hl] }
simp [hl]
intros
constructor
intros cb n hn
haveI : (parser.foldr_core f p b (cb.size - n + 1)).bounded := foldr_core he
obtain ‚ü®np, errp, hp‚ü© := bounded.exists (parser.foldr_core f p b (cb.size - n + 1)) hn
simp [foldr, hp]
intros
simp [decorate_errors, h]
intros
simp [foldr, foldr_core_eq_done]
intros
simp [norm_sq]
intros
rw ‚Üê of_real_inj; simp [sinh_sq]
rw ‚Üê of_real_inj
simp [sinh_sq]
intros
rw [‚Üê of_real_exp]; exact abs_of_nonneg (le_of_lt (real.exp_pos _))
rw [‚Üê of_real_exp]
exact abs_of_nonneg (le_of_lt (real.exp_pos _))
intros
rw [‚Üê of_real_sinh_of_real_re, of_real_im]
intros
convert sin_add_mul_I z.re z.im; exact (re_add_im z).symm
convert sin_add_mul_I z.re z.im
exact (re_add_im z).symm
intros
rw [exp_eq_exp_re_mul_sin_add_cos]
{ rw [exp_eq_exp_re_mul_sin_add_cos], simp [exp_of_real_re, cos_of_real_re] }
simp [exp_of_real_re, cos_of_real_re]
intros
rw [‚Üêof_real_one, of_real_re]
simp [‚Üê finrank_eq_dim, finrank_real_complex, bit0]
intros
classical
exact finset.induction_on s (by simp [prod_zero_index]) (by simp [prod_add_index, h_zero, h_add] {contextual := tt})
intros
{ cases h, refl }
cases h
refl
intros
simp [map_range_def]
intros
{ ext x, simp [(equiv.set.congr f).symm.exists_congr_left] }
ext x
simp [(equiv.set.congr f).symm.exists_congr_left]
intros
rintro i j ij x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
revert h‚ÇÅ h‚ÇÇ
simp
intros b‚ÇÅ e‚ÇÅ h‚ÇÅ b‚ÇÇ e‚ÇÇ h‚ÇÇ
refine hd _ _ _ ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
cases encodable.mem_decode‚ÇÇ.1 e‚ÇÅ
cases encodable.mem_decode‚ÇÇ.1 e‚ÇÇ
exact mt (congr_arg _) ij
intros
simp [equiv.perm.via_fintype_embedding]
intros
rw [‚Üê e.image_source_inter_eq', inter_eq_self_of_subset_right h]
intros
refl
intros
simpa using congr_arg mk h
intros
{ cases a, refl }
cases a
refl
intros
simp [funext_iff, forall_iff_succ_above i, eq_comm]
intros
rw [fin.coe_add, nat.add_mod_eq_ite, nat.mod_eq_of_lt (show ‚Üëa < n, from a.2), nat.mod_eq_of_lt (show ‚Üëb < n, from b.2)]
intros
congr
intros
rw one_lt_card
{ rw one_lt_card, simp only [exists_prop, exists_and_distrib_left] }
simp only [exists_prop, exists_and_distrib_left]
intros
classical
rw [‚Üê insert_emptyc_eq, bUnion_insert, bUnion_empty, union_empty]
intros
apply le_antisymm
{ apply sup'_le, intros, apply le_refl, }
apply sup'_le
intros
apply le_refl
{ apply le_sup' (Œª b, a) H.some_spec, }
apply le_sup' (Œª b, a) H.some_spec
intros
simp only [noncomm_foldr, coe_foldr, coe_attach, list.attach]
rw ‚Üêlist.foldr_map
simp [list.map_pmap, list.pmap_eq_map]
intros
simp [‚Üê finsupp.support_eq_empty, finset.eq_empty_iff_forall_not_mem]
intros
ext
{ ext, simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype], }
simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype]
intros
{ ext m, simp }
ext m
simp
intros
simp [bijective, injective_iff_surjective]
intros
have nd := v.nodup (mk_idx n (hash_fn a))
rcases hash_map.valid.erase_aux a (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ‚ü®u, w, b, hl, hfl‚ü©
refine (v.modify hash_fn u [‚ü®a, b‚ü©] [] w hl hfl list.nodup_nil _ _ _).2
refine (v.modify hash_fn u [‚ü®a, b‚ü©] [] w hl hfl list.nodup_nil _ _ _).2; simp
simp
simp
simp
intros
letI := classical.dec_pred (Œª (n : ‚Ñï), cprank_max n x); exact nat.find_min' ‚ü®ds.prod, show (Œª n, cprank_max n x) ds.prod, from cprank_max_upper_bound x‚ü© (cprank_max_upper_bound x)
letI := classical.dec_pred (Œª (n : ‚Ñï), cprank_max n x)
exact nat.find_min' ‚ü®ds.prod, show (Œª n, cprank_max n x) ds.prod, from cprank_max_upper_bound x‚ü© (cprank_max_upper_bound x)
intros
rw [‚Üê shiftl_neg, neg_neg]
intros
rw [mul_comm, int.eq_mul_of_div_eq_right H1 H2]
intros
simp [abs_eq_max_neg]
intros
rw [int.lcm, int.lcm, int.lcm, int.lcm, nat_abs_of_nat, nat_abs_of_nat]
{ rw [int.lcm, int.lcm, int.lcm, int.lcm, nat_abs_of_nat, nat_abs_of_nat], apply nat.lcm_assoc }
apply nat.lcm_assoc
intros
rcases greatest_of_bdd b Hb Hinh with ‚ü®n, hn, h2n‚ü©
rcases greatest_of_bdd b' Hb' Hinh with ‚ü®n', hn', h2n'‚ü©
exact le_antisymm (h2n' _ hn) (h2n _ hn')
intros
simp [even_add]
intros
rw [modify_nth_tail_modify_nth_tail_le n n l (le_refl n), nat.sub_self]
rw [modify_nth_tail_modify_nth_tail_le n n l (le_refl n), nat.sub_self]; refl
refl
intros
rw ‚Üê h; apply drop_left
rw ‚Üê h
apply drop_left
intros
{ revert a, induction l; intros; [refl, simp only [*, foldr]] }
revert a
induction l
induction l; intros; [refl, simp only [*, foldr]]
induction l; intros
intros
refl
intros
simp only [*, foldr]
intros
rw [‚Üê head_add_tail_sum L, add_comm, nat.add_sub_cancel]
intros
induction l; [refl, simp only [*, pmap, length]]
induction l
refl
simp only [*, pmap, length]
intros
cases x; refl
cases x
refl
refl
intros
simp only [count, countp_filter]; congr; exact set.ext (Œª b, and_iff_left_of_imp (Œª e, e ‚ñ∏ h))
simp only [count, countp_filter]; congr
simp only [count, countp_filter]
congr
exact set.ext (Œª b, and_iff_left_of_imp (Œª e, e ‚ñ∏ h))
intros
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]; congr; ext b; simp [finj.eq_iff]
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]; congr; ext b
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]; congr
congr
ext b
simp [finj.eq_iff]
intros
induction n generalizing xs
{ simp [slice] }
simp [slice]
cases xs; simp [slice, *, nat.succ_add]
{ cases xs; simp [slice, *, nat.succ_add], }
cases xs
simp [slice, *, nat.succ_add]
simp [slice, *, nat.succ_add]
intros
induction m with k IH
{ simp }
simp
{ simpa only [repeat_succ, last] }
simpa only [repeat_succ, last]
intros
cases xs with z zs
{ refl }
refl
{ exact if_neg h }
exact if_neg h
intros
simp
simp; intros; refl
simp; intros
intros
induction l with hd tl ihl
simp
{ simp }
rw [nodup_cons] at hl
simp only [mem_cons_iff, map, ihl hl.2]
by_cases H : hd = x
subst hd
{ subst hd, simp [update_nth, hl.1] }
simp [update_nth, hl.1]
simp [ne.symm H, H, update_nth, ‚Üê apply_ite (cons (f hd))]
{ simp [ne.symm H, H, update_nth, ‚Üê apply_ite (cons (f hd))] }
intros
classical
refine pairwise_of_reflexive_on_dupl_of_forall_ne _ h
exact Œª _ _, hr _
intros
refine ‚ü®Œª h, _, nodup_permutations'_aux_of_not_mem _ _‚ü©
intro H
obtain ‚ü®k, hk, hk'‚ü© := nth_le_of_mem H
rw nodup_iff_nth_le_inj at h
suffices : k = k + 1
{ simpa using this }
simpa using this
refine h k (k + 1) _ _ _
{ simpa [nat.lt_succ_iff] using hk.le }
simpa [nat.lt_succ_iff] using hk.le
{ simpa using hk }
simpa using hk
rw [nth_le_permutations'_aux, nth_le_permutations'_aux]
have hl : length (insert_nth k x s) = length (insert_nth (k + 1) x s)
rw [length_insert_nth _ _ hk.le, length_insert_nth _ _ (nat.succ_le_of_lt hk)]
{ rw [length_insert_nth _ _ hk.le, length_insert_nth _ _ (nat.succ_le_of_lt hk)] }
refine ext_le hl (Œª n hn hn', _)
rcases lt_trichotomy n k with H|rfl|H
rw [nth_le_insert_nth_of_lt _ _ _ _ H (H.trans hk), nth_le_insert_nth_of_lt _ _ _ _ (H.trans (nat.lt_succ_self _))]
{ rw [nth_le_insert_nth_of_lt _ _ _ _ H (H.trans hk), nth_le_insert_nth_of_lt _ _ _ _ (H.trans (nat.lt_succ_self _))] }
rw [nth_le_insert_nth_self _ _ _ hk.le, nth_le_insert_nth_of_lt _ _ _ _ (nat.lt_succ_self _) hk, hk']
{ rw [nth_le_insert_nth_self _ _ _ hk.le, nth_le_insert_nth_of_lt _ _ _ _ (nat.lt_succ_self _) hk, hk'] }
rcases (nat.succ_le_of_lt H).eq_or_lt with rfl|H'
{ rcases (nat.succ_le_of_lt H).eq_or_lt with rfl|H', { rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)], convert hk' using 1, convert nth_le_insert_nth_add_succ _ _ _ 0 _, simpa using hk }, { obtain ‚ü®m, rfl‚ü© := nat.exists_eq_add_of_lt H', rw [length_insert_nth _ _ hk.le, nat.succ_lt_succ_iff, nat.succ_add] at hn, rw nth_le_insert_nth_add_succ, convert nth_le_insert_nth_add_succ s x k m.succ _ using 2, { simp [nat.add_succ, nat.succ_add] }, { simp [add_left_comm, add_comm] }, { simpa [nat.add_succ] using hn }, { simpa [nat.succ_add] using hn } } }
rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)]
{ rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)], convert hk' using 1, convert nth_le_insert_nth_add_succ _ _ _ 0 _, simpa using hk }
convert hk' using 1
convert nth_le_insert_nth_add_succ _ _ _ 0 _
simpa using hk
obtain ‚ü®m, rfl‚ü© := nat.exists_eq_add_of_lt H'
{ obtain ‚ü®m, rfl‚ü© := nat.exists_eq_add_of_lt H', rw [length_insert_nth _ _ hk.le, nat.succ_lt_succ_iff, nat.succ_add] at hn, rw nth_le_insert_nth_add_succ, convert nth_le_insert_nth_add_succ s x k m.succ _ using 2, { simp [nat.add_succ, nat.succ_add] }, { simp [add_left_comm, add_comm] }, { simpa [nat.add_succ] using hn }, { simpa [nat.succ_add] using hn } }
rw [length_insert_nth _ _ hk.le, nat.succ_lt_succ_iff, nat.succ_add] at hn
rw nth_le_insert_nth_add_succ
convert nth_le_insert_nth_add_succ s x k m.succ _ using 2
{ simp [nat.add_succ, nat.succ_add] }
simp [nat.add_succ, nat.succ_add]
{ simp [add_left_comm, add_comm] }
simp [add_left_comm, add_comm]
{ simpa [nat.add_succ] using hn }
simpa [nat.add_succ] using hn
{ simpa [nat.succ_add] using hn }
simpa [nat.succ_add] using hn
intros
by_cases h : a = b
subst b
{ subst b, rw [erase_cons_head], apply subperm_cons_erase }
rw [erase_cons_head]
apply subperm_cons_erase
{ rw [erase_cons_tail _ h] }
rw [erase_cons_tail _ h]
intros
simp only [range_eq_range', nodup_range']
intros
rw [rotate_eq_rotate', length_rotate']
intros
cases l
cases l; refl
refl
refl
intros
simp only [kinsert, lookup_cons_eq]
intros
cases eq_or_lt_of_le hab with H H
{ subst H, exact refl _ }
subst H
exact refl _
{ exact h.rel_nth_le_of_lt _ _ H }
exact h.rel_nth_le_of_lt _ _ H
intros
rw [‚Üêoption.some_inj, ‚Üênth_le_nth, nth_zip_with_eq_some]
refine ‚ü®l.nth_le i (lt_length_left_of_zip_with h), l'.nth_le i (lt_length_right_of_zip_with h), nth_le_nth _, _‚ü©
simp only [‚Üênth_le_nth, eq_self_iff_true, and_self]
intros
ext
ext; refl
refl
intros
ext
{ext, refl}
refl
intros
simp [dot_product]
intros
{ ext, apply smul_dot_product }
ext
apply smul_dot_product
intros
ext
norm_num [std_basis_matrix, vec_mul_vec]
split_ifs; tauto
split_ifs
tauto
tauto
tauto
tauto
tauto
tauto
intros
ext
{ ext, simp only [block_diagonal'_apply, pi.smul_apply], split_ifs; simp }
simp only [block_diagonal'_apply, pi.smul_apply]
split_ifs
split_ifs; simp
simp
simp
intros
simp
intros
dsimp [to_matrix, matrix.mul_apply]
cases h : f.symm j with fj
{ simp [h, ‚Üê f.eq_some_iff] }
simp [h, ‚Üê f.eq_some_iff]
rw finset.sum_eq_single fj
{ rw finset.sum_eq_single fj, { simp [h, ‚Üê f.eq_some_iff], }, { intros b H n, simp [h, ‚Üê f.eq_some_iff, n.symm], }, { simp, } }
{ simp [h, ‚Üê f.eq_some_iff], }
simp [h, ‚Üê f.eq_some_iff]
{ intros b H n, simp [h, ‚Üê f.eq_some_iff, n.symm], }
intros b H n
simp [h, ‚Üê f.eq_some_iff, n.symm]
{ simp, }
simp
intros
induction h
simp
case rel.zero { simp }
case rel.cons : a b s t hab hst ih { simpa using hab.add ih }
intros
{ simp_rw [singleton_eq_cons], exact cons_inj_left _ }
simp_rw [singleton_eq_cons]
exact cons_inj_left _
intros
refine ring_hom.ext (Œª x, _)
rw ring_hom.comp_apply
refine (mv_polynomial.fin_succ_equiv R n).injective (trans ((mv_polynomial.fin_succ_equiv R n).apply_symm_apply _) _)
simp only [mv_polynomial.fin_succ_equiv_apply, mv_polynomial.eval‚ÇÇ_hom_C]
intros
{ ext1, apply aeval_bind‚ÇÅ }
ext1
apply aeval_bind‚ÇÅ
intros
ext1
simp [supported_equiv_mv_polynomial, mv_polynomial.algebra_map_eq]
intros
simp [vars, degrees_map_of_injective _ hf]
intros
rcases nat.eq_zero_or_pos b with rfl|hb
simp
{ simp }
rcases nat.eq_zero_or_pos c with rfl|hc
simp
{ simp }
conv_rhs { rw ‚Üê mod_add_div a (b * c) }
rw [mul_assoc, nat.add_mul_div_left _ _ hb, add_mul_mod_self_left, mod_eq_of_lt (nat.div_lt_of_lt_mul (mod_lt _ (mul_pos hb hc)))]
intros
rw [‚Üê cast_one, cast_lt, lt_succ_iff, le_zero_iff]
intros
cases b
{ cases w‚ÇÇ }
cases w‚ÇÇ
cases b
{ cases b, { interval_cases x, }, { cases x, { cases w‚ÇÅ, }, { rw [digits_add_two_add_one, nat.div_eq_of_lt w‚ÇÇ, digits_zero, nat.mod_eq_of_lt w‚ÇÇ] } } }
{ interval_cases x, }
interval_cases x
cases x
{ cases x, { cases w‚ÇÅ, }, { rw [digits_add_two_add_one, nat.div_eq_of_lt w‚ÇÇ, digits_zero, nat.mod_eq_of_lt w‚ÇÇ] } }
{ cases w‚ÇÅ, }
cases w‚ÇÅ
{ rw [digits_add_two_add_one, nat.div_eq_of_lt w‚ÇÇ, digits_zero, nat.mod_eq_of_lt w‚ÇÇ] }
rw [digits_add_two_add_one, nat.div_eq_of_lt w‚ÇÇ, digits_zero, nat.mod_eq_of_lt w‚ÇÇ]
intros
rw [‚Üê some_eq_coe]
show (‚àÉ (h : true ‚Üí x.dom), _) ‚Üî ‚àÉ h : x.dom, x.get h ‚â§ n
simp only [forall_prop_of_true, some_eq_coe, dom_coe, get_coe']
intros
delta lcm; rw [zero_mul, nat.zero_div]
delta lcm
rw [zero_mul, nat.zero_div]
intros
rwa [‚Üêsucc_le_iff, ‚Üêpow_le_iff_le_log hb (hb.le.trans hn), pow_one]
{ rwa [‚Üêsucc_le_iff, ‚Üêpow_le_iff_le_log hb (hb.le.trans hn), pow_one] }
intros
rw [modeq_iff_dvd, ‚Üêint.coe_nat_dvd, int.coe_nat_sub h]
intros
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.add_mod]; norm_num
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.add_mod]
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.add_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.add_mod]
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.add_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.add_mod]
norm_num
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp
cases x
simp
simp
intros
cases x; refl
cases x
refl
refl
intros
rw insert_eq_insert_with; exact insert_with.valid _ _ (Œª _ _, ‚ü®le_refl _, le_refl _‚ü©) h
rw insert_eq_insert_with
exact insert_with.valid _ _ (Œª _ _, ‚ü®le_refl _, le_refl _‚ü©) h
intros
rw [size_dual, size_dual]
exact H.symm.imp (Exists.imp $ Œª _, and.imp_right balanced_sz.symm) (Exists.imp $ Œª _, and.imp_right balanced_sz.symm)
intros
cases x with a f
apply @Wp_ind n P Œ± (Œª a f, C ‚ü®a, f‚ü©)
dsimp
intros a f f' ih'
dsimp [W_mk] at ih
let ih'' := ih a (P.W_path_dest_left f') (Œª i, ‚ü®f i, P.W_path_dest_right f' i‚ü©)
dsimp at ih''
rw W_path_cases_on_eta at ih''
apply ih''
apply ih'
intros
revert h
generalize h : (M.mk ‚ü®a,f‚ü©) = x
intros h'
cases h'
subst x
cases mk_inj ‚Äπ_‚Ä∫
refl
intros
unfold_coes
dsimp [of_nat_multiset, to_nat_multiset]
have : (Œª (p : ‚Ñï) (h : p.prime), ((‚ü®p, h‚ü© : nat.primes) : ‚Ñï)) = (Œª p h, id p) := by {funext p h, refl}
rw [multiset.map_pmap, this, multiset.pmap_eq_map, multiset.map_id]
intros
dsimp [is_special, step] at hs ‚ä¢
rw [mul_add, mul_comm u.y u.x, ‚Üê hs]
ring
intros
rw [X_mul, monomial_mul_X]
intros
fsplit
intro h
{ intro h, apply_fun (Œª p, p.coeff 0) at h, simpa using h, }
apply_fun (Œª p, p.coeff 0) at h
simpa using h
{ rintro rfl, refl, }
rintro rfl
refl
intros
{ haveI := nontrivial.of_polynomial_ne hne, exact hp.ne_zero }
haveI := nontrivial.of_polynomial_ne hne
exact hp.ne_zero
intros
rw ‚Üê degree_neg q at h
{ rw ‚Üê degree_neg q at h, rw [sub_eq_add_neg, degree_add_eq_right_of_degree_lt h, degree_neg] }
rw [sub_eq_add_neg, degree_add_eq_right_of_degree_lt h, degree_neg]
intros
rw [nat_trailing_degree, trailing_degree_monomial ha]
rw [nat_trailing_degree, trailing_degree_monomial ha]; refl
refl
intros
apply polynomial.induction_on' p
{ intros p‚ÇÅ p‚ÇÇ h‚ÇÅ h‚ÇÇ, simp [h‚ÇÅ, h‚ÇÇ, mul_add], }
intros p‚ÇÅ p‚ÇÇ h‚ÇÅ h‚ÇÇ
simp [h‚ÇÅ, h‚ÇÇ, mul_add]
intros n r
{ intros n r, simp only [derivative_pow, derivative_mul, monomial_comp, derivative_monomial, derivative_C, zero_mul, C_eq_nat_cast, zero_add, ring_hom.map_mul], rw [mul_comm (derivative q)], simp only [mul_assoc], }
simp only [derivative_pow, derivative_mul, monomial_comp, derivative_monomial, derivative_C, zero_mul, C_eq_nat_cast, zero_add, ring_hom.map_mul]
rw [mul_comm (derivative q)]
simp only [mul_assoc]
intros
rw [ne.def, ‚Üê card_support_eq_zero, erase_lead_support]
exact (zero_lt_one.trans_le $ (nat.sub_le_sub_right f0 1).trans finset.pred_card_le_card_erase).ne.symm
intros
rw [‚Üê C_0, C_comp]
intros
rw [monic, leading_coeff_map, ‚Üê f.map_one, function.injective.eq_iff f.injective, monic]
intros
rw [monic, leading_coeff_mul, leading_coeff_C, mul_inv_cancel (show leading_coeff p ‚â† 0, from mt leading_coeff_eq_zero.1 h)]
intros
rw mem_lifts_iff_mem_alg at hp ‚ä¢
{ rw mem_lifts_iff_mem_alg at hp ‚ä¢, exact subalgebra.smul_mem (map_alg R S).range hp r }
exact subalgebra.smul_mem (map_alg R S).range hp r
intros
revert ht
refine t.induction_on _ _
simp
{ simp }
intros a t ih ht
rw [multiset.map_cons, multiset.prod_cons]
exact monic_mul (ht _ (multiset.mem_cons_self _ _)) (ih (Œª _ hi, ht _ (multiset.mem_cons_of_mem hi)))
intros
rw [nth_roots_finset, mem_to_finset, mem_nth_roots h]
intros
cases x; reflexivity
cases x
reflexivity
intros
refine iff.trans _ quotient.eq
rw quotient.out_eq y
intros
rw [rat.inv_def', rat.coe_int_num, rat.coe_int_denom, nat.cast_one, ‚Üêint.cast_one]
apply num_div_eq_of_coprime ha0
rw int.nat_abs_one
exact nat.coprime_one_left _
intros
rw le_iff_forall_pos_lt_add
refine ‚ü®Œª H Œµ Œµ_neg, _, Œª H Œµ Œµ_pos, _‚ü©
exact exists_lt_of_lt_cSup h' (lt_sub_iff_add_lt.mp (H _ (neg_pos.mpr Œµ_neg)))
{ exact exists_lt_of_lt_cSup h' (lt_sub_iff_add_lt.mp (H _ (neg_pos.mpr Œµ_neg))) }
rcases H _ (neg_lt_zero.mpr Œµ_pos) with ‚ü®x, x_in, hx‚ü©
{ rcases H _ (neg_lt_zero.mpr Œµ_pos) with ‚ü®x, x_in, hx‚ü©, exact sub_lt_iff_lt_add.mp (lt_cSup_of_lt h x_in hx) }
exact sub_lt_iff_lt_add.mp (lt_cSup_of_lt h x_in hx)
intros
refine le_antisymm (mk_real ‚ñ∏ mk_set_le _) _
have h2 : (Œª x, a + a - x) '' Iio a = Ioi a
{ convert image_const_sub_Iio _ _, simp }
convert image_const_sub_Iio _ _
simp
exact mk_Ioi_real a ‚ñ∏ h2 ‚ñ∏ mk_image_le
intros
rw [ennreal.of_real, ennreal.of_real, coe_lt_coe, real.to_nnreal_lt_to_nnreal_iff_of_nonneg hp]
intros
simp [Inf_eq_infi, infi_add]
intros
by_cases h' : x = ‚ä§
{ simp only [h', le_top] }
simp only [h', le_top]
{ simp only [le_refl, coe_to_real h' h] }
simp only [le_refl, coe_to_real h' h]
intros
rw [ereal.sub_eq_add_neg, to_real_add hx h'x, to_real_neg]
{ refl }
refl
{ simpa using hy }
simpa using hy
{ simpa using h'y }
simpa using h'y
intros
simpa only [neg_zero] using is_st_neg hx
intros
simpa [-to_nnreal_pos] using (not_iff_not.2 (@to_nnreal_pos r))
intros
refine ‚ü®Œª h, _, Œª h, h.symm ‚ñ∏ sign_zero‚ü©
obtain hn | rfl | hp := lt_trichotomy r (0 : ‚Ñù)
rw [sign_of_neg hn, neg_eq_zero] at h
{ rw [sign_of_neg hn, neg_eq_zero] at h, exact (one_ne_zero h).elim }
exact (one_ne_zero h).elim
{ refl }
refl
{ rw sign_of_pos hp at h, exact (one_ne_zero h).elim }
rw sign_of_pos hp at h
exact (one_ne_zero h).elim
intros
rw [mul_self_lt_mul_self_iff hx (sqrt_nonneg y), sq, mul_self_sqrt hy]
intros
haveI := terminates_of_mem ac; haveI := terminates_parallel cs; exact mem_of_promises _ (parallel_promises H)
haveI := terminates_of_mem ac; haveI := terminates_parallel cs
haveI := terminates_of_mem ac
haveI := terminates_parallel cs
exact mem_of_promises _ (parallel_promises H)
intros
simp [set.ite]
intros
simp_rw [diff_eq, ‚Üê preimage_compl, image_inter_preimage]
intros
{ ext ‚ü®x, y‚ü©, simp [and.left_comm, eq_comm] }
ext ‚ü®x, y‚ü©
simp [and.left_comm, eq_comm]
intros
ext
{ ext, split; rintro ‚ü®a, b, ha, hb, rfl‚ü©; refine ‚ü®a, b, ha, hb, by rw h a ha b hb‚ü© }
split
split; rintro ‚ü®a, b, ha, hb, rfl‚ü©; refine ‚ü®a, b, ha, hb, by rw h a ha b hb‚ü©
split; rintro ‚ü®a, b, ha, hb, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
refine ‚ü®a, b, ha, hb, by rw h a ha b hb‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
refine ‚ü®a, b, ha, hb, by rw h a ha b hb‚ü©
intros
by_cases hx : x ‚àà s; simp [hx]
by_cases hx : x ‚àà s
simp [hx]
simp [hx]
intros
rw [inter_comm, Ioc_inter_Ioo_of_left_lt h, max_comm]
intros
rw [‚Üê Ico_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 $ left_mem_Ico.2 h)]
intros
ext1 x
simp_rw [mem_union, mem_Ioo, mem_Ioi, min_lt_iff]
by_cases hc : c < x
{ tauto }
tauto
have hxb : x < b := (le_of_not_gt hc).trans_lt h‚ÇÅ
{ have hxb : x < b := (le_of_not_gt hc).trans_lt h‚ÇÅ, tauto }
tauto
intros
simp [‚Üê Ioi_inter_Iio]
intros
simp
intros
simp [‚Üê Ici_inter_Iic, h, inter_comm]
intros
rintros a ‚ü®‚ü®hxa, hay‚ü©, ha'‚ü©
simpa [le_update_iff, update_le_iff, hxa, hay, hxa _, hay _, ‚Üê exists_or_distrib, not_and_distrib] using ha'
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa using h.preimage f
intros
{ cases x‚ÇÄ, cases x‚ÇÅ, cases h‚ÇÄ, cases h‚ÇÅ, refl }
cases x‚ÇÄ
cases x‚ÇÅ
cases h‚ÇÄ
cases h‚ÇÅ
refl
intros
ext x
ext x; cases x
cases x
intros
cases n; refl
{ cases n; refl }
cases n
refl
refl
intros
cases n
rcases int.units_eq_one_or u with rfl|rfl; simp
{ rcases int.units_eq_one_or u with rfl|rfl; simp }
rcases int.units_eq_one_or u with rfl|rfl
simp
simp
apply nat.coprime_of_mul_modeq_one ((u‚Åª¬π : units (zmod (n+1))) : zmod (n+1)).val
have := units.ext_iff.1 (mul_right_inv u)
rw [units.coe_one] at this
rw [‚Üê eq_iff_modeq_nat, nat.cast_one, ‚Üê this]
clear this
rw [‚Üê nat_cast_zmod_val ((u * u‚Åª¬π : units (zmod (n+1))) : zmod (n+1))]
rw [units.coe_mul, val_mul, nat_cast_mod]
intros
split
split; { contrapose, simp [eq_zero_iff_even], }
{ contrapose, simp [eq_zero_iff_even], }
contrapose
{ contrapose, simp [eq_zero_iff_even], }
simp [eq_zero_iff_even]
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h
intros
rw [‚Üê nat.mod_add_div m n] at hm
exact hm.left_of_add (hn.mul_const _)
intros
apply_instance
intros
{ ext, refl }
ext
refl
intros
apply splits_mul
rw ‚Üê (splitting_field.lift q‚ÇÅ (splits_of_splits_of_dvd _ (mul_ne_zero hq‚ÇÅ hq‚ÇÇ) (splitting_field.splits _) (dvd_mul_right q‚ÇÅ q‚ÇÇ))).comp_algebra_map
{ rw ‚Üê (splitting_field.lift q‚ÇÅ (splits_of_splits_of_dvd _ (mul_ne_zero hq‚ÇÅ hq‚ÇÇ) (splitting_field.splits _) (dvd_mul_right q‚ÇÅ q‚ÇÇ))).comp_algebra_map, exact splits_comp_of_splits _ _ h‚ÇÅ, }
exact splits_comp_of_splits _ _ h‚ÇÅ
rw ‚Üê (splitting_field.lift q‚ÇÇ (splits_of_splits_of_dvd _ (mul_ne_zero hq‚ÇÅ hq‚ÇÇ) (splitting_field.splits _) (dvd_mul_left q‚ÇÇ q‚ÇÅ))).comp_algebra_map
{ rw ‚Üê (splitting_field.lift q‚ÇÇ (splits_of_splits_of_dvd _ (mul_ne_zero hq‚ÇÅ hq‚ÇÇ) (splitting_field.splits _) (dvd_mul_left q‚ÇÇ q‚ÇÅ))).comp_algebra_map, exact splits_comp_of_splits _ _ h‚ÇÇ, }
exact splits_comp_of_splits _ _ h‚ÇÇ
intros
have := h.of_mul_left_left
rw derivative_mul at this
exact is_coprime.of_mul_right_right (is_coprime.of_add_mul_left_right this)
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
unfold angle
rw [inner_smul_right, norm_smul, real.norm_eq_abs, abs_of_nonneg (le_of_lt hr), ‚Üêmul_assoc, mul_comm _ r, mul_assoc, mul_div_mul_left _ _ (ne_of_gt hr)]
intros
rw [midpoint_comm p1 p2, angle_left_midpoint_eq_pi_div_two_of_dist_eq h.symm]
intros
set e := ext_chart_at I c
have : is_closed (e '' s) := f.closed_image_of_closed hsc hs
rw [support_eq_inter_preimage, subset_inter_iff, ‚Üê image_subset_iff] at hs
rcases euclidean.exists_pos_lt_subset_ball f.R_pos this hs.2 with ‚ü®r, hrR, hr‚ü©
exact ‚ü®r, hrR, subset_inter hs.1 (image_subset_iff.1 hr)‚ü©
intros
have : s = univ ‚à© s
rw univ_inter
rw univ_inter
rwa [this, mdifferentiable_within_at_inter hs, mdifferentiable_within_at_univ] at h
intros
rw [ext_chart_at_coe, (‚àò), ‚Üê I.map_nhds_eq, ‚Üê (chart_at H x).map_nhds_eq, map_map]
rwa ext_chart_at_source at hy
intros
rw ‚Üê times_cont_mdiff_within_at_univ at *
convert hf.prod_map hg
exact univ_prod_univ.symm
intros
cases add_subgroup.bot_or_exists_ne_zero H with h h
use 0
{ use 0, rw h, exact add_subgroup.closure_singleton_zero.symm }
rw h
exact add_subgroup.closure_singleton_zero.symm
let s := {g : ‚Ñ§ | g ‚àà H ‚àß 0 < g}
have h_bdd : ‚àÄ g ‚àà s, (0 : ‚Ñ§) ‚â§ g := Œª _ h, le_of_lt h.2
obtain ‚ü®g‚ÇÄ, g‚ÇÄ_in, g‚ÇÄ_ne‚ü© := h
obtain ‚ü®g‚ÇÅ, g‚ÇÅ_in, g‚ÇÅ_pos‚ü© : ‚àÉ g‚ÇÅ : ‚Ñ§, g‚ÇÅ ‚àà H ‚àß 0 < g‚ÇÅ
cases lt_or_gt_of_ne g‚ÇÄ_ne with Hg‚ÇÄ Hg‚ÇÄ
{ cases lt_or_gt_of_ne g‚ÇÄ_ne with Hg‚ÇÄ Hg‚ÇÄ, { exact ‚ü®-g‚ÇÄ, H.neg_mem g‚ÇÄ_in, neg_pos.mpr Hg‚ÇÄ‚ü© }, { exact ‚ü®g‚ÇÄ, g‚ÇÄ_in, Hg‚ÇÄ‚ü© } }
{ exact ‚ü®-g‚ÇÄ, H.neg_mem g‚ÇÄ_in, neg_pos.mpr Hg‚ÇÄ‚ü© }
exact ‚ü®-g‚ÇÄ, H.neg_mem g‚ÇÄ_in, neg_pos.mpr Hg‚ÇÄ‚ü©
{ exact ‚ü®g‚ÇÄ, g‚ÇÄ_in, Hg‚ÇÄ‚ü© }
exact ‚ü®g‚ÇÄ, g‚ÇÄ_in, Hg‚ÇÄ‚ü©
obtain ‚ü®a, ha, ha'‚ü© := int.exists_least_of_bdd ‚ü®(0 : ‚Ñ§), h_bdd‚ü© ‚ü®g‚ÇÅ, g‚ÇÅ_in, g‚ÇÅ_pos‚ü©
exact ‚ü®a, add_subgroup.cyclic_of_min ‚ü®ha, ha'‚ü©‚ü©
intros
{ ext, exact (right_coset_eq_iff s).symm }
ext
exact (right_coset_eq_iff s).symm
intros
simp
intros
rw [mul_mk'_eq_mk'_of_mul, mul_one]
intros
simp_rw [add_order_of_eq_add_order_of_iff, ‚Üêf.map_nsmul, ‚Üêf.map_zero, hf.eq_iff, iff_self, forall_const]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
rw prod.mk.inj_iff
split
split; ext i
ext i
{ simpa using equiv.congr_fun h (sum.inl i), }
simpa using equiv.congr_fun h (sum.inl i)
ext i
{ simpa using equiv.congr_fun h (sum.inr i), }
simpa using equiv.congr_fun h (sum.inr i)
intros
rwa [is_three_cycle, cycle_type_inv]
intros
convert cycle_of_apply_apply_pow_self f x 1 using 1
intros
obtain ‚ü®m, rfl‚ü© := exists_add_of_le h
rw [add_comm]
exact is_cycle_fin_rotate
intros
cases xs with x xs
{ simp }
simp
have : n ‚â§ xs.length
{ have : n ‚â§ xs.length, { refine nat.le_of_lt_succ _, simpa using hn }, rcases this.eq_or_lt with rfl|hn', { simp }, { simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn'] } }
refine nat.le_of_lt_succ _
{ refine nat.le_of_lt_succ _, simpa using hn }
simpa using hn
rcases this.eq_or_lt with rfl|hn'
{ simp }
simp
{ simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn'] }
simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn']
intros
intro b
by_cases pb : p b
refine (h (f.symm ‚ü®b, pb‚ü©)).imp _ _; { intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] }
refine (h (f.symm ‚ü®b, pb‚ü©)).imp _ _
{ refine (h (f.symm ‚ü®b, pb‚ü©)).imp _ _; { intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] } }
{ intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] }
intro h
{ intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] }
rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk]
left
{ left, rw [extend_domain_apply_not_subtype _ _ pb] }
rw [extend_domain_apply_not_subtype _ _ pb]
intros
rintro ‚ü®_, g, rfl‚ü©
use mk g
refl
intros
cases n
{ simp_rw [mul_zero, pow_zero] }
simp_rw [mul_zero, pow_zero]
rw [a_one_pow, one_def]
{ rw [a_one_pow, one_def], congr' 1, exact zmod.nat_cast_self _ }
congr' 1
exact zmod.nat_cast_self _
intros
simp [homothety_apply, point_reflection_apply]
intros
rw ‚Üêmem_coe at hp1
rw [‚Üêvsub_right_mem_direction_iff_mem (mem_affine_span k (set.mem_insert_of_mem _ hp1)), direction_affine_span_insert hp1, submodule.mem_sup]
split
rintros ‚ü®v1, hv1, v2, hv2, hp‚ü©
{ rintros ‚ü®v1, hv1, v2, hv2, hp‚ü©, rw submodule.mem_span_singleton at hv1, rcases hv1 with ‚ü®r, rfl‚ü©, use [r, v2 +·µ• p1, vadd_mem_of_mem_direction hv2 hp1], symmetry' at hp, rw [‚Üêsub_eq_zero, ‚Üêvsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp, rw [hp, vadd_vadd] }
rw submodule.mem_span_singleton at hv1
rcases hv1 with ‚ü®r, rfl‚ü©
use [r, v2 +·µ• p1, vadd_mem_of_mem_direction hv2 hp1]
symmetry' at hp
rw [‚Üêsub_eq_zero, ‚Üêvsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp
rw [hp, vadd_vadd]
rintros ‚ü®r, p3, hp3, rfl‚ü©
{ rintros ‚ü®r, p3, hp3, rfl‚ü©, use [r ‚Ä¢ (p2 -·µ• p1), submodule.mem_span_singleton.2 ‚ü®r, rfl‚ü©, p3 -·µ• p1, vsub_mem_direction hp3 hp1], rw [vadd_vsub_assoc, add_comm] }
use [r ‚Ä¢ (p2 -·µ• p1), submodule.mem_span_singleton.2 ‚ü®r, rfl‚ü©, p3 -·µ• p1, vsub_mem_direction hp3 hp1]
rw [vadd_vsub_assoc, add_comm]
intros
refine le_antisymm _ (subset_span_points _ _)
rintros p ‚ü®p1, hp1, v, hv, rfl‚ü©
exact vadd_mem_of_mem_direction hv hp1
intros
rw univ_fin2
convert centroid_insert_singleton k p 0 1
intros
obtain (rfl|hab) : a = b ‚à® a ‚â† b := classical.em _
simp
{ simp }
rw [slope_comm _ a, slope_comm _ a, slope_comm _ _ b]
convert line_map_slope_slope_sub_div_sub f b (line_map a b r) a hab.symm using 2
rw [line_map_apply_ring, eq_div_iff (sub_ne_zero.2 hab), sub_mul, one_mul, mul_sub, ‚Üê sub_sub, sub_sub_cancel]
intros
rw [span_le, set.singleton_subset_iff, set_like.mem_coe]
exact smul_mem _ _ (mem_span_singleton_self _)
intros
apply is_linear_map.mk
intros x y
{ intros x y, simp [add_comm, add_left_comm, sub_eq_add_neg] }
simp [add_comm, add_left_comm, sub_eq_add_neg]
intros x y
{ intros x y, simp [smul_sub] }
simp [smul_sub]
intros
simp [to_clifford]
intros
rw [‚Üê linear_map_to_matrix_mul_basis_to_matrix c b c, ‚Üê basis_to_matrix_mul_linear_map_to_matrix b c b, matrix.det_conj]
rw [‚Üê linear_map_to_matrix_mul_basis_to_matrix c b c, ‚Üê basis_to_matrix_mul_linear_map_to_matrix b c b, matrix.det_conj]; rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
intros
rw [rank, linear_map.range_zero, dim_bot]
intros
{ ext œÜ x, simp }
ext œÜ x
simp
intros
rw finrank_eq_one_iff_of_nonzero v nz
apply span_singleton_eq_top_iff
intros
rw submodule.eq_bot_iff
intros x hx
refine b.ext_elem (Œª i, _)
rw (eq_bot_iff_generator_eq_zero _).mpr hgen at hœï
rw [linear_equiv.map_zero, finsupp.zero_apply]
exact (submodule.eq_bot_iff _).mp (hœï ((finsupp.lapply i) ‚àò‚Çó ‚Üëb.repr) bot_le) _ ‚ü®x, hx, rfl‚ü©
intros
rw [‚Üê linear_independent_fin_cons, fin.cons_self_tail]
intros
intros i j hij
let l : Œπ ‚Üí‚ÇÄ R := finsupp.single i (1 : R) - finsupp.single j 1
have h_total : finsupp.total Œπ M R v l = 0
simp_rw [linear_map.map_sub, finsupp.total_apply]
{ simp_rw [linear_map.map_sub, finsupp.total_apply], simp [hij] }
simp [hij]
have h_single_eq : finsupp.single i (1 : R) = finsupp.single j 1
rw linear_independent_iff at hv
{ rw linear_independent_iff at hv, simp [eq_add_of_sub_eq' (hv l h_total)] }
simp [eq_add_of_sub_eq' (hv l h_total)]
simpa [finsupp.single_eq_single_iff] using h_single_eq
intros
simp
intros
{ intros i j h, simp [ha h, hb h] }
intros i j h
simp [ha h, hb h]
intros
rw [‚Üê matrix.to_lin_alg_equiv_symm, alg_equiv.symm_apply_apply]
intros
simp [polar, add_left, add_right, sub_eq_add_neg _ (B y y), add_comm (B y x) _, add_assoc]
intros
obtain ‚ü®x, _, not_mem_s‚ü© := set_like.exists_of_lt h
refine ‚ü®‚ü®mk x, 0, _‚ü©‚ü©
simpa using not_mem_s
intros
ext x j
convert (update_apply 0 x i j _).symm
refl
intros
rw [‚Üê decidable.not_and_distrib, decidable.not_not]
intros
induction n with n ihn
refl
{ refl }
funext x
simp only [ihn, (h.iterate_right n).eq, iterate_succ, comp_app]
intros
induction hbc
assumption
case refl_trans_gen.refl : { assumption }
case refl_trans_gen.tail : c d hbc hcd hac { exact hac.tail hcd }
intros
rw [has_finite_integral_congr h1f.ae_eq_mk, has_finite_integral_prod_iff h1f.measurable_mk]
apply and_congr
apply eventually_congr
{ apply eventually_congr, filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm], assume x hx, exact has_finite_integral_congr hx }
filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
assume x hx
exact has_finite_integral_congr hx
apply has_finite_integral_congr
{ apply has_finite_integral_congr, filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm], assume x hx, exact integral_congr_ae (eventually_eq.fun_comp hx _) }
filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
assume x hx
exact integral_congr_ae (eventually_eq.fun_comp hx _)
{ apply_instance }
apply_instance
intros
ext1
refine (mem_‚Ñíp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_smul _ _).symm
rw condexp_ind_smul_smul hs hŒºs c x
refine (Lp.coe_fn_smul _ _).trans _
refine (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hŒºs x).mono (Œª y hy, _)
rw [pi.smul_apply, pi.smul_apply, hy]
intros
simp [has_finite_integral]
intros
{ rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢, exact hf.im, }
rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢
exact hf.im
intros
by_cases pzero : p = 0
{ simp [pzero, norm_def] }
simp [pzero, norm_def]
cases le_or_lt 0 c with hc hc
have := snorm_le_mul_snorm_aux_of_nonneg h hc p
{ have := snorm_le_mul_snorm_aux_of_nonneg h hc p, rw [‚Üê ennreal.to_real_le_to_real, ennreal.to_real_mul, ennreal.to_real_of_real hc] at this, { exact this }, { exact (Lp.mem_‚Ñíp _).snorm_ne_top }, { simp [(Lp.mem_‚Ñíp _).snorm_ne_top] } }
rw [‚Üê ennreal.to_real_le_to_real, ennreal.to_real_mul, ennreal.to_real_of_real hc] at this
{ exact this }
exact this
{ exact (Lp.mem_‚Ñíp _).snorm_ne_top }
exact (Lp.mem_‚Ñíp _).snorm_ne_top
{ simp [(Lp.mem_‚Ñíp _).snorm_ne_top] }
simp [(Lp.mem_‚Ñíp _).snorm_ne_top]
have := snorm_le_mul_snorm_aux_of_neg h hc p
{ have := snorm_le_mul_snorm_aux_of_neg h hc p, simp only [snorm_eq_zero_iff (Lp.ae_measurable _) pzero, ‚Üê eq_zero_iff_ae_eq_zero] at this, simp [this] }
simp only [snorm_eq_zero_iff (Lp.ae_measurable _) pzero, ‚Üê eq_zero_iff_ae_eq_zero] at this
simp [this]
intros
rw Lp.eq_zero_iff_ae_eq_zero
apply (coe_fn_comp_Lp _ _ _).trans
filter_upwards [Lp.coe_fn_zero E p Œº]
assume a ha
simp [ha, g0]
intros
simp only [mem_‚Ñíp, snorm_congr_ae hfg, ae_measurable_congr hfg]
intros
by_cases hfm : ae_measurable f (measure.map e Œº)
{ exact integral_map e.measurable hfm }
exact integral_map e.measurable hfm
rw [integral_non_ae_measurable hfm, integral_non_ae_measurable]
{ rw [integral_non_ae_measurable hfm, integral_non_ae_measurable], rwa ‚Üê ae_measurable_map_equiv_iff }
rwa ‚Üê ae_measurable_map_equiv_iff
intros
rw [norm_eq_sum_mul f, (to_simple_func f).map_integral norm (simple_func.integrable f) norm_zero]
simp_rw smul_eq_mul
intros
simpa [mul_comm] using integral_deriv_comp_smul_deriv' hf hff' hf' hg hgg' hg'
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
casesI is_empty_or_nonempty Œ≤
simp [supr_of_empty]
{ simp [supr_of_empty] }
inhabit Œ≤
have : ‚àÄa, (‚®Ü b, f b a) = (‚®Ü n, f (h_directed.sequence f n) a)
assume a
{ assume a, refine le_antisymm (supr_le $ assume b, _) (supr_le $ assume n, le_supr (Œªn, f n a) _), exact le_supr_of_le (encode b + 1) (h_directed.le_sequence b a) }
refine le_antisymm (supr_le $ assume b, _) (supr_le $ assume n, le_supr (Œªn, f n a) _)
exact le_supr_of_le (encode b + 1) (h_directed.le_sequence b a)
calc ‚à´‚Åª a, ‚®Ü b, f b a ‚àÇŒº = ‚à´‚Åª a, ‚®Ü n, f (h_directed.sequence f n) a ‚àÇŒº : by simp only [this] ... = ‚®Ü n, ‚à´‚Åª a, f (h_directed.sequence f n) a ‚àÇŒº : lintegral_supr (assume n, hf _) h_directed.sequence_mono ... = ‚®Ü b, ‚à´‚Åª a, f b a ‚àÇŒº : begin refine le_antisymm (supr_le $ assume n, _) (supr_le $ assume b, _), { exact le_supr (Œªb, ‚à´‚Åª a, f b a ‚àÇŒº) _ }, { exact le_supr_of_le (encode b + 1) (lintegral_mono $ h_directed.le_sequence b) } end
intros
simp_rw [pi.mul_apply, ennreal.coe_mul]
exact ennreal.lintegral_mul_le_Lp_mul_Lq Œº hpq hf.coe_nnreal_ennreal hg.coe_nnreal_ennreal
intros
{ rw [‚Üê image_univ], exact measurable_set.univ.inl_image }
rw [‚Üê image_univ]
exact measurable_set.univ.inl_image
intros
simp only [prehaar, compacts.map_val, is_left_invariant_index K.2 _ hU]
intros
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp *
{ convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp * }
simp *
simp *
intros
conv_rhs { rw [‚Üê real.smul_map_volume_mul_left h, smul_smul, ‚Üê ennreal.of_real_mul (abs_nonneg _), ‚Üê abs_mul, inv_mul_cancel h, abs_one, ennreal.of_real_one, one_smul] }
intros
refine ext_of_generate_from_of_cover_subset hA hC _ (countable_range B) h1B _ h_eq
{ rintro _ ‚ü®i, rfl‚ü©, apply h2B }
rintro _ ‚ü®i, rfl‚ü©
apply h2B
{ rintro _ ‚ü®i, rfl‚ü©, apply hŒºB }
rintro _ ‚ü®i, rfl‚ü©
apply hŒºB
intros
rw [sUnion_eq_bUnion, measure_bUnion hs hd h]
intros
rw [union_eq_Union, extend_Union P0 m0 PU mU (pairwise_disjoint_on_bool.2 hd) (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©), tsum_fintype]
simp
intros
rw [bounded_by, le_of_function, forall_congr]
intro s
cases s.eq_empty_or_nonempty with h h
cases s.eq_empty_or_nonempty with h h; simp [h, empty_not_nonempty]
simp [h, empty_not_nonempty]
simp [h, empty_not_nonempty]
intros
haveI := hI.to_subtype
{ haveI := hI.to_subtype, rw [‚Üê infi_subtype'', ‚Üê infi_subtype''], exact map_infi_comap _ }
rw [‚Üê infi_subtype'', ‚Üê infi_subtype'']
exact map_infi_comap _
intros
rw of_union h hA‚ÇÅ hB‚ÇÅ at hAB
linarith
apply_instance
intros
by_cases hj‚ÇÅ : measurable_set j
{ exact (restrict_le_restrict_iff _ _ hi).1 hi‚ÇÇ hj‚ÇÅ hj }
exact (restrict_le_restrict_iff _ _ hi).1 hi‚ÇÇ hj‚ÇÅ hj
{ rw [v.not_measurable hj‚ÇÅ, w.not_measurable hj‚ÇÅ] }
rw [v.not_measurable hj‚ÇÅ, w.not_measurable hj‚ÇÅ]
intros
simpa using d.has_compl d.has_empty
intros
have hp3 : p < 3 := lt_three hpq hqr H
interval_cases p
{ exact admissible_A' q r }
exact admissible_A' q r
have hq4 : q < 4 := lt_four hqr H
interval_cases q
{ exact admissible_D' r }
exact admissible_D' r
have hr6 : r < 6 := lt_six H
interval_cases r
{ exact admissible_E6 }
exact admissible_E6
{ exact admissible_E7 }
exact admissible_E7
{ exact admissible_E8 }
exact admissible_E8
intros
apply int.gcd_eq_one_iff_coprime.mp
by_contradiction hab
obtain ‚ü®p, hp, hpa, hpb‚ü© := nat.prime.not_coprime_iff_dvd.mp hab
obtain ‚ü®a1, rfl‚ü© := (int.coe_nat_dvd_left.mpr hpa)
obtain ‚ü®b1, rfl‚ü© := (int.coe_nat_dvd_left.mpr hpb)
have hpc : (p : ‚Ñ§) ^ 2 ‚à£ c
apply (int.pow_dvd_pow_iff (dec_trivial : 0 < 2)).mp
{ apply (int.pow_dvd_pow_iff (dec_trivial : 0 < 2)).mp, rw ‚Üê h.1.2.2, apply dvd.intro (a1 ^ 4 + b1 ^ 4), ring }
rw ‚Üê h.1.2.2
apply dvd.intro (a1 ^ 4 + b1 ^ 4)
ring
obtain ‚ü®c1, rfl‚ü© := hpc
have hf : fermat_42 a1 b1 c1
exact (fermat_42.mul (int.coe_nat_ne_zero.mpr (nat.prime.ne_zero hp))).mpr h.1
apply nat.le_lt_antisymm (h.2 _ _ _ hf)
rw [int.nat_abs_mul, lt_mul_iff_one_lt_left, int.nat_abs_pow, int.nat_abs_of_nat]
exact nat.one_lt_pow _ _ (show 0 < 2, from dec_trivial) (nat.prime.one_lt hp)
{ exact nat.one_lt_pow _ _ (show 0 < 2, from dec_trivial) (nat.prime.one_lt hp) }
exact (nat.pos_of_ne_zero (int.nat_abs_ne_zero_of_ne_zero (ne_zero hf)))
{ exact (nat.pos_of_ne_zero (int.nat_abs_ne_zero_of_ne_zero (ne_zero hf))) }
intros
cases x
cases y
congr
congr; assumption
assumption
assumption
intros
rw [ideal.mem_span_singleton]
split
rintro ‚ü®c, rfl‚ü©
{ rintro ‚ü®c, rfl‚ü©, suffices : c ‚â† 0, { rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right], apply valuation_nonneg, }, contrapose! hx, rw [hx, mul_zero], }
suffices : c ‚â† 0
rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right]
{ rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right], apply valuation_nonneg, }
apply valuation_nonneg
contrapose! hx
rw [hx, mul_zero]
rw [unit_coeff_spec hx] { occs := occurrences.pos [2] }
{ rw [unit_coeff_spec hx] { occs := occurrences.pos [2] }, lift x.valuation to ‚Ñï using x.valuation_nonneg with k hk, simp only [int.nat_abs_of_nat, units.is_unit, is_unit.dvd_mul_left, int.coe_nat_le], intro H, obtain ‚ü®k, rfl‚ü© := nat.exists_eq_add_of_le H, simp only [pow_add, dvd_mul_right], }
lift x.valuation to ‚Ñï using x.valuation_nonneg with k hk
simp only [int.nat_abs_of_nat, units.is_unit, is_unit.dvd_mul_left, int.coe_nat_le]
intro H
obtain ‚ü®k, rfl‚ü© := nat.exists_eq_add_of_le H
simp only [pow_add, dvd_mul_right]
intros
unfold padic_val_rat
split_ifs
simp [-add_comm]; refl
{ simp [-add_comm]; refl }
simp [-add_comm]
refl
{ exfalso, simp * at * }
exfalso
simp * at *
{ exfalso, simp * at * }
exfalso
simp * at *
intros
induction n with n ih
{ refl }
refl
{ simpa using ih }
simpa using ih
intros
refine frequently_at_top.2 (Œª n, _)
obtain ‚ü®p, hp‚ü© := exists_prime_ge_modeq_one k n hpos
exact ‚ü®p, ‚ü®hp.2.1, hp.1, hp.2.2‚ü©‚ü©
intros
simp [norm]
intros
cases x; rw [norm, norm_sq]; simp
cases x; rw [norm, norm_sq]
cases x
rw [norm, norm_sq]
simp
intros
rintro rfl
{ rintro rfl, apply (hf.reflect_lt h1).not_le, exact int.le_of_lt_add_one (hf.reflect_lt h2) }
apply (hf.reflect_lt h1).not_le
exact int.le_of_lt_add_one (hf.reflect_lt h2)
intros
rw [inf_comm, inf_sdiff_self_right]
intros
classical
refine ‚ü®Œª H a, ‚ü®(function.monotone_eval a).mem_upper_bounds_image H.1, Œª b hb, _‚ü©, Œª H, ‚ü®_, _‚ü©‚ü©
suffices : function.update f a b ‚àà upper_bounds s
{ suffices : function.update f a b ‚àà upper_bounds s, from function.update_same a b f ‚ñ∏ H.2 this a, refine Œª g hg, le_update_iff.2 ‚ü®hb $ mem_image_of_mem _ hg, Œª i hi, H.1 hg i‚ü© }
from function.update_same a b f ‚ñ∏ H.2 this a
refine Œª g hg, le_update_iff.2 ‚ü®hb $ mem_image_of_mem _ hg, Œª i hi, H.1 hg i‚ü©
{ exact Œª g hg a, (H a).1 (mem_image_of_mem _ hg) }
exact Œª g hg a, (H a).1 (mem_image_of_mem _ hg)
exact Œª g hg a, (H a).2 ((function.monotone_eval a).mem_upper_bounds_image hg)
{ exact Œª g hg a, (H a).2 ((function.monotone_eval a).mem_upper_bounds_image hg) }
intros
rw [well_founded_iff_is_Sup_finite_compact, is_Sup_finite_compact_iff_all_elements_compact] at h
exact ‚ü®Œª x, ‚ü®{x}, ‚ü®Œª x _, h x, Sup_singleton‚ü©‚ü©‚ü©
intros
have := (hs.mono $ insert_subset.mpr ‚ü®hx, hy‚ü©) (mem_insert x _)
rw [insert_diff_of_mem _ (mem_singleton _), diff_singleton_eq_self hxy] at this
exact this
intros
simp only [‚Üê infi_inf_eq, infi_or]
intros
classical
contrapose! hb
exact cSup_le hs hb
intros
rw [disjointed_succ, hf.partial_sups_eq]
intros
simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]
simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]; refl
refl
intros
rw [prod_map_map_eq, prod_at_top_at_top_eq, prod.map_def]
intros
simp only [le_def, hl.mem_iff]
intros
simpa only [div_eq_mul_inv] using h.mul h'.inv
intros
{ rw [prod_comm', ‚Üê map_swap_eq_comap_swap], refl }
rw [prod_comm', ‚Üê map_swap_eq_comap_swap]
refl
intros
split
rw [infi_eq_generate, mem_generate_iff]
{ rw [infi_eq_generate, mem_generate_iff], rintro ‚ü®t, tsub, tfin, tinter‚ü©, rcases eq_finite_Union_of_finite_subset_Union tfin tsub with ‚ü®I, Ifin, œÉ, œÉfin, œÉsub, rfl‚ü©, rw sInter_Union at tinter, set V := Œª i, U ‚à™ ‚ãÇ‚ÇÄ œÉ i with hV, have V_in : ‚àÄ i, V i ‚àà s i, { rintro i, have : (‚ãÇ‚ÇÄ œÉ i) ‚àà s i, { rw sInter_mem (œÉfin _), apply œÉsub }, exact mem_of_superset this (subset_union_right _ _) }, refine ‚ü®I, Ifin, V, V_in, _‚ü©, rwa [hV, ‚Üê union_Inter, union_eq_self_of_subset_right] }
rintro ‚ü®t, tsub, tfin, tinter‚ü©
rcases eq_finite_Union_of_finite_subset_Union tfin tsub with ‚ü®I, Ifin, œÉ, œÉfin, œÉsub, rfl‚ü©
rw sInter_Union at tinter
set V := Œª i, U ‚à™ ‚ãÇ‚ÇÄ œÉ i with hV
have V_in : ‚àÄ i, V i ‚àà s i
rintro i
{ rintro i, have : (‚ãÇ‚ÇÄ œÉ i) ‚àà s i, { rw sInter_mem (œÉfin _), apply œÉsub }, exact mem_of_superset this (subset_union_right _ _) }
have : (‚ãÇ‚ÇÄ œÉ i) ‚àà s i
rw sInter_mem (œÉfin _)
{ rw sInter_mem (œÉfin _), apply œÉsub }
apply œÉsub
exact mem_of_superset this (subset_union_right _ _)
refine ‚ü®I, Ifin, V, V_in, _‚ü©
rwa [hV, ‚Üê union_Inter, union_eq_self_of_subset_right]
rintro ‚ü®I, Ifin, V, V_in, rfl‚ü©
{ rintro ‚ü®I, Ifin, V, V_in, rfl‚ü©, exact mem_infi_of_Inter Ifin V_in subset.rfl }
exact mem_infi_of_Inter Ifin V_in subset.rfl
intros
rwa [inf_principal_eq_bot, compl_compl] at h
intros
by_cases h : ‚àÉi, a ‚àà s i
rcases h with ‚ü®i, hi‚ü©
{ rcases h with ‚ü®i, hi‚ü©, refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _), rw [indicator_of_mem (hs hn hi) _, indicator_of_mem ((subset_Union _ _) hi) _] }
refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _)
rw [indicator_of_mem (hs hn hi) _, indicator_of_mem ((subset_Union _ _) hi) _]
rw [not_exists] at h
{ rw [not_exists] at h, simp only [indicator_of_not_mem (h _)], convert tendsto_const_pure, apply indicator_of_not_mem, simpa only [not_exists, mem_Union] }
simp only [indicator_of_not_mem (h _)]
convert tendsto_const_pure
apply indicator_of_not_mem
simpa only [not_exists, mem_Union]
intros
rw [prod_same_eq, mem_lift'_sets]; exact set.monotone_prod monotone_id monotone_id
rw [prod_same_eq, mem_lift'_sets]
exact set.monotone_prod monotone_id monotone_id
intros
simp only [le_antisymm_iff, h.iterate_pos_le_iff_map_le hf hg hn, h.symm.iterate_pos_le_iff_map_le' hg hf hn]
intros
obtain ‚ü®c, hc, hbc‚ü© : ‚àÉ (c : Œ≤) (hc : c ‚àà {c : Œ≤ | ‚àÄ·∂† (n : Œ±) in f, c ‚â§ u n}), b < c := exists_lt_of_lt_cSup hu h
exact hc.mono (Œª x hx, lt_of_lt_of_le hbc hx)
intros
classical
let bad : set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨ r (f m) (f n) }
by_cases hbad : infinite bad
haveI := hbad
{ haveI := hbad, refine ‚ü®nat.order_embedding_of_set bad, or.intro_right _ (Œª m n mn, _)‚ü©, have h := set.mem_range_self m, rw nat.order_embedding_of_set_range bad at h, exact h _ ((order_embedding.lt_iff_lt _).2 mn) }
refine ‚ü®nat.order_embedding_of_set bad, or.intro_right _ (Œª m n mn, _)‚ü©
have h := set.mem_range_self m
rw nat.order_embedding_of_set_range bad at h
exact h _ ((order_embedding.lt_iff_lt _).2 mn)
rw [set.infinite_coe_iff, set.infinite, not_not] at hbad
{ rw [set.infinite_coe_iff, set.infinite, not_not] at hbad, obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨ n ‚àà bad, { by_cases he : hbad.to_finset.nonempty, { refine ‚ü®(hbad.to_finset.max' he).succ, Œª n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))‚ü© }, { exact ‚ü®0, Œª n hn nbad, he ‚ü®n, hbad.mem_to_finset.2 nbad‚ü©‚ü© } }, have h : ‚àÄ (n : ‚Ñï), ‚àÉ (n' : ‚Ñï), n < n' ‚àß r (f (n + m)) (f (n' + m)), { intro n, have h := hm _ (le_add_of_nonneg_left n.zero_le), simp only [exists_prop, not_not, set.mem_set_of_eq, not_forall] at h, obtain ‚ü®n', hn1, hn2‚ü© := h, obtain ‚ü®x, hpos, rfl‚ü© := exists_pos_add_of_lt hn1, refine ‚ü®n + x, add_lt_add_left hpos n, _‚ü©, rw [add_assoc, add_comm x m, ‚Üê add_assoc], exact hn2 }, let g' : ‚Ñï ‚Üí ‚Ñï := @nat.rec (Œª _, ‚Ñï) m (Œª n gn, nat.find (h gn)), exact ‚ü®(rel_embedding.nat_lt (Œª n, g' n + m) (Œª n, nat.add_lt_add_right (nat.find_spec (h (g' n))).1 m)).order_embedding_of_lt_embedding, or.intro_left _ (Œª n, (nat.find_spec (h (g' n))).2)‚ü© }
obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨ n ‚àà bad
by_cases he : hbad.to_finset.nonempty
{ by_cases he : hbad.to_finset.nonempty, { refine ‚ü®(hbad.to_finset.max' he).succ, Œª n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))‚ü© }, { exact ‚ü®0, Œª n hn nbad, he ‚ü®n, hbad.mem_to_finset.2 nbad‚ü©‚ü© } }
refine ‚ü®(hbad.to_finset.max' he).succ, Œª n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))‚ü©
{ refine ‚ü®(hbad.to_finset.max' he).succ, Œª n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))‚ü© }
{ exact ‚ü®0, Œª n hn nbad, he ‚ü®n, hbad.mem_to_finset.2 nbad‚ü©‚ü© }
exact ‚ü®0, Œª n hn nbad, he ‚ü®n, hbad.mem_to_finset.2 nbad‚ü©‚ü©
have h : ‚àÄ (n : ‚Ñï), ‚àÉ (n' : ‚Ñï), n < n' ‚àß r (f (n + m)) (f (n' + m))
intro n
{ intro n, have h := hm _ (le_add_of_nonneg_left n.zero_le), simp only [exists_prop, not_not, set.mem_set_of_eq, not_forall] at h, obtain ‚ü®n', hn1, hn2‚ü© := h, obtain ‚ü®x, hpos, rfl‚ü© := exists_pos_add_of_lt hn1, refine ‚ü®n + x, add_lt_add_left hpos n, _‚ü©, rw [add_assoc, add_comm x m, ‚Üê add_assoc], exact hn2 }
have h := hm _ (le_add_of_nonneg_left n.zero_le)
simp only [exists_prop, not_not, set.mem_set_of_eq, not_forall] at h
obtain ‚ü®n', hn1, hn2‚ü© := h
obtain ‚ü®x, hpos, rfl‚ü© := exists_pos_add_of_lt hn1
refine ‚ü®n + x, add_lt_add_left hpos n, _‚ü©
rw [add_assoc, add_comm x m, ‚Üê add_assoc]
exact hn2
let g' : ‚Ñï ‚Üí ‚Ñï := @nat.rec (Œª _, ‚Ñï) m (Œª n gn, nat.find (h gn))
exact ‚ü®(rel_embedding.nat_lt (Œª n, g' n + m) (Œª n, nat.add_lt_add_right (nat.find_spec (h (g' n))).1 m)).order_embedding_of_lt_embedding, or.intro_left _ (Œª n, (nat.find_spec (h (g' n))).2)‚ü©
intros
rw is_prime_iff
use ‚Äπ_‚Ä∫
apply is_pfilter.of_def
{ exact set.nonempty_compl.2 (I.is_proper_iff.1 ‚Äπ_‚Ä∫) }
exact set.nonempty_compl.2 (I.is_proper_iff.1 ‚Äπ_‚Ä∫)
intros x _ y _
{ intros x _ y _, refine ‚ü®x ‚äì y, _, inf_le_left, inf_le_right‚ü©, have := mt hI, tauto! }
refine ‚ü®x ‚äì y, _, inf_le_left, inf_le_right‚ü©
have := mt hI
tauto!
{ exact @mem_compl_of_ge _ _ _ }
exact @mem_compl_of_ge _ _ _
intros
refine Œª y, (hg' _).unique _
rw [‚Üê fa.surjective.image_preimage {x | g x ‚â§ fb y}, preimage_set_of_eq]
simp only [h.eq, fb.le_iff_le, fa.left_ord_continuous (hg' _)]
intros
split
intro h'
{ intro h', have : ¬¨r x y, { intro hy, rw [well_founded.succ, dif_pos] at h', exact wo.wf.not_lt_min _ h hy h' }, rcases trichotomous_of r x y with hy | hy | hy, exfalso, exact this hy, right, exact hy.symm, left, exact hy }
have : ¬¨r x y
intro hy
{ intro hy, rw [well_founded.succ, dif_pos] at h', exact wo.wf.not_lt_min _ h hy h' }
rw [well_founded.succ, dif_pos] at h'
exact wo.wf.not_lt_min _ h hy h'
rcases trichotomous_of r x y with hy | hy | hy
exfalso
exact this hy
right
exact hy.symm
left
exact hy
rintro (hy | rfl)
exact trans hy (wo.wf.lt_succ h)
exact wo.wf.lt_succ h
intros
let Q : s ‚Üí Prop := Œª y, P y
change Q ‚ü®x, hx‚ü©
refine well_founded.induction hs ‚ü®x, hx‚ü© _
rintros ‚ü®y, ys‚ü© ih
exact hP _ ys (Œª z zs zy, ih ‚ü®z, zs‚ü© zy)
intros
rw [equivariant_projection, smul_apply, sum_of_conjugates_equivariant, equivariant_of_linear_of_comm_apply, sum_of_conjugates]
rw [linear_map.sum_apply]
simp only [conjugate_i œÄ i h]
rw [finset.sum_const, finset.card_univ, nsmul_eq_smul_cast k, ‚Üêmul_smul, invertible.inv_of_mul_self, one_smul]
intros
rw [is_artinian_iff_well_founded, well_founded.well_founded_iff_has_min']
intros
{ rw mul_comm at h, exact h.of_add_mul_left_left }
rw mul_comm at h
exact h.of_add_mul_left_left
intros
rcases hI with ‚ü®I, rfl‚ü©
rcases exist_integer_multiples_of_finset S I with ‚ü®‚ü®s, hs1‚ü©, hs‚ü©
rw is_fractional_span_iff
exact ‚ü®s, hs1, hs‚ü©
intros
apply set.subset.trans (Œª x hx, _) support_add_antidiagonal_subset_add
{ exact x.is_pwo_support }
exact x.is_pwo_support
{ exact y.is_pwo_support }
exact y.is_pwo_support
contrapose! hx
simp only [not_nonempty_iff_eq_empty, ne.def, set.mem_set_of_eq] at hx
simp [hx]
intros
rw [mul_comm, span_singleton_mul_right_unit h2]
intros
{ rw [map_eq_bot_iff_le_ker, mk_ker], exact h }
rw [map_eq_bot_iff_le_ker, mk_ker]
exact h
intros
simp only [span_singleton_mul_le_iff, mem_span_singleton_mul, eq_comm]
intros
rw int.coe_nat_dvd_left
exact int.prime.dvd_pow hp h
intros
split
contrapose!
{ contrapose!, intro h, rw [power_series.ext_iff, not_forall], refine ‚ü®0, _‚ü©, simp [coeff_order_ne_zero h] }
intro h
rw [power_series.ext_iff, not_forall]
refine ‚ü®0, _‚ü©
simp [coeff_order_ne_zero h]
rintro rfl
{ rintro rfl, simp }
simp
intros
split
split; rintros ‚ü®n, hn‚ü©; use n; simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ‚ä¢ hn; exact hn
split; rintros ‚ü®n, hn‚ü©; use n; simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ‚ä¢ hn
split; rintros ‚ü®n, hn‚ü©; use n
split; rintros ‚ü®n, hn‚ü©
rintros ‚ü®n, hn‚ü©
use n
simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ‚ä¢ hn
exact hn
exact hn
rintros ‚ü®n, hn‚ü©
use n
simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ‚ä¢ hn
exact hn
exact hn
intros
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R); exact is_noetherian_ring_iff.2 (ring.is_noetherian_of_fintype R R)
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R)
haveI := subsingleton_of_zero_eq_one h01
haveI := fintype.of_subsingleton (0:R)
exact is_noetherian_ring_iff.2 (ring.is_noetherian_of_fintype R R)
intros
rw [‚Üê C_0, content_C, normalize_zero]
intros
rw total_degree
apply le_antisymm
apply finset.sup_le
{ apply finset.sup_le, intros d hd, rw mem_support_iff at hd, rw [finsupp.sum, hœÜ hd], }
intros d hd
rw mem_support_iff at hd
rw [finsupp.sum, hœÜ hd]
obtain ‚ü®d, hd‚ü© : ‚àÉ d, coeff d œÜ ‚â† 0 := exists_coeff_ne_zero h
{ obtain ‚ü®d, hd‚ü© : ‚àÉ d, coeff d œÜ ‚â† 0 := exists_coeff_ne_zero h, simp only [‚Üê hœÜ hd, finsupp.sum], replace hd := finsupp.mem_support_iff.mpr hd, exact finset.le_sup hd, }
simp only [‚Üê hœÜ hd, finsupp.sum]
replace hd := finsupp.mem_support_iff.mpr hd
exact finset.le_sup hd
intros
dsimp only [minpoly_gen, map_dim]
{ dsimp only [minpoly_gen, map_dim], simp only [linear_equiv.trans_apply, map_basis, basis.map_repr, map_gen, alg_equiv.to_linear_equiv_apply, e.to_linear_equiv_symm, alg_equiv.map_pow, alg_equiv.symm_apply_apply, sub_right_inj] }
simp only [linear_equiv.trans_apply, map_basis, basis.map_repr, map_gen, alg_equiv.to_linear_equiv_apply, e.to_linear_equiv_symm, alg_equiv.map_pow, alg_equiv.symm_apply_apply, sub_right_inj]
intros
simp only [coeff_X, single_left_inj one_ne_zero]
{ simp only [coeff_X, single_left_inj one_ne_zero], split_ifs; refl }
intros
rw [‚Üê mv_power_series.eq_mul_inv_iff_mul_eq h, one_mul]
intros
simp only [coeff, finsupp.single_add]
convert œÜ.coeff_add_mul_monomial (single () n) (single () 1) _
rw mul_one
intros
change ‚Üë(‚Üë(Œ∂ ^ m) : units R) = ‚Üë(Œ∂ : units R) ^ m
rw [subgroup.coe_pow, units.coe_pow]
intros
obtain ‚ü®Œ∂, hŒ∂‚ü© := h.is_unit n.pos
rw [‚Üê hŒ∂, is_primitive_root.coe_units_iff] at h
exact h.card_roots_of_unity'
intros
simpa only [range_eq_map] using (‚ä§ : subring R).map_map g f
intros
cases n
simp only [is_unit_one, int.coe_nat_zero, int.coe_nat_succ, zero_add, pow_zero, C_1, is_unit.dvd]
{ simp only [is_unit_one, int.coe_nat_zero, int.coe_nat_succ, zero_add, pow_zero, C_1, is_unit.dvd] }
have key := bind‚ÇÅ_rename_expand_witt_polynomial Œ¶ n IH
apply_fun (map (int.cast_ring_hom (zmod (p ^ (n + 1))))) at key
conv_lhs at key { simp only [map_bind‚ÇÅ, map_rename, map_expand, map_witt_polynomial] }
rw [nat.succ_eq_add_one, C_dvd_iff_zmod, ring_hom.map_sub, sub_eq_zero, map_bind‚ÇÅ]
simp only [map_rename, map_witt_polynomial, witt_polynomial_zmod_self]
rw key
clear key IH
rw [bind‚ÇÅ, aeval_witt_polynomial, ring_hom.map_sum, ring_hom.map_sum, finset.sum_congr rfl]
intros k hk
rw [finset.mem_range, nat.lt_succ_iff] at hk
simp only [‚Üê sub_eq_zero, ‚Üê ring_hom.map_sub, ‚Üê C_dvd_iff_zmod, C_eq_coe_nat, ‚Üê mul_sub, ‚Üê int.nat_cast_eq_coe_nat, ‚Üê nat.cast_pow]
rw show p ^ (n + 1) = p ^ k * p ^ (n - k + 1), { rw [‚Üê pow_add, ‚Üêadd_assoc], congr' 2, rw [add_comm, ‚Üênat.sub_eq_iff_eq_add hk] }
rw [nat.cast_mul, nat.cast_pow, nat.cast_pow]
apply mul_dvd_mul_left
rw show p ^ (n + 1 - k) = p * p ^ (n - k), { rw [‚Üê pow_succ, nat.sub_add_comm hk] }
rw [pow_mul]
apply dvd_sub_pow_of_dvd_sub
rw [‚Üê C_eq_coe_nat, int.nat_cast_eq_coe_nat, C_dvd_iff_zmod, ring_hom.map_sub, sub_eq_zero, map_expand, ring_hom.map_pow, mv_polynomial.expand_zmod]
intros
obtain ‚ü®y, rfl‚ü© := witt_vector.truncate_surjective p _ _ x
simp only [truncate_witt_vector_truncate, witt_vector.coeff_truncate, fin.coe_cast_le]
intros
rw [to_nat_apply_of_omega_le h, nat.cast_zero]
intros
intro h
have t := state.left_bound m
rw h at t
exact nat.not_succ_le_zero _ t
intros
rw [‚Üê@not_lt _ _ o' o, enum_lt ho']
intros
rw div_def a h; exact omin_mem {o | a < b * succ o} _
rw div_def a h
exact omin_mem {o | a < b * succ o} _
intros
simp [termg]
intros
simp
intros
convert ‚Üê normalize_fin_lt.cast h
intros
suffices : ‚áë(homothety x t) = Œª y, t ‚Ä¢ (y - x) + x
rw this
{ rw this, continuity, }
continuity
ext y
simp [homothety_apply]
intros
simpa only [div_eq_mul_inv] using hf.mul continuous_on_const
intros
rw has_sum_subtype_iff_indicator at *
rw set.indicator_union_of_disjoint hs
exact ha.add hb
intros
simp only [div_eq_mul_inv, h.mul_right b‚Åª¬π]
intros
convert is_closed_closure
intros
simpa [(‚àò)] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)
intros
obtain ‚ü®x, h, hfg, hgf‚ü© : (univ ‚à© {x | f x ‚â§ g x ‚àß g x ‚â§ f x}).nonempty
from is_preconnected_closed_iff.1 preconnected_space.is_preconnected_univ _ _ (is_closed_le hf hg) (is_closed_le hg hf) (Œª x hx, le_total _ _) ‚ü®a, trivial, ha‚ü© ‚ü®b, trivial, hb‚ü©
exact ‚ü®x, le_antisymm hfg hgf‚ü©
intros
rw [nhds_order_unbounded hu hl]; from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl, tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)
rw [nhds_order_unbounded hu hl]
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl, tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)
intros
refine is_topological_basis_of_open_of_nhds _ _
rintros _ ‚ü®V, hV, rfl‚ü©
{ rintros _ ‚ü®V, hV, rfl‚ü©, rwa hf.is_open_iff, refine ‚ü®V, h.is_open hV, rfl‚ü© }
rwa hf.is_open_iff
refine ‚ü®V, h.is_open hV, rfl‚ü©
intros a U ha hU
{ intros a U ha hU, rw hf.is_open_iff at hU, obtain ‚ü®V, hV, rfl‚ü© := hU, obtain ‚ü®S, hS, rfl‚ü© := h.open_eq_sUnion hV, obtain ‚ü®W, hW, ha‚ü© := ha, refine ‚ü®f ‚Åª¬π' W, ‚ü®_, hS hW, rfl‚ü©, ha, set.preimage_mono $ set.subset_sUnion_of_mem hW‚ü© }
rw hf.is_open_iff at hU
obtain ‚ü®V, hV, rfl‚ü© := hU
obtain ‚ü®S, hS, rfl‚ü© := h.open_eq_sUnion hV
obtain ‚ü®W, hW, ha‚ü© := ha
refine ‚ü®f ‚Åª¬π' W, ‚ü®_, hS hW, rfl‚ü©, ha, set.preimage_mono $ set.subset_sUnion_of_mem hW‚ü©
intros
simp only [maps_to, mem_closure_iff_cluster_pt]
exact Œª x hx, hx.map hc.continuous_at (tendsto_principal_principal.2 h)
intros
simp [frontier]
intros
rw [filter.frequently, filter.eventually, ‚Üê mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl]
rw [filter.frequently, filter.eventually, ‚Üê mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl]; refl
refl
intros
{ rw is_clopen_iff at h', finish [h.ne_empty] }
rw is_clopen_iff at h'
finish [h.ne_empty]
intros
rw [nhds_prod_eq, prod_mem_prod_iff]
intros
{ simp only [div_eq_mul_inv], refl, }
simp only [div_eq_mul_inv]
refl
intros
have c : continuous (Œª x, dist (f x) (g x))
continuity
{ continuity, }
obtain ‚ü®x, -, le‚ü© := is_compact.exists_forall_ge compact_univ set.univ_nonempty (continuous.continuous_on c)
exact lt_of_le_of_lt (dist_le_iff_of_nonempty.mpr (Œª y, le y trivial)) (w x)
intros
{ rw algebra.algebra_map_eq_smul_one, refl, }
rw algebra.algebra_map_eq_smul_one
refl
intros
rw subalgebra_topological_closure_eq_top_of_separates_points A w
simp
intros
rw [‚Üê nhds_within_singleton, ‚Üê nhds_within_union, compl_union_self, nhds_within_univ]
intros
simp only [‚Üê singleton_union, continuous_within_at_union, continuous_within_at_singleton, true_and]
intros
refine id (Œª z H, id (Œª U h, preimage_nhds_within_coinduced' H (a.pretrivialization_at x).open_target (le_def.1 (nhds_mono _) U h)))
exact le_supr _ x
intros
cases F
cases G
congr' 1
ext x
exact h x
intros
refine ‚ü®has_sum.tendsto_sum_nat, assume h, _‚ü©
rw [‚Üê supr_eq_of_tendsto _ h, ‚Üê ennreal.tsum_eq_supr_nat]
{ exact ennreal.summable.has_sum }
exact ennreal.summable.has_sum
exact assume s t hst, finset.sum_le_sum_of_subset (finset.range_subset.2 hst)
{ exact assume s t hst, finset.sum_le_sum_of_subset (finset.range_subset.2 hst) }
intros
rw [‚Üênnreal.coe_eq, coe_tsum, nnreal.coe_add, coe_sum, coe_tsum, sum_add_tsum_nat_add k (nnreal.summable_coe.2 hf)]
intros
refine local_homeomorph.ext _ _ (Œªx, rfl) (Œªx, rfl) _
simp [e.open_source.interior_eq, ‚Üê inter_assoc]
intros
rw (is_locally_constant.tfae f).out 0 3
intros a
have : f ‚Åª¬π' {a} = (g ‚àò f) ‚Åª¬π' { g a }
ext x
{ ext x, simp only [mem_singleton_iff, function.comp_app, mem_preimage], exact ‚ü®Œª h, by rw h, Œª h, inj h‚ü© }
simp only [mem_singleton_iff, function.comp_app, mem_preimage]
exact ‚ü®Œª h, by rw h, Œª h, inj h‚ü©
rw this
apply h
intros
rw [‚Üê nhds_comap_dist a, tendsto_comap_iff]
intros
simp only [diam, emetric.diam_subsingleton hs, ennreal.zero_to_real]
intros
funext x y; exact dist_comm _ _
funext x y
exact dist_comm _ _
intros
rw [‚Üê tendsto_uniformly_on_univ, tendsto_uniformly_on_iff]
{ rw [‚Üê tendsto_uniformly_on_univ, tendsto_uniformly_on_iff], simp }
simp
intros
rw [GH_dist, p.to_GH_space_rep, q.to_GH_space_rep]
intros
{ rw dimH_def, exact le_bsupr d h }
rw dimH_def
exact le_bsupr d h
intros
simp [Hausdorff_dist, Hausdorff_edist_comm]
intros
rw [‚Üê image_symm, ediam_image]
intros
refine finite.induction_on hI (by simp) (Œª i I hi _ hI, _)
rw [bUnion_insert, ball_insert_iff, union_left_iff, hI]
intros
{ rw continuous_def, assume s h, exact ‚ü®_, h, rfl‚ü© }
rw continuous_def
assume s h
exact ‚ü®_, h, rfl‚ü©
intros
refine ((f i).continuous.mul $ continuous_finprod_cond (Œª j _, continuous_const.sub (f j).continuous) _)
simp only [mul_support_one_sub]
exact f.locally_finite
intros
rcases hF with ‚ü®x, x_in, hx‚ü©
use [f x, mem_image_of_mem f x_in]
rintros _ ‚ü®y, y_in, rfl‚ü©
exact ‚ü®(hx y_in).some_path.map hf, Œª t, ‚ü®_, (hx y_in).some_path_mem t, rfl‚ü©‚ü©
intros
simp_rw [‚Üê continuous_within_at_univ, ‚Üê lower_semicontinuous_within_at_univ_iff, ‚Üê upper_semicontinuous_within_at_univ_iff, continuous_within_at_iff_lower_upper_semicontinuous_within_at]
intros
rw [res, limit.lift_œÄ, fan.mk_œÄ_app]
intros
erw [‚Üê F.germ_res iWU ‚ü®x, hxW‚ü©, ‚Üê F.germ_res iWV ‚ü®x, hxW‚ü©, comp_apply, comp_apply, ih]
intros
introsI f hnf hstf
obtain ‚ü®a, hsa, ha‚ü© : ‚àÉ a ‚àà s, cluster_pt a f := hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))
have : a ‚àà t := (ht.mem_of_nhds_within_ne_bot $ ha.mono $ le_trans hstf (le_principal_iff.2 (inter_subset_right _ _)))
exact ‚ü®a, ‚ü®hsa, this‚ü©, ha‚ü©
intros
rw sUnion_eq_Union at hc‚ÇÇ; simpa using lebesgue_number_lemma hs (by simpa) hc‚ÇÇ
rw sUnion_eq_Union at hc‚ÇÇ
simpa using lebesgue_number_lemma hs (by simpa) hc‚ÇÇ
intros
{ rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right], refl }
rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]
refl
intros
rw ‚Üê continuous_within_at_univ at h
rw ‚Üê nhds_within_univ at hunif hg
exact tendsto_comp_of_locally_uniform_limit_within h hg hunif
intros
split
split; rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©; split; linarith
split; rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©; split
split; rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
split
linarith
linarith
rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
split
linarith
linarith
intros
rw [‚Üê stream.eta (map f s), tail_map, head_map]
intros
cases b; simp
cases b
simp
simp
intros
rw [h, int.neg_neg]
intros
have h := int.add_lt_add_left h (-a)
rwa int.neg_add_cancel_left at h
intros
rw [qsort, well_founded.fix_eq, qsort.F]
intros
rw [mod_eq_sub_mod (nat.le_add_left _ _), nat.add_sub_cancel]
intros
revert x
apply nat.strong_induction_on y _
clear y
intros y IH x
cases lt_or_le y k with h h
rw [div_eq_of_lt h]
{ rw [div_eq_of_lt h], cases x with x, { simp [nat.zero_mul, y.zero_le] }, { simp [succ_mul, not_succ_le_zero, nat.add_comm], apply lt_of_lt_of_le h, apply nat.le_add_right } }
cases x with x
{ simp [nat.zero_mul, y.zero_le] }
simp [nat.zero_mul, y.zero_le]
simp [succ_mul, not_succ_le_zero, nat.add_comm]
{ simp [succ_mul, not_succ_le_zero, nat.add_comm], apply lt_of_lt_of_le h, apply nat.le_add_right }
apply lt_of_lt_of_le h
apply nat.le_add_right
rw [div_eq_sub_div Hk h]
{ rw [div_eq_sub_div Hk h], cases x with x, { simp [nat.zero_mul, nat.zero_le] }, { have Hlt : y - k < y, { apply nat.sub_lt_of_pos_le ; assumption }, rw [ ‚Üê add_one , nat.add_le_add_iff_le_right , IH (y - k) Hlt x , add_one , succ_mul, nat.add_le_to_le_sub _ h ] } }
cases x with x
{ simp [nat.zero_mul, nat.zero_le] }
simp [nat.zero_mul, nat.zero_le]
have Hlt : y - k < y
{ have Hlt : y - k < y, { apply nat.sub_lt_of_pos_le ; assumption }, rw [ ‚Üê add_one , nat.add_le_add_iff_le_right , IH (y - k) Hlt x , add_one , succ_mul, nat.add_le_to_le_sub _ h ] }
apply nat.sub_lt_of_pos_le ; assumption
{ apply nat.sub_lt_of_pos_le ; assumption }
apply nat.sub_lt_of_pos_le
assumption
assumption
rw [ ‚Üê add_one , nat.add_le_add_iff_le_right , IH (y - k) Hlt x , add_one , succ_mul, nat.add_le_to_le_sub _ h ]
intros
cases it; cases it_snd; simp [iterator.next, iterator.next_to_string, string.length, nat.add_sub_cancel_left]
cases it; cases it_snd
cases it
cases it_snd
simp [iterator.next, iterator.next_to_string, string.length, nat.add_sub_cancel_left]
simp [iterator.next, iterator.next_to_string, string.length, nat.add_sub_cancel_left]
intros
refine neg_eq_of_add_eq_zero (vadd_right_cancel p1 _)
rw [vsub_add_vsub_cancel, vsub_self]
intros
rw [‚Üê nat.nsmul_eq_mul, ‚Üê sum_const]
apply sum_congr rfl h‚ÇÅ
intros
simp only [mul_comm, prod_range_succ_comm]
intros
rw [finprod_eq_prod_plift_of_mul_support_subset h.coe_to_finset.ge, finprod_eq_prod_plift_of_mul_support_subset, f.map_prod]
rw [h.coe_to_finset]
exact mul_support_comp_subset f.map_one (g ‚àò plift.down)
intros
rw [finprod_mem_insert, finprod_mem_singleton]
{ rw [finprod_mem_insert, finprod_mem_singleton], exacts [h, finite_singleton b] }
exacts [h, finite_singleton b]
intros
simpa only [sub_eq_add_neg] using sum_Ico_eq_add_neg f h
intros
ext k
rw [‚Üê finset.univ_sum_single k, g.map_sum, h.map_sum]
simp only [w]
intros
ext
simp [kernel_iso_ker]
intros
{ rw ‚Üêcocone_naturality F f, refl }
rw ‚Üêcocone_naturality F f
refl
intros
{ rw [eq_comm], exact bit1_eq_one }
rw [eq_comm]
exact bit1_eq_one
intros
simp [zeroth_s_eq, continuants_aux, next_continuants, next_denominator, next_numerator]
intros
rw [sub_eq_add_neg, ‚Üê neg_div, div_add_div_same, sub_eq_add_neg]
intros
{ ext, simp [floor_lt] }
ext
simp [floor_lt]
intros
simp [star, has_star.star]
intros
simp only [mul_comm, lcm_mul_left]
intros
simpa only [div_eq_mul_inv] using Œª a a' h, inv_injective (mul_right_injective b h)
intros
rw [semiconj_by, mul_one, one_mul]
intros
simp only [divp, mul_inv_rev, units.coe_mul, mul_assoc]
intros
rw [pow_bit0', neg_mul_neg, pow_bit0']
intros
rcases nat.exists_eq_succ_of_ne_zero hn with ‚ü®k, rfl‚ü©
induction k with k ih
simp only [pow_one]
{ simp only [pow_one] }
let n := k.succ
have h1 := add_nonneg (mul_nonneg hx (pow_nonneg hy n)) (mul_nonneg hy (pow_nonneg hx n))
have h2 := add_nonneg hx hy
calc x^n.succ + y^n.succ ‚â§ x*x^n + y*y^n + (x*y^n + y*x^n) : by { rw [pow_succ _ n, pow_succ _ n], exact le_add_of_nonneg_right h1 } ... = (x+y) * (x^n + y^n) : by rw [add_mul, mul_add, mul_add, add_comm (y*x^n), ‚Üê add_assoc, ‚Üê add_assoc, add_assoc (x*x^n) (x*y^n), add_comm (x*y^n) (y*y^n), ‚Üê add_assoc] ... ‚â§ (x+y)^n.succ : by { rw [pow_succ _ n], exact mul_le_mul_of_nonneg_left (ih (nat.succ_ne_zero k)) h2 }
intros
assume h
rcases exists_pair_ne M‚ÇÄ with ‚ü®x, y, hx‚ü©
apply hx
calc x = 1 * x : by rw [one_mul] ... = 0 : by rw [‚Üê h, zero_mul] ... = 1 * y : by rw [‚Üê h, zero_mul] ... = y : by rw [one_mul]
intros
simp only [semiconj_by, mul_zero, zero_mul]
intros
{ ext, simp, }
ext
simp
intros
cases i
dsimp [prev_d]
{ dsimp [prev_d], rcases (complex_shape.up ‚Ñï).prev 0 with _|‚ü®j,hj‚ü©; dsimp [prev_d], { rw [D.shape, comp_zero], dsimp, dec_trivial }, { dsimp at hj, exact (nat.succ_ne_zero _ hj).elim } }
rcases (complex_shape.up ‚Ñï).prev 0 with _|‚ü®j,hj‚ü©; dsimp [prev_d]
rcases (complex_shape.up ‚Ñï).prev 0 with _|‚ü®j,hj‚ü©
dsimp [prev_d]
{ rw [D.shape, comp_zero], dsimp, dec_trivial }
rw [D.shape, comp_zero]
dsimp
dec_trivial
dsimp [prev_d]
{ dsimp at hj, exact (nat.succ_ne_zero _ hj).elim }
dsimp at hj
exact (nat.succ_ne_zero _ hj).elim
rw prev_d_eq
dsimp
refl
intros
{ ext, simp, }
ext
simp
intros
intro x
simp_rw indicator_apply
split_ifs
{ exact le_rfl, }
exact le_rfl
{ exact (not_le.mp h_1).le, }
exact (not_le.mp h_1).le
{ exact h_1, }
exact h_1
{ exact le_rfl, }
exact le_rfl
intros
rw le_antisymm_iff
split
{ simp, }
simp
rw [‚Üê mul_le_mul_iff_left c‚Åª¬π, ‚Üê mul_assoc, inv_mul_self, one_mul, le_inf_iff]
{ rw [‚Üê mul_le_mul_iff_left c‚Åª¬π, ‚Üê mul_assoc, inv_mul_self, one_mul, le_inf_iff], simp, }
simp
intros
simp only [sub_add_cancel, map_lie, lie_hom.lie_apply]
intros
simp [PB, JB, JD_transform, matrix.from_blocks_transpose, matrix.from_blocks_multiply, matrix.from_blocks_smul]
intros
conv_rhs { rw ‚Üê I‚ÇÅ.incl_ideal_range, }
{ conv_rhs { rw ‚Üê I‚ÇÅ.incl_ideal_range, }, rw ‚Üê map_comap_eq, exact I‚ÇÅ.incl_is_ideal_morphism, }
rw ‚Üê map_comap_eq
exact I‚ÇÅ.incl_is_ideal_morphism
intros
induction k with k ih
change (‚ä§ : lie_ideal R L').map f = ‚ä§
{ change (‚ä§ : lie_ideal R L').map f = ‚ä§, rw ‚Üêf.ideal_range_eq_map, exact f.ideal_range_eq_top_of_surjective h, }
rw ‚Üêf.ideal_range_eq_map
exact f.ideal_range_eq_top_of_surjective h
simp only [derived_series_def, map_bracket_eq f h, ih, derived_series_of_ideal_succ]
{ simp only [derived_series_def, map_bracket_eq f h, ih, derived_series_of_ideal_succ], }
intros
let œÜ : (P ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := finsupp.total _ _ _ (Œª p, function.surj_inv hf (g p))
cases h.out with s hs
use œÜ.comp s
ext p
conv_rhs {rw ‚Üê hs p}
simp [œÜ, finsupp.total_apply, function.surj_inv_eq hf]
intros
simpa using abv_add abv (a - b) b
intros
{ rw [inv_eq_one_div], exact div_le_iff ha }
rw [inv_eq_one_div]
exact div_le_iff ha
intros
rw [div_le_iff hb, one_mul]
intros
simp only [le_iff_eq_or_lt, inv_pos, zero_eq_inv]
intros
rw [abs_le', and.comm, neg_le]
intros
{ ext x, refl }
ext x
refl
intros
simp [abs_eq_max_neg]
intros
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®lt_imp_lt_of_le_imp_le $ Œª h', decidable.mul_le_mul_of_nonneg_right h' h.le, Œª h', mul_lt_mul_of_pos_right h' h‚ü©
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®lt_imp_lt_of_le_imp_le $ Œª h', decidable.mul_le_mul_of_nonneg_right h' h.le, Œª h', mul_lt_mul_of_pos_right h' h‚ü©
intros
simpa using coeff_zero_multiset_prod (s.1.map f)
intros
assume h'
rw [quadratic_eq_zero_iff_discrim_eq_sq h2 ha, sq] at h'
exact h _ h'
intros
rw [add_comm, self_add_conj']
intros
rw inv_eq_iff_mul_eq_one
{ rw inv_eq_iff_mul_eq_one, simp only [units.ext_iff], push_cast, exact mul_self_eq_one_iff }
simp only [units.ext_iff]
push_cast
exact mul_self_eq_one_iff
intros
simp only [sub_eq_add_neg, h.add_left]
intros
simp only [‚Üê mul_support_prod_mk, prod.mk.eta]
intros
simp [trop_eq_iff_eq_untrop]
intros
rw [mul_comm, const_mul_cancel]
intros
rcases hf with ‚ü®r, hf‚ü©
rcases ennreal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ‚ü®r', r'0, h‚ü©
obtain ‚ü®a, ha, C, hC, hp‚ü© : ‚àÉ (a ‚àà Ioo (0 : ‚Ñù) 1) (C > 0), (‚àÄ y ‚àà metric.ball (0 : E) r', ‚àÄ n, ‚à•f (x + y) - p.partial_sum n y‚à• ‚â§ C * (a * (‚à•y‚à• / r')) ^ n)
from hf.uniform_geometric_approx' h
refine is_O_iff.2 ‚ü®C * (a / r') ^ n, _‚ü©
replace r'0 : 0 < (r' : ‚Ñù)
exact_mod_cast r'0
exact_mod_cast r'0
filter_upwards [metric.ball_mem_nhds (0 : E) r'0]
intros y hy
simpa [mul_pow, mul_div_assoc, mul_assoc, div_mul_eq_mul_div] using hp y hy n
intros
simp [apply_composition]
intros
cases n
exact hn.false.elim
clear hn
induction n with n ihn
simpa only [pow_one]
{ simpa only [pow_one] }
convert h.mul ihn; simp [pow_succ]
convert h.mul ihn
simp [pow_succ]
simp [pow_succ]
intros
rw [‚Üê nat.cofinite_eq_at_top, is_O_cofinite_iff h]
intros
refine (h‚ÇÅ.trans_le $ Œª x, _).add (h‚ÇÇ.trans_le _)
refine (h‚ÇÅ.trans_le $ Œª x, _).add (h‚ÇÇ.trans_le _); simp [real.norm_eq_abs, abs_of_nonneg, add_nonneg]
simp [real.norm_eq_abs, abs_of_nonneg, add_nonneg]
simp [real.norm_eq_abs, abs_of_nonneg, add_nonneg]
intros
rcases hf with ‚ü®f', hf‚ÇÅ, cf‚ü©
rcases hg with ‚ü®g', hg‚ÇÅ, cg‚ü©
exact ‚ü®g'.comp f', hg‚ÇÅ.comp x hf‚ÇÅ, cg.comp cf‚ü©
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
rw [‚Üê has_fderiv_within_at_univ, ‚Üê has_fderiv_within_at_univ, iso.comp_has_fderiv_within_at_iff']
intros
{ simp [differentiable_on, differentiable_within_at_univ], refl }
simp [differentiable_on, differentiable_within_at_univ]
refl
intros
assume x hx
rw [D, mem_Inter]
assume e
have : (0 : ‚Ñù) < (1/2) ^ e := pow_pos (by norm_num) _
rcases mem_A_of_differentiable this hx.1 with ‚ü®R, R_pos, hR‚ü©
obtain ‚ü®n, hn‚ü© : ‚àÉ (n : ‚Ñï), (1/2) ^ n < R := exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : ‚Ñù)/2 < 1)
simp only [mem_Union, mem_Inter, B, mem_inter_eq]
refine ‚ü®n, Œª p hp q hq, ‚ü®fderiv ùïú f x, hx.2, ‚ü®_, _‚ü©‚ü©‚ü©
refine ‚ü®n, Œª p hp q hq, ‚ü®fderiv ùïú f x, hx.2, ‚ü®_, _‚ü©‚ü©‚ü©; { refine hR _ ‚ü®pow_pos (by norm_num) _, lt_of_le_of_lt _ hn‚ü©, exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
{ refine hR _ ‚ü®pow_pos (by norm_num) _, lt_of_le_of_lt _ hn‚ü©, exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
refine hR _ ‚ü®pow_pos (by norm_num) _, lt_of_le_of_lt _ hn‚ü©
{ refine hR _ ‚ü®pow_pos (by norm_num) _, lt_of_le_of_lt _ hn‚ü©, exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)
intros
simp only [unique_diff_within_at_iff] at *
rw [mem_closure_iff_nhds_within_ne_bot] at h ‚ä¢
exact ‚ü®h.1.mono $ submodule.span_mono $ tangent_cone_mono_nhds st, h.2.mono st‚ü©
intros
rw ‚Üê times_cont_diff_within_at_univ
{ rw ‚Üê times_cont_diff_within_at_univ, simp [times_cont_diff_within_at_zero, nhds_within_univ] }
simp [times_cont_diff_within_at_zero, nhds_within_univ]
intros
refine ‚ü®Œª x hx, _, h.fderiv_within, h.cont‚ü©
rw h‚ÇÅ x hx
exact h.zero_eq x hx
intros
rcases hf 1 hn with ‚ü®u, H, p, hp‚ü©
simp only [nhds_within_univ, mem_univ, insert_eq_of_mem] at H
have := hp.has_strict_fderiv_at le_rfl H
rwa hf'.unique this.has_fderiv_at
intros
induction m with m IH generalizing x
rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp]
{ rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp] }
have A : (m : with_top ‚Ñï) < n := lt_of_lt_of_le (with_top.coe_lt_coe.2 (lt_add_one m)) hmn
{ have A : (m : with_top ‚Ñï) < n := lt_of_lt_of_le (with_top.coe_lt_coe.2 (lt_add_one m)) hmn, have : has_fderiv_within_at (Œª (y : E), iterated_fderiv_within ùïú m f s y) (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x := (h.fderiv_within m A x hx).congr (Œª y hy, (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm, rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply, this.fderiv_within (hs x hx)], exact (continuous_multilinear_map.uncurry_curry_left _).symm }
have : has_fderiv_within_at (Œª (y : E), iterated_fderiv_within ùïú m f s y) (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x := (h.fderiv_within m A x hx).congr (Œª y hy, (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm
rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply, this.fderiv_within (hs x hx)]
exact (continuous_multilinear_map.uncurry_curry_left _).symm
intros
simp only [open_segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc]
intros
rw [center_mass, sum_subset ht h, smul_sum, center_mass, smul_sum]
apply sum_subset ht
assume i hit' hit
rw [h i hit' hit, zero_smul, smul_zero]
intros
simp only [to_cone, convex_cone.mem_mk, mem_Union, mem_smul_set, eq_comm, exists_prop]
intros
refine tsum_le_of_sum_le' _ (Œª s, hv.sum_inner_products_le x)
simp only [norm_nonneg, pow_nonneg]
intros
rw[‚Üêinner_conj_sym, mul_comm]
{ rw[‚Üêinner_conj_sym, mul_comm], exact re_eq_abs_of_mul_conj (inner y x), }
exact re_eq_abs_of_mul_conj (inner y x)
intros
rw [to_euclidean.to_homeomorph.nhds_eq_comap]
exact metric.nhds_basis_closed_ball.comap _
intros
ext
ext; simp [reflection_apply]
simp [reflection_apply]
intros
have h := rpow_arith_mean_le_arith_mean_rpow (univ : finset (fin 2)) (fin.cons w‚ÇÅ $ fin.cons w‚ÇÇ fin_zero_elim) (fin.cons z‚ÇÅ $ fin.cons z‚ÇÇ $ fin_zero_elim) _ hp
simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h
{ simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h, }
simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero]
{ simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero], }
intros
simpa using dist_triangle (v +·µ• p) (v' +·µ• p) (v' +·µ• p')
intros
{ rw [dist_point_reflection_self, real.norm_two] }
rw [dist_point_reflection_self, real.norm_two]
intros
induction n with n ih
simp only [norm_zero, nat.cast_zero, zero_mul, zero_smul]
{ simp only [norm_zero, nat.cast_zero, zero_mul, zero_smul] }
simp only [nat.succ_eq_add_one, add_smul, add_mul, one_mul, nat.cast_add, nat.cast_one, one_nsmul]
exact norm_add_le_of_le ih le_rfl
intros
intros k k_in
rcases h k k_in with ‚ü®g, rfl, hg‚ü©
use [g, rfl]
by_cases Hg : ‚à•f g‚à• = 0
{ simpa [Hg] using hg }
simpa [Hg] using hg
exact hg.trans ((mul_le_mul_right $ (ne.symm Hg).le_iff_lt.mp (norm_nonneg _)).mpr H)
{ exact hg.trans ((mul_le_mul_right $ (ne.symm Hg).le_iff_lt.mp (norm_nonneg _)).mpr H) }
intros
ext
{ ext, rw [comp_apply, comp_apply, ‚Üê sub_eq_zero, ‚Üê normed_group_hom.sub_apply], exact x.2 }
rw [comp_apply, comp_apply, ‚Üê sub_eq_zero, ‚Üê normed_group_hom.sub_apply]
exact x.2
intros
erw quotient_norm_eq_zero_iff
exact subset_closure S.zero_mem
simp [arg, le_refl]
intros
rw integral_deriv_eq_sub'; norm_num [continuous_on_cos]
rw integral_deriv_eq_sub'
norm_num [continuous_on_cos]
norm_num [continuous_on_cos]
norm_num [continuous_on_cos]
intros
nth_rewrite 0 ‚Üêennreal.rpow_one x
exact ennreal.rpow_le_rpow_of_exponent_le hx h_one_le
intros
split_ifs; simp [rpow_def, *]; exact rpow_def_of_neg (lt_of_le_of_ne hx h) _
split_ifs; simp [rpow_def, *]
split_ifs
simp [rpow_def, *]
simp [rpow_def, *]
simp [rpow_def, *]
exact rpow_def_of_neg (lt_of_le_of_ne hx h) _
intros
simp only [div_eq_mul_inv, mul_rpow hx (inv_nonneg.2 hy), inv_rpow hy]
intros
cases hp.lt_or_lt with hneg hpos
exacts [(((times_cont_diff_at_fst.log hneg.ne).mul times_cont_diff_at_snd).exp.mul (times_cont_diff_at_snd.mul times_cont_diff_at_const).cos).congr_of_eventually_eq ((continuous_at_fst.eventually (gt_mem_nhds hneg)).mono (Œª p hp, rpow_def_of_neg hp _)), ((times_cont_diff_at_fst.log hpos.ne').mul times_cont_diff_at_snd).exp.congr_of_eventually_eq ((continuous_at_fst.eventually (lt_mem_nhds hpos)).mono (Œª p hp, rpow_def_of_pos hp _))]
intros
rw [‚Üê not_iff_not, not_exists, ‚Üê ne, tan_ne_zero_iff]
intros
rw [‚Üê not_exists, not_iff_not, sin_eq_zero_iff]
rw [‚Üê cos_pi_div_two_sub, ‚Üê sq_cos_pi_div_six]
congr
ring
intros
refine ‚ü®Œª hc h‚ÇÄ, _, Œª h, (has_deriv_at_tan h).continuous_at‚ü©
exact not_tendsto_nhds_of_tendsto_at_top (tendsto_abs_tan_of_cos_eq_zero h‚ÇÄ) _ (hc.norm.tendsto.mono_left inf_le_left)
intros
refine ‚ü®Œª h, _, Œª h, (has_deriv_within_at_arcsin_Iic h).differentiable_within_at‚ü©
rw [‚Üê neg_neg x, ‚Üê image_neg_Ici] at h
have := (h.comp (-x) differentiable_within_at_id.neg (maps_to_image _ _)).neg
simpa [(‚àò), differentiable_within_at_arcsin_Ici] using this
intros
refine (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _
{ simp }
simp
{ simp [pow_succ, mul_assoc, le_refl] }
simp [pow_succ, mul_assoc, le_refl]
intros
rw [limits.is_image.iso_ext_hom, ‚Üêimages.image_strong_epi_mono_factorisation_to_mono_factorisation_m, is_image.lift_fac, coimages.coimage_strong_epi_mono_factorisation_to_mono_factorisation_m, coimages.coimage.fac]
intros
rw [add_def, sub_comp, neg_def, sub_comp, zero_comp, add_def, neg_def]
intros
simp only [conj_Aut_apply, iso.trans_symm, iso.trans_assoc]
intros
constructor
intros Z g h H
replace H := congr_arg (adj.hom_equiv X Z) H
rwa [adj.hom_equiv_naturality_left, adj.hom_equiv_naturality_left, cancel_epi, equiv.apply_eq_iff_eq] at H
intros
{ dsimp [inv_fun_id_assoc], tidy }
dsimp [inv_fun_id_assoc]
tidy
intros
let sa := max‚ÇÉ k‚ÇÅ l k‚ÇÇ
let sb := coeq (f‚ÇÅ ‚â´ first_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ) (g‚ÇÅ ‚â´ second_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ)
let sc := coeq (f‚ÇÇ ‚â´ first_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ) (f‚ÇÉ ‚â´ third_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ)
let sd := coeq (f‚ÇÑ ‚â´ third_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ) (g‚ÇÇ ‚â´ second_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ)
let se := max‚ÇÉ sb sc sd
let sf := coeq‚ÇÉ (coeq_hom _ _ ‚â´ first_to_max‚ÇÉ sb sc sd) (coeq_hom _ _ ‚â´ second_to_max‚ÇÉ sb sc sd) (coeq_hom _ _ ‚â´ third_to_max‚ÇÉ sb sc sd)
use sf
use first_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ first_to_max‚ÇÉ sb sc sd ‚â´ coeq‚ÇÉ_hom _ _ _
use second_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ second_to_max‚ÇÉ sb sc sd ‚â´ coeq‚ÇÉ_hom _ _ _
use third_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ third_to_max‚ÇÉ sb sc sd ‚â´ coeq‚ÇÉ_hom _ _ _
fsplit
slice_lhs 1 3 { rw [‚Üê category.assoc, coeq_condition] }
slice_lhs 3 6 { rw [‚Üê category.assoc, coeq‚ÇÉ_condition‚ÇÅ] }
simp only [category.assoc]
fsplit
slice_lhs 3 6 { rw [‚Üê category.assoc, coeq‚ÇÉ_condition‚ÇÅ] }
slice_lhs 1 3 { rw [‚Üê category.assoc, coeq_condition] }
slice_rhs 3 6 { rw [‚Üê category.assoc, ‚Üê coeq‚ÇÉ_condition‚ÇÇ] }
simp only [category.assoc]
slice_rhs 3 6 { rw [‚Üê category.assoc, coeq‚ÇÉ_condition‚ÇÇ] }
slice_rhs 1 3 { rw [‚Üê category.assoc, ‚Üê coeq_condition] }
simp only [category.assoc]
intros
{dsimp, simp}
dsimp
simp
intros
rw [‚Üêeq_inv_comp, comp_id]
intros
{ dsimp [colimit_limit_to_limit_colimit], simp, }
dsimp [colimit_limit_to_limit_colimit]
simp
intros
apply induction F (Œª X k, s.œÄ.app X ‚â´ G.map k = (s.œÄ.app j : _))
intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h
{ intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h, rw ‚Üês.w f, rw ‚Üêw at h, simpa using h, }
rw ‚Üês.w f
rw ‚Üêw at h
simpa using h
intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h
{ intros j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ f w h, rw ‚Üês.w f at h, rw ‚Üêw, simpa using h, }
rw ‚Üês.w f at h
rw ‚Üêw
simpa using h
{ exact s.w (ùüô _), }
exact s.w (ùüô _)
intros
ext
ext; simp
simp
intros
tidy
intros
simp
intros
{ ext, simp [biproduct.matrix], }
ext
simp [biproduct.matrix]
intros
rw [‚Üês.w right, parallel_pair_map_right]
intros
apply (cancel_mono (image.Œπ h)).1
simp [image.pre_comp, image.eq_to_hom]
intros
tidy
intros
simp
intros
{ rw [‚Üêtensor_id, associator_inv_naturality] }
rw [‚Üêtensor_id, associator_inv_naturality]
intros
ext X S
apply grothendieck_topology.close_eq_top_iff_mem
intros
split
intros h Y Z f g hf
{ intros h Y Z f g hf, simpa using h (ùüô _) g (S.downward_closed hf g) hf (id_comp _) }
simpa using h (ùüô _) g (S.downward_closed hf g) hf (id_comp _)
intros h Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ k
{ intros h Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ k, simp_rw [‚Üê h f‚ÇÅ g‚ÇÅ h‚ÇÅ, k, h f‚ÇÇ g‚ÇÇ h‚ÇÇ] }
simp_rw [‚Üê h f‚ÇÅ g‚ÇÅ h‚ÇÅ, k, h f‚ÇÇ g‚ÇÇ h‚ÇÇ]
intros
{ ext, simp [w], }
ext
simp [w]
intros
change F.corepr_f.app X f = (F.corepr_f.app F.corepr_X ‚â´ F.map f) (ùüô F.corepr_X)
rw ‚ÜêF.corepr_f.naturality
dsimp
simp
intros
conv_rhs { rw ‚Üê c.blocks_sum }
exact length_le_sum_of_one_le _ (Œª i hi, c.one_le_blocks hi)
intros
simp [blocks_fun, single, blocks, i.2]
intros
rw [‚Üêapply_ne_one_iff h, not_not]
intros
cases G.exists_maximal_degree_vertex with v hv
rw hv
apply G.degree_lt_card_verts v
intros
ext x
change (‚àÉ S H, S ‚àà M.to_NFA.eval_from {M.start} x) ‚Üî _
rw to_NFA_eval_from_match
split
rintro ‚ü® S, hS‚ÇÅ, hS‚ÇÇ ‚ü©
{ rintro ‚ü® S, hS‚ÇÅ, hS‚ÇÇ ‚ü©, rw set.mem_singleton_iff at hS‚ÇÇ, rw hS‚ÇÇ at hS‚ÇÅ, assumption }
rw set.mem_singleton_iff at hS‚ÇÇ
rw hS‚ÇÇ at hS‚ÇÅ
assumption
intro h
{ intro h, use M.eval x, finish }
use M.eval x
finish
intros
simp [partrec, map_id']
intros
induction k generalizing v s
exact ‚ü®_, rfl, trans_gen.single rfl‚ü©
case halt : { exact ‚ü®_, rfl, trans_gen.single rfl‚ü© }
case cons‚ÇÅ : fs as k IH { obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := tr_normal_respects fs (cont.cons‚ÇÇ v k) as none, refine ‚ü®s', h‚ÇÅ, trans_gen.head rfl _‚ü©, simp, refine (move‚ÇÇ_ok dec_trivial _ (split_at_pred_ff _)).trans _, {refl}, simp, refine (move‚ÇÇ_ok dec_trivial _ _).trans _, swap 4, {refl}, swap 4, {exact (split_at_pred_eq _ _ _ (some Œì'.Cons) _ (Œª x h, to_bool_ff (tr_list_ne_Cons _ _ h)) ‚ü®rfl, rfl‚ü©)}, refine (move‚ÇÇ_ok dec_trivial _ (split_at_pred_ff _)).trans _, {refl}, simp, exact h‚ÇÇ }
case cons‚ÇÇ : ns k IH { obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH (ns.head :: v) none, exact ‚ü®c, h‚ÇÅ, trans_gen.head rfl $ head_stack_ok.trans h‚ÇÇ‚ü© }
case comp : f k IH { obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := tr_normal_respects f k v s, exact ‚ü®_, h‚ÇÅ, trans_gen.head rfl h‚ÇÇ‚ü© }
case fix : f k IH { rw [step_ret], have : if v.head = 0 then nat_end (tr_list v).head'.iget = tt ‚àß (tr_list v).tail = tr_list v.tail else nat_end (tr_list v).head'.iget = ff ‚àß (tr_list v).tail = (tr_nat v.head).tail ++ Œì'.cons :: tr_list v.tail, { cases v with n, {exact ‚ü®rfl, rfl‚ü©}, cases n, {exact ‚ü®rfl, rfl‚ü©}, rw [tr_list, list.head, tr_nat, nat.cast_succ, num.add_one, num.succ, list.tail], cases (n:num).succ'; exact ‚ü®rfl, rfl‚ü© }, by_cases v.head = 0; simp [h] at this ‚ä¢, { obtain ‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü© := IH v.tail (tr_list v).head', refine ‚ü®c, h‚ÇÅ, trans_gen.head rfl _‚ü©, simp [tr_cont, tr_cont_stack, this], exact h‚ÇÇ }, { obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := tr_normal_respects f (cont.fix f k) v.tail (some Œì'.cons), refine ‚ü®_, h‚ÇÅ, trans_gen.head rfl $ trans_gen.trans _ h‚ÇÇ‚ü©, swap 3, simp [tr_cont, this.1], convert clear_ok (split_at_pred_eq _ _ (tr_nat v.head).tail (some Œì'.cons) _ _ _) using 2, { simp }, { exact Œª x h, tr_nat_nat_end _ _ (list.tail_subset _ h) }, { exact ‚ü®rfl, this.2‚ü© } } }
intros
simp only [tape.write, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self]
intros
ext
ext; simp with functor_norm
simp with functor_norm
intros
simp only [to_list_spec, fold_map, traverse]
induction xs
refl
case list.nil { refl }
case list.cons : _ _ ih { unfold list.traverse list.ret, rw ih, refl }
intros
rw list.nth_eq_some
have ll := to_list_length a
split
split; intro h; cases h with h e; subst v
split; intro h; cases h with h e
split; intro h
intro h
cases h with h e
subst v
{ exact ‚ü®ll ‚ñ∏ h, (to_list_nth_le _ _ _).symm‚ü© }
exact ‚ü®ll ‚ñ∏ h, (to_list_nth_le _ _ _).symm‚ü©
intro h
cases h with h e
subst v
{ exact ‚ü®ll.symm ‚ñ∏ h, to_list_nth_le _ _ _‚ü© }
exact ‚ü®ll.symm ‚ñ∏ h, to_list_nth_le _ _ _‚ü©
intros
{ cases b, simp [size, push_back] }
cases b
simp [size, push_back]
intros
cases reps
{ exact bounded.foldl_core_zero }
exact bounded.foldl_core_zero
constructor
intros cb n hn
obtain ‚ü®np, errp, hp‚ü© := bounded.exists p hn
simpa [foldl_core_succ_eq_fail, hp] using he cb n np errp
intros
introI
rcases h with ‚ü®cb, n, n', a, h‚ü©
have hs := static.of_done h
simpa [‚Üêhs] using of_done h
intros
have : cb.size - n = 0 := nat.sub_eq_zero_of_le hc
simp only [foldr, foldr_core_succ_eq_fail, this, and.left_comm, foldr_core_zero_eq_fail, ne_iff_lt_iff_le, exists_and_distrib_right, exists_eq_left, and.congr_left_iff, exists_and_distrib_left]
rintro (h | ‚ü®‚ü®a, h‚ü©, rfl‚ü©)
{ exact mono.of_fail h }
exact mono.of_fail h
{ exact mono.of_done h }
exact mono.of_done h
intros
{ ext; simp [norm_sq, mul_comm], }
ext
ext; simp [norm_sq, mul_comm]
simp [norm_sq, mul_comm]
simp [norm_sq, mul_comm]
intros
rw ‚Üê of_real_inj; simp [sinh_two_mul]
rw ‚Üê of_real_inj
simp [sinh_two_mul]
intros
rw [cos_add, cos_mul_I, sin_mul_I, mul_assoc]
intros
rw [exp_eq_exp_re_mul_sin_add_cos]
{ rw [exp_eq_exp_re_mul_sin_add_cos], simp [exp_of_real_re, sin_of_real_re] }
simp [exp_of_real_re, sin_of_real_re]
intros
rw [‚Üêof_real_one, of_real_im]
intros
have := add_monoid_hom.congr_fun lift_add_hom_single_add_hom f
rw [lift_add_hom_apply, sum_add_hom_apply] at this
exact this
intros
ext i
by_cases h1 : g‚ÇÅ i ‚â† 0; by_cases h2 : g‚ÇÇ i ‚â† 0; simp only [not_not, ne.def] at h1 h2; simp [h1, h2, hf]
by_cases h1 : g‚ÇÅ i ‚â† 0; by_cases h2 : g‚ÇÇ i ‚â† 0; simp only [not_not, ne.def] at h1 h2
by_cases h1 : g‚ÇÅ i ‚â† 0; by_cases h2 : g‚ÇÇ i ‚â† 0
by_cases h1 : g‚ÇÅ i ‚â† 0
by_cases h2 : g‚ÇÇ i ‚â† 0
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
by_cases h2 : g‚ÇÇ i ‚â† 0
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
intros
delta bind bind._proof_1; cases f a.out; refl
delta bind bind._proof_1; cases f a.out
delta bind bind._proof_1
cases f a.out
refl
intros
refine insert_nth_eq_iff.2 ‚ü®by simp, _‚ü©
ext j
convert (cons_succ _ _ _).symm
intros
{ cases k, refl }
cases k
refl
intros
{ ext, apply zero_add }
ext
apply zero_add
intros
rw [‚Üê card_disjoint_union sdiff_disjoint, sdiff_union_self_eq_union]
intros
ext
simp [or.comm]
{ ext i, simp }
ext i
simp
intros
rw [‚Üêwith_bot.coe_lt_coe, coe_sup', sup_lt_iff (with_bot.bot_lt_coe a)]
exact ball_congr (Œª b hb, with_bot.coe_lt_coe)
intros
induction s using quotient.induction_on
simp
intros
rw [to_multiset_apply, sum_single_index]; apply zero_nsmul
rw [to_multiset_apply, sum_single_index]
apply zero_nsmul
intros
{ ext, simp [finset.mem_powerset_len] }
ext
simp [finset.mem_powerset_len]
intros
rw [subtype.ext_iff, fintype.choose_spec (Œª (y : {a : Œ± // p a}), (y : Œ±) = x) _]
intros
rw [‚Üê fin.succ_above_zero, fin.image_succ_above_univ]
intros
simp [bijective, injective_iff_surjective]
intros
subst eq; refl
subst eq
refl
intros
cases m with m m; cases n with n n; unfold has_add.add; simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
cases m with m m; cases n with n n; unfold has_add.add
cases m with m m; cases n with n n
cases m with m m
cases n with n n
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
cases n with n n
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
intros
cases n
cases n; refl
refl
refl
intros
{ rw [int.lcm], apply nat.lcm_zero_left }
rw [int.lcm]
apply nat.lcm_zero_left
intros
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.mul_mod]; norm_num
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.mul_mod]
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.mul_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.mul_mod]
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.mul_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, int.mul_mod]
norm_num
intros
induction L; [refl, simp only [*, join, map, map_append]]
induction L
refl
simp only [*, join, map, map_append]
intros
simp
intros
induction l generalizing f
{ exact hf }
exact hf
apply l_ih (Œª _ h, hl _ (list.mem_cons_of_mem _ h))
{ apply l_ih (Œª _ h, hl _ (list.mem_cons_of_mem _ h)), apply function.injective.comp hf, apply hl _ (list.mem_cons_self _ _) }
apply function.injective.comp hf
apply hl _ (list.mem_cons_self _ _)
intros
simp only [mem_singleton, forall_eq]
intros
rw [‚Üê length_eq_zero, length_pmap, length_eq_zero]
intros
induction l with hd tl hl generalizing x
cases x; simp [option.to_list]
cases x
{ cases x; simp [option.to_list] }
simp [option.to_list]
simp [option.to_list]
simp only [concat_eq_append, reduce_option_append] at hl
{ simp only [concat_eq_append, reduce_option_append] at hl, cases hd; simp [hl, reduce_option_append] }
cases hd; simp [hl, reduce_option_append]
cases hd
simp [hl, reduce_option_append]
simp [hl, reduce_option_append]
intros
induction l with hd tl IH
{ simp }
simp
{ simpa }
simpa
intros
simp
intros
induction is with t is ih generalizing is'
simp
{simp}
simp [foldr_permutations_aux2, ih, bind_map]
congr' 2
funext ys
rw [map_permutations_aux2]
simp only [‚Üê permutations_aux2_comp_append] {single_pass := tt}
simp only [id, append_assoc]
intros
induction l‚ÇÇ generalizing l‚ÇÅ; [refl, simp only [foldl_cons, map_erase finj, *]]
induction l‚ÇÇ generalizing l‚ÇÅ
refl
simp only [foldl_cons, map_erase finj, *]
intros
simp only [chain'_singleton, chain'_cons, and_true]
intros
simp only [neg, length_map]
intros
cases le_total n l with hnl hln
rw [‚Üê append_consecutive hnl hlm, filter_append, filter_lt_of_top_le (le_refl l), filter_lt_of_le_bot (le_refl l), append_nil]
{ rw [‚Üê append_consecutive hnl hlm, filter_append, filter_lt_of_top_le (le_refl l), filter_lt_of_le_bot (le_refl l), append_nil] }
{ rw [eq_nil_of_le hln, filter_lt_of_le_bot hln] }
rw [eq_nil_of_le hln, filter_lt_of_le_bot hln]
intros
induction l with y l IH
{ simp }
simp
specialize IH (Œª x hx, h x (mem_cons_of_mem _ hx))
{ specialize IH (Œª x hx, h x (mem_cons_of_mem _ hx)), have hy : y ‚â§ n := h y (mem_cons_self _ _), simpa [hy] using IH }
have hy : y ‚â§ n := h y (mem_cons_self _ _)
simpa [hy] using IH
intros
classical
refine pairwise_of_reflexive_on_dupl_of_forall_ne _ h
intros x hx
rw nodup_iff_count_le_one at hl
exact absurd (hl x) hx.not_le
intros
simp only [range_eq_range', range'_subset_right]
intros
obtain ‚ü®iy, hiy, rfl‚ü© := nth_le_of_mem hy
obtain ‚ü®ix, hix, rfl‚ü© := nth_le_of_mem hx
rw [nth_le_take', nth_le_drop']
rw length_take at hix
exact h.rel_nth_le_of_lt _ _ (ix.lt_add_right _ _ (lt_min_iff.mp hix).left)
intros
induction l generalizing init tail; simp_rw [tails, inits, zip_cons_cons]
induction l generalizing init tail
simp_rw [tails, inits, zip_cons_cons]
{ simp }
simp
simp_rw [tails, inits, zip_cons_cons]
split; rw [mem_cons_iff, zip_map_left, mem_map, prod.exists]
split
{ split; rw [mem_cons_iff, zip_map_left, mem_map, prod.exists], { rintros (‚ü®rfl, rfl‚ü© | ‚ü®_, _, h, rfl, rfl‚ü©), { simp }, { simp [l_ih.mp h], }, }, { cases init, { simp }, { intro h, right, use [init_tl, tail], simp * at *, }, }, }
rw [mem_cons_iff, zip_map_left, mem_map, prod.exists]
rintros (‚ü®rfl, rfl‚ü© | ‚ü®_, _, h, rfl, rfl‚ü©)
{ rintros (‚ü®rfl, rfl‚ü© | ‚ü®_, _, h, rfl, rfl‚ü©), { simp }, { simp [l_ih.mp h], }, }
{ simp }
simp
{ simp [l_ih.mp h], }
simp [l_ih.mp h]
rw [mem_cons_iff, zip_map_left, mem_map, prod.exists]
cases init
{ cases init, { simp }, { intro h, right, use [init_tl, tail], simp * at *, }, }
{ simp }
simp
intro h
{ intro h, right, use [init_tl, tail], simp * at *, }
right
use [init_tl, tail]
simp * at *
intros
ext i j; refl
ext i j
refl
intros
by_cases i' = i
{ rw [h, update_row_self, if_pos rfl] }
rw [h, update_row_self, if_pos rfl]
{ rwa [update_row_ne h, if_neg h] }
rwa [update_row_ne h, if_neg h]
intros
simp [dot_product]
intros
{ ext, apply dot_product_smul }
ext
apply dot_product_smul
intros
rw [matrix_eq_sum_std_basis M, ‚Üê finset.sum_product']
apply finset.sum_induction _ _ h_add h_zero
{ intros, apply h_std_basis, }
intros
apply h_std_basis
intros
ext i j
rcases i
rcases i; rcases j; refl
rcases i; rcases j
rcases j
refl
refl
rcases j
refl
refl
intros
simp [dot_product, fin.sum_univ_succ, vec_head, vec_tail]
intros
simp [countp_eq_card_filter, card_pos_iff_exists_mem]
intros
conv_rhs { rw ‚Üêcoe_to_list s, }
rw coe_prod
intros
rw [‚Üê fold_add op, union_add_inter, fold_add op]
intros
simp [nodup_add, d‚ÇÅ, d‚ÇÇ]
intros
{ rw [ne.def, eq_zero_iff], push_neg, }
rw [ne.def, eq_zero_iff]
push_neg
intros
rw [C_dvd_iff_dvd_coeff, mv_polynomial.ext_iff]
simp only [coeff_map, coeff_zero, hr]
intros
simp only [monomial_eq, alg_hom.map_mul, bind‚ÇÅ_C_right, finsupp.prod, alg_hom.map_prod, alg_hom.map_pow, bind‚ÇÅ_X_right]
intros
simp [supported_equiv_mv_polynomial]
intros
rw [vars_monomial hr, finsupp.support_single_ne_zero he]
intros
rw [‚Üênat.mod_add_div a c, ‚Üênat.mod_add_div b c, ‚Üêh, ‚Üênat.sub_sub, nat.add_sub_cancel_left, ‚Üênat.mul_sub_left_distrib, nat.mul_mod_right]
intros
rw add_comm
exact add_pos_left h m
intros
rw [mul_comm c, mod_mul_right_div_self]
intros
rw [‚Üê cast_one, cast_le]
intros
cases b
{ cases h, }
cases h
cases b
{ cases b, { norm_num at h, }, { cases y, { norm_num at w', simp [w, w'], }, dsimp [digits], rw digits_aux_def, { congr, { simp [nat.add_mod, nat.mod_eq_of_lt w], }, { simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], } }, { apply nat.succ_pos, }, }, }
{ norm_num at h, }
norm_num at h
cases y
{ cases y, { norm_num at w', simp [w, w'], }, dsimp [digits], rw digits_aux_def, { congr, { simp [nat.add_mod, nat.mod_eq_of_lt w], }, { simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], } }, { apply nat.succ_pos, }, }
norm_num at w'
{ norm_num at w', simp [w, w'], }
simp [w, w']
dsimp [digits]
rw digits_aux_def
congr
{ congr, { simp [nat.add_mod, nat.mod_eq_of_lt w], }, { simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], } }
simp [nat.add_mod, nat.mod_eq_of_lt w]
{ simp [nat.add_mod, nat.mod_eq_of_lt w], }
simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w]
{ simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], }
{ apply nat.succ_pos, }
apply nat.succ_pos
intros
have t := zmodeq_of_digits_digits 11 10 (-1 : ‚Ñ§) (by unfold int.modeq; norm_num) n
rwa of_digits_neg_one at t
intros
simp only [lt_def, forall_prop_of_true, get_coe', dom_coe]
intros
rw coe_lt_iff
intro h'
rw find_get
have := @nat.find_spec P _ h'
contrapose! this
exact h _ this
intros
delta lcm; rw [one_mul, gcd_one_left, nat.div_one]
delta lcm
rw [one_mul, gcd_one_left, nat.div_one]
intros
rw gcd_comm; apply gcd_eq_left_iff_dvd
rw gcd_comm
apply gcd_eq_left_iff_dvd
intros
rw [‚Üênot_le, pow_le_iff_le_log hb hx, not_le]
exact lt_succ_self _
intros
unfold modeq at *; rw [mul_mod_mul_left, mul_mod_mul_left, h]
unfold modeq at *
rw [mul_mod_mul_left, mul_mod_mul_left, h]
intros
rw [even_sub h, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
{ rw [sq, sq], exact nat.mul_self_sub_mul_self_eq a b }
rw [sq, sq]
exact nat.mul_self_sub_mul_self_eq a b
intros
by_cases n1 : n = 1; [exact n1.symm ‚ñ∏ dec_trivial, exact (min_fac_prime n1).pos]
by_cases n1 : n = 1
exact n1.symm ‚ñ∏ dec_trivial
exact (min_fac_prime n1).pos
intros
simp [nat.min_fac_eq, show 2 ‚à£ bit0 n, by simp [bit0_eq_two_mul n]]
intros
simpa only [pow_two] using exists_mul_self x
intros
rw [‚Üê zneg_zneg (succ (-n)), zneg_succ, zneg_zneg]
intros
simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some']
intros
cases x; refl
cases x
refl
refl
intros
rw [balance_l_eq_balance' hl hr sl sr H, all_balance']
intros
revert h
generalize h : (M.mk ‚ü®a,f‚ü©) = x
intros h'
cases h'
subst x
have := mk_inj ‚Äπ_‚Ä∫
cases this
cases this
assumption
intros
simp only [single_apply, eq_comm]; congr
simp only [single_apply, eq_comm]
intros
rw[coe_prod, to_of_nat_multiset]
intros
let ha : u.r + u.b * u.q = u.a := u.rq_eq
let hr : (u.r - 1) + 1 = u.r := (add_comm _ 1).trans (nat.add_sub_of_le (nat.pos_of_ne_zero hr))
ext
change ((u.y * u.q + u.z) * u.b + u.y * (u.r - 1 + 1) : ‚Ñï) = u.y * u.a + u.z * u.b
{ change ((u.y * u.q + u.z) * u.b + u.y * (u.r - 1 + 1) : ‚Ñï) = u.y * u.a + u.z * u.b, rw [‚Üê ha, hr], ring }
rw [‚Üê ha, hr]
ring
change ((u.w * u.q + u.x) * u.b + u.w * (u.r - 1 + 1) : ‚Ñï) = u.w * u.a + u.x * u.b
{ change ((u.w * u.q + u.x) * u.b + u.w * (u.r - 1 + 1) : ‚Ñï) = u.w * u.a + u.x * u.b, rw [‚Üê ha, hr], ring }
rw [‚Üê ha, hr]
ring
intros
rw [X_pow_mul, monomial_mul_X_pow]
intros
{ rcases p, rcases q, simp [coeff, add_to_finsupp] }
rcases p
rcases q
simp [coeff, add_to_finsupp]
intros
induction k with k ih generalizing p
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
simp [not_mem_support_iff]
intros
rw [‚Üê C_1, C_comp]
intros
simp [‚Üêcoeff_zero_eq_eval_zero]
intros
simp_rw [is_unit_iff_degree_eq_zero, degree_map]
intros
simp only [coe_map_ring_hom, lifts, ring_hom.mem_srange]
intros
rw [is_unit_iff_dvd_one, is_unit_iff_dvd_one]
split
rintros ‚ü®g, hg‚ü©
{ rintros ‚ü®g, hg‚ü©, replace hg := congr_arg (eval 0) hg, rw [eval_one, eval_mul, eval_C] at hg, exact ‚ü®g.eval 0, hg‚ü© }
replace hg := congr_arg (eval 0) hg
rw [eval_one, eval_mul, eval_C] at hg
exact ‚ü®g.eval 0, hg‚ü©
rintros ‚ü®y, hy‚ü©
{ rintros ‚ü®y, hy‚ü©, exact ‚ü®C y, by rw [‚Üê C_mul, ‚Üê hy, C_1]‚ü© }
exact ‚ü®C y, by rw [‚Üê C_mul, ‚Üê hy, C_1]‚ü©
intros
have := liftr_map_last R x f id hh
rwa [append_fun_id_id,mvfunctor.id_map] at this
intros
refine iff.trans _ quotient.eq
rw quotient.out_eq x
intros
rw [mk_lt] {md := tactic.transparency.semireducible}
exact const_lt
intros
rw [‚Üê @ennreal.mul_le_mul_left _ a _ hr‚ÇÄ hr‚ÇÅ, ‚Üê mul_assoc, mul_inv_cancel hr‚ÇÄ hr‚ÇÅ, one_mul]
intros
{ rw [coe_nnreal_eq], refl }
rw [coe_nnreal_eq]
refl
intros
rw [add_comm, infi_add]; simp [add_comm]
rw [add_comm, infi_add]
simp [add_comm]
intros
simp only [nonpos_iff_eq_zero.symm, max_le_iff]
intros
split
{ rintro rfl, exact ereal.coe_lt_top }
rintro rfl
exact ereal.coe_lt_top
contrapose!
{ contrapose!, intro h, exact ‚ü®x.to_real, le_coe_to_real h‚ü©, }
intro h
exact ‚ü®x.to_real, le_coe_to_real h‚ü©
intros
rw [is_st_real_iff_eq, is_st_real_iff_eq, eq_comm]
intros
simpa only [mul_zero] using is_st_mul hx hy
intros
simp [nnreal.coe_le_coe.symm, real.to_nnreal, hp]
intros
by_cases hx : 0 ‚â§ x
nth_rewrite 0 ‚Üê real.coe_to_nnreal x hx
{ nth_rewrite 0 ‚Üê real.coe_to_nnreal x hx, rw [‚Üênnreal.coe_inv, real.to_nnreal_coe], }
rw [‚Üênnreal.coe_inv, real.to_nnreal_coe]
have hx' := le_of_not_ge hx
{ have hx' := le_of_not_ge hx, rw [to_nnreal_eq_zero.mpr hx', inv_zero, to_nnreal_eq_zero.mpr (inv_nonpos.mpr hx')], }
rw [to_nnreal_eq_zero.mpr hx', inv_zero, to_nnreal_eq_zero.mpr (inv_nonpos.mpr hx')]
intros
obtain hn | rfl | hp := lt_trichotomy z (0 : ‚Ñ§)
rw [sign_of_neg (int.cast_lt_zero.mpr hn), int.sign_eq_neg_one_of_neg hn, int.cast_neg, int.cast_one]
{ rw [sign_of_neg (int.cast_lt_zero.mpr hn), int.sign_eq_neg_one_of_neg hn, int.cast_neg, int.cast_one], }
rw [int.cast_zero, sign_zero, int.sign_zero, int.cast_zero]
{ rw [int.cast_zero, sign_zero, int.sign_zero, int.cast_zero], }
rw [sign_of_pos (int.cast_pos.mpr hp), int.sign_eq_one_of_pos hp, int.cast_one]
{ rw [sign_of_pos (int.cast_pos.mpr hp), int.sign_eq_one_of_pos hp, int.cast_one] }
intros
split
simpa only [‚Üê sqrt_lt_sqrt_iff (sq_nonneg x), sqrt_sq_eq_abs] using abs_lt.mp
{ simpa only [‚Üê sqrt_lt_sqrt_iff (sq_nonneg x), sqrt_sq_eq_abs] using abs_lt.mp }
rw [‚Üê abs_lt, ‚Üê sq_abs]
{ rw [‚Üê abs_lt, ‚Üê sq_abs], exact Œª h, (lt_sqrt (abs_nonneg x) (sqrt_pos.mp (lt_of_le_of_lt (abs_nonneg x) h)).le).mp h }
exact Œª h, (lt_sqrt (abs_nonneg x) (sqrt_pos.mp (lt_of_le_of_lt (abs_nonneg x) h)).le).mp h
intros
cases s with f al; apply subtype.eq; dsimp [tail, think]; rw [stream.tail_cons]
cases s with f al; apply subtype.eq; dsimp [tail, think]
cases s with f al; apply subtype.eq
cases s with f al
apply subtype.eq
dsimp [tail, think]
rw [stream.tail_cons]
intros
have := h1.mem
revert m
apply mem_rec_on this _ (Œª s IH, _); intros m h1
apply mem_rec_on this _ (Œª s IH, _)
intros m h1
rw [ret_bind]
{ rw [ret_bind], rw h1.len_unique (results_ret _), exact h2 }
rw h1.len_unique (results_ret _)
exact h2
intros m h1
rw [think_bind]
{ rw [think_bind], cases of_results_think h1 with m' h, cases h with h1 e, rw e, exact results_think (IH h1) }
cases of_results_think h1 with m' h
cases h with h1 e
rw e
exact results_think (IH h1)
intros
simp [set.ite]
intros
ext
{ ext, simp only [function.comp_app], apply apply_range_splitting, }
simp only [function.comp_app]
apply apply_range_splitting
intros
simp
intros
simp [‚Üê not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]
intros
ext x
{ ext x, split; rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©; exact ‚ü®a, b, c, ha, hb, hc, by rw h a ha b hb c hc‚ü© }
split; rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©; exact ‚ü®a, b, c, ha, hb, hc, by rw h a ha b hb c hc‚ü©
split; rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
split
rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
exact ‚ü®a, b, c, ha, hb, hc, by rw h a ha b hb c hc‚ü©
rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
exact ‚ü®a, b, c, ha, hb, hc, by rw h a ha b hb c hc‚ü©
intros
split
{ intro h, exact ‚ü®fintype_of_univ_finite h‚ü© }
intro h
exact ‚ü®fintype_of_univ_finite h‚ü©
{ rintro ‚ü®_i‚ü©, exactI finite_univ }
rintro ‚ü®_i‚ü©
exactI finite_univ
intros
funext x
rw [subtype.ext_iff, maps_to.coe_restrict_apply]
induction n with n ihn generalizing x
{ refl }
refl
{ simp [nat.iterate, ihn] }
simp [nat.iterate, ihn]
intros
{ ext x, by_cases hx : x ‚àà s; simp [hx] }
ext x
by_cases hx : x ‚àà s
by_cases hx : x ‚àà s; simp [hx]
simp [hx]
simp [hx]
intros
rw [‚Üê Ioc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 $ right_mem_Ioc.2 h)]
intros
ext1 x
simp_rw [mem_union, mem_Ico, mem_Ici, min_le_iff]
by_cases hc : c ‚â§ x
{ tauto }
tauto
have hxb : x < b := (lt_of_not_ge hc).trans_le h‚ÇÅ
{ have hxb : x < b := (lt_of_not_ge hc).trans_le h‚ÇÅ, tauto }
tauto
intros
simp [‚Üê Ici_inter_Iic]
intros
simp
intros
simp [‚Üê Ioi_inter_Iio, h]
intros
rintros a ‚ü®‚ü®hax, haz‚ü©, hay‚ü©
simpa [not_and_distrib, hax, le_update_iff, haz _] using hay
intros
simp [sub_eq_add_neg, add_comm]
intros
ext
ext; simp
simp
intros
{ cases x‚ÇÄ, cases x‚ÇÅ, exact sigma.mk.inj_iff }
cases x‚ÇÄ
cases x‚ÇÅ
exact sigma.mk.inj_iff
intros
ext i : 1; cases i; refl
ext i : 1; cases i
ext i : 1
cases i
intros
rw ‚Üêv.cons_head_tail
simp only [to_list_cons, to_list_nil, cons_head, eq_self_iff_true, and_self, singleton_tail]
intros
cases n; simp
cases n
simp
simp
intros
have := congr_arg (coe : ‚Ñï ‚Üí zmod n) (val_coe_unit_coprime u)
rw [‚Üê mul_inv_eq_gcd, nat.cast_one] at this
let u' : units (zmod n) := ‚ü®u, (u : zmod n)‚Åª¬π, this, by rwa mul_comm‚ü©
have h : u = u'
apply units.ext
{ apply units.ext, refl }
refl
rw h
refl
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strict_mono_id.add_const m) hn
intros
rw [‚Üê hf.map_eq, map_apply hf.1 hs]
intros
revert hm hn
refine nat.gcd.induction m n (Œª n h0 hn, _) (Œª m n hm ih hm hn, _)
{ rwa [nat.gcd_zero_left], }
rwa [nat.gcd_zero_left]
rw [nat.gcd_rec]
{ rw [nat.gcd_rec], exact ih (hn.mod hm) hm }
exact ih (hn.mod hm) hm
intros
obtain ‚ü®S, rfl‚ü© := hK
exact induction_on_adjoin_finset S P base (Œª K x _ hK, ih K x hK)
intros
split
introI h
{ introI h, exact ‚ü®‚ü®finset_basis_index K V, by { convert (finset_basis K V).span_eq, simp }‚ü©‚ü© }
exact ‚ü®‚ü®finset_basis_index K V, by { convert (finset_basis K V).span_eq, simp }‚ü©‚ü©
rintros ‚ü®s, hs‚ü©
{ rintros ‚ü®s, hs‚ü©, rw [is_noetherian.iff_dim_lt_omega, ‚Üê dim_top, ‚Üê hs], exact lt_of_le_of_lt (dim_span_le _) (lt_omega_iff_finite.2 (set.finite_mem_finset s)) }
rw [is_noetherian.iff_dim_lt_omega, ‚Üê dim_top, ‚Üê hs]
exact lt_of_le_of_lt (dim_span_le _) (lt_omega_iff_finite.2 (set.finite_mem_finset s))
intros
{ ext, refl }
ext
refl
intros
intro ha
refine not_lt_of_ge (minpoly.min A x hamonic ha) _
obtain ‚ü®hzeroa, b, hb_nunit, prod‚ü© := hdvd
have hbmonic : b.monic
rw monic.def
{ rw monic.def, have := monic hx, rwa [monic.def, prod, leading_coeff_mul, monic.def.mp hamonic, one_mul] at this }
have := monic hx
rwa [monic.def, prod, leading_coeff_mul, monic.def.mp hamonic, one_mul] at this
have hzerob : b ‚â† 0 := hbmonic.ne_zero
have degbzero : 0 < b.nat_degree
apply nat.pos_of_ne_zero
{ apply nat.pos_of_ne_zero, intro h, have h‚ÇÅ := eq_C_of_nat_degree_eq_zero h, rw [‚Üêh, ‚Üêleading_coeff, monic.def.1 hbmonic, C_1] at h‚ÇÅ, rw h‚ÇÅ at hb_nunit, have := is_unit_one, contradiction }
intro h
have h‚ÇÅ := eq_C_of_nat_degree_eq_zero h
rw [‚Üêh, ‚Üêleading_coeff, monic.def.1 hbmonic, C_1] at h‚ÇÅ
rw h‚ÇÅ at hb_nunit
have := is_unit_one
contradiction
rw [prod, degree_mul, degree_eq_nat_degree hzeroa, degree_eq_nat_degree hzerob]
exact_mod_cast lt_add_of_pos_right _ degbzero
intros
let P : polynomial F ‚Üí Prop := Œª r, r.splits (algebra_map F (r.comp q).splitting_field)
have key1 : ‚àÄ {r : polynomial F}, irreducible r ‚Üí P r
intros r hr
{ intros r hr, by_cases hr' : nat_degree r = 0, { exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one) }, obtain ‚ü®x, hx‚ü© := exists_root_of_splits _ (splitting_field.splits (r.comp q)) (Œª h, hr' ((mul_eq_zero.mp (nat_degree_comp.symm.trans (nat_degree_eq_of_degree_eq_some h))).resolve_right hq)), rw [‚Üêaeval_def, aeval_comp] at hx, have h_normal : normal F (r.comp q).splitting_field := splitting_field.normal (r.comp q), have qx_int := normal.is_integral h_normal (aeval x q), exact splits_of_splits_of_dvd _ (minpoly.ne_zero qx_int) (normal.splits h_normal _) ((minpoly.irreducible qx_int).dvd_symm hr (minpoly.dvd F _ hx)) }
by_cases hr' : nat_degree r = 0
exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one)
{ exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one) }
obtain ‚ü®x, hx‚ü© := exists_root_of_splits _ (splitting_field.splits (r.comp q)) (Œª h, hr' ((mul_eq_zero.mp (nat_degree_comp.symm.trans (nat_degree_eq_of_degree_eq_some h))).resolve_right hq))
rw [‚Üêaeval_def, aeval_comp] at hx
have h_normal : normal F (r.comp q).splitting_field := splitting_field.normal (r.comp q)
have qx_int := normal.is_integral h_normal (aeval x q)
exact splits_of_splits_of_dvd _ (minpoly.ne_zero qx_int) (normal.splits h_normal _) ((minpoly.irreducible qx_int).dvd_symm hr (minpoly.dvd F _ hx))
have key2 : ‚àÄ {p‚ÇÅ p‚ÇÇ : polynomial F}, P p‚ÇÅ ‚Üí P p‚ÇÇ ‚Üí P (p‚ÇÅ * p‚ÇÇ)
intros p‚ÇÅ p‚ÇÇ hp‚ÇÅ hp‚ÇÇ
{ intros p‚ÇÅ p‚ÇÇ hp‚ÇÅ hp‚ÇÇ, by_cases h‚ÇÅ : p‚ÇÅ.comp q = 0, { cases comp_eq_zero_iff.mp h‚ÇÅ with h h, { rw [h, zero_mul], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }, by_cases h‚ÇÇ : p‚ÇÇ.comp q = 0, { cases comp_eq_zero_iff.mp h‚ÇÇ with h h, { rw [h, mul_zero], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }, have key := mul_splits_in_splitting_field_of_mul h‚ÇÅ h‚ÇÇ hp‚ÇÅ hp‚ÇÇ, rwa ‚Üê mul_comp at key }
by_cases h‚ÇÅ : p‚ÇÅ.comp q = 0
cases comp_eq_zero_iff.mp h‚ÇÅ with h h
{ cases comp_eq_zero_iff.mp h‚ÇÅ with h h, { rw [h, zero_mul], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }
rw [h, zero_mul]
{ rw [h, zero_mul], exact splits_zero _ }
exact splits_zero _
{ exact false.rec _ (hq (by rw [h.2, nat_degree_C])) }
exact false.rec _ (hq (by rw [h.2, nat_degree_C]))
by_cases h‚ÇÇ : p‚ÇÇ.comp q = 0
cases comp_eq_zero_iff.mp h‚ÇÇ with h h
{ cases comp_eq_zero_iff.mp h‚ÇÇ with h h, { rw [h, mul_zero], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }
rw [h, mul_zero]
{ rw [h, mul_zero], exact splits_zero _ }
exact splits_zero _
{ exact false.rec _ (hq (by rw [h.2, nat_degree_C])) }
exact false.rec _ (hq (by rw [h.2, nat_degree_C]))
have key := mul_splits_in_splitting_field_of_mul h‚ÇÅ h‚ÇÇ hp‚ÇÅ hp‚ÇÇ
rwa ‚Üê mul_comp at key
exact wf_dvd_monoid.induction_on_irreducible p (splits_zero _) (Œª _, splits_of_is_unit _) (Œª _ _ _ h, key2 (key1 h))
intros
rw [angle_comm, angle_smul_right_of_pos y x hr, angle_comm]
intros
rw [finset.weighted_vsub_apply, finset.weighted_vsub_apply, inner_sum_smul_sum_smul_of_sum_eq_zero _ h‚ÇÅ _ h‚ÇÇ]
simp_rw [vsub_sub_vsub_cancel_right]
rcongr i‚ÇÅ i‚ÇÇ; rw dist_eq_norm_vsub V (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)
rcongr i‚ÇÅ i‚ÇÇ
rw dist_eq_norm_vsub V (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)
rw dist_eq_norm_vsub V (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)
rw dist_eq_norm_vsub V (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)
rw dist_eq_norm_vsub V (p‚ÇÅ i‚ÇÅ) (p‚ÇÇ i‚ÇÇ)
intros
rw [orthocenter_eq_monge_point, monge_point_eq_smul_vsub_vadd_circumcenter]
norm_num
intros
rw norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero
exact inner_eq_zero_iff_angle_eq_pi_div_two x y
intros
simp only [support_eq_inter_preimage, update_r_R]
intros
simp [stereographic']
intros
dsimp [tangent_map]
rw mdifferentiable_at.mfderiv
{ refl }
refl
exact mdifferentiable_at_atlas _ (chart_mem_atlas _ _) h
{ exact mdifferentiable_at_atlas _ (chart_mem_atlas _ _) h }
intros
simp only [mdifferentiable_on, mdifferentiable_within_at_univ] with mfld_simps
{ simp only [mdifferentiable_on, mdifferentiable_within_at_univ] with mfld_simps, refl }
refl
intros
rw [‚Üê mfderiv_within_univ, ‚Üê fderiv_within_univ]
exact mfderiv_within_eq_fderiv_within
intros
rw [‚Üê local_equiv.image_source_eq_target, ‚Üê ext_chart_at_map_nhds' I hy]
exact image_mem_map (ext_chart_at_source_mem_nhds' _ _ hy)
intros
rcases p
exact hf.prod_map hg
intros
rw [right_transversals, set.mem_set_of_eq, is_complement_iff_exists_unique]
refine ‚ü®Œª h g, _, Œª h g, _‚ü©
obtain ‚ü®x, h1, h2‚ü© := h g
{ obtain ‚ü®x, h1, h2‚ü© := h g, exact ‚ü®x.2, (congr_arg (‚àà T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, Œª y hy, (prod.ext_iff.mp (h2 ‚ü®‚ü®g * y‚Åª¬π, hy‚ü©, y‚ü© (inv_mul_cancel_right g y))).2‚ü© }
exact ‚ü®x.2, (congr_arg (‚àà T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, Œª y hy, (prod.ext_iff.mp (h2 ‚ü®‚ü®g * y‚Åª¬π, hy‚ü©, y‚ü© (inv_mul_cancel_right g y))).2‚ü©
obtain ‚ü®x, h1, h2‚ü© := h g
{ obtain ‚ü®x, h1, h2‚ü© := h g, refine ‚ü®‚ü®‚ü®g * x‚Åª¬π, h1‚ü©, x‚ü©, inv_mul_cancel_right g x, Œª y hy, _‚ü©, have := h2 y.2 ((congr_arg (‚àà T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2), exact prod.ext (subtype.ext (eq_mul_inv_of_mul_eq ((congr_arg _ this).mp hy))) this }
refine ‚ü®‚ü®‚ü®g * x‚Åª¬π, h1‚ü©, x‚ü©, inv_mul_cancel_right g x, Œª y hy, _‚ü©
have := h2 y.2 ((congr_arg (‚àà T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2)
exact prod.ext (subtype.ext (eq_mul_inv_of_mul_eq ((congr_arg _ this).mp hy))) this
intros
apply free_abelian_group.induction_on x
{ exact add_monoid_hom.map_zero _ }
exact add_monoid_hom.map_zero _
{ intro y, refl }
intro y
refl
{ intros x h, simp only [h, add_monoid_hom.map_neg] }
intros x h
simp only [h, add_monoid_hom.map_neg]
intros x y h‚ÇÅ h‚ÇÇ
{ intros x y h‚ÇÅ h‚ÇÇ, simp only [h‚ÇÅ, h‚ÇÇ, add_monoid_hom.map_add] }
simp only [h‚ÇÅ, h‚ÇÇ, add_monoid_hom.map_add]
intros
simp [mul_smul]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, smul_add, smul_neg]
intros
rw [‚Üêmul_mk'_one_eq_mk', f.to_map.map_mul, mul_assoc, mul_mk'_one_eq_mk', mk'_self', mul_one]
intros
simp_rw [order_of_eq_order_of_iff, ‚Üêf.map_pow, ‚Üêf.map_one, hf.eq_iff, iff_self, forall_const]
intros
intros x y h
ext a b
simpa using equiv.congr_fun h ‚ü®a, b‚ü©
intros
rw cycle_type_def
congr
rw cycle_factors_finset_eq_finset
exact ‚ü®h1, h2, h0‚ü©
intros
rw [is_cycle_fin_rotate.cycle_type, support_fin_rotate, ‚Üê fintype.card, fintype.card_fin]
refl
intros
apply le_antisymm
{ exact support_form_perm_le' l }
exact support_form_perm_le' l
intros x hx
{ intros x hx, simp only [finset.mem_coe, mem_to_finset] at hx, obtain ‚ü®n, hn, rfl‚ü© := nth_le_of_mem hx, rw [set.mem_set_of_eq, form_perm_apply_nth_le _ h], intro H, rw nodup_iff_nth_le_inj at h, specialize h _ _ _ _ H, cases (nat.succ_le_of_lt hn).eq_or_lt with hn' hn', { simp only [‚Üêhn', nat.mod_self] at h, refine not_exists.mpr h' _, simpa [‚Üêh, eq_comm, length_eq_one] using hn' }, { simpa [nat.mod_eq_of_lt hn'] using h } }
simp only [finset.mem_coe, mem_to_finset] at hx
obtain ‚ü®n, hn, rfl‚ü© := nth_le_of_mem hx
rw [set.mem_set_of_eq, form_perm_apply_nth_le _ h]
intro H
rw nodup_iff_nth_le_inj at h
specialize h _ _ _ _ H
cases (nat.succ_le_of_lt hn).eq_or_lt with hn' hn'
simp only [‚Üêhn', nat.mod_self] at h
{ simp only [‚Üêhn', nat.mod_self] at h, refine not_exists.mpr h' _, simpa [‚Üêh, eq_comm, length_eq_one] using hn' }
refine not_exists.mpr h' _
simpa [‚Üêh, eq_comm, length_eq_one] using hn'
{ simpa [nat.mod_eq_of_lt hn'] using h }
simpa [nat.mod_eq_of_lt hn'] using h
intros
obtain ‚ü®m, hm‚ü© := exists_pow_eq_self_of_coprime h
exact le_antisymm (support_pow_le œÉ n) (le_trans (ge_of_eq (congr_arg support hm)) (support_pow_le (œÉ ^ n) m))
intros
obtain ‚ü®l, hl, mem_l‚ü© := fintype.exists_univ_list Œ±
have l_to_finset : l.to_finset = finset.univ
apply eq_top_iff.mpr
{ apply eq_top_iff.mpr, intros b _, exact list.mem_to_finset.mpr (mem_l b) }
intros b _
exact list.mem_to_finset.mpr (mem_l b)
rw [‚Üê prod_prod_extend_right œÉ hl mem_l, sign.map_list_prod, list.map_map, ‚Üê l_to_finset, list.prod_to_finset _ hl]
simp_rw ‚Üê Œª a, sign_prod_extend_right a (œÉ a)
intros
refine ‚ü®Œª h H, _, support_swap‚ü©
subst H
simp only [swap_self, support_refl, insert_singleton_self_eq] at h
have : x ‚àà ‚àÖ
rw h
{ rw h, exact mem_singleton.mpr rfl }
exact mem_singleton.mpr rfl
simpa
intros
simp [sq]
intros
ext
ext; simp
simp
intros
simp_rw ‚Üêhh
exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm
intros
{ cases a, simp only [inclusion, coe_mk, monoid_hom.mk'_apply] }
cases a
simp only [inclusion, coe_mk, monoid_hom.mk'_apply]
intros
conv_rhs { rw [‚Üêvsub_vadd p1 p2, map_vadd, vadd_vsub] }
intros
split
contrapose
{ contrapose, rw [set.not_nonempty_iff_eq_empty, set.not_nonempty_iff_eq_empty], intro h, simp [h, span_points] }
rw [set.not_nonempty_iff_eq_empty, set.not_nonempty_iff_eq_empty]
intro h
simp [h, span_points]
{ exact Œª h, h.mono (subset_span_points _ _) }
exact Œª h, h.mono (subset_span_points _ _)
intros
rw vector_span_def
refine le_antisymm _ (submodule.span_mono _)
rw submodule.span_le
{ rw submodule.span_le, rintros v ‚ü®p1, p2, hp1, hp2, hv‚ü©, rw ‚Üêvsub_sub_vsub_cancel_right p1 p2 p at hv, rw [‚Üêhv, set_like.mem_coe, submodule.mem_span], exact Œª m hm, submodule.sub_mem _ (hm ‚ü®p1, hp1, rfl‚ü©) (hm ‚ü®p2, hp2, rfl‚ü©) }
rintros v ‚ü®p1, p2, hp1, hp2, hv‚ü©
rw ‚Üêvsub_sub_vsub_cancel_right p1 p2 p at hv
rw [‚Üêhv, set_like.mem_coe, submodule.mem_span]
exact Œª m hm, submodule.sub_mem _ (hm ‚ü®p1, hp1, rfl‚ü©) (hm ‚ü®p2, hp2, rfl‚ü©)
rintros v ‚ü®p2, hp2, hv‚ü©
{ rintros v ‚ü®p2, hp2, hv‚ü©, exact ‚ü®p2, p, hp2, hp, hv‚ü© }
exact ‚ü®p2, p, hp2, hp, hv‚ü©
intros
simp [centroid_def, affine_combination_map, centroid_weights]
intros
simp only [line_map_apply_module]
exact add_le_add_right (smul_le_smul_of_nonneg ha (sub_nonneg.2 hr)) _
intros
simp only [alternatization_def, smul_apply, sum_apply]
intros
simpa using map_comap_subtype p ‚ä§
intros
rw [b.equiv_fun_symm_apply, finset.sum_eq_single i]
{ rw [std_basis_same, one_smul] }
rw [std_basis_same, one_smul]
rintros j - hj
{ rintros j - hj, rw [std_basis_ne _ _ _ _ hj, zero_smul] }
rw [std_basis_ne _ _ _ _ hj, zero_smul]
intro
{ intro, have := mem_univ i, contradiction }
have := mem_univ i
contradiction
intros
erw [‚Üêalg_hom.map_mul, ring_quot.mk_alg_hom_rel R (rel.of m), alg_hom.commutes]
refl
intros
apply trunc.induction_on tb
{ apply trunc.induction_on tb, intro b, rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b'] }
intro b
rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']
intros
refine dim_le_of_submodule _ _ _
rw [linear_map.range_comp]
exact linear_map.map_le_range
intros
apply linear_independent_le_span' v i w
rw s
exact le_top
intros
fsplit
intro h
{ intro h, haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le), exact ‚ü®basis_unique Œπ h‚ü© }
haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)
exact ‚ü®basis_unique Œπ h‚ü©
rintro ‚ü®b‚ü©
{ rintro ‚ü®b‚ü©, simpa using finrank_eq_card_basis b }
simpa using finrank_eq_card_basis b
intros
rw ‚Üêlinear_equiv.finrank_eq (submodule.comap_subtype_equiv_of_le hle) at hd
exact le_antisymm hle (submodule.comap_subtype_eq_top.1 (eq_top_of_finrank_eq (le_antisymm (comap (submodule.subtype S‚ÇÇ) S‚ÇÅ).finrank_le hd)))
intros
let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin Œ±)
let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin Œ≤)
exact le_of_fin_injective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map) (((linear_equiv.symm Q).injective.comp i).comp (linear_equiv.injective P))
intros
rw [‚Üê linear_independent_fin_snoc, fin.snoc_init_self]
intros
nontriviality R
exact (linear_independent_subtype_range hf.injective).2 hf
intros
refine ‚ü®le_sup_left, Œª z‚ÇÅ z‚ÇÇ hz, _‚ü©
rw [‚Üê add_zero (f _), ‚Üê g.map_zero]
refine (sup_apply h _ _ _ _).symm
simpa
intros
rw det_to_block M p
convert upper_two_block_triangular_det (to_block M p p) (to_block M p (Œª j, ¬¨p j)) (to_block M (Œª j, ¬¨p j) (Œª j, ¬¨p j))
ext
exact h ‚Üëi i.2 ‚Üëj j.2
intros
intros v w h
ext k
rw [‚Üê circulant_col_zero_eq v, ‚Üê circulant_col_zero_eq w, h]
intros
{ intros i j h, simp [ha h] }
intros i j h
simp [ha h]
intros
{ ext, refl }
ext
refl
intros
{ ext, refl }
ext
refl
intros
rw [‚Üêtrace_transpose, ‚Üêtrace_transpose_mul, transpose_mul]
intros
{ ext, simp }
ext
simp
intros
tidy
intros
simp only [‚Üê coe_ltensor_hom, map_sub]
intros
rw [iterate_succ, (commute.self_iterate f n).comp_eq]
intros
induction hbc
case trans_gen.single : c hbc { exact tail' hab hbc }
case trans_gen.tail : c d hbc hcd hac { exact hac.tail hcd }
intros
simp_rw [prod_apply hs] at h2s
{ simp_rw [prod_apply hs] at h2s, refine ae_lt_top (measurable_measure_prod_mk_left hs) h2s }
refine ae_lt_top (measurable_measure_prod_mk_left hs) h2s
intros
ext1
refine (mem_‚Ñíp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_smul _ _).symm
rw condexp_ind_smul_smul' hs hŒºs c x
refine (Lp.coe_fn_smul _ _).trans _
refine (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hŒºs x).mono (Œª y hy, _)
rw [pi.smul_apply, pi.smul_apply, hy]
intros
symmetry
rw [‚Üê sub_eq_zero, ‚Üê inner_sub_left, condexp_L2]
simp only [mem_Lp_meas_iff_ae_measurable'.mpr hg, orthogonal_projection_inner_eq_zero]
intros
simpa [has_finite_integral] using hfi
intros
simp only [of_real_norm_eq_coe_nnnorm, edist_eq_coe_nnnorm]
intros
have h_two : ennreal.of_real (2 : ‚Ñù) = 2
simp [zero_le_one]
simp [zero_le_one]
rw [snorm_norm_rpow f zero_lt_two, one_mul, h_two]
exact ennreal.rpow_lt_top_of_nonneg zero_le_two (Lp.snorm_ne_top f)
intros
rw [snorm_eq_snorm' hp_ne_zero hp_ne_top, snorm']
intros
induction l with f l ihl
exact measurable_one
{ exact measurable_one }
rw [list.forall_mem_cons] at hl
rw [list.prod_cons]
exact hl.1.mul (ihl hl.2)
intros
obtain ‚ü®C, hC‚ü© : ‚àÉ C, ‚àÄ·∂† s in (l.lift' powerset), ‚àÄ x ‚àà s, ‚à•f x‚à• ‚â§ C
from hf.imp (Œª C hC, eventually_lift'_powerset.2 ‚ü®_, hC, Œª t, id‚ü©)
rcases (hfm.eventually.and (hŒº.eventually.and hC)).exists_measurable_mem_of_lift' with ‚ü®s, hsl, hsm, hfm, hŒº, hC‚ü©
refine ‚ü®s, hsl, ‚ü®hfm, has_finite_integral_restrict_of_bounded hŒº _‚ü©‚ü©
exact C
rw [ae_restrict_eq hsm, eventually_inf_principal]
exact eventually_of_forall hC
intros
simpa [mul_comm] using integral_deriv_comp_smul_deriv hf hg hf' hg'
intros
rw [‚Üê integral_comp_add_left, ‚Üê integral_comp_mul_left _ hc]
intros
have A : ‚à´‚Åª a, f a ‚àÇŒº = ‚à´‚Åª a, hf.mk f a ‚àÇŒº := lintegral_congr_ae hf.ae_eq_mk
have B : ‚à´‚Åª a, r * f a ‚àÇŒº = ‚à´‚Åª a, r * hf.mk f a ‚àÇŒº := lintegral_congr_ae (eventually_eq.fun_comp hf.ae_eq_mk _)
rw [A, B, lintegral_const_mul _ hf.measurable_mk]
intros
simp only [lintegral, measure.restrict_apply, f.measurable_set_preimage]
intros
calc ‚à´‚Åª (a : Œ±), ((f * g) a) ‚àÇŒº ‚â§ ‚à´‚Åª (a : Œ±), ((f a)^p / ennreal.of_real p + (g a)^q / ennreal.of_real q) ‚àÇŒº : lintegral_mono (Œª a, young_inequality (f a) (g a) hpq) ... = 1 : begin simp only [div_eq_mul_inv], rw lintegral_add', { rw [lintegral_mul_const'' _ (hf.pow_const p), lintegral_mul_const'' _ (hg.pow_const q), hf_norm, hg_norm, ‚Üê div_eq_mul_inv, ‚Üê div_eq_mul_inv, hpq.inv_add_inv_conj_ennreal], }, { exact (hf.pow_const _).mul_const _, }, { exact (hg.pow_const _).mul_const _, }, end
intros
rw [‚Üê integral_indicator hs, ‚Üê integral_indicator (measurable_set_le measurable_const hf)]
exact integral_mono (hfi.indicator hs) (hfi.indicator (measurable_set_le measurable_const hf)) (indicator_le_indicator_nonneg s f)
intros
refine ‚ü®_, Œª hs, ‚ü®Œª t ht, ‚ü®s, mem_principal_self s, hs, ht‚ü©‚ü©‚ü©
rintros ‚ü®hs‚ü©
rcases hs (mem_principal_self s) with ‚ü®t, ht, htm, hts‚ü©
have : t = s := subset.antisymm hts ht
rwa ‚Üê this
intros
rw [infi, measurable_set_Inf, forall_range_iff]
intros
rintro ‚ü®K, hK‚ü© h2K
{ rintro ‚ü®K, hK‚ü© h2K, rw [mem_Icc], exact ‚ü®prehaar_nonneg K‚ÇÄ _, prehaar_le_index K‚ÇÄ _ hU‚ü© }
rw [mem_Icc]
exact ‚ü®prehaar_nonneg K‚ÇÄ _, prehaar_le_index K‚ÇÄ _ hU‚ü©
intros
rw [‚Üê empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]
intros
simp only [‚Üê Iic_diff_right, diff_ae_eq_self, measure_mono_null (set.inter_subset_right _ _) (measure_singleton a)]
intros
rw [measure_eq_infi' (map f Œº)]
refine le_infi _
rintro ‚ü®t, hst, ht‚ü©
convert measure_mono (preimage_mono hst)
exact map_apply hf ht
intros
rw [le_bounded_by, forall_congr]
{ rw [le_bounded_by, forall_congr], intro s, cases s.eq_empty_or_nonempty with h h; simp [h] }
intro s
cases s.eq_empty_or_nonempty with h h
cases s.eq_empty_or_nonempty with h h; simp [h]
simp [h]
simp [h]
intros
by_cases hi : measurable_set i
{ exact (restrict_le_restrict_iff _ _ hi).2 h }
exact (restrict_le_restrict_iff _ _ hi).2 h
rw [restrict_not_measurable v hi, restrict_not_measurable w hi]
{ rw [restrict_not_measurable v hi, restrict_not_measurable w hi], exact le_refl _ }
exact le_refl _
intros
rw ‚Üê encodable.Union_decode‚ÇÇ
{ rw ‚Üê encodable.Union_decode‚ÇÇ, exact d.has_Union_nat (encodable.Union_decode‚ÇÇ_disjoint_on hd) (Œª n, encodable.Union_decode‚ÇÇ_cases d.has_empty h) }
exact d.has_Union_nat (encodable.Union_decode‚ÇÇ_disjoint_on hd) (Œª n, encodable.Union_decode‚ÇÇ_cases d.has_empty h)
intros
simp
intros
rw [sum_range_succ_comm, bernoulli'_def n, nat.sub_self]
conv in (n.choose (_ - _)) { rw choose_symm (mem_range.1 H).le }
simp only [one_mul, cast_one, sub_self, sub_add_cancel, choose_zero_right, zero_add, div_one]
intros
dsimp [bit1]
{ dsimp [bit1], simp, }
simp
intros
induction n; simp [cast_eq_of_rat_of_nat]
induction n
simp [cast_eq_of_rat_of_nat]
simp [cast_eq_of_rat_of_nat]
intros
{ simp only [norm, mul_im, mul_re], ring }
simp only [norm, mul_im, mul_re]
ring
intros
{ cases o, exacts [iff.rfl, eq_comm, iff.rfl] }
cases o
exacts [iff.rfl, eq_comm, iff.rfl]
intros
rw [sup_sdiff, sdiff_self, sup_bot_eq]
intros
refine ‚ü®Œª H, ‚ü®‚ü®monotone_fst.mem_upper_bounds_image H.1, Œª a ha, _‚ü©, ‚ü®monotone_snd.mem_upper_bounds_image H.1, Œª a ha, _‚ü©‚ü©, Œª H, ‚ü®_, _‚ü©‚ü©
suffices : (a, p.2) ‚àà upper_bounds s
{ suffices : (a, p.2) ‚àà upper_bounds s, from (H.2 this).1, exact Œª q hq, ‚ü®ha $ mem_image_of_mem _ hq, (H.1 hq).2‚ü© }
from (H.2 this).1
exact Œª q hq, ‚ü®ha $ mem_image_of_mem _ hq, (H.1 hq).2‚ü©
suffices : (p.1, a) ‚àà upper_bounds s
{ suffices : (p.1, a) ‚àà upper_bounds s, from (H.2 this).2, exact Œª q hq, ‚ü®(H.1 hq).1, ha $ mem_image_of_mem _ hq‚ü© }
from (H.2 this).2
exact Œª q hq, ‚ü®(H.1 hq).1, ha $ mem_image_of_mem _ hq‚ü©
exact Œª q hq, ‚ü®H.1.1 $ mem_image_of_mem _ hq, H.2.1 $ mem_image_of_mem _ hq‚ü©
{ exact Œª q hq, ‚ü®H.1.1 $ mem_image_of_mem _ hq, H.2.1 $ mem_image_of_mem _ hq‚ü© }
exact Œª q hq, ‚ü®H.1.2 $ monotone_fst.mem_upper_bounds_image hq, H.2.2 $ monotone_snd.mem_upper_bounds_image hq‚ü©
{ exact Œª q hq, ‚ü®H.1.2 $ monotone_fst.mem_upper_bounds_image hq, H.2.2 $ monotone_snd.mem_upper_bounds_image hq‚ü© }
intros
simp_rw [independent, set_independent, set_coe.forall, Sup_eq_supr]
apply forall_congr
intro a
apply forall_congr
intro ha
congr' 2
convert supr_subtype.symm
simp [supr_and]
intros
simpa [classical.em] using @infi_union _ _ _ f {i | p i} {i | ¬¨ p i}
intros
rw Inf_eq_argmin_on hs
{ rw Inf_eq_argmin_on hs, exact ‚ü®argmin_on_mem _ _ _ _, Œª a ha, argmin_on_le id _ _ ha‚ü© }
exact ‚ü®argmin_on_mem _ _ _ _, Œª a ha, argmin_on_le id _ _ ha‚ü©
intros
choose u hu using h
cases forall_and_distrib.mp hu with hu hu'
exact ‚ü®u ‚àò (nat.rec 0 (Œª n v, u v)), strict_mono_nat_of_lt_succ (Œª n, hu _), Œª n, hu' _‚ü©
intros
rw ‚Üê prod_at_bot_at_bot_eq
{ rw ‚Üê prod_at_bot_at_bot_eq, exact tendsto_id.prod_mk tendsto_id }
exact tendsto_id.prod_mk tendsto_id
intros
simp only [hl'.ge_iff, hl.mem_iff]
intros
simpa only [sub_eq_add_neg] using h.add h'.neg
intros
rw [map_comap, subtype.range_coe]
intros
rw mem_inf_principal
filter_upwards [hs]
intros a has hat
exact ‚ü®has, hat‚ü©
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
by_cases h : ‚àÉi, a ‚àâ s i
rcases h with ‚ü®i, hi‚ü©
{ rcases h with ‚ü®i, hi‚ü©, refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _), rw [indicator_of_not_mem _ _, indicator_of_not_mem _ _], { simp only [mem_Inter, not_forall], exact ‚ü®i, hi‚ü© }, { assume h, have := hs hn h, contradiction } }
refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _)
rw [indicator_of_not_mem _ _, indicator_of_not_mem _ _]
{ simp only [mem_Inter, not_forall], exact ‚ü®i, hi‚ü© }
simp only [mem_Inter, not_forall]
exact ‚ü®i, hi‚ü©
{ assume h, have := hs hn h, contradiction }
assume h
have := hs hn h
contradiction
push_neg at h
{ push_neg at h, simp only [indicator_of_mem, h, (mem_Inter.2 h), tendsto_const_pure] }
simp only [indicator_of_mem, h, (mem_Inter.2 h), tendsto_const_pure]
intros
simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self]
intros
revert hu_le
rw [‚Üênot_imp_not, not_frequently]
simp_rw ‚Üêlt_iff_not_ge
exact Œª h, eventually_lt_of_limsup_lt h hu
intros
obtain ‚ü®g, hr | hnr‚ü© := exists_increasing_or_nonincreasing_subseq' r f
refine ‚ü®g, or.intro_left _ (Œª m n mn, _)‚ü©
{ refine ‚ü®g, or.intro_left _ (Œª m n mn, _)‚ü©, obtain ‚ü®x, rfl‚ü© := le_iff_exists_add.1 (nat.succ_le_iff.2 mn), induction x with x ih, { apply hr }, { apply is_trans.trans _ _ _ _ (hr _), exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _)) } }
obtain ‚ü®x, rfl‚ü© := le_iff_exists_add.1 (nat.succ_le_iff.2 mn)
induction x with x ih
{ apply hr }
apply hr
apply is_trans.trans _ _ _ _ (hr _)
{ apply is_trans.trans _ _ _ _ (hr _), exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _)) }
exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _))
{ exact ‚ü®g, or.intro_right _ hnr‚ü© }
exact ‚ü®g, or.intro_right _ hnr‚ü©
intros
{ ext a b, exact f.map_rel_iff.symm }
ext a b
exact f.map_rel_iff.symm
intros
classical
split
{ exact has_min, }
exact has_min
set counterexamples := { x : Œ± | ¬¨ acc r x}
{ set counterexamples := { x : Œ± | ¬¨ acc r x}, intro exists_max, fconstructor, intro x, by_contra hx, obtain ‚ü®m, m_mem, hm‚ü© := exists_max counterexamples ‚ü®x, hx‚ü©, refine m_mem (acc.intro _ ( Œª y y_gt_m, _)), by_contra hy, exact hm y hy y_gt_m, }
intro exists_max
fconstructor
intro x
by_contra hx
obtain ‚ü®m, m_mem, hm‚ü© := exists_max counterexamples ‚ü®x, hx‚ü©
refine m_mem (acc.intro _ ( Œª y y_gt_m, _))
by_contra hy
exact hm y hy y_gt_m
intros
simp [mul_antidiagonal]
intros
obtain ‚ü®n, w‚ü© := monotone_stabilizes_iff_artinian.mpr I (f.iterate_range.comp ‚ü®Œª n, n+1, Œª n m w, by linarith‚ü©)
specialize w ((n + 1) + n) (by linarith)
dsimp at w
refine ‚ü®n + 1, nat.succ_ne_zero _, _‚ü©
simp_rw [eq_top_iff', mem_sup]
intro x
have : (f^(n + 1)) x ‚àà (f ^ ((n + 1) + n + 1)).range
{ rw ‚Üê w, exact mem_range_self _ }
rw ‚Üê w
exact mem_range_self _
rcases this with ‚ü®y, hy‚ü©
use x - (f ^ (n+1)) y
split
rw [linear_map.mem_ker, linear_map.map_sub, ‚Üê hy, sub_eq_zero, pow_add]
{ rw [linear_map.mem_ker, linear_map.map_sub, ‚Üê hy, sub_eq_zero, pow_add], simp [iterate_add_apply], }
simp [iterate_add_apply]
use (f^ (n+1)) y
{ use (f^ (n+1)) y, simp }
simp
intros
{ rw is_coprime_comm at h ‚ä¢, exact h.of_add_mul_left_left }
rw is_coprime_comm at h ‚ä¢
exact h.of_add_mul_left_left
intros
rw order_of_ne hx
exact x.is_wf_support.min_mem (support_nonempty_iff.2 hx)
intros
rw [is_unit_iff_dvd_one, ‚Üê span_singleton_le_span_singleton, span_singleton_one, eq_top_iff]
intros
ext x
split
intro hx
{ intro hx, obtain ‚ü®y, hy‚ü© := quotient.mk_surjective x, rw [ring_hom.mem_ker, ‚Üê hy, ideal.quotient.lift_mk, ‚Üê ring_hom.mem_ker] at hx, rw [‚Üê hy, mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective], exact ‚ü®y, hx, rfl‚ü© }
obtain ‚ü®y, hy‚ü© := quotient.mk_surjective x
rw [ring_hom.mem_ker, ‚Üê hy, ideal.quotient.lift_mk, ‚Üê ring_hom.mem_ker] at hx
rw [‚Üê hy, mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective]
exact ‚ü®y, hx, rfl‚ü©
intro hx
{ intro hx, rw mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective at hx, obtain ‚ü®y, hy‚ü© := hx, rw [ring_hom.mem_ker, ‚Üê hy.right, ideal.quotient.lift_mk, ‚Üê (ring_hom.mem_ker f)], exact hy.left }
rw mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective at hx
obtain ‚ü®y, hy‚ü© := hx
rw [ring_hom.mem_ker, ‚Üê hy.right, ideal.quotient.lift_mk, ‚Üê (ring_hom.mem_ker f)]
exact hy.left
intros
simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]
intros
apply @is_prime_of_is_prime_prod_top _ R
rw ‚Üêmap_prod_comm_prod
exact map_is_prime_of_equiv _
intros
cases int.prime.dvd_mul hp h with hp2 hpp
apply or.intro_left
{ apply or.intro_left, exact le_antisymm (nat.le_of_dvd zero_lt_two hp2) (nat.prime.two_le hp) }
exact le_antisymm (nat.le_of_dvd zero_lt_two hp2) (nat.prime.two_le hp)
apply or.intro_right
{ apply or.intro_right, rw [sq, int.nat_abs_mul] at hpp, exact (or_self _).mp ((nat.prime.dvd_mul hp).mp hpp)}
rw [sq, int.nat_abs_mul] at hpp
exact (or_self _).mp ((nat.prime.dvd_mul hp).mp hpp)
intros
refine ‚ü®_, is_jacobson_polynomial_of_is_jacobson‚ü©
introI H
exact is_jacobson_of_surjective ‚ü®eval‚ÇÇ_ring_hom (ring_hom.id _) 1, Œª x, ‚ü®C x, by simp only [coe_eval‚ÇÇ_ring_hom, ring_hom.id_apply, eval‚ÇÇ_C]‚ü©‚ü©
intros
refine eq.trans _ (congr rfl x.single_order_mul_power_series_part)
rw [‚Üê mul_assoc, single_mul_single, neg_add_self, mul_one, ‚Üê C_apply, C_one, one_mul, coe_power_series]
intros
rcases hb with ‚ü®b', hb‚ü©
use a * b'
rw [‚Üêhb, (algebra_map R S).map_mul, algebra.smul_def]
intros
{ unfold has_scalar.smul localization.smul, apply lift_on_mk }
unfold has_scalar.smul localization.smul
apply lift_on_mk
intros
apply multiplicity.multiplicity_eq_zero_of_not_dvd
rwa zero_dvd_iff
intros
split
split; rintros ‚ü®n, hn‚ü©; use n; simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ‚ä¢ hn; exact hn
split; rintros ‚ü®n, hn‚ü©; use n; simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ‚ä¢ hn
split; rintros ‚ü®n, hn‚ü©; use n
split; rintros ‚ü®n, hn‚ü©
rintros ‚ü®n, hn‚ü©
use n
simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ‚ä¢ hn
exact hn
exact hn
rintros ‚ü®n, hn‚ü©
use n
simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ‚ä¢ hn
exact hn
exact hn
intros
rw is_noetherian_iff_well_founded at h ‚ä¢
exact order_embedding.well_founded (submodule.map_subtype.order_embedding N).dual h
intros
rw [‚Üê C_1, content_C, normalize_one]
intros
simp [scale_roots, coeff_monomial] {contextual := tt}
intros
apply polynomial.induction_on' p
intros p q hp hq
{ intros p q hp hq, ext, simp [hp, hq, coeff_add, add_apply, std_basis_matrix_add], }
ext
simp [hp, hq, coeff_add, add_apply, std_basis_matrix_add]
intros k x
{ intros k x, simp only [mat_poly_equiv_coeff_apply_aux_1, coeff_monomial], split_ifs; { funext, simp, }, }
simp only [mat_poly_equiv_coeff_apply_aux_1, coeff_monomial]
split_ifs; { funext, simp, }
split_ifs
{ funext, simp, }
funext
{ funext, simp, }
simp
intros
split
intro h
{ intro h, ext n, rw [(coeff R n).map_zero, coeff_of_lt_order], simp [h] }
ext n
rw [(coeff R n).map_zero, coeff_of_lt_order]
simp [h]
{ rintros rfl, exact order_zero }
rintros rfl
exact order_zero
intros
rw [eq_comm, mv_power_series.eq_inv_iff_mul_eq_one h]
intros
simp only [coeff, finsupp.single_add, add_comm n 1]
convert œÜ.coeff_add_monomial_mul (single () 1) (single () n) _
rw one_mul
intros
obtain ‚ü®a, nz, rfl‚ü© := associates.exists_non_zero_rep h‚ÇÅ
rw [factors_mk _ nz, ‚Üê with_top.some_eq_coe, count_some, multiset.le_count_iff_repeat_le, ‚Üê factors_le, factors_prime_pow h‚ÇÇ, factors_mk _ nz]
exact with_top.coe_le_coe
intros
by_cases ha0 : a = 0
rw ha0
{ rw ha0, exact dvd_zero p }
exact dvd_zero p
obtain ‚ü®a0, nza, ha'‚ü© := exists_non_zero_rep ha0
rw [‚Üê associates.factors_prod a]
rw [‚Üê ha', factors_mk a0 nza] at hm ‚ä¢
erw prod_coe
apply multiset.dvd_prod
apply multiset.mem_map.mpr
exact ‚ü®‚ü®p, hp‚ü©, mem_factor_set_some.mp hm, rfl‚ü©
intros
simp only [truncated_witt_vector, fintype.card_fin, fintype.card_fun]
intros
rw [to_nat_apply_of_lt_omega (nat_lt_omega n), ‚Üê nat_cast_inj]
exact (classical.some_spec (lt_omega.1 (nat_lt_omega n))).symm
intros
rw [‚Üêord_lt_ord, ‚Üêsup_ord]
{ rw [‚Üêord_lt_ord, ‚Üêsup_ord], apply sup_lt_ord _ H1, intro i, rw ord_lt_ord, apply H2 }
apply sup_lt_ord _ H1
intro i
rw ord_lt_ord
apply H2
intros
rw [quot_mul_comm, quot_neg_mul, quot_mul_comm]
intros
intro h
have t := state.right_bound m
rw h at t
exact nat.not_succ_le_zero _ t
intros
rw [subsingleton.elim h (f.trans g)]
{ rw [subsingleton.elim h (f.trans g)], apply principal_seg.lt_top }
apply principal_seg.lt_top
intros
simpa only [mul_succ] using lt_mul_succ_div a h
intros
{ cases x, cases y, rw mk_le_mk, refl }
cases x
cases y
rw mk_le_mk
refl
intros
{ cases x, refl }
cases x
refl
intros
rw [sub_eq_add_neg, h]
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
apply val_except_eq_val_except update_eq_of_ne (get_set_eq_of_ne _)
intros
simp only [val]
by_cases h1 : m = 1
rw [if_pos h1, h1, one_mul]
rw [if_neg h1, mul_comm]
intros
simp [add_const]
cases k; simp! *
cases k
simp! *
simp! *
simp [show znum.pos k ‚â† 0, from dec_trivial]
induction e with n a x n b A B; simp *
induction e with n a x n b A B
simp *
rcases cs with ‚ü®n, rfl‚ü©
{ rcases cs with ‚ü®n, rfl‚ü©, refine ‚ü®‚ü®n + num.pos k, by simp [add_comm]; refl‚ü©, _‚ü©, cases n; simp! }
refine ‚ü®‚ü®n + num.pos k, by simp [add_comm]; refl‚ü©, _‚ü©
cases n; simp!
cases n
simp!
simp!
simp *
rcases B cs.2 with ‚ü®csb, h‚ü©
{ rcases B cs.2 with ‚ü®csb, h‚ü©, simp! [*, cs.1], rw [‚Üê tactic.ring.horner_add_const, add_comm], rw add_comm }
simp! [*, cs.1]
rw [‚Üê tactic.ring.horner_add_const, add_comm]
rw add_comm
intros
simp
intros
rw [bInter_eq_Inter]
haveI := hs.to_encodable
exact is_GŒ¥_Inter (Œª x, ht x x.2)
intros
apply is_open_map.of_inverse (homothety_continuous x t‚Åª¬π)
apply is_open_map.of_inverse (homothety_continuous x t‚Åª¬π); intros e; simp [‚Üê affine_map.comp_apply, ‚Üê homothety_mul, ht]
apply is_open_map.of_inverse (homothety_continuous x t‚Åª¬π); intros e
intros e
simp [‚Üê affine_map.comp_apply, ‚Üê homothety_mul, ht]
intros e
simp [‚Üê affine_map.comp_apply, ‚Üê homothety_mul, ht]
intros
simpa [‚Üê hs.compl_eq] using (has_sum_subtype_iff_indicator.1 ha).add (has_sum_subtype_iff_indicator.1 hb)
intros
convert has_sum_zero
intros
rcases h with ‚ü®f, hf‚ü©
have : ker (id R M - (subtype_val p).comp f) = p := linear_map.ker_id_sub_eq_of_proj hf
exact this ‚ñ∏ (is_closed_ker _)
intros
convert is_closed_closure
intros
rw mem_nhds_within_Ioi_iff_exists_Ioo_subset
split
rintros ‚ü®u, au, as‚ü©
{ rintros ‚ü®u, au, as‚ü©, rcases exists_between au with ‚ü®v, hv‚ü©, exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© }
rcases exists_between au with ‚ü®v, hv‚ü©
exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©
rintros ‚ü®u, au, as‚ü©
{ rintros ‚ü®u, au, as‚ü©, exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü© }
exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü©
intros
simpa [(‚àò)] using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)
intros
have : ((Œªx:Œ≤√óŒ≤, x.2 - x.1) ‚àò (Œªx:Œ±√óŒ±, (f x.1, f x.2))) = (Œªx:Œ±√óŒ±, f (x.2 - x.1))
{ simp only [f.map_sub] }
simp only [f.map_sub]
rw [uniform_continuous, uniformity_eq_comap_nhds_zero Œ±, uniformity_eq_comap_nhds_zero Œ≤, tendsto_comap_iff, this]
exact tendsto.comp h tendsto_comap
intros
refine is_topological_basis_of_open_of_nhds (Œª u hu, _) _
simp only [mem_Union, mem_image] at hu
{ simp only [mem_Union, mem_image] at hu, rcases hu with ‚ü®i, s, sb, rfl‚ü©, exact (Uo i).is_open_map_subtype_coe _ ((hb i).is_open sb) }
rcases hu with ‚ü®i, s, sb, rfl‚ü©
exact (Uo i).is_open_map_subtype_coe _ ((hb i).is_open sb)
intros a u ha uo
{ intros a u ha uo, rcases Union_eq_univ_iff.1 Uc a with ‚ü®i, hi‚ü©, lift a to ‚Ü•(U i) using hi, rcases (hb i).exists_subset_of_mem_open (by exact ha) (uo.preimage continuous_subtype_coe) with ‚ü®v, hvb, hav, hvu‚ü©, exact ‚ü®coe '' v, mem_Union.2 ‚ü®i, mem_image_of_mem _ hvb‚ü©, mem_image_of_mem _ hav, image_subset_iff.2 hvu‚ü© }
rcases Union_eq_univ_iff.1 Uc a with ‚ü®i, hi‚ü©
lift a to ‚Ü•(U i) using hi
rcases (hb i).exists_subset_of_mem_open (by exact ha) (uo.preimage continuous_subtype_coe) with ‚ü®v, hvb, hav, hvu‚ü©
exact ‚ü®coe '' v, mem_Union.2 ‚ü®i, mem_image_of_mem _ hvb‚ü©, mem_image_of_mem _ hav, image_subset_iff.2 hvu‚ü©
intros
simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]
convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)
simp only [inter_distrib_left, inter_distrib_right, inter_assoc]
congr' 2
apply inter_comm
intros
rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq]
rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq]; refl
refl
intros
{ ext, simp, }
ext
simp
intros
have w := mem_closure_iff_frequently.mp (continuous_map_mem_subalgebra_closure_of_separates_points A w f)
rw metric.nhds_basis_ball.frequently_iff at w
obtain ‚ü®g, H, m‚ü© := w Œµ pos
rw [metric.mem_ball, dist_eq_norm] at H
exact ‚ü®‚ü®g, m‚ü©, H‚ü©
intros
rw [nhds_within, principal_univ, inf_top_eq]
intros
letI := a.total_space_topology
refine is_open_supr_iff.mpr (Œª y, is_open_coinduced.mpr (is_open_induced_iff.mpr ‚ü®(a.pretrivialization_at x).target, (a.pretrivialization_at x).open_target, _‚ü©))
rw [pretrivialization.set_symm, restrict, (a.pretrivialization_at x).target_eq, (a.pretrivialization_at x).source_eq, preimage_comp, subtype.preimage_coe_eq_preimage_coe_iff, (a.pretrivialization_at y).target_eq, prod_inter_prod, inter_univ, pretrivialization.preimage_symm_proj_inter]
intros
{ rw ‚Üê has_sum_iff_tendsto_nat, exact ennreal.summable.has_sum }
rw ‚Üê has_sum_iff_tendsto_nat
exact ennreal.summable.has_sum
intros
have h_f_coe : f = Œª n, real.to_nnreal (f n : ‚Ñù)
from funext (Œª n, real.to_nnreal_coe.symm)
rw [h_f_coe, ‚Üê @real.to_nnreal_coe 0]
exact tendsto_of_real ((summable_coe.mpr hf).tendsto_cofinite_zero)
intros
ext
ext; simp
simp
simp
simp
intros
cases S.eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
rcases hS.exists_surjective h with ‚ü®f, hf‚ü©
{ rcases hS.exists_surjective h with ‚ü®f, hf‚ü©, have F : ‚àÄn, f n ‚àà S := Œªn, by rw hf; exact mem_range_self _, rw [hf, sInter_range], exact dense_Inter_of_open_nat (Œªn, ho _ (F n)) (Œªn, hd _ (F n)) }
have F : ‚àÄn, f n ‚àà S := Œªn, by rw hf; exact mem_range_self _
rw [hf, sInter_range]
exact dense_Inter_of_open_nat (Œªn, ho _ (F n)) (Œªn, hd _ (F n))
intros
simp only [diam, emetric.diam_pair, dist_edist]
intros
apply diam_le (Œª x hx y hy, edist_pi_le_iff.mpr _)
rw [mem_univ_pi] at hx hy
exact Œª b, diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)
intros
rw Hausdorff_edist
intros
cases s.eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
{ simp [Hausdorff_dist, Hausdorff_edist_empty h] }
simp [Hausdorff_dist, Hausdorff_edist_empty h]
intros
rw [‚Üê image_symm, diam_image]
intros
rw continuous_def
rintros s ‚ü®t, ht, s_eq‚ü©
simpa [‚Üê s_eq] using continuous_def.1 h t ht
intros
simp only [continuous_on, continuous_within_at_iff_lower_upper_semicontinuous_within_at]
exact ‚ü®Œª H, ‚ü®Œª x hx, (H x hx).1, Œª x hx, (H x hx).2‚ü©, Œª H x hx, ‚ü®H.1 x hx, H.2 x hx‚ü©‚ü©
intros
dsimp [res, left_res, right_res]
ext
simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, fan.mk_œÄ_app, category.assoc]
rw [‚ÜêF.map_comp]
rw [‚ÜêF.map_comp]
congr
intros
induction n with n ihn generalizing c
{ exact indicator_of_not_mem (Œª hU, hU $ c.subset hx) _ }
exact indicator_of_not_mem (Œª hU, hU $ c.subset hx) _
simp only [approx]
{ simp only [approx], rw [ihn, ihn, midpoint_self], exacts [c.subset_right_C hx, hx] }
rw [ihn, ihn, midpoint_self]
exacts [c.subset_right_C hx, hx]
intros
rw [‚Üê stream.eta (map f (a :: s)), map_eq]
refl
intros
cases b; simp
cases b
simp
simp
intros
rw [int.sub_eq_add_neg, ‚Üê int.neg_add]; refl
rw [int.sub_eq_add_neg, ‚Üê int.neg_add]
refl
intros
rw [‚Üê int.add_assoc, int.add_left_neg, int.zero_add]
intros
have h := int.add_lt_add_left h a
rwa [‚Üê int.add_sub_assoc, int.add_comm a c, int.add_sub_cancel] at h
intros
rw [qsort, well_founded.fix_eq, qsort.F]
induction e : partition (Œª x, lt h x = tt) t with large small
simp [e]
rw [e]
intros
rw [nat.add_comm, add_mod_right]
intros
simp [‚Üê not_le]
apply not_iff_not_of_iff
apply le_div_iff_mul_le _ _ Hk
intros
rw [‚Üêadd_right_inj (p2 -·µ• p1 : G), vsub_add_vsub_cancel, ‚Üêneg_vsub_eq_vsub_rev, vadd_vsub, ‚Üêadd_sub_assoc, ‚Üêneg_vsub_eq_vsub_rev, neg_add_self, zero_sub]
intros
rw [‚Üê(one_smul A m), ‚Üêsmul_assoc, algebra.smul_def, mul_one, one_smul]
intros
{ ext, simp }
ext
simp
intros
simp [sum_ite]
intros
by_cases hg : (mul_support $ g ‚àò plift.down).finite
exact f.map_finprod_plift g hg
{ exact f.map_finprod_plift g hg }
rw [finprod, dif_neg, f.map_one, finprod, dif_neg]
exacts [infinite.mono (Œª x hx, mt (hf (g x.down)) hx) hg, hg]
intros
rcases lt_trichotomy a 0 with h|rfl|h
rw [‚Üê neg_eq_zero, ‚Üê int.cast_neg, ‚Üê dvd_neg]
{ rw [‚Üê neg_eq_zero, ‚Üê int.cast_neg, ‚Üê dvd_neg], lift -a to ‚Ñï using neg_nonneg.mpr (le_of_lt h) with b, rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd] }
lift -a to ‚Ñï using neg_nonneg.mpr (le_of_lt h) with b
rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd]
{ simp only [int.cast_zero, eq_self_iff_true, dvd_zero] }
simp only [int.cast_zero, eq_self_iff_true, dvd_zero]
lift a to ‚Ñï using (le_of_lt h) with b
{ lift a to ‚Ñï using (le_of_lt h) with b, rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd] }
rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd]
intros
rw [‚Üê mul_two, mul_div_cancel a two_ne_zero']
intros
simp [nth_cont_eq_succ_nth_cont_aux, (second_continuant_aux_eq zeroth_s_eq)]
intros
simpa only [one_mul] using mul_div_cancel 1 a0
intros
simpa only [‚Üê @div_self _ _ b h] using (div_sub_div_same b a b).symm
intros
{ ext, simp [ceil_le] }
ext
simp [ceil_le]
intros
simpa only [lcm_comm b a] using lcm_eq_left_iff b a h
intros
rw [‚Üê lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add]
{ rw [‚Üê lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add], simp }
simp
intros
simp only [mul_left_comm, mul_assoc]
intros
rw [sub_eq_add_neg, add_right_neg a]
intros
revert b
rw forall_is_conj
intro b
rw [carrier, eq_comm, mk_eq_mk_iff_is_conj, ‚Üê quotient_mk_eq_mk, quotient.lift_mk]
refl
intros
simp only [bit1, pow_succ, neg_pow_bit0, neg_mul_eq_neg_mul]
intros
induction n with n ih; [rw [zero_nsmul, nat.cast_zero, mul_zero], rw [succ_nsmul', ih, nat.cast_succ, mul_add, mul_one]]
induction n with n ih
rw [zero_nsmul, nat.cast_zero, mul_zero]
rw [succ_nsmul', ih, nat.cast_succ, mul_add, mul_one]
intros
cases lt_or_eq_of_le Hxpos
rw ‚Üênat.sub_add_cancel Hnpos
{ rw ‚Üênat.sub_add_cancel Hnpos, induction (n - 1), { simpa only [pow_one] }, rw [pow_add, pow_add, nat.succ_eq_add_one, pow_one, pow_one], apply mul_lt_mul ih (le_of_lt Hxy) h (le_of_lt (pow_pos (lt_trans h Hxy) _)) }
induction (n - 1)
simpa only [pow_one]
{ simpa only [pow_one] }
rw [pow_add, pow_add, nat.succ_eq_add_one, pow_one, pow_one]
apply mul_lt_mul ih (le_of_lt Hxy) h (le_of_lt (pow_pos (lt_trans h Hxy) _))
rw [‚Üêh, zero_pow Hnpos]
{ rw [‚Üêh, zero_pow Hnpos], apply pow_pos (by rwa ‚Üêh at Hxy : 0 < y),}
apply pow_pos (by rwa ‚Üêh at Hxy : 0 < y)
intros
rw [eq_comm, div_eq_iff_mul_eq hc]
intros
simp only [semiconj_by, mul_zero, zero_mul]
intros
{ dsimp [of], rw [if_pos rfl, category.id_comp] }
dsimp [of]
rw [if_pos rfl, category.id_comp]
intros
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, comap_coe_submodule, lie_submodule.sup_coe_to_submodule, f.ker_coe_submodule, ‚Üê submodule.comap_map_eq, lie_submodule.lie_ideal_oper_eq_linear_span, lie_submodule.lie_ideal_oper_eq_linear_span, linear_map.map_span]
congr
simp only [lie_hom.coe_to_linear_map, set.mem_set_of_eq]
ext y
split
rintros ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©, hy‚ü©
{ rintros ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©, hy‚ü©, rw ‚Üê hy, erw [lie_submodule.mem_inf, f.mem_ideal_range_iff h] at hx‚ÇÅ hx‚ÇÇ, obtain ‚ü®‚ü®z‚ÇÅ, hz‚ÇÅ‚ü©, hz‚ÇÅ'‚ü© := hx‚ÇÅ, rw ‚Üê hz‚ÇÅ at hz‚ÇÅ', obtain ‚ü®‚ü®z‚ÇÇ, hz‚ÇÇ‚ü©, hz‚ÇÇ'‚ü© := hx‚ÇÇ, rw ‚Üê hz‚ÇÇ at hz‚ÇÇ', use [‚ÅÖz‚ÇÅ, z‚ÇÇ‚ÅÜ, ‚ü®z‚ÇÅ, hz‚ÇÅ'‚ü©, ‚ü®z‚ÇÇ, hz‚ÇÇ'‚ü©, rfl], simp only [hz‚ÇÅ, hz‚ÇÇ, submodule.coe_mk, lie_hom.map_lie], }
rw ‚Üê hy
erw [lie_submodule.mem_inf, f.mem_ideal_range_iff h] at hx‚ÇÅ hx‚ÇÇ
obtain ‚ü®‚ü®z‚ÇÅ, hz‚ÇÅ‚ü©, hz‚ÇÅ'‚ü© := hx‚ÇÅ
rw ‚Üê hz‚ÇÅ at hz‚ÇÅ'
obtain ‚ü®‚ü®z‚ÇÇ, hz‚ÇÇ‚ü©, hz‚ÇÇ'‚ü© := hx‚ÇÇ
rw ‚Üê hz‚ÇÇ at hz‚ÇÇ'
use [‚ÅÖz‚ÇÅ, z‚ÇÇ‚ÅÜ, ‚ü®z‚ÇÅ, hz‚ÇÅ'‚ü©, ‚ü®z‚ÇÇ, hz‚ÇÇ'‚ü©, rfl]
simp only [hz‚ÇÅ, hz‚ÇÇ, submodule.coe_mk, lie_hom.map_lie]
rintros ‚ü®x, ‚ü®‚ü®z‚ÇÅ, hz‚ÇÅ‚ü©, ‚ü®z‚ÇÇ, hz‚ÇÇ‚ü©, hx‚ü©, hy‚ü©
{ rintros ‚ü®x, ‚ü®‚ü®z‚ÇÅ, hz‚ÇÅ‚ü©, ‚ü®z‚ÇÇ, hz‚ÇÇ‚ü©, hx‚ü©, hy‚ü©, rw [‚Üê hy, ‚Üê hx], have hz‚ÇÅ' : f z‚ÇÅ ‚àà f.ideal_range ‚äì J‚ÇÅ, { rw lie_submodule.mem_inf, exact ‚ü®f.mem_ideal_range, hz‚ÇÅ‚ü©, }, have hz‚ÇÇ' : f z‚ÇÇ ‚àà f.ideal_range ‚äì J‚ÇÇ, { rw lie_submodule.mem_inf, exact ‚ü®f.mem_ideal_range, hz‚ÇÇ‚ü©, }, use [‚ü®f z‚ÇÅ, hz‚ÇÅ'‚ü©, ‚ü®f z‚ÇÇ, hz‚ÇÇ'‚ü©], simp only [submodule.coe_mk, lie_hom.map_lie], }
rw [‚Üê hy, ‚Üê hx]
have hz‚ÇÅ' : f z‚ÇÅ ‚àà f.ideal_range ‚äì J‚ÇÅ
{ rw lie_submodule.mem_inf, exact ‚ü®f.mem_ideal_range, hz‚ÇÅ‚ü©, }
rw lie_submodule.mem_inf
exact ‚ü®f.mem_ideal_range, hz‚ÇÅ‚ü©
have hz‚ÇÇ' : f z‚ÇÇ ‚àà f.ideal_range ‚äì J‚ÇÇ
{ rw lie_submodule.mem_inf, exact ‚ü®f.mem_ideal_range, hz‚ÇÇ‚ü©, }
rw lie_submodule.mem_inf
exact ‚ü®f.mem_ideal_range, hz‚ÇÇ‚ü©
use [‚ü®f z‚ÇÅ, hz‚ÇÅ'‚ü©, ‚ü®f z‚ÇÇ, hz‚ÇÇ'‚ü©]
simp only [submodule.coe_mk, lie_hom.map_lie]
intros
have h : ‚àÄ (K K' : lie_subalgebra R L), (K : set L) ‚â§ K' ‚Üî K ‚â§ K'
intros
{ intros, exact iff.rfl, }
exact iff.rfl
apply is_glb.of_image h
simp only [Inf_coe]
exact is_glb_binfi
intros
have aux : ‚àÄ (x : L) m, m ‚àà (N ‚äî N' : submodule R M) ‚Üí ‚ÅÖx,m‚ÅÜ ‚àà (N ‚äî N' : submodule R M)
simp only [submodule.mem_sup]
{ simp only [submodule.mem_sup], rintro x m ‚ü®y, hy, z, hz, rfl‚ü©, refine ‚ü®‚ÅÖx, y‚ÅÜ, N.lie_mem hy, ‚ÅÖx, z‚ÅÜ, N'.lie_mem hz, (lie_add _ _ _).symm‚ü© }
rintro x m ‚ü®y, hy, z, hz, rfl‚ü©
refine ‚ü®‚ÅÖx, y‚ÅÜ, N.lie_mem hy, ‚ÅÖx, z‚ÅÜ, N'.lie_mem hz, (lie_add _ _ _).symm‚ü©
refine le_antisymm (Inf_le ‚ü®{ lie_mem := aux, ..(N ‚äî N' : submodule R M) }, _‚ü©) _
simp only [exists_prop, and_true, mem_set_of_eq, eq_self_iff_true, coe_to_submodule_mk, ‚Üê coe_submodule_le_coe_submodule, and_self, le_sup_left, le_sup_right]
{ simp only [exists_prop, and_true, mem_set_of_eq, eq_self_iff_true, coe_to_submodule_mk, ‚Üê coe_submodule_le_coe_submodule, and_self, le_sup_left, le_sup_right] }
{ simp, }
simp
intros
rw ideal_range_eq_map
exact lie_ideal.mem_map (lie_submodule.mem_top x)
intros
{ ext x, refl }
ext x
refl
intros
{ rw [inv_eq_one_div], exact div_le_iff' ha }
rw [inv_eq_one_div]
exact div_le_iff' ha
intros
rw [lt_div_iff hb, one_mul]
intros
rw [mul_comm b c, ‚Üê div_sub_div _ _ hc hd, sub_lt_zero]
intros
{ rw [‚Üê mul_le_mul_iff_left a], simp }
rw [‚Üê mul_le_mul_iff_left a]
simp
intros
{ ext x, refl }
ext x
refl
intros
simp [abs_eq_max_neg]
intros
lift a to Œ± using ha
lift b to Œ± using hb
simp only [‚Üê coe_mul, coe_lt_top]
intros
{ convert mul_le_mul_left h, simp }
convert mul_le_mul_left h
simp
intros
simpa only [sub_eq_neg_add] using h.int_mul n (-x)
intros
rw image_eq_preimage_of_inverse; intro c; simp
rw image_eq_preimage_of_inverse; intro c
{ rw image_eq_preimage_of_inverse; intro c; simp }
rw image_eq_preimage_of_inverse
intro c
simp
intro c
simp
intros
rw next_coeff_multiset_prod
simp only [next_coeff_X_sub_C]
{ simp only [next_coeff_X_sub_C], refine t.sum_hom ‚ü®has_neg.neg, _, _‚ü©; simp [add_comm] }
refine t.sum_hom ‚ü®has_neg.neg, _, _‚ü©; simp [add_comm]
refine t.sum_hom ‚ü®has_neg.neg, _, _‚ü©
simp [add_comm]
simp [add_comm]
{ intros, apply monic_X_sub_C }
intros
apply monic_X_sub_C
intros
have h2 : (2 : K) ‚â† 0 := nonzero_of_invertible 2
rw [quadratic_eq_zero_iff_discrim_eq_sq h2 ha, h, sq, mul_self_eq_mul_self_iff]
have ne : 2 * a ‚â† 0 := mul_ne_zero h2 ha
have : x = 2 * a * x / (2 * a) := (mul_div_cancel_left x ne).symm
have h‚ÇÅ : 2 * a * ((-b + s) / (2 * a)) = -b + s := mul_div_cancel' _ ne
have h‚ÇÇ : 2 * a * ((-b - s) / (2 * a)) = -b - s := mul_div_cancel' _ ne
split
intro h'
{ intro h', rcases h', { left, rw h', simpa [add_comm] }, { right, rw h', simpa [add_comm, sub_eq_add_neg] } }
rcases h'
{ left, rw h', simpa [add_comm] }
left
rw h'
simpa [add_comm]
{ right, rw h', simpa [add_comm, sub_eq_add_neg] }
right
rw h'
simpa [add_comm, sub_eq_add_neg]
intro h'
{ intro h', rcases h', { left, rw [h', h‚ÇÅ], ring }, { right, rw [h', h‚ÇÇ], ring } }
rcases h'
left
{ left, rw [h', h‚ÇÅ], ring }
rw [h', h‚ÇÅ]
ring
right
{ right, rw [h', h‚ÇÇ], ring }
rw [h', h‚ÇÇ]
ring
intros
rw [a.conj_eq_two_re_sub]
exact (coe_commute (2 * a.re) a).sub_left (commute.refl a)
intros
simp only [sub_eq_add_neg, h.neg.add_right]
intros
tidy
intros
induction n with n IH
{ simp }
simp
{ rw [add_nsmul, IH, one_nsmul, add_self] }
rw [add_nsmul, IH, one_nsmul, add_self]
intros
rw [topological_space.opens.le_def, basic_open_eq_zero_locus_compl, basic_open_eq_zero_locus_compl, set.le_eq_subset, set.compl_subset_compl, zero_locus_subset_zero_locus_singleton_iff]
intros
rw right_inv
intros
simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left
intros
contrapose! hf'
rcases hf' with ‚ü®‚ü®b, hb, hmb‚ü©, ‚ü®a, ha, hma‚ü©‚ü©
exact (convex_image_has_deriv_at hs hf).ord_connected.out (mem_image_of_mem f' ha) (mem_image_of_mem f' hb) ‚ü®hma, hmb‚ü©
intros
rcases eq_or_ne x 0 with rfl|hne
simp [deriv_zero_of_not_differentiable_at (mt differentiable_at_inv.1 (not_not.2 rfl))]
{ simp [deriv_zero_of_not_differentiable_at (mt differentiable_at_inv.1 (not_not.2 rfl))] }
{ exact (has_deriv_at_inv hne).deriv }
exact (has_deriv_at_inv hne).deriv
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hf.const_smul c
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
by_cases h : differentiable_within_at ùïú f s x
rw [fderiv.comp_fderiv_within x iso.differentiable_at h hxs, iso.fderiv]
{ rw [fderiv.comp_fderiv_within x iso.differentiable_at h hxs, iso.fderiv] }
have : ¬¨differentiable_within_at ùïú (iso ‚àò f) s x
{ have : ¬¨differentiable_within_at ùïú (iso ‚àò f) s x, from mt iso.comp_differentiable_within_at_iff.1 h, rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this, continuous_linear_map.comp_zero] }
from mt iso.comp_differentiable_within_at_iff.1 h
rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this, continuous_linear_map.comp_zero]
intros
assume x xs
rcases h x xs with ‚ü®t, t_open, xt, ht‚ü©
exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 (ht x ‚ü®xs, xt‚ü©)
intros
cases hc with hE hc
haveI : subsingleton s := ‚ü®Œª x y, subtype.eq $ @subsingleton.elim _ hE _ _‚ü©
{ haveI : subsingleton s := ‚ü®Œª x y, subtype.eq $ @subsingleton.elim _ hE _ _‚ü©, exact antilipschitz_with.of_subsingleton }
exact antilipschitz_with.of_subsingleton
convert (f'.antilipschitz.restrict s).add_lipschitz_with hf.lipschitz_sub hc
simp [restrict]
intros
rcases submodule.exists_le_ker_of_lt_top _ (lt_top_iff_ne_top.2 $ hextr.range_ne_top_of_has_strict_fderiv_at hf' hœÜ') with ‚ü®Œõ', h0, hŒõ'‚ü©
set e : ((F ‚Üí‚Çó[‚Ñù] ‚Ñù) √ó ‚Ñù) ‚âÉ‚Çó[‚Ñù] (F √ó ‚Ñù ‚Üí‚Çó[‚Ñù] ‚Ñù) := ((linear_equiv.refl ‚Ñù (F ‚Üí‚Çó[‚Ñù] ‚Ñù)).prod (linear_map.ring_lmap_equiv_self ‚Ñù ‚Ñù ‚Ñù).symm).trans (linear_map.coprod_equiv ‚Ñù)
rcases e.surjective Œõ' with ‚ü®‚ü®Œõ, Œõ‚ÇÄ‚ü©, rfl‚ü©
refine ‚ü®Œõ, Œõ‚ÇÄ, e.map_ne_zero_iff.1 h0, Œª x, _‚ü©
convert linear_map.congr_fun (linear_map.range_le_ker_iff.1 hŒõ') x using 1
simp only [linear_map.coprod_equiv_apply, linear_equiv.refl_apply, linear_map.ring_lmap_equiv_self_symm_apply, linear_map.comp_apply, continuous_linear_map.coe_coe, continuous_linear_map.prod_apply, linear_equiv.trans_apply, linear_equiv.prod_apply, linear_map.coprod_apply, linear_map.smul_right_apply, linear_map.one_apply, smul_eq_mul, mul_comm]
intros
simpa using continuous_linear_map.ext_iff.1 (h.has_fderiv_at_eq_zero (has_deriv_at_iff_has_fderiv_at.1 hf)) 1
intros
simpa only [univ_inter] using unique_diff_within_at_univ.inter h
intros
induction n with n IH
{ ext x, simp }
ext x
simp
ext x m
{ ext x m, rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ] }
rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ]
intros
set f' := Œª y, continuous_multilinear_curry_fin1 ‚Ñù E F (p y 1)
have hder : ‚àÄ y ‚àà s, has_fderiv_within_at f (f' y) s y
from Œª y hy, (hf.has_fderiv_within_at le_rfl (subset_insert x s hy)).mono (subset_insert x s)
have hcont : continuous_within_at f' s x
from (continuous_multilinear_curry_fin1 ‚Ñù E F).continuous_at.comp_continuous_within_at ((hf.cont _ le_rfl _ (mem_insert _ _)).mono (subset_insert x s))
replace hK : ‚à•f' x‚à•‚Çä < K
simpa only [linear_isometry_equiv.nnnorm_map]
simpa only [linear_isometry_equiv.nnnorm_map]
exact hs.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at_of_nnnorm_lt (eventually_nhds_within_iff.2 $ eventually_of_forall hder) hcont K hK
intros
refine hs.mem_to_cone.trans ‚ü®_, _‚ü©
rintros ‚ü®c, hc, y, hy, rfl‚ü©
{ rintros ‚ü®c, hc, y, hy, rfl‚ü©, exact ‚ü®c‚Åª¬π, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]‚ü© }
exact ‚ü®c‚Åª¬π, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]‚ü©
rintros ‚ü®c, hc, hcx‚ü©
{ rintros ‚ü®c, hc, hcx‚ü©, exact ‚ü®c‚Åª¬π, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]‚ü© }
exact ‚ü®c‚Åª¬π, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]‚ü©
intros
rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove, mem_diff]
apply adjoin_eq_span_of_subset
refine subset.trans _ submodule.subset_span
intros x hx
apply submonoid.closure_induction hx (Œª _, id) ‚ü®0, rfl‚ü©
rintros _ _ ‚ü®m, rfl‚ü© ‚ü®n, rfl‚ü©
refine ‚ü®m + n, _‚ü©
ext1 z
exact fourier_add
intros
simp only [inner_add_left, inner_add_right]; ring
simp only [inner_add_left, inner_add_right]
ring
intros
{ have h := @norm_sub_mul_self ‚Ñù F _ _, simpa using h }
have h := @norm_sub_mul_self ‚Ñù F _ _
simpa using h
intros
simpa only [dist_eq_norm] using dist_comm g h
intros
simp only [le_rank_iff_exists_linear_independent_finset, set_of_exists, ‚Üê exists_prop]
refine is_open_bUnion (Œª t ht, _)
have : continuous (Œª f : E ‚ÜíL[ùïú] F, (Œª x : (t : set E), f x))
from continuous_pi (Œª x, (continuous_linear_map.apply ùïú F (x : E)).continuous)
exact is_open_set_of_linear_independent.preimage this
intros
{ ext, refl }
ext
refl
intros
refine ‚ü®abs C + 1, _, _‚ü©
{ linarith [abs_nonneg C] }
linarith [abs_nonneg C]
apply h.mono
{ apply h.mono, linarith [le_abs_self C] }
linarith [le_abs_self C]
intros
rwa [quotient_norm_eq_zero_iff, hS.closure_eq] at h
intros
refine f.op_norm_le_bound hC (Œª x, _)
by_cases hx : ‚à•x‚à• = 0
rw [hx, mul_zero]
{ rw [hx, mul_zero], exact le_of_eq (norm_image_of_norm_zero f.2 hx) }
exact le_of_eq (norm_image_of_norm_zero f.2 hx)
exact linear_map.bound_of_shell_semi_normed f Œµ_pos hc hf hx
intros
by_cases hx : x = 0
simp [hx]
{ simp [hx] }
exact linear_map.bound_of_shell_semi_normed f Œµ_pos hc hf (ne_of_lt (norm_pos_iff.2 hx)).symm
simp [arg, le_refl]
norm_num [real.pi_ne_zero, I_ne_zero]
intros
simpa only [sq, sub_eq_add_neg, neg_mul_eq_mul_neg] using integral_deriv_mul_eq_sub (Œª x hx, has_deriv_at_sin x) (Œª x hx, has_deriv_at_cos x) continuous_on_cos.interval_integrable continuous_on_sin.neg.interval_integrable
intros
by_cases hp : P = 0
simpa [hp] using is_O_zero (Œª x, eval x Q) filter.at_top
{ simpa [hp] using is_O_zero (Œª x, eval x Q) filter.at_top }
have hq : Q ‚â† 0 := ne_zero_of_degree_ge_degree h hp
{ have hq : Q ‚â† 0 := ne_zero_of_degree_ge_degree h hp, have hPQ : ‚àÄ·∂† (x : ùïú) in at_top, eval x Q = 0 ‚Üí eval x P = 0 := filter.mem_of_superset (polynomial.eventually_no_roots Q hq) (Œª x h h', absurd h' h), cases le_iff_lt_or_eq.mp h with h h, { exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h) }, { exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h) } }
have hPQ : ‚àÄ·∂† (x : ùïú) in at_top, eval x Q = 0 ‚Üí eval x P = 0 := filter.mem_of_superset (polynomial.eventually_no_roots Q hq) (Œª x h h', absurd h' h)
cases le_iff_lt_or_eq.mp h with h h
exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h)
{ exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h) }
exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h)
{ exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h) }
intros
by_cases hp_zero : p = 0
{ simp [hp_zero, ennreal.zero_lt_one], }
simp [hp_zero, ennreal.zero_lt_one]
rw ‚Üêne.def at hp_zero
{ rw ‚Üêne.def at hp_zero, have hp_pos := lt_of_le_of_ne hp_nonneg hp_zero.symm, rw ‚Üêzero_rpow_of_pos hp_pos, exact rpow_lt_rpow hx_pos hp_pos, }
have hp_pos := lt_of_le_of_ne hp_nonneg hp_zero.symm
rw ‚Üêzero_rpow_of_pos hp_pos
exact rpow_lt_rpow hx_pos hp_pos
intros
rw rpow_def_of_pos hx; apply exp_pos
rw rpow_def_of_pos hx
apply exp_pos
intros
apply exp_injective
rw [exp_log (rpow_pos_of_pos hx y), ‚Üê exp_log hx, mul_comm, rpow_def_of_pos (exp_pos (log x)) y]
intros
convert (has_strict_fderiv_at_rpow_of_pos ((Œª x, (f x, g x)) x) h).comp_has_strict_deriv_at _ (hf.prod hg) using 1
simp [mul_assoc, mul_comm, mul_left_comm]
intros
rw [‚Üê mul_self_eq_one_iff, ‚Üê sin_sq_add_cos_sq x, sq, sq, ‚Üê sub_eq_iff_eq_add, sub_self]
rw [‚Üê mul_self_eq_one_iff, ‚Üê sin_sq_add_cos_sq x, sq, sq, ‚Üê sub_eq_iff_eq_add, sub_self]; exact ‚ü®Œª h, by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero ‚àò eq.symm‚ü©
exact ‚ü®Œª h, by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero ‚àò eq.symm‚ü©
intros
simp only [sinh, div_eq_mul_inv]
convert ((has_strict_deriv_at_exp x).add (has_strict_deriv_at_id x).neg.cexp).mul_const (2:‚ÑÇ)‚Åª¬π
rw [id, mul_neg_one, sub_eq_add_neg]
funext x
by_cases h : x ‚â† -1 ‚àß x ‚â† 1
{ exact (has_deriv_at_arcsin h.1 h.2).deriv }
exact (has_deriv_at_arcsin h.1 h.2).deriv
rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_arcsin.1 h)]
{ rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_arcsin.1 h)], simp only [not_and_distrib, ne.def, not_not] at h, rcases h with (rfl|rfl); simp }
simp only [not_and_distrib, ne.def, not_not] at h
rcases h with (rfl|rfl); simp
rcases h with (rfl|rfl)
simp
simp
intros
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _; simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
intros
simp [dist_eq_norm', sum_range_succ]
intros
simp [unit_comp_partial_bijective_aux]
intros
simp
intros
constructor
intros Z g h H
replace H := congr_arg (adj.hom_equiv Z Y).symm H
rwa [adj.hom_equiv_naturality_right_symm, adj.hom_equiv_naturality_right_symm, cancel_mono, equiv.apply_eq_iff_eq] at H
intros
simp
intros
rw [‚Üêeq_comp_inv, id_comp]
intros
{ dsimp [colimit_limit_to_limit_colimit], simp, }
dsimp [colimit_limit_to_limit_colimit]
simp
intros
ext j
ext j; erw [assoc, limit.pre_œÄ, limit.pre_œÄ, limit.pre_œÄ]; refl
ext j; erw [assoc, limit.pre_œÄ, limit.pre_œÄ, limit.pre_œÄ]
erw [assoc, limit.pre_œÄ, limit.pre_œÄ, limit.pre_œÄ]
refl
intros
ext
rw [‚Üêassoc, colimit.Œπ_post, ‚ÜêH.map_comp, colimit.Œπ_map, H.map_comp]
rw [‚Üêassoc, colimit.Œπ_map, assoc, colimit.Œπ_post]
refl
intros
tidy
intros
simp [biproduct.components]
intros
rw hI.hom_ext f (hI.to X)
apply initial_mono_class.is_initial_mono_from
intros
{ ext, refl }
ext
refl
intros
rw [associator_inv_naturality, hom_inv_id_assoc]
intros
simp
intros
ext
change c _ (sieve.pullback f S) = ‚ä§ ‚Üî c _ S f
rw [pb, sieve.pullback_eq_top_iff_mem]
intros
rw ‚Üê id_mem_iff_eq_top
exact ‚ü®_, section_ f, f, hf, by simp‚ü©
intros
simp [of_le_mk]
intros
apply length_pos_of_sum_pos
convert h
exact c.blocks_sum
intros
{ ext, simp }
ext
simp
intros
rw [‚Üêcard_neighbor_set_eq_degree]
exact set.card_le_of_subset (set.inter_subset_left _ _)
intros
simp only [step_set, set.mem_Union, set.bind_def]
intros
induction d‚ÇÅ using many_one_degree.ind_on
induction d‚ÇÇ using many_one_degree.ind_on
induction d‚ÇÉ using many_one_degree.ind_on
simpa only [‚Üê add_of, of_le_of] using disjoin_le
intros
obtain ‚ü®i, h‚ÇÅ, h‚ÇÇ‚ü© := tr_init c v
refine part.ext (Œª x, _)
rw [reaches_eval h‚ÇÇ.to_refl]
simp
refine ‚ü®Œª h, _, _‚ü©
obtain ‚ü®c, hc‚ÇÅ, hc‚ÇÇ‚ü© := tr_eval_rev tr_respects h‚ÇÅ h
{ obtain ‚ü®c, hc‚ÇÅ, hc‚ÇÇ‚ü© := tr_eval_rev tr_respects h‚ÇÅ h, simp [step_normal_eval] at hc‚ÇÇ, obtain ‚ü®v', hv, rfl‚ü© := hc‚ÇÇ, exact ‚ü®_, hv, hc‚ÇÅ.symm‚ü© }
simp [step_normal_eval] at hc‚ÇÇ
obtain ‚ü®v', hv, rfl‚ü© := hc‚ÇÇ
exact ‚ü®_, hv, hc‚ÇÅ.symm‚ü©
rintro ‚ü®v', hv, rfl‚ü©
{ rintro ‚ü®v', hv, rfl‚ü©, have := tr_eval tr_respects h‚ÇÅ, simp [step_normal_eval] at this, obtain ‚ü®_, ‚ü®‚ü©, h‚ü© := this _ hv rfl, exact h }
have := tr_eval tr_respects h‚ÇÅ
simp [step_normal_eval] at this
obtain ‚ü®_, ‚ü®‚ü©, h‚ü© := this _ hv rfl
exact h
intros
cases x
cases x; refl
refl
intros
induction x; simp! * with functor_norm; refl
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
simp [list.mem_iff_nth, to_list_nth, and.comm, and.assoc, and.left_comm]
intros
by_cases p; simp *
by_cases p
simp *
simp *
intros
rw ‚Üêbuffer.size_eq_zero_iff
have : char_buf cb' cb' 0 = done cb'.size () := by simp [char_buf_eq_done]
cases hc : cb'.size with n
{ simp only [eq_self_iff_true, iff_true], exact ‚ü®Œª _ _ _ _ h, by simpa [hc] using (char_buf_eq_done.mp h).left‚ü© }
simp only [eq_self_iff_true, iff_true]
exact ‚ü®Œª _ _ _ _ h, by simpa [hc] using (char_buf_eq_done.mp h).left‚ü©
rw hc at this
{ rw hc at this, simpa [nat.succ_ne_zero] using not_of_ne this (nat.succ_ne_zero n).symm }
simpa [nat.succ_ne_zero] using not_of_ne this (nat.succ_ne_zero n).symm
intros
constructor
intros cb n hn
haveI : (parser.foldl_core f b p (cb.size - n + 1)).bounded := foldl_core he
obtain ‚ü®np, errp, hp‚ü© := bounded.exists (parser.foldl_core f b p (cb.size - n + 1)) hn
simp [foldl, hp]
intros
apply not_step_of_static_done
simp [pure_eq_done]
intros
simp [foldr, foldr_core_succ_eq_fail]
simp [norm_sq]
intros
rw ‚Üê of_real_inj; simp [cosh_three_mul]
rw ‚Üê of_real_inj
simp [cosh_three_mul]
intros
convert cos_add_mul_I z.re z.im; exact (re_add_im z).symm
convert cos_add_mul_I z.re z.im
exact (re_add_im z).symm
intros
rw [‚Üê exp_mul_I, ‚Üê exp_mul_I]
induction n with n ih
rw [pow_zero, nat.cast_zero, zero_mul, zero_mul, exp_zero]
{ rw [pow_zero, nat.cast_zero, zero_mul, zero_mul, exp_zero] }
rw [pow_succ', ih, nat.cast_succ, add_mul, add_mul, one_mul, exp_add]
{ rw [pow_succ', ih, nat.cast_succ, add_mul, add_mul, one_mul, exp_add] }
intros
rw [‚Üê finite_dimensional.finrank_mul_finrank ‚Ñù ‚ÑÇ E, complex.finrank_real_complex]
intros
simp
intros
simp [zip_with_def]
intros
{ ext, refl }
ext
refl
intros
{ ext, simp }
ext
simp
intros
by_cases hx : z = x
simp [hx]
simp [hx]
by_cases hy : z = y
simp [hy]
simp [hy]
rw [equiv.swap_apply_of_ne_of_ne hx hy, equiv.swap_apply_of_ne_of_ne (hf.ne hx) (hf.ne hy)]
intros
simp [fin_succ_equiv_last]
intros
ext x
simp only [map_equiv_apply, refl_apply]
exact is_lawful_functor.id_map x
intros
have A : (e : Œ± ‚Üí Œ≤) = e'
ext x
ext x
{ ext x, exact h x }
{ ext x, exact h x }
exact h x
exact h x
have B : (e.symm : Œ≤ ‚Üí Œ±) = e'.symm
ext x
ext x
{ ext x, exact hsymm x }
{ ext x, exact hsymm x }
exact hsymm x
exact hsymm x
have I : e '' e.source = e.target := e.image_source_eq_target
have I' : e' '' e'.source = e'.target := e'.image_source_eq_target
rw [A, hs, I'] at I
cases e; cases e'
cases e
cases e'
simp * at *
intros
cases i with i hi
rw [add_cases, dif_pos (cast_add_lt _ _)]
refl
intros
refine insert_nth_eq_iff.2 ‚ü®by simp, _‚ü©
ext j
apply eq_of_heq
transitivity snoc (Œª j, _root_.cast (congr_arg Œ± (succ_above_last_apply j)) (p j)) x j.cast_succ
{ rw [snoc_cast_succ], exact (cast_heq _ _).symm }
rw [snoc_cast_succ]
exact (cast_heq _ _).symm
apply congr_arg_heq
{ apply congr_arg_heq, rw [succ_above_last] }
rw [succ_above_last]
intros
cases n
cases k with k h
{ cases k with k h, cases k, {show _ % _ = _, simp}, cases h with _ h, cases h }
cases k
show _ % _ = _
{show _ % _ = _, simp}
simp
cases h with _ h
cases h
simp [bit1, fin.coe_bit0, fin.coe_add, fin.coe_one]
intros
simp [finset.nonempty]
intros
ext (‚ü®‚ü© | ‚ü®n‚ü©); simp [nat.succ_eq_add_one, nat.zero_lt_succ n]
ext (‚ü®‚ü© | ‚ü®n‚ü©)
simp [nat.succ_eq_add_one, nat.zero_lt_succ n]
simp [nat.succ_eq_add_one, nat.zero_lt_succ n]
intros
rw insert_eq_of_mem h
intros
rw [‚Üêwith_bot.coe_le_coe, coe_sup', le_sup_iff (with_bot.bot_lt_coe a)]
exact bex_congr (Œª b hb, with_bot.coe_le_coe)
intros
induction s using quotient.induction_on
simp
intros
classical
{ classical, rw [prod_preimage', prod_filter_of_ne], exact Œª x hx, not.imp_symm (hg x hx) }
rw [prod_preimage', prod_filter_of_ne]
exact Œª x hx, not.imp_symm (hg x hx)
intros
simp
intros
rcases em (a = x) with (rfl|hx); [simp, simp [single_eq_of_ne hx]]
rcases em (a = x) with (rfl|hx)
simp
simp [single_eq_of_ne hx]
intros
simp [fintype.subtype_card, finset.card_univ]
intros
simpa using exists_max_image univ f univ_nonempty
intros
rw [‚Üê fin.succ_above_last, fin.image_succ_above_univ]
intros
dsimp [keys]; rw entries_empty; refl
dsimp [keys]; rw entries_empty
dsimp [keys]
rw entries_empty
refl
intros
cases m with m m; cases n with n n; simp [‚Üê int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
cases m with m m; cases n with n n
cases m with m m
cases n with n n
simp [‚Üê int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
simp [‚Üê int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
cases n with n n
simp [‚Üê int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
simp [‚Üê int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
intros
cases n
cases n; refl
refl
refl
intros
rw [mul_comm, int.add_mul_div_right _ _ H]
intros
rw [‚Üê int.mul_div_cancel' h, H, mul_zero]
intros
induction n; simp *
induction n
simp *
simp *
intros
{ rw [int.lcm], apply nat.lcm_zero_right }
rw [int.lcm]
apply nat.lcm_zero_right
intros
{ rw [sub_eq_add_neg, sub_eq_add_neg], exact h‚ÇÅ.add h‚ÇÇ.neg }
rw [sub_eq_add_neg, sub_eq_add_neg]
exact h‚ÇÅ.add h‚ÇÇ.neg
intros
simp [not_or_distrib] with parity_simps
intros
induction l with b l ih
{ exact iff_of_true rfl (not_mem_nil _) }
exact iff_of_true rfl (not_mem_nil _)
simp only [length, mem_cons_iff, index_of_cons]
split_ifs
{ exact iff_of_false (by rintro ‚ü®‚ü©) (Œª H, H $ or.inl h) }
exact iff_of_false (by rintro ‚ü®‚ü©) (Œª H, H $ or.inl h)
{ simp only [h, false_or], rw ‚Üê ih, exact succ_inj' }
simp only [h, false_or]
rw ‚Üê ih
exact succ_inj'
intros
unfold list.bind; induction l; simp only [map, join, list.ret, cons_append, nil_append, *]; split; refl
unfold list.bind; induction l; simp only [map, join, list.ret, cons_append, nil_append, *]; split
unfold list.bind; induction l; simp only [map, join, list.ret, cons_append, nil_append, *]
unfold list.bind; induction l
unfold list.bind
induction l
simp only [map, join, list.ret, cons_append, nil_append, *]
simp only [map, join, list.ret, cons_append, nil_append, *]
split
intros
induction l‚ÇÅ generalizing n
simp
{ simp }
cases n
simp
{ simp }
simp *
intros
rw [sub_eq_add_neg, alternating_sum]
intros
induction l with l_hd l_tl l_ih
{ apply (hl‚ÇÇ rfl).elim }
apply (hl‚ÇÇ rfl).elim
cases l_tl
{ cases l_tl, { simp }, { apply l_ih } }
{ simp }
simp
{ apply l_ih }
apply l_ih
intros
simp only [reduce_option_nil, concat_eq_append, reduce_option_append, reduce_option_cons_of_some]
intros
simp [permutations, permutations_aux_append]
intros
simp only [mem_union, or_imp_distrib, forall_and_distrib]
intros
induction xs generalizing i j
case list.nil : i j h { cases hi }
case list.cons : x xs xs_ih i j h { cases i; simp only [-slice_eq, list.slice], { cases j, cases h, dsimp only [drop], unfold_wf, apply @lt_of_le_of_lt _ _ _ xs.sizeof, { clear_except, induction xs generalizing j; unfold_wf, case list.nil : j { refl }, case list.cons : xs_hd xs_tl xs_ih j { cases j; unfold_wf, refl, transitivity, apply xs_ih, simp }, }, unfold_wf, apply zero_lt_one_add, }, { unfold_wf, apply xs_ih _ _ h, apply lt_of_succ_lt_succ hi, } }
intros
simp [length_subsingleton_iff]
intros
simpa only [erase_dup, forall_mem_ne, not_not] using not_congr (@forall_mem_pw_filter Œ± (‚â†) _ (Œª x y z xz, not_and_distrib.1 $ mt (and.rec eq.trans) xz) a l)
intros
cases le_total m l with hml hlm
{ rw [min_eq_left hml, filter_lt_of_top_le hml] }
rw [min_eq_left hml, filter_lt_of_top_le hml]
{ rw [min_eq_right hlm, filter_lt_of_ge hlm] }
rw [min_eq_right hlm, filter_lt_of_ge hlm]
intros
have := pairwise_sublists' (pairwise_reverse.2 H)
have := pairwise_sublists' (pairwise_reverse.2 H); rwa [sublists'_reverse, pairwise_map] at this
rwa [sublists'_reverse, pairwise_map] at this
intros
induction h with x _ _ _ _ x y _ _ _ _ _ _ ih_1 ih_2 generalizing t
simp
{simp}
by_cases x ‚àà t; simp [*, perm.cons]
{ by_cases x ‚àà t; simp [*, perm.cons] }
by_cases x ‚àà t
simp [*, perm.cons]
simp [*, perm.cons]
by_cases x = y
{ by_cases x = y, {simp [h]}, by_cases xt : x ‚àà t; by_cases yt : y ‚àà t, { simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap] }, { simp [xt, yt, mt mem_of_mem_erase, perm.cons] }, { simp [xt, yt, mt mem_of_mem_erase, perm.cons] }, { simp [xt, yt] } }
simp [h]
{simp [h]}
by_cases xt : x ‚àà t; by_cases yt : y ‚àà t
by_cases xt : x ‚àà t
by_cases yt : y ‚àà t
simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap]
{ simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap] }
{ simp [xt, yt, mt mem_of_mem_erase, perm.cons] }
simp [xt, yt, mt mem_of_mem_erase, perm.cons]
by_cases yt : y ‚àà t
{ simp [xt, yt, mt mem_of_mem_erase, perm.cons] }
simp [xt, yt, mt mem_of_mem_erase, perm.cons]
{ simp [xt, yt] }
simp [xt, yt]
{ exact (ih_1 _).trans (ih_2 _) }
exact (ih_1 _).trans (ih_2 _)
intros
simp only [range_eq_range', mem_range', nat.zero_le, true_and, zero_add]
intros
rw rotate_eq_rotate'
induction l generalizing l'
{ simp, }
simp
{ simp [rotate', l_ih] }
simp [rotate', l_ih]
intros
simp [‚Üê lookup_is_some, option.is_none_iff_eq_none]
intros
dsimp [erase_dupkeys]
generalize hl : nil = l'
have : nodupkeys l'
rw ‚Üê hl
{ rw ‚Üê hl, apply nodup_nil }
apply nodup_nil
clear hl
induction l with x xs
{ apply this }
apply this
cases x
{ cases x, simp [erase_dupkeys], split, { simp [keys_kerase], apply mem_erase_of_nodup l_ih }, apply kerase_nodupkeys _ l_ih, }
simp [erase_dupkeys]
split
{ simp [keys_kerase], apply mem_erase_of_nodup l_ih }
simp [keys_kerase]
apply mem_erase_of_nodup l_ih
apply kerase_nodupkeys _ l_ih
intros
rw [‚Üê sublists_aux_eq_foldr]; refl
rw [‚Üê sublists_aux_eq_foldr]
refl
intros
simp [tfae, -eq_iff_iff]
intros
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l' with hd' tl'
{ cases l' with hd' tl', { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
ext i j
unfold has_one.one transpose
by_cases i = j
{ simp only [h, diagonal_apply_eq] }
simp only [h, diagonal_apply_eq]
simp only [diagonal_apply_ne h, diagonal_apply_ne (Œª p, h (symm p))]
{ simp only [diagonal_apply_ne h, diagonal_apply_ne (Œª p, h (symm p))] }
intros
by_cases j' = j
{ rw [h, update_column_self, if_pos rfl] }
rw [h, update_column_self, if_pos rfl]
{ rwa [update_column_ne h, if_neg h] }
rwa [update_column_ne h, if_neg h]
intros
simp [dot_product]
intros
simp [dot_product, fin.sum_univ_succ, vec_head, vec_tail]
intros
by_cases h : a = b; simp [h]
by_cases h : a = b
simp [h]
simp [h]
intros
induction h; simp [*]
induction h
simp [*]
simp [*]
intros
simpa using add_le_add_right (zero_le t) s
intros
rw mv_polynomial.ext_iff
apply forall_congr
intro m
rw [coeff_map]
apply eq_iff_eq_cancel_right.mpr
refl
intros
simp only [monomial_eq, ring_hom.map_mul, bind‚ÇÇ_C_right, finsupp.prod, ring_hom.map_prod, ring_hom.map_pow, bind‚ÇÇ_X_right, C_1, one_mul]
intros
rw [supported_eq_range_rename, alg_hom.mem_range]
split
rintros ‚ü®p, rfl‚ü©
{ rintros ‚ü®p, rfl‚ü©, refine trans (finset.coe_subset.2 (vars_rename _ _)) _, simp }
refine trans (finset.coe_subset.2 (vars_rename _ _)) _
simp
intros hs
{ intros hs, exact exists_rename_eq_of_vars_subset_range p (coe : s ‚Üí œÉ) subtype.val_injective (by simpa) }
exact exists_rename_eq_of_vars_subset_range p (coe : s ‚Üí œÉ) subtype.val_injective (by simpa)
intros
{ ext i, rw [mem_vars, finset.mem_bUnion] }
ext i
rw [mem_vars, finset.mem_bUnion]
intros
have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm
have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; rwa [add_right_comm, mod_add_div] at this
rwa [add_right_comm, mod_add_div] at this
intros
{ dunfold decreasing_induction, rw [le_rec_on_self] }
dunfold decreasing_induction
rw [le_rec_on_self]
intros
rw [test_bit, shiftr_eq_div_pow, nat.div_self (pow_pos zero_lt_two n), bodd_one]
intros
{ rw one_div, exact inv_pos_of_nat }
rw one_div
exact inv_pos_of_nat
intros
induction L with d L ih
{ refl, }
refl
{ dsimp [of_digits], rw ih, }
dsimp [of_digits]
rw ih
intros
rw ‚Üêof_digits_one
conv_lhs { rw ‚Üê(of_digits_digits b' n) }
rw [nat.dvd_iff_mod_eq_zero, nat.dvd_iff_mod_eq_zero, of_digits_mod, h]
intros
rw [‚Üê some_eq_coe]
simp only [le_def, exists_prop_of_true, dom_some, forall_true_iff]
refl
intros
refine ‚ü®_, lt_find P n‚ü©
intros h m hm
by_cases H : (find P).dom
apply nat.find_min H
{ apply nat.find_min H, rw coe_lt_iff at h, specialize h H, exact lt_of_le_of_lt hm h }
rw coe_lt_iff at h
specialize h H
exact lt_of_le_of_lt hm h
{ exact not_exists.mp H m }
exact not_exists.mp H m
intros
simp only [modeq_iff_dvd, int.coe_nat_add] at *
rw add_sub_comm at h‚ÇÇ
convert _root_.dvd_sub h‚ÇÇ h‚ÇÅ using 1
rw add_sub_cancel'
intros
rw [mul_comm a, mul_comm b, mul_comm n]; exact h.mul_left' c
rw [mul_comm a, mul_comm b, mul_comm n]
exact h.mul_left' c
intros
rintro ‚ü®t, rfl‚ü©
have h1 : m < t
from nat.mul_self_lt_mul_self_iff.mpr hl
have h2 : t < m + 1
from nat.mul_self_lt_mul_self_iff.mpr hr
exact (not_lt_of_ge $ le_of_lt_succ h2) h1
intros
rw ‚Üê not_lt; exact not_congr lt_to_int
rw ‚Üê not_lt
exact not_congr lt_to_int
intros
rw ‚Üê not_lt; exact not_congr lt_to_nat
rw ‚Üê not_lt
exact not_congr lt_to_nat
intros
cases a; cases b; refl
cases a; cases b
cases a
cases b
refl
refl
cases b
refl
refl
intros
cases a; simp
cases a
simp
simp
intros
rw insert'_eq_insert_with; exact insert_with.valid _ _ (Œª _, id) h
rw insert'_eq_insert_with
exact insert_with.valid _ _ (Œª _, id) h
intros
rw [‚Üê dual_dual (balance_r l x r), dual_balance_r, balance_l_eq_balance' hr.dual hl.dual sr.dual sl.dual (balance_sz_dual H), ‚Üê dual_balance', dual_dual]
intros
rw [obj_append1, obj_append1, map_eq, append_fun, ‚Üê split_fun_comp]
rw [obj_append1, obj_append1, map_eq, append_fun, ‚Üê split_fun_comp]; refl
refl
intros
simpa only [pi.zero_apply, hf', single] using function.apply_update f' 0 i x j
intros
unfold_coes
dsimp[of_pnat_multiset, to_pnat_multiset]
have : (Œª (p : ‚Ñï+) (h : p.prime), ((coe : nat.primes ‚Üí ‚Ñï+) ‚ü®p, h‚ü©)) = (Œª p h, id p) := by {funext p h, apply subtype.eq, refl}
rw[multiset.map_pmap, this, multiset.pmap_eq_map, multiset.map_id]
intros
simp only [monomial, monomial_fun, coeff, linear_map.coe_mk]
{ simp only [monomial, monomial_fun, coeff, linear_map.coe_mk], rw finsupp.single_apply }
rw finsupp.single_apply
intros
{ rcases p, simp [coeff, smul_to_finsupp] }
rcases p
simp [coeff, smul_to_finsupp]
intros
simpa only [C_1, one_mul] using degree_C_mul_X_pow_le n (1:R)
intros
{ rintro rfl, exact nat_degree_not_mem_erase_lead_support h }
rintro rfl
exact nat_degree_not_mem_erase_lead_support h
intros
apply polynomial.induction_on' p
intros p q hp hq
{ intros p q hp hq, simp only [hp, hq, add_mul, add_comp] }
simp only [hp, hq, add_mul, add_comp]
intros n b
{ intros n b, simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp] }
simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp]
intros
simp only [coe_map_ring_hom, lifts, set.mem_range, ring_hom.mem_srange]
intros
simp [monomial, monomial_fun, finsupp.single_eq_single_iff]
intros
{ cases x, cases y, apply Wequiv.abs, apply h }
cases x
cases y
apply Wequiv.abs
apply h
intros
cases d; refl
cases d
refl
intros
rw [rat.inv_def', rat.coe_int_num, rat.coe_int_denom, nat.cast_one, ‚Üêint.cast_one]
apply denom_div_eq_of_coprime ha0
rw int.nat_abs_one
exact nat.coprime_one_left _
intros
have q_num_pos : 0 < q.num
from rat.num_pos_iff_pos.elim_right q_pos
have q_num_abs_eq_q_num : (q.num.nat_abs : ‚Ñ§) = q.num
from (int.nat_abs_of_nonneg $ le_of_lt q_num_pos)
set q_inv := (q.denom : ‚Ñö) / q.num with q_inv_def
have q_inv_eq : q‚Åª¬π = q_inv
from rat.inv_def'
suffices : (q_inv - ‚åäq_inv‚åã).num < q.num
rwa q_inv_eq
rwa q_inv_eq
suffices : ((q.denom - q.num * ‚åäq_inv‚åã : ‚Ñö) / q.num).num < q.num
field_simp [this, (ne_of_gt q_num_pos)]
field_simp [this, (ne_of_gt q_num_pos)]
suffices : (q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã < q.num
have : ((q.denom - q.num * ‚åäq_inv‚åã : ‚Ñö) / q.num).num = q.denom - q.num * ‚åäq_inv‚åã
have : ((q.denom - q.num * ‚åäq_inv‚åã : ‚Ñö) / q.num).num = q.denom - q.num * ‚åäq_inv‚åã
{ have : ((q.denom - q.num * ‚åäq_inv‚åã : ‚Ñö) / q.num).num = q.denom - q.num * ‚åäq_inv‚åã, by { suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }, rwa this }
{ have : ((q.denom - q.num * ‚åäq_inv‚åã : ‚Ñö) / q.num).num = q.denom - q.num * ‚åäq_inv‚åã, by { suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }, rwa this }
suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs
suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs
suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs
{ suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }
{ suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }
{ suffices : ((q.denom : ‚Ñ§) - q.num * ‚åäq_inv‚åã).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö)
have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö)
have : (q.num.nat_abs : ‚Ñö) = (q.num : ‚Ñö)
exact_mod_cast q_num_abs_eq_q_num
exact_mod_cast q_num_abs_eq_q_num
exact_mod_cast q_num_abs_eq_q_num
exact_mod_cast q_num_abs_eq_q_num
have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm
have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm
have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm
simpa only [this, q_num_abs_eq_q_num] using tmp
simpa only [this, q_num_abs_eq_q_num] using tmp
simpa only [this, q_num_abs_eq_q_num] using tmp
rwa this
rwa this
have q_inv_num_denom_ineq : q‚Åª¬π.num - ‚åäq‚Åª¬π‚åã * q‚Åª¬π.denom < q‚Åª¬π.denom
have : q‚Åª¬π.num < (‚åäq‚Åª¬π‚åã + 1) * q‚Åª¬π.denom
have : q‚Åª¬π.num < (‚åäq‚Åª¬π‚åã + 1) * q‚Åª¬π.denom
{ have : q‚Åª¬π.num < (‚åäq‚Åª¬π‚åã + 1) * q‚Åª¬π.denom, from rat.num_lt_succ_floor_mul_denom q‚Åª¬π, have : q‚Åª¬π.num < ‚åäq‚Åª¬π‚åã * q‚Åª¬π.denom + q‚Åª¬π.denom, by rwa [right_distrib, one_mul] at this, rwa [‚Üêsub_lt_iff_lt_add'] at this }
{ have : q‚Åª¬π.num < (‚åäq‚Åª¬π‚åã + 1) * q‚Åª¬π.denom, from rat.num_lt_succ_floor_mul_denom q‚Åª¬π, have : q‚Åª¬π.num < ‚åäq‚Åª¬π‚åã * q‚Åª¬π.denom + q‚Åª¬π.denom, by rwa [right_distrib, one_mul] at this, rwa [‚Üêsub_lt_iff_lt_add'] at this }
from rat.num_lt_succ_floor_mul_denom q‚Åª¬π
from rat.num_lt_succ_floor_mul_denom q‚Åª¬π
have : q‚Åª¬π.num < ‚åäq‚Åª¬π‚åã * q‚Åª¬π.denom + q‚Åª¬π.denom
have : q‚Åª¬π.num < ‚åäq‚Åª¬π‚åã * q‚Åª¬π.denom + q‚Åª¬π.denom
rwa [right_distrib, one_mul] at this
rwa [right_distrib, one_mul] at this
rwa [right_distrib, one_mul] at this
rwa [‚Üêsub_lt_iff_lt_add'] at this
rwa [‚Üêsub_lt_iff_lt_add'] at this
have : q_inv.num = q.denom ‚àß q_inv.denom = q.num.nat_abs
have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs
have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs
{ have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs, from q.cop.symm, have : int.nat_abs q.denom = q.denom, by simp, rw ‚Üêthis at coprime_q_denom_q_num, rw q_inv_def, split, { exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }, { suffices : (((q.denom : ‚Ñö) / q.num).denom : ‚Ñ§) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) } }
{ have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs, from q.cop.symm, have : int.nat_abs q.denom = q.denom, by simp, rw ‚Üêthis at coprime_q_denom_q_num, rw q_inv_def, split, { exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }, { suffices : (((q.denom : ‚Ñö) / q.num).denom : ‚Ñ§) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) } }
from q.cop.symm
from q.cop.symm
have : int.nat_abs q.denom = q.denom
have : int.nat_abs q.denom = q.denom
simp
simp
simp
rw ‚Üêthis at coprime_q_denom_q_num
rw ‚Üêthis at coprime_q_denom_q_num
rw q_inv_def
rw q_inv_def
split
split
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
{ exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
{ exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
suffices : (((q.denom : ‚Ñö) / q.num).denom : ‚Ñ§) = q.num.nat_abs
suffices : (((q.denom : ‚Ñö) / q.num).denom : ‚Ñ§) = q.num.nat_abs
{ suffices : (((q.denom : ‚Ñö) / q.num).denom : ‚Ñ§) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
{ suffices : (((q.denom : ‚Ñö) / q.num).denom : ‚Ñ§) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
exact_mod_cast this
exact_mod_cast this
exact_mod_cast this
rw q_num_abs_eq_q_num
rw q_num_abs_eq_q_num
exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
rwa [q_inv_eq, this.left, this.right, q_num_abs_eq_q_num, mul_comm] at q_inv_num_denom_ineq
convert of_rat_lt.2 zero_lt_one; simp
convert of_rat_lt.2 zero_lt_one
simp
simp
intros
simp [cantor_function_aux, h]
intros
simp [ennreal.of_real]
intros
split
{ rintro rfl, exact bot_lt_coe }
rintro rfl
exact bot_lt_coe
contrapose!
{ contrapose!, intro h, exact ‚ü®x.to_real, coe_to_real_le h‚ü©, }
intro h
exact ‚ü®x.to_real, coe_to_real_le h‚ü©
intros
{ unfold_coes, simp [real.to_ereal] }
unfold_coes
simp [real.to_ereal]
intros
simp [real.to_nnreal, hr, hp, add_nonneg]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, ‚Üê real.to_nnreal_inv, ‚Üê real.to_nnreal_mul hx]
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ‚Ñù)
rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg]
{ rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg] }
{ rw [sign_zero, neg_zero, sign_zero] }
rw [sign_zero, neg_zero, sign_zero]
{ rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)] }
rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)]
intros
unfold to_list
unfold to_list; simp; rw to_list'_map; simp; refl
unfold to_list; simp; rw to_list'_map; simp
unfold to_list; simp; rw to_list'_map
unfold to_list; simp
simp
rw to_list'_map
simp
refl
intros
{ ext x, finish [set.ite, iff_def] }
ext x
finish [set.ite, iff_def]
intros
rcases hs.eq_empty_or_singleton with rfl|‚ü®x, rfl‚ü©
{ rcases hs.eq_empty_or_singleton with rfl|‚ü®x, rfl‚ü©, exacts [he, h‚ÇÅ _] }
exacts [he, h‚ÇÅ _]
intros
{ ext ‚ü®x, y‚ü©, simp [or_and_distrib_right] }
ext ‚ü®x, y‚ü©
simp [or_and_distrib_right]
intros
apply subset.antisymm
rintro _ ‚ü®x, rfl‚ü© i -
{ rintro _ ‚ü®x, rfl‚ü© i -, exact ‚ü®x i, rfl‚ü© }
exact ‚ü®x i, rfl‚ü©
intros x hx
{ intros x hx, choose y hy using hx, exact ‚ü®Œª i, y i trivial, funext $ Œª i, hy i trivial‚ü© }
choose y hy using hx
exact ‚ü®Œª i, y i trivial, funext $ Œª i, hy i trivial‚ü©
intros
ext
split
rintro ‚ü®_, c, ‚ü®a, b, ha, hb, rfl‚ü©, hc, rfl‚ü©
{ rintro ‚ü®_, c, ‚ü®a, b, ha, hb, rfl‚ü©, hc, rfl‚ü©, refine ‚ü®a, b, c, ha, hb, hc, rfl‚ü© }
refine ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
{ rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©, refine ‚ü®_, c, ‚ü®a, b, ha, hb, rfl‚ü©, hc, rfl‚ü© }
refine ‚ü®_, c, ‚ü®a, b, ha, hb, rfl‚ü©, hc, rfl‚ü©
intros
simp [set.ext_iff]
intros
rw maps_to'
intros
ext y
split
rintro ‚ü®x, rfl‚ü©
{ rintro ‚ü®x, rfl‚ü©, by_cases h : x ‚àà s;[left, right]; use x; simp [h] }
by_cases h : x ‚àà s
by_cases h : x ‚àà s;[left, right]; use x; simp [h]
by_cases h : x ‚àà s;[left, right]; use x
by_cases h : x ‚àà s;[left, right]
left
use x
simp [h]
right
use x
simp [h]
rintro (‚ü®x, hx, rfl‚ü©|‚ü®x, hx, rfl‚ü©); use x; simp * at *
rintro (‚ü®x, hx, rfl‚ü©|‚ü®x, hx, rfl‚ü©); use x
rintro (‚ü®x, hx, rfl‚ü©|‚ü®x, hx, rfl‚ü©)
{ rintro (‚ü®x, hx, rfl‚ü©|‚ü®x, hx, rfl‚ü©); use x; simp * at * }
use x
simp * at *
use x
simp * at *
intros
rw [‚Üê Icc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 $ right_mem_Icc.2 h)]
intros
simp [‚Üê Ici_inter_Iio]
intros
simp
intros
simp [‚Üê Ioi_inter_Iic, h]
intros
simp
intros
ext x
simp only [mem_Union, mem_Inter, mem_sInter, exists_imp_distrib]
split
split; tauto
tauto
tauto
intros
induction n; refl
induction n
refl
refl
intros
cases n; simp
cases n
simp
simp
intros
rcases h with ‚ü®u, rfl‚ü©
rw [inv_coe_unit, u.mul_inv]
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strict_mono_id.add_const m) hn
intros
rw [‚Üê hx.eq, ‚Üê hy.eq, ‚Üê iterate_pred_comp_of_pos f hn, comp_app, h]
intros
haveI : is_solvable (q.splitting_field ‚âÉ‚Çê[F] q.splitting_field) := hq
exact solvable_of_surjective (alg_equiv.restrict_normal_hom_surjective q.splitting_field)
intros
cases (zorn.chain_insert hc (Œª _ _ _, or.inl bot_le)).total_of_refl hx hy with hxy hyx
{ exact ‚ü®y, hy, hxy, le_refl y‚ü© }
exact ‚ü®y, hy, hxy, le_refl y‚ü©
{ exact ‚ü®x, hx, le_refl x, hyx‚ü© }
exact ‚ü®x, hx, le_refl x, hyx‚ü©
intros
ext
conv_rhs { rw [ring_hom.one_def, ring_hom.id_apply, ‚Üê pow_card x, hcard], }
clear hcard
induction n
simp
{simp}
rw [pow_succ, pow_succ', pow_mul, ring_hom.mul_def, ring_hom.comp_apply, frobenius_def, n_ih]
intros
induction n with n ih
{ simp }
simp
{ simp [pow_succ, ih] }
simp [pow_succ, ih]
intros
cases irreducible_or_factor (minpoly A x) (not_is_unit A x) with hirr hred
{ exact hirr }
exact hirr
exfalso
obtain ‚ü®a, b, ha_nunit, hb_nunit, hab_eq‚ü© := hred
have coeff_prod : a.leading_coeff * b.leading_coeff = 1
rw [‚Üêmonic.def.1 (monic hx), ‚Üêhab_eq]
{ rw [‚Üêmonic.def.1 (monic hx), ‚Üêhab_eq], simp only [leading_coeff_mul] }
simp only [leading_coeff_mul]
have hamonic : (a * C b.leading_coeff).monic
rw monic.def
{ rw monic.def, simp only [coeff_prod, leading_coeff_mul, leading_coeff_C] }
simp only [coeff_prod, leading_coeff_mul, leading_coeff_C]
have hbmonic : (b * C a.leading_coeff).monic
rw [monic.def, mul_comm]
{ rw [monic.def, mul_comm], simp only [coeff_prod, leading_coeff_mul, leading_coeff_C] }
simp only [coeff_prod, leading_coeff_mul, leading_coeff_C]
have prod : minpoly A x = (a * C b.leading_coeff) * (b * C a.leading_coeff)
symmetry
{ symmetry, calc a * C b.leading_coeff * (b * C a.leading_coeff) = a * b * (C a.leading_coeff * C b.leading_coeff) : by ring ... = a * b * (C (a.leading_coeff * b.leading_coeff)) : by simp only [ring_hom.map_mul] ... = a * b : by rw [coeff_prod, C_1, mul_one] ... = minpoly A x : hab_eq }
calc a * C b.leading_coeff * (b * C a.leading_coeff) = a * b * (C a.leading_coeff * C b.leading_coeff) : by ring ... = a * b * (C (a.leading_coeff * b.leading_coeff)) : by simp only [ring_hom.map_mul] ... = a * b : by rw [coeff_prod, C_1, mul_one] ... = minpoly A x : hab_eq
have hzero := aeval A x
rw [prod, aeval_mul, mul_eq_zero] at hzero
cases hzero
refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hamonic _ hzero
{ refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hamonic _ hzero, exact ‚ü®hamonic.ne_zero, _, mt is_unit_of_mul_is_unit_left hb_nunit, prod‚ü© }
exact ‚ü®hamonic.ne_zero, _, mt is_unit_of_mul_is_unit_left hb_nunit, prod‚ü©
refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hbmonic _ hzero
{ refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hbmonic _ hzero, rw mul_comm at prod, exact ‚ü®hbmonic.ne_zero, _, mt is_unit_of_mul_is_unit_left ha_nunit, prod‚ü© }
rw mul_comm at prod
exact ‚ü®hbmonic.ne_zero, _, mt is_unit_of_mul_is_unit_left ha_nunit, prod‚ü©
intros
simp only [restrict_comp, restrict_surjective]
intros
refine ‚ü®Œª f hf1, _‚ü©
rw ‚Üê coe_fn_coe_base at hf1
have hf2 := eq_C_of_degree_eq_zero (degree_eq_zero_of_is_unit hf1)
rw [coeff_expand hp, if_pos (dvd_zero _), p.zero_div] at hf2
rw [hf2, is_unit_C] at hf1
rw expand_eq_C hp at hf2
rwa [hf2, is_unit_C]
intros
rw [‚Üêneg_neg r, neg_smul, angle_neg_right, angle_smul_right_of_pos x y (neg_pos_of_neg hr), angle_neg_right]
intros
rw [‚Üêmul_self_inj_of_nonneg dist_nonneg dist_nonneg, ‚Üêmul_self_inj_of_nonneg dist_nonneg dist_nonneg, dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p3 hp1, dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p3 hp2]
simp
intros
have hs : ({i‚ÇÇ, i‚ÇÉ}·∂ú : finset (fin 3)) = {i‚ÇÅ}
dec_trivial!
dec_trivial!
have he : univ.erase i‚ÇÅ = {i‚ÇÇ, i‚ÇÉ}
dec_trivial!
dec_trivial!
rw [monge_plane_def, altitude_def, direction_affine_span, hs, he, centroid_singleton, coe_insert, coe_singleton, vector_span_image_eq_span_vsub_set_left_ne ‚Ñù _ (set.mem_insert i‚ÇÇ _)]
simp [h‚ÇÇ‚ÇÉ, submodule.span_insert_eq_span]
intros
rw norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero
exact inner_eq_zero_iff_angle_eq_pi_div_two x y
intros
rw support_eq_symm_image
exact closure_minimal (image_subset _ $ inter_subset_inter_left _ ball_subset_closed_ball) f.closed_symm_image_closed_ball
intros
simp [stereographic']
intros
assume x xs
rcases h x xs with ‚ü®t, t_open, xt, ht‚ü©
exact (mdifferentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 (ht x ‚ü®xs, xt‚ü©)
intros
simp only with mfld_simps
intros
assume p
exact (hf p.1).prod_map' (hg p.2)
intros
have key : ‚àÄ g h, quotient.mk' g = quotient.mk' h ‚Üî g‚Åª¬π * h ‚àà H := @quotient.eq' G (quotient_group.left_rel H)
simp_rw [mem_left_transversals_iff_exists_unique_inv_mul_mem, set_like.mem_coe, ‚Üêkey]
exact ‚ü®Œª h q, quotient.induction_on' q h, Œª h g, h (quotient.mk' g)‚ü©
intros
rwa [eq', mul_inv_rev, inv_mul_cancel_right, s.inv_mem_iff]
intros
rw map_id
{rw map_id, refl }
refl
intros
rw [‚Üê mk_eq_monoid_of_mk', lift_on_mk]
intros
rw [mul_comm, mk'_mul_cancel_right]
intros
convert minimal_period_iterate_eq_div_gcd h
simp only [order_of, mul_left_iterate]
intros
convert iff.rfl
{ convert iff.rfl, simp only [exists_prop, is_periodic_pt_add_iff_nsmul_eq_zero] }
simp only [exists_prop, is_periodic_pt_add_iff_nsmul_eq_zero]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
rw prod.mk.inj_iff
split
split; ext i; simpa using equiv.congr_fun h i
split; ext i
ext i
simpa using equiv.congr_fun h i
ext i
simpa using equiv.congr_fun h i
intros
rw ‚Üêfinset.coe_inj
convert support_form_perm_of_nodup' _ h h'
simp [set.ext_iff]
intros
refine (sign_eq_sign_of_equiv _ _ (prod_comm Œ≤ Œ±) _).trans (sign_prod_congr_right œÉ)
rintro ‚ü®b, Œ±‚ü©
refl
intros
simp only [list.not_mem_nil, and_true, list.mem_cons_iff, not_false_iff, list.nodup_cons, list.mem_singleton, and_self, list.nodup_nil] at h
push_neg at h
apply le_antisymm
convert support_mul_le _ _
{ convert support_mul_le _ _, rw [support_swap h.left.left, support_swap h.right], ext, simp [or.comm, or.left_comm] }
rw [support_swap h.left.left, support_swap h.right]
ext
simp [or.comm, or.left_comm]
intro
{ intro, simp only [mem_insert, mem_singleton], rintro (rfl | rfl | rfl | _); simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm] }
simp only [mem_insert, mem_singleton]
rintro (rfl | rfl | rfl | _); simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
rintro (rfl | rfl | rfl | _)
simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
intros
induction n with n ih
{ simp only [derived_series_zero, le_top], }
simp only [derived_series_zero, le_top]
{ simp only [derived_series_succ, map_commutator_eq_commutator_map, general_commutator_mono, *], }
simp only [derived_series_succ, map_commutator_eq_commutator_map, general_commutator_mono, *]
intros
simp only [pow_succ, sq, xa_mul_xa, xa_mul_a, add_sub_cancel, add_sub_assoc, add_sub_cancel', sub_self, add_zero]
norm_cast
rw ‚Üê two_mul
simp [one_def]
intros
{ ext, simp }
ext
simp
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
rcases f with ‚ü®f, f_linear, f_add‚ü©
rcases g with ‚ü®g, g_linear, g_add‚ü©
have : f = g := funext h
subst g
congr' with v
cases (add_torsor.nonempty : nonempty P1) with p
apply vadd_right_cancel (f p)
erw [‚Üê f_add, ‚Üê g_add]
intros
rcases hp with ‚ü®p2, ‚ü®hp2, ‚ü®v2, ‚ü®hv2, hv2p‚ü©‚ü©‚ü©‚ü©
rw [hv2p, vadd_vadd]
use [p2, hp2, v + v2, (vector_span k s).add_mem hv hv2, rfl]
intros
simp [vector_span_def]
intros
rw sum_centroid_weights_indicator
exact s.sum_centroid_weights_eq_one_of_card_ne_zero k h
intros
simp only [line_map_apply_module]
exact add_lt_add_right (smul_lt_smul_of_pos ha (sub_pos.2 hr)) _
intros
refine disjoint_def.trans ‚ü®Œª H hx, H x hx $ subset_span $ mem_singleton x, _‚ü©
assume H y hy hyx
obtain ‚ü®c, hc‚ü© := mem_span_singleton.1 hyx
subst y
classical
by_cases hc : c = 0
simp only [hc, zero_smul]
simp only [hc, zero_smul]
rw [s.smul_mem_iff hc] at hy
rw [H hy, smul_zero]
intros
rw ker_comp; exact comap_mono bot_le
rw ker_comp
exact comap_mono bot_le
intros
simpa using (map_le_range : map p.subtype p' ‚â§ p.subtype.range)
intros
rw set_like.le_def
intros m h
change c ‚Ä¢ (f‚Çó m) ‚àà q‚Çó
change f‚Çó m ‚àà q‚Çó at h
apply q‚Çó.smul_mem _ h
intros
rw [‚Üê b.total_repr x, ‚Üê b.total_repr y]
{ rw [‚Üê b.total_repr x, ‚Üê b.total_repr y], congr' 1, ext i, exact h i }
congr' 1
ext i
exact h i
intros
{ ext i, simp }
ext i
simp
intros
rw [‚Üê@neg_one_smul R‚ÇÅ _ _, smul_right, neg_one_mul]
intros
rw [bilin_form.to_matrix, linear_equiv.trans_apply, bilin_form.to_matrix'_apply, congr_apply, b.equiv_fun_symm_std_basis, b.equiv_fun_symm_std_basis]
intros
rw [‚Üêalg_hom.map_mul, Œπ_sq_scalar, alg_hom.commutes]
intros
ext
{ ext, unfold linear_map.det, split_ifs, { congr }, refl }
unfold linear_map.det
split_ifs
{ congr }
congr
refl
intros
rw [rank, rank, linear_map.range_comp]; exact dim_map_le _ _
rw [rank, rank, linear_map.range_comp]
exact dim_map_le _ _
intros
{ erw [constr_basis b, constr_basis b], ac_refl }
erw [constr_basis b, constr_basis b]
ac_refl
intros
simp [total_apply, sum_single_index]
intros
haveI := classical.dec_eq V
haveI := classical.dec_eq V'
let m := basis.of_vector_space K V
let m' := basis.of_vector_space K V'
rw [‚Üêcardinal.lift_inj.1 m.mk_eq_dim, ‚Üêcardinal.lift_inj.1 m'.mk_eq_dim] at h
rcases quotient.exact h with ‚ü®e‚ü©
let e := (equiv.ulift.symm.trans e).trans equiv.ulift
exact ‚ü®(m.repr ‚â™‚â´‚Çó (finsupp.dom_lcongr e)) ‚â™‚â´‚Çó m'.repr.symm‚ü©
intros
let P := (finsupp.linear_equiv_fun_on_fintype R R Œ≤)
let Q := (finsupp.linear_equiv_fun_on_fintype R R Œ±).symm
exact card_le_of_injective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.injective.comp i).comp Q.injective)
intros
nontriviality R
have : inj_on f s
from inj_on_iff_injective.2 hs.injective.of_comp
exact (linear_independent_equiv' (equiv.set.image_of_inj_on f s this) rfl).1 hs
intros
refine ‚ü®le_sup_right, Œª z‚ÇÅ z‚ÇÇ hz, _‚ü©
rw [‚Üê zero_add (g _), ‚Üê f.map_zero]
refine (sup_apply h _ _ _ _).symm
simpa
intros
convert matrix.det_reindex_self (equiv.subtype_equiv_right e) (to_square_block_prop M q)
intros
ext
ext; simp
simp
intros
ext j
rw [cramer_apply, pi.single_apply]
split_ifs with h
{ subst h, simp only [update_column_transpose, det_transpose, update_row, function.update_eq_self] }
subst h
simp only [update_column_transpose, det_transpose, update_row, function.update_eq_self]
rw [update_column_transpose, det_transpose]
{ rw [update_column_transpose, det_transpose], apply det_zero_of_row_eq h, rw [update_row_self, update_row_ne (ne.symm h)] }
apply det_zero_of_row_eq h
rw [update_row_self, update_row_ne (ne.symm h)]
intros
split
split; rintros ‚ü®x, hx‚ü©; refine @is_unit_of_invertible _ _ _ (id _)
split; rintros ‚ü®x, hx‚ü©
rintros ‚ü®x, hx‚ü©
refine @is_unit_of_invertible _ _ _ (id _)
haveI : invertible A := hx.rec x.invertible
{ haveI : invertible A := hx.rec x.invertible, apply det_invertible_of_invertible, }
apply det_invertible_of_invertible
rintros ‚ü®x, hx‚ü©
refine @is_unit_of_invertible _ _ _ (id _)
haveI : invertible A.det := hx.rec x.invertible
{ haveI : invertible A.det := hx.rec x.invertible, apply invertible_of_det_invertible, }
apply invertible_of_det_invertible
intros
{ rw [‚Üê reindex_linear_equiv_trans], refl }
rw [‚Üê reindex_linear_equiv_trans]
refl
intros
ext a b
by_cases ha : i = a; by_cases hb : j = b
by_cases ha : i = a
by_cases hb : j = b
simp only [update_row, transvection, ha, hb, function.update_same, std_basis_matrix.apply_same, pi.add_apply, one_apply_eq, pi.smul_apply, mul_one, algebra.id.smul_eq_mul]
{ simp only [update_row, transvection, ha, hb, function.update_same, std_basis_matrix.apply_same, pi.add_apply, one_apply_eq, pi.smul_apply, mul_one, algebra.id.smul_eq_mul], }
simp only [update_row, transvection, ha, hb, std_basis_matrix.apply_of_ne, function.update_same, pi.add_apply, ne.def, not_false_iff, pi.smul_apply, and_false, one_apply_ne, algebra.id.smul_eq_mul, mul_zero]
{ simp only [update_row, transvection, ha, hb, std_basis_matrix.apply_of_ne, function.update_same, pi.add_apply, ne.def, not_false_iff, pi.smul_apply, and_false, one_apply_ne, algebra.id.smul_eq_mul, mul_zero] }
by_cases hb : j = b
{ simp only [update_row, transvection, ha, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, dmatrix.add_apply, pi.smul_apply, mul_zero, false_and] }
simp only [update_row, transvection, ha, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, dmatrix.add_apply, pi.smul_apply, mul_zero, false_and]
simp only [update_row, transvection, ha, hb, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, and_self, dmatrix.add_apply, pi.smul_apply, mul_zero]
{ simp only [update_row, transvection, ha, hb, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, and_self, dmatrix.add_apply, pi.smul_apply, mul_zero] }
intros
have e : n ‚âÉ fin (fintype.card n) := fintype.equiv_of_card_eq (by simp)
apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux
intros
ext c
ext c; simp [funext_iff]; refl
ext c; simp [funext_iff]
simp [funext_iff]
intros
ext
ext; simp only [map_zero, add_zero, coprod_apply, inl_apply, comp_apply]
simp only [map_zero, add_zero, coprod_apply, inl_apply, comp_apply]
intros
{ tidy, exact 0, }
tidy
exact 0
intros
rw [std_basis_eq_pi_diag, proj_pi]
intros
simp only [‚Üê coe_rtensor_hom, map_sub]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
{ cases h, refl, }
cases h
refl
intros
{ ext, simp }
ext
simp
intros
rw [iterate_succ']
intros
simp_rw [ennreal.tsum_eq_supr_sum]
{ simp_rw [ennreal.tsum_eq_supr_sum], apply measurable_supr, exact Œª s, s.measurable_sum (Œª i _, h i) }
apply measurable_supr
exact Œª s, s.measurable_sum (Œª i _, h i)
intros
rw [ball_pi _ hr, pi_pi]
intros
refine ‚ü®(measurable_measure_prod_mk_left hs).ennreal_to_real.ae_measurable, _‚ü©
simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg]
convert h2s.lt_top using 1
simp_rw [prod_apply hs]
apply lintegral_congr_ae
refine (ae_measure_lt_top hs h2s).mp _
apply eventually_of_forall
intros x hx
rw [lt_top_iff_ne_top] at hx
simp [of_real_to_real, hx]
intros
simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right', h1f.prod_mk_left]
intros
refine ae_nonneg_restrict_of_forall_set_integral_nonneg_inter hŒºt (hf_int_finite t ht (lt_top_iff_ne_top.mpr hŒºt)) (Œª s hs, _)
refine (hf_zero (s ‚à© t) (hs.inter ht) _)
exact (measure_mono (set.inter_subset_right s t)).trans_lt (lt_top_iff_ne_top.mpr hŒºt)
intros
refine (condexp_ae_eq_condexp_L1 f).trans (eventually_of_forall (Œª x, _))
rw condexp_L1_eq hf
intros
rw ‚Üê L2.inner_indicator_const_Lp_one (hm s hs) hŒºs
have h_eq_inner : ‚à´ x in s, condexp_L2 ùïú hm f x ‚àÇŒº = inner (indicator_const_Lp 2 (hm s hs) hŒºs (1 : ùïú)) (condexp_L2 ùïú hm f)
rw L2.inner_indicator_const_Lp_one (hm s hs) hŒºs
{ rw L2.inner_indicator_const_Lp_one (hm s hs) hŒºs, congr, }
congr
rw [h_eq_inner, ‚Üê inner_condexp_L2_left_eq_right, condexp_L2_indicator_of_measurable hm hs hŒºs]
intros
rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢
{ rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢, exact hf.const_inner c, }
exact hf.const_inner c
intros
simp_rw [snorm_eq_lintegral_rpow_nnnorm one_ne_zero ennreal.coe_ne_top, ennreal.one_to_real, one_div_one, ennreal.rpow_one]
intros
apply Lp.norm_le_mul_norm_of_ae_le_mul
filter_upwards [hg.coe_fn_comp_Lp g0 f, hg.coe_fn_comp_Lp g0 f', Lp.coe_fn_sub (hg.comp_Lp g0 f) (hg.comp_Lp g0 f'), Lp.coe_fn_sub f f']
assume a ha1 ha2 ha3 ha4
simp [ha1, ha2, ha3, ha4, ‚Üê dist_eq_norm]
exact hg.dist_le_mul (f a) (f' a)
intros
{ rw sub_eq_add_neg, exact hf.add hg.neg }
rw sub_eq_add_neg
exact hf.add hg.neg
intros
induction l with f l ihl
exact ae_measurable_one
{ exact ae_measurable_one }
rw [list.forall_mem_cons] at hl
rw [list.prod_cons]
exact hl.1.mul (ihl hl.2)
intros
rw [integral, simple_func.integral_eq_lintegral (simple_func.integrable f) h_pos]
intros
refine ‚ü®Œª hfg, ‚ü®_, _‚ü©, Œª h, h.1.add h.2‚ü©
rw ‚Üê indicator_add_eq_left h
{ rw ‚Üê indicator_add_eq_left h, exact hfg.indicator (measurable_set_support hf) }
exact hfg.indicator (measurable_set_support hf)
rw ‚Üê indicator_add_eq_right h
{ rw ‚Üê indicator_add_eq_right h, exact hfg.indicator (measurable_set_support hg) }
exact hfg.indicator (measurable_set_support hg)
intros
split
split; simp
simp
simp
simp
simp
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [‚Üê simple_func.const_lintegral, ‚Üê simple_func.lintegral_eq_lintegral, simple_func.coe_const]
intros
simp_rw [mul_comm, lintegral_const_mul r hf]
intros
simp only [measure.restrict_Union hd hm, lintegral_sum_measure]
intros
rw [f.restrict_lintegral hs, lintegral_restrict]
intros
rw [‚Üê image_univ]
{ rw [‚Üê image_univ], exact measurable_set_inr_image measurable_set.univ }
exact measurable_set_inr_image measurable_set.univ
intros
change @measurable_set' _ (generate_from $ ‚ãÉ‚ÇÄ _) _ ‚Üî _
simp [generate_from, ‚Üê set_of_exists]
intros
have : is_compact (haar_product K‚ÇÄ.1)
apply is_compact_univ_pi
{ apply is_compact_univ_pi, intro K, apply is_compact_Icc }
intro K
apply is_compact_Icc
refine this.inter_Inter_nonempty (cl_prehaar K‚ÇÄ.1) (Œª s, is_closed_closure) (Œª t, _)
let V‚ÇÄ := ‚ãÇ (V ‚àà t), (V : open_nhds_of 1).1
have h1V‚ÇÄ : is_open V‚ÇÄ
apply is_open_bInter
{ apply is_open_bInter, apply finite_mem_finset, rintro ‚ü®V, hV‚ü© h2V, exact hV.1 }
apply finite_mem_finset
rintro ‚ü®V, hV‚ü© h2V
exact hV.1
have h2V‚ÇÄ : (1 : G) ‚àà V‚ÇÄ
simp only [mem_Inter]
{ simp only [mem_Inter], rintro ‚ü®V, hV‚ü© h2V, exact hV.2 }
rintro ‚ü®V, hV‚ü© h2V
exact hV.2
refine ‚ü®prehaar K‚ÇÄ.1 V‚ÇÄ, _‚ü©
split
apply prehaar_mem_haar_product K‚ÇÄ
{ apply prehaar_mem_haar_product K‚ÇÄ, use 1, rwa h1V‚ÇÄ.interior_eq }
use 1
rwa h1V‚ÇÄ.interior_eq
simp only [mem_Inter]
{ simp only [mem_Inter], rintro ‚ü®V, hV‚ü© h2V, apply subset_closure, apply mem_image_of_mem, rw [mem_set_of_eq], exact ‚ü®subset.trans (Inter_subset _ ‚ü®V, hV‚ü©) (Inter_subset _ h2V), h1V‚ÇÄ, h2V‚ÇÄ‚ü© }
rintro ‚ü®V, hV‚ü© h2V
apply subset_closure
apply mem_image_of_mem
rw [mem_set_of_eq]
exact ‚ü®subset.trans (Inter_subset _ ‚ü®V, hV‚ü©) (Inter_subset _ h2V), h1V‚ÇÄ, h2V‚ÇÄ‚ü©
intros
rcases has_le.le.eq_or_lt hr with h|h
{ simp [‚Üê h, zero_pow finrank_pos] }
simp [‚Üê h, zero_pow finrank_pos]
{ exact add_haar_ball_of_pos Œº x h }
exact add_haar_ball_of_pos Œº x h
intros
simpa only [mul_comm] using real.smul_map_volume_mul_left h
intros
simp only [mem_ae_iff, map_apply hf hs.compl, preimage_compl]
intros
ext1 s hs
simp_rw [Inf_apply hs, restrict_apply hs, Inf_apply (measurable_set.inter hs ht), set.image_image, restrict_to_outer_measure_eq_to_outer_measure_restrict ht, ‚Üê set.image_image _ to_outer_measure, ‚Üê outer_measure.restrict_Inf_eq_Inf_restrict _ (hm.image _), outer_measure.restrict_apply]
intros
simp only [bounded_by, smul_of_function hc]
congr' 1 with s : 1
rcases s.eq_empty_or_nonempty with rfl|hs
rcases s.eq_empty_or_nonempty with rfl|hs; simp *
simp *
simp *
intros
haveI := hI.to_subtype
{ haveI := hI.to_subtype, rw [‚Üê infi_subtype'', ‚Üê infi_subtype''], exact restrict_infi _ _ }
rw [‚Üê infi_subtype'', ‚Üê infi_subtype'']
exact restrict_infi _ _
intros
{ rw left_lim, exact f.mono.tendsto_nhds_within_Iio x }
rw left_lim
exact f.mono.tendsto_nhds_within_Iio x
intros
rw union_eq_Union
{ rw union_eq_Union, exact d.has_Union (pairwise_disjoint_on_bool.2 h) (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©) }
exact d.has_Union (pairwise_disjoint_on_bool.2 h) (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)
intros
simp
intros
simp only [admissible]
let S := sort ((‚â§) : ‚Ñï+ ‚Üí ‚Ñï+ ‚Üí Prop) {p,q,r}
have hS : S.sorted (‚â§) := sort_sorted _ _
have hpqr : ({p,q,r} : multiset ‚Ñï+) = S := (sort_eq has_le.le {p, q, r}).symm
simp only [hpqr] at *
apply admissible_of_one_lt_sum_inv_aux hS _ H
simp only [S, length_sort]
dec_trivial
ext
{ ext, simp }
simp
intros
obtain ‚ü®a0, b0, c0, hf‚ü© := exists_minimal h
cases int.mod_two_eq_zero_or_one a0 with hap hap
cases int.mod_two_eq_zero_or_one b0 with hbp hbp
{ cases int.mod_two_eq_zero_or_one b0 with hbp hbp, { exfalso, have h1 : 2 ‚à£ (int.gcd a0 b0 : ‚Ñ§), { exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp) }, rw int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf) at h1, revert h1, norm_num }, { exact ‚ü®b0, ‚ü®a0, ‚ü®c0, minimal_comm hf, hbp‚ü©‚ü©‚ü© }}
exfalso
{ exfalso, have h1 : 2 ‚à£ (int.gcd a0 b0 : ‚Ñ§), { exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp) }, rw int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf) at h1, revert h1, norm_num }
have h1 : 2 ‚à£ (int.gcd a0 b0 : ‚Ñ§)
{ exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp) }
exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp)
rw int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf) at h1
revert h1
norm_num
{ exact ‚ü®b0, ‚ü®a0, ‚ü®c0, minimal_comm hf, hbp‚ü©‚ü©‚ü© }
exact ‚ü®b0, ‚ü®a0, ‚ü®c0, minimal_comm hf, hbp‚ü©‚ü©‚ü©
exact ‚ü®a0, ‚ü®b0, ‚ü®c0 , hf, hap‚ü©‚ü©‚ü©
intros
rw [‚Üê stream.eta (zip f s‚ÇÅ s‚ÇÇ)]
refl
intros
unfold tail drop
simp [nat.add_comm, nat.add_left_comm]
intros
cases b; simp
cases b
simp
simp
intros
rw [‚Üê int.add_assoc, int.add_right_neg, int.zero_add]
intros
have h := int.add_lt_add_right h (-a)
rwa [int.add_comm a b, int.add_neg_cancel_right] at h
intros
{rw [binary_rec], refl}
rw [binary_rec]
refl
intros
{induction z with z ih, rw [nat.mul_zero, nat.add_zero], rw [mul_succ, ‚Üê nat.add_assoc, add_mod_right, ih]}
induction z with z ih
rw [nat.mul_zero, nat.add_zero]
rw [mul_succ, ‚Üê nat.add_assoc, add_mod_right, ih]
intros
rw [‚Üêvsub_vadd_eq_vsub_sub, vsub_vadd]
intros
obtain ‚ü®m, rfl : n = N + m‚ü© := le_iff_exists_add.mp hn
clear hn
induction m with m hm
{ simp }
simp
erw [prod_range_succ, hm]
simp [hu]
intros
rcases eq_or_ne c 0 with rfl|hc
simp
{ simp }
exact (smul_add_hom R M c).map_finsum_of_injective (smul_right_injective M hc) _
intros
rw [‚Üê image_univ, finprod_mem_image', finprod_mem_univ]
rwa univ_inter
intros
intros h
{ intros h, apply @zero_ne_one R, symmetry, rw [‚Üênat.cast_one, ring_char.spec, h], }
apply @zero_ne_one R
symmetry
rw [‚Üênat.cast_one, ring_char.spec, h]
intros
rw [‚Üê add_div, half_add_self]
intros
simp[num_eq_conts_a, (first_continuant_eq zeroth_s_eq)]
intros
rw [‚Üê h, mul_div_cancel _ hb]
intros
simpa only [‚Üê @div_self _ _ b h] using (div_sub_div_same a b b).symm
intros
{ ext, simp [lt_ceil] }
ext
simp [lt_ceil]
intros
{ ext, simp }
ext
simp
intros
rw [‚Üê lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add]
{ rw [‚Üê lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add], simp }
simp
intros
rw [bit1, bit0_zero, zero_add]
intros
rw [sub_eq_add_neg, neg_add_cancel_right a b]
intros
ring
intros
rw [nsmul_eq_mul', (n.cast_commute a).eq]
intros
by_cases hb : b = 0
rw [hb, div_zero] at h
{ rw [hb, div_zero] at h, exact eq_of_zero_eq_one h a b }
exact eq_of_zero_eq_one h a b
{ rwa [div_eq_iff_mul_eq hb, one_mul, eq_comm] at h }
rwa [div_eq_iff_mul_eq hb, one_mul, eq_comm] at h
intros
by_cases hij : c.rel i j
{ exact f.comm' i j hij }
exact f.comm' i j hij
rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]
intros
{ dsimp [of], rw [dif_neg h], }
dsimp [of]
rw [dif_neg h]
intros
simp only [funext_iff, subset_def, mem_mul_support, mul_indicator_apply_eq_self, not_imp_comm]
intros
rw [‚Üê map_sup_ker_eq_map, ‚Üê comap_bracket_eq h, map_comap_eq h, inf_eq_right]
{ rw [‚Üê map_sup_ker_eq_map, ‚Üê comap_bracket_eq h, map_comap_eq h, inf_eq_right], exact le_trans (lie_submodule.lie_le_left _ _) inf_le_left, }
exact le_trans (lie_submodule.lie_le_left _ _) inf_le_left
intros
obtain ‚ü®k, hk‚ü© := h‚ÇÅ
tactic.unfreeze_local_instances
use k
apply lie_ideal.bot_of_map_eq_bot h‚ÇÇ
rw [eq_bot_iff, ‚Üê hk]
apply lie_ideal.derived_series_map_le
intros
rw [‚Üê mem_coe_submodule, ‚Üê mem_coe_submodule, ‚Üê mem_coe_submodule, inf_coe_to_submodule, submodule.mem_inf]
intros
rw f.is_ideal_morphism_def at h
rw [‚Üê lie_submodule.mem_coe, ‚Üê lie_ideal.coe_to_subalgebra, h, f.range_coe, set.mem_range]
intros
rw [‚Üêone_smul R x, ‚Üêzero_eq_one, zero_smul]
intros
rintro ‚ü®f, _‚ü© ‚ü®g, _‚ü© ‚ü®h‚ü©; congr
rintro ‚ü®f, _‚ü© ‚ü®g, _‚ü© ‚ü®h‚ü©
congr
intros
ext y
simp only [mem_support_iff, mem_map, exists_prop, mul_right_embedding_apply]
by_cases H : ‚àÉ a, a * x = y
rcases H with ‚ü®a, rfl‚ü©
{ rcases H with ‚ü®a, rfl‚ü©, rw [mul_single_apply_aux f (Œª _, mul_left_inj x)], simp [hr] }
rw [mul_single_apply_aux f (Œª _, mul_left_inj x)]
simp [hr]
push_neg at H
{ push_neg at H, simp [mul_apply, H] }
simp [mul_apply, H]
intros
simpa [sub_eq_add_neg, add_assoc] using abv.add_le (a - b) (b - c)
intros
{ rw [inv_eq_one_div], exact div_lt_iff ha }
rw [inv_eq_one_div]
exact div_lt_iff ha
intros
rw [div_lt_iff hb, one_mul]
intros
simp only [‚Üê not_le, inv_nonneg]
intros
{ rw [sub_eq_add_neg, ‚Üêabs_neg b], exact abs_add a _ }
rw [sub_eq_add_neg, ‚Üêabs_neg b]
exact abs_add a _
intros
rw [div_eq_mul_inv, div_eq_mul_inv, ‚Üê mul_le_mul_iff_left a‚Åª¬π, inv_mul_cancel_left, inv_mul_cancel_left, inv_le_inv_iff]
intros
by_cases 0 ‚â§ a
left
{ left, exact ‚ü®abs_eq_self.mpr h, h‚ü© }
exact ‚ü®abs_eq_self.mpr h, h‚ü©
right
{ right, push_neg at h, exact ‚ü®abs_eq_neg_self.mpr (le_of_lt h), h‚ü© }
push_neg at h
exact ‚ü®abs_eq_neg_self.mpr (le_of_lt h), h‚ü©
intros
{ convert mul_le_mul_right h, simp }
convert mul_le_mul_right h
simp
intros
simpa only [zero_add] using h 0
intros
simp
intros
simpa using multiset_prod_X_sub_C_next_coeff (s.1.map f)
intros
{ split, apply (act x).injective, rintro rfl, refl }
split
apply (act x).injective
rintro rfl
refl
intros
ext
{ext, simp}
simp
intros
simp
intros
simp only [algebra.smul_def, rel.mul_right h]
intros
simp [‚Üêuntrop_inj_iff, with_top.add_eq_top]
intros
rw [‚Üê to_open_res R ‚ä§ U (hom_of_le le_top : U ‚ü∂ ‚ä§), category.assoc, presheaf.germ_res]
{ rw [‚Üê to_open_res R ‚ä§ U (hom_of_le le_top : U ‚ü∂ ‚ä§), category.assoc, presheaf.germ_res], refl }
refl
intros
ext1 n
induction n using nat.strong_rec' with n IH
cases n
simp
{ simp }
cases n
simp
{ simp }
simp only [right_inv, neg_inj]
unfold_coes
congr' 1
rw remove_zero_comp_of_pos _ _ (show 0 < n+2, by dec_trivial)
congr' 1
ext k
by_cases hk : k < n+2; simp [hk, IH]
by_cases hk : k < n+2
simp [hk, IH]
simp [hk, IH]
intros
refine ((h.norm_left.const_mul_left (‚à•c‚à•)).congr_left _).of_norm_left
exact Œª x, (norm_smul _ _).symm
intros
simpa only [sub_eq_add_neg] using h‚ÇÅ.add_is_o h‚ÇÇ.neg_left hc
intros
rw differentiable_at.deriv_within (differentiable_at_inv.2 x_ne_zero) hxs
exact deriv_inv
intros
apply (hf.limsup_norm_slope_le hr).mono
assume z hz
refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) _) hz
exact inv_nonneg.2 (norm_nonneg _)
intros
simpa using h.neg.has_strict_deriv_at
intros
ext x : 1
by_cases h : differentiable_at ùïú f x
apply has_fderiv_within_at.fderiv_within _ unique_diff_within_at_univ
{ apply has_fderiv_within_at.fderiv_within _ unique_diff_within_at_univ, rw has_fderiv_within_at_univ, apply h.has_fderiv_at }
rw has_fderiv_within_at_univ
apply h.has_fderiv_at
have : ¬¨ differentiable_within_at ùïú f univ x
{ have : ¬¨ differentiable_within_at ùïú f univ x, by contrapose! h; rwa ‚Üê differentiable_within_at_univ, rw [fderiv_zero_of_not_differentiable_at h, fderiv_within_zero_of_not_differentiable_within_at this] }
contrapose! h
contrapose! h
contrapose! h; rwa ‚Üê differentiable_within_at_univ
contrapose! h; rwa ‚Üê differentiable_within_at_univ
rwa ‚Üê differentiable_within_at_univ
rwa ‚Üê differentiable_within_at_univ
rw [fderiv_zero_of_not_differentiable_at h, fderiv_within_zero_of_not_differentiable_within_at this]
intros
simp [differentiable_set_eq_D K hK, D, is_open_B.measurable_set, measurable_set.Inter_Prop, measurable_set.Inter, measurable_set.Union]
intros
apply continuous_on_iff_continuous_restrict.2
refine ((hf.antilipschitz hc).to_right_inv_on' _ (hf.to_local_equiv hc).right_inv').continuous
exact (Œª x hx, (hf.to_local_equiv hc).map_target hx)
intros
ext1 x
ext1 n
change iterated_fderiv_within ùïú n f univ x = iterated_fderiv ùïú n f x
rw iterated_fderiv_within_univ
intros
have : times_cont_diff_within_at ùïú n g univ (f x) := h.times_cont_diff_at.times_cont_diff_within_at
exact this.comp x hf (subset_univ _)
intros
rcases hf 1 le_rfl with ‚ü®t, hst, p, hp‚ü©
rcases metric.mem_nhds_within_iff.mp hst with ‚ü®Œµ, Œµ0, hŒµ‚ü©
replace hp : has_ftaylor_series_up_to_on 1 f p (metric.ball x Œµ ‚à© insert x s) := hp.mono hŒµ
clear hst hŒµ t
rw [‚Üê insert_eq_of_mem (metric.mem_ball_self Œµ0), ‚Üê insert_inter] at hp
rcases hp.exists_lipschitz_on_with ((convex_ball _ _).inter hs) with ‚ü®K, t, hst, hft‚ü©
rw [inter_comm, ‚Üê nhds_within_restrict' _ (metric.ball_mem_nhds _ Œµ0)] at hst
exact ‚ü®K, t, hst, hft‚ü©
intros
assume x hx m hm
rw insert_eq_of_mem hx
refine ‚ü®s, self_mem_nhds_within, ftaylor_series_within ùïú f s, _‚ü©
split
assume y hy
{ assume y hy, simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply] }
simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]
assume k hk y hy
{ assume k hk y hy, convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at, simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, continuous_linear_equiv.coe_apply, function.comp_app, coe_fn_coe_base], exact continuous_linear_map.curry_uncurry_left _ }
convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at
simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, continuous_linear_equiv.coe_apply, function.comp_app, coe_fn_coe_base]
exact continuous_linear_map.curry_uncurry_left _
assume k hk
{ assume k hk, exact Hcont k (le_trans hk hm) }
exact Hcont k (le_trans hk hm)
intros
rintro x hx
rw (convex_convex_hull ùïú _).mem_extreme_points_iff_convex_diff at hx
by_contra
exact (convex_hull_min (subset_diff.2 ‚ü®subset_convex_hull ùïú _, disjoint_singleton_right.2 h‚ü©) hx.2 hx.1).2 rfl
intros
have : ‚ü™y, x‚ü´_‚Ñù = ‚ü™x, y‚ü´_‚Ñù := by rw [‚Üêinner_conj_sym]; refl
simp [inner_add_add_self, this]
ring
intros
simp only [‚Üê nnreal.coe_le_coe, nnreal.coe_add, ‚Üê dist_nndist, dist_vadd_vadd_le]
intros
{ ext, refl }
ext
refl
intros
simpa only [‚Üênnreal.coe_le_coe, nnreal.coe_mul, nnreal.coe_nat_cast] using norm_nsmul_le n a
intros
simp only [dist_eq_norm, ‚Üê finset.sum_sub_distrib] at *
exact norm_sum_le_of_le s h
intros
rw norm_def
{ rw norm_def, apply congr_arg, ext, simp }
apply congr_arg
ext
simp
intros
{ ext, refl }
ext
refl
intros
rcases normed_field.exists_one_lt_norm ùïú with ‚ü®c, hc‚ü©
refine op_norm_le_of_shell Œµ_pos hC hc (Œª x _ hx, hf x _)
rwa ball_zero_eq
intros
simp
intros
unfold arg; split_ifs; simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
unfold arg; split_ifs
unfold arg
split_ifs
simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
intros
simp only [‚Üê one_div]
refine integral_deriv_eq_sub' _ _ _ (continuous_const.div _ (Œª x, _)).continuous_on
{ norm_num }
norm_num
{ norm_num }
norm_num
{ continuity }
continuity
{ nlinarith }
nlinarith
intros
obtain ‚ü®x‚ÇÄ, hx‚ÇÄ‚ü© := exists_max_root P hP
refine filter.eventually_at_top.mpr (‚ü®x‚ÇÄ + 1, Œª x hx h, _‚ü©)
exact absurd (hx‚ÇÄ x h) (not_le.mpr (lt_of_lt_of_le (lt_add_one x‚ÇÄ) hx))
intros
rcases lt_trichotomy 0 y with H|rfl|H
{ simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl] }
simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl]
{ simp [lt_irrefl] }
simp [lt_irrefl]
{ simp [H, asymm H, ne_of_lt, zero_rpow_of_neg] }
simp [H, asymm H, ne_of_lt, zero_rpow_of_neg]
intros
simp [rpow_def]
intros
rw le_iff_eq_or_lt at hx
cases hx
rw [‚Üê hx, zero_rpow (ne_of_gt hz)]
{ rw [‚Üê hx, zero_rpow (ne_of_gt hz)], exact rpow_pos_of_pos (by rwa ‚Üê hx at hxy) _ }
exact rpow_pos_of_pos (by rwa ‚Üê hx at hxy) _
rw [rpow_def_of_pos hx, rpow_def_of_pos (lt_trans hx hxy), exp_lt_exp]
exact mul_lt_mul_of_pos_right (log_lt_log hx hxy) hz
intros
cases hx.lt_or_lt with hx hx
have := (has_strict_fderiv_at_rpow_of_neg (x, p) hx).comp_has_strict_deriv_at x ((has_strict_deriv_at_id x).prod (has_strict_deriv_at_const _ _))
{ have := (has_strict_fderiv_at_rpow_of_neg (x, p) hx).comp_has_strict_deriv_at x ((has_strict_deriv_at_id x).prod (has_strict_deriv_at_const _ _)), convert this, simp }
convert this
simp
simpa using (has_strict_deriv_at_id x).rpow (has_strict_deriv_at_const x p) hx
{ simpa using (has_strict_deriv_at_id x).rpow (has_strict_deriv_at_const x p) hx }
intros
exact_mod_cast (complex.has_strict_deriv_at_tan (by exact_mod_cast h)).real_of_complex
rw [‚Üê cos_pi_div_two_sub, ‚Üê cos_pi_div_six]
congr
ring
intros
rw ‚Üê sub_eq_zero
field_simp [cos, exp_neg, exp_ne_zero]
refine eq.congr _ rfl
ring
{ rw [arcsin, range_comp coe], simp [Icc] }
rw [arcsin, range_comp coe]
simp [Icc]
intros
rw [‚Üê equiv.eq_symm_apply]; simp
rw [‚Üê equiv.eq_symm_apply]
simp
intros
simp
intros
{ convert w (ùüô X), tidy }
convert w (ùüô X)
tidy
intros
convert unit_transfer_nat_trans _ _ (prod_comparison_nat_iso F A).inv B
ext
dsimp
simp
intros
ext
ext; simp only [map_iso_hom, iso.conj_Aut_hom, F.map_conj]
simp only [map_iso_hom, iso.conj_Aut_hom, F.map_conj]
intros
have h : f = ùüô j
cases f
{ cases f, cases f, ext, }
cases f
ext
rw h
simp
intros
classical
apply finset.induction_on O
exact ‚ü®is_cofiltered.nonempty.some, (by rintros - ‚ü®‚ü©)‚ü©
{ exact ‚ü®is_cofiltered.nonempty.some, (by rintros - ‚ü®‚ü©)‚ü©, }
rintros X O' nm ‚ü®S', w'‚ü©
{ rintros X O' nm ‚ü®S', w'‚ü©, use min X S', rintros Y mY, by_cases h : X = Y, { subst h, exact ‚ü®min_to_left _ _‚ü©, }, { exact ‚ü®min_to_right _ _ ‚â´ (w' (by finish)).some‚ü©, }, }
use min X S'
rintros Y mY
by_cases h : X = Y
{ subst h, exact ‚ü®min_to_left _ _‚ü©, }
subst h
exact ‚ü®min_to_left _ _‚ü©
{ exact ‚ü®min_to_right _ _ ‚â´ (w' (by finish)).some‚ü©, }
exact ‚ü®min_to_right _ _ ‚â´ (w' (by finish)).some‚ü©
intros
{ erw [inv_eq_inv Œ±.symm Œ≤, eq_comm], refl }
erw [inv_eq_inv Œ±.symm Œ≤, eq_comm]
refl
intros
dsimp [is_limit_whisker_equiv]
apply P.hom_ext
intro j
simp
intros
tidy
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
{ ext, simp [biproduct.components], }
ext
simp [biproduct.components]
intros
rw [‚Üêtensor_right_iff, comp_tensor_id, braiding_left_unitor_aux‚ÇÇ]
intros
rw [associator_naturality, inv_hom_id_assoc]
intros
{ ext, rw [‚Üêassociator_hom_f, ‚Üêcomp_f, iso.hom_inv_id], refl, }
ext
rw [‚Üêassociator_hom_f, ‚Üêcomp_f, iso.hom_inv_id]
refl
intros
simp [of_components]
intros
simp [of_mk_le]
intros
revert P
refine quotient.ind' _
intro P
rintro ‚ü®g, rfl‚ü©
exact ‚ü®f ‚â´ g, by simp‚ü©
intros
have h := contractible_distinguished T.obj‚ÇÅ
have f := complete_distinguished_triangle_morphism
specialize f (contractible_triangle C T.obj‚ÇÅ) T h H (ùüô T.obj‚ÇÅ) T.mor‚ÇÅ
have t : (contractible_triangle C T.obj‚ÇÅ).mor‚ÇÅ ‚â´ T.mor‚ÇÅ = ùüô T.obj‚ÇÅ ‚â´ T.mor‚ÇÅ
refl
refl
specialize f t
cases f with c f
rw ‚Üê f.left
simp only [limits.zero_comp, contractible_triangle_mor‚ÇÇ]
intros
change (f.app (op X) ‚â´ F.map g.op) (ùüô X) = f.app (op Y) (ùüô Y ‚â´ g)
rw ‚Üêf.naturality
dsimp
simp
intros
simp [size_up_to]
intros
split
assume H
{ assume H, rw H, exact single_length h }
rw H
exact single_length h
assume H
{ assume H, ext1, have A : c.blocks.length = 1 := H ‚ñ∏ c.blocks_length, have B : c.blocks.sum = n := c.blocks_sum, rw eq_cons_of_length_one A at B ‚ä¢, simpa [single_blocks] using B }
ext1
have A : c.blocks.length = 1 := H ‚ñ∏ c.blocks_length
have B : c.blocks.sum = n := c.blocks_sum
rw eq_cons_of_length_one A at B ‚ä¢
simpa [single_blocks] using B
intros
ext x
rw [accepts, DFA.accepts, eval, DFA.eval]
change list.foldl _ _ _ ‚àà {S | _} ‚Üî _
finish
intros
simp [zero]
intros
induction n with n IH
refl
{refl}
apply (IH (le_of_lt H)).tail
rw iterate_succ_apply'
simp only [TM1.step, TM1.step_aux, tr, tape.mk'_nth_nat, tape.move_right_n_head, add_bottom_nth_snd, option.mem_def]
rw [stk_nth_val _ hL, list.nth_le_nth]
refl
rwa list.length_reverse
intros
cases x; simp [sum.traverse, id_map] with functor_norm; congr; refl
cases x; simp [sum.traverse, id_map] with functor_norm; congr
cases x; simp [sum.traverse, id_map] with functor_norm
cases x
simp [sum.traverse, id_map] with functor_norm
congr
simp [sum.traverse, id_map] with functor_norm
congr
intros
by_cases p; by_cases q; simp *
by_cases p; by_cases q
by_cases p
by_cases q
simp *
simp *
by_cases q
simp *
simp *
intros
cases cs with hd tl
{ simp [one_of, static.decorate_errors] }
simp [one_of, static.decorate_errors]
have : one_of (hd :: tl) (hd :: tl).to_buffer 0 = done 1 hd
{ have : one_of (hd :: tl) (hd :: tl).to_buffer 0 = done 1 hd, { simp [one_of_eq_done] }, simpa using not_of_ne this zero_ne_one }
{ simp [one_of_eq_done] }
simp [one_of_eq_done]
simpa using not_of_ne this zero_ne_one
intros
{ convert bounded.map, exact many he }
convert bounded.map
exact many he
intros
simp [decorate_errors, h]
intros
induction l with hd tl hl generalizing n
convert h
{ convert h, rw many_eq_done_nil at h, exact h.left.symm }
rw many_eq_done_nil at h
exact h.left.symm
rw [‚Üêmany1_eq_done_iff_many_eq_done, many1_eq_done] at h
{ rw [‚Üêmany1_eq_done_iff_many_eq_done, many1_eq_done] at h, obtain ‚ü®_, -, h‚ü© := h, exact hl h }
obtain ‚ü®_, -, h‚ü© := h
exact hl h
intros
simp [foldl_core]
intros
simp [norm_sq]
intros
rw ‚Üê of_real_inj; simp [cos_two_mul]
rw ‚Üê of_real_inj
simp [cos_two_mul]
intros
rw ‚Üê of_real_inj; simp [sinh_three_mul]
rw ‚Üê of_real_inj
simp [sinh_three_mul]
intros
rw [‚Üê of_real_cosh_of_real_re, of_real_im]
intros
have s1 := sin_add ((x + y) / 2) ((x - y) / 2)
have s2 := sin_sub ((x + y) / 2) ((x - y) / 2)
rw [div_add_div_same, add_sub, add_right_comm, add_sub_cancel, half_add_self] at s1
rw [div_sub_div_same, ‚Üêsub_add, add_sub_cancel', half_add_self] at s2
rw [s1, s2]
ring
simp [real.exp]
intros
simp only [bit1, add_monoid_hom.map_add, bit0_re, add_right_inj, one_re]
intros
ext
simp only [map_range_apply f, coe_add, pi.add_apply, hf']
intros
simp [h]
intros
ext j
{ ext j, by_cases h1 : j = i; by_cases h2 : f j ‚â† 0; simp at h2; simp [h1, h2] }
by_cases h1 : j = i
by_cases h1 : j = i; by_cases h2 : f j ‚â† 0; simp at h2; simp [h1, h2]
by_cases h1 : j = i; by_cases h2 : f j ‚â† 0; simp at h2
by_cases h1 : j = i; by_cases h2 : f j ‚â† 0
by_cases h2 : f j ‚â† 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
by_cases h2 : f j ‚â† 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
intros
simp [perm.extend_domain]
intros
{ ext i, cases i; refl }
ext i
cases i
cases i; refl
refl
refl
intros
simp [insert_nth_last]
intros
cases n
{ cases h }
cases h
rw [fin.coe_add, fin.coe_one, nat.mod_eq_of_lt (nat.succ_lt_succ _)]
exact h
intros
{ cases i, refl }
cases i
refl
intros
simpa [eq_empty_iff_forall_not_mem]
intros
rw [‚Üê not_nonempty_iff_eq_empty, nonempty_range_iff, not_not]
intros
simp only [mem_def, image_val, mem_erase_dup, multiset.mem_map, exists_prop]
intros
by_cases a ‚àà s; [{rw [insert_eq_of_mem h], apply nat.le_add_right}, rw [card_insert_of_not_mem h]]
by_cases a ‚àà s
rw [insert_eq_of_mem h]
apply nat.le_add_right
rw [card_insert_of_not_mem h]
intros
haveI := classical.dec_eq Œ±; exact finset.induction_on s rfl (Œª a s has ih, by simp only [bUnion_insert, image_union, ih])
haveI := classical.dec_eq Œ±
exact finset.induction_on s rfl (Œª a s has ih, by simp only [bUnion_insert, image_union, ih])
intros
classical
{ classical, simp [‚Üê card_union_eq, filter_union_filter_neg_eq, disjoint_filter], }
simp [‚Üê card_union_eq, filter_union_filter_neg_eq, disjoint_filter]
intros
{ contrapose! h, simp [h] }
contrapose! h
simp [h]
intros
change _ ‚Üî ‚àÉ v ‚àà s, x ‚àà (f v).val
rw [‚Üêmultiset.mem_sup, ‚Üêmultiset.mem_to_finset, sup_to_finset]
simp_rw [val_to_finset]
intros
simp_rw [to_multiset_sum, finsupp.to_multiset_single, sum_nsmul, sum_multiset_singleton]
intros
ext
simp only [inf_apply, mem_support_iff, ne.def, finset.mem_union, finset.mem_filter, finset.mem_inter]
simp only [inf_eq_min, ‚Üê nonpos_iff_eq_zero, min_le_iff, not_or_distrib]
intros
{ ext, simp only [set.mem_univ, mem_univ, set.mem_to_finset] }
ext
simp only [set.mem_univ, mem_univ, set.mem_to_finset]
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
simpa using exists_min_image univ f univ_nonempty
intros
simp
intros
simp [fin.univ_def, finset.fin_range]
intros
induction n; simp *
induction n
simp *
simp *
intros
{ rw int.lcm, apply nat.lcm_one_left }
rw int.lcm
apply nat.lcm_one_left
intros
induction n with n ih; simp [*, even_mul, pow_succ]
{ induction n with n ih; simp [*, even_mul, pow_succ], tauto }
induction n with n ih
simp [*, even_mul, pow_succ]
simp [*, even_mul, pow_succ]
tauto
intros
simp only [has_mem.mem, lazy_list.mem, or_imp_distrib, forall_and_distrib, forall_eq]
intros
induction l with b l ih
refl
{refl}
simp only [length, index_of_cons]
by_cases h : a = b
rw if_pos h
{rw if_pos h, exact nat.zero_le _}
exact nat.zero_le _
rw if_neg h
exact succ_le_succ ih
intros
cases l; refl
cases l
refl
refl
intros
refl
intros
induction l with hd tl hl generalizing n
{ simp }
simp
cases n; simp [hl]
{ cases n; simp [hl] }
cases n
simp [hl]
simp [hl]
intros
simp only [reduce_option, id.def, mem_filter_map, exists_eq_right]
intros
simp only [eq_nil_iff_forall_not_mem, mem_inter, not_and]
simp only [eq_nil_iff_forall_not_mem, mem_inter, not_and]; refl
refl
intros
{ induction l with c l', contradiction, use [c,l'], }
induction l with c l'
contradiction
use [c,l']
intros
induction l‚ÇÅ with a l‚ÇÅ IH
refl
{refl}
rw [cons_union, ‚Üê IH]
show erase_dup (a :: (l‚ÇÅ ++ l‚ÇÇ)) = insert a (erase_dup (l‚ÇÅ ++ l‚ÇÇ))
by_cases a ‚àà erase_dup (l‚ÇÅ ++ l‚ÇÇ); [ rw [erase_dup_cons_of_mem' h, insert_of_mem h], rw [erase_dup_cons_of_not_mem' h, insert_of_not_mem h]]
by_cases a ‚àà erase_dup (l‚ÇÅ ++ l‚ÇÇ)
rw [erase_dup_cons_of_mem' h, insert_of_mem h]
rw [erase_dup_cons_of_not_mem' h, insert_of_not_mem h]
intros
cases le_total l m with hlm hml
rw [‚Üê append_consecutive hnl hlm, filter_append, filter_le_of_top_le (le_refl l), filter_le_of_le_bot (le_refl l), nil_append]
{ rw [‚Üê append_consecutive hnl hlm, filter_append, filter_le_of_top_le (le_refl l), filter_le_of_le_bot (le_refl l), nil_append] }
{ rw [eq_nil_of_le hml, filter_le_of_top_le hml] }
rw [eq_nil_of_le hml, filter_le_of_top_le hml]
intros
induction l with a l IH generalizing t‚ÇÅ t‚ÇÇ p
simp
{simp}
by_cases a ‚àà t‚ÇÅ
{ simp [h, p.subset h, IH (p.erase _)] }
simp [h, p.subset h, IH (p.erase _)]
{ simp [h, mt p.mem_iff.2 h, IH p] }
simp [h, mt p.mem_iff.2 h, IH p]
intros
simp only [succ_pos', lt_add_iff_pos_right, mem_range]
intros
rw [rotate_eq_rotate', rotate'_length]
intros
obtain ‚ü®n, rfl‚ü© := h
exact ‚ü®_, (reverse_rotate _ _).symm‚ü©
intros
induction l
refl
cases l_hd with a' b
by_cases a = a'
subst a'
{ subst a', rw [erase_dupkeys_cons,lookup_kinsert,lookup_cons_eq] }
rw [erase_dupkeys_cons,lookup_kinsert,lookup_cons_eq]
rw [erase_dupkeys_cons,lookup_kinsert_ne h,l_ih,lookup_cons_ne]
{ rw [erase_dupkeys_cons,lookup_kinsert_ne h,l_ih,lookup_cons_ne], exact h }
exact h
intros
induction l with hd tl hl generalizing l' n
{ simp }
simp
cases l'
{ cases l', { simp }, { cases n, { simp }, { simp [hl] } } }
{ simp }
simp
cases n
{ cases n, { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
{ ext i j, simp }
ext i j
simp
intros
ext x y
simp [update_column_apply, subsingleton.elim i y]
intros
simp [dot_product, add_mul, finset.sum_add_distrib]
intros
simp only [h, coe_scalar, one_apply_ne, ne.def, not_false_iff, pi.smul_apply, smul_zero]
intros
ext i j
rcases i
rcases i; rcases j; simp [from_blocks]
rcases i; rcases j
rcases j
simp [from_blocks]
simp [from_blocks]
rcases j
simp [from_blocks]
simp [from_blocks]
intros
{ ext, simp, }
ext
simp
intros
{ ext i j, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i j
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
rw [‚Üê singleton_add, ‚Üê singleton_add, add_assoc]
intros
induction l using quotient.induction_on
simpa using list.max_le_of_forall_le _ _ h
intros
{ ext i, simp }
ext i
simp
intros
simp only [expand, bind‚ÇÅ_X_left, alg_hom.id_apply, ring_hom.to_fun_eq_coe, eval‚ÇÇ_hom_C_left, alg_hom.coe_to_ring_hom, pow_one, alg_hom.coe_mk]
intros
rw [bind‚ÇÇ_monomial, f.map_one, one_mul]
intros
rw [mem_supported]
intros
rw [total_degree]
congr
funext m
exact (finsupp.card_to_multiset _).symm
intros
rw [add_mod_mod, mod_add_mod]
intros
cases b; [exact nat.bit0_ne_zero h, exact nat.bit1_ne_zero _]
cases b
exact nat.bit0_ne_zero h
exact nat.bit1_ne_zero _
intros
{ dunfold decreasing_induction, rw [le_rec_on_succ] }
dunfold decreasing_induction
rw [le_rec_on_succ]
intros
rw [test_bit, shiftr_eq_div_pow]
cases hm.lt_or_lt with hm hm
rw [nat.div_eq_zero, bodd_zero]
{ rw [nat.div_eq_zero, bodd_zero], exact nat.pow_lt_pow_of_lt_right one_lt_two hm }
exact nat.pow_lt_pow_of_lt_right one_lt_two hm
rw [pow_div hm.le zero_lt_two, ‚Üênat.sub_add_cancel (nat.sub_pos_of_lt hm), pow_succ]
{ rw [pow_div hm.le zero_lt_two, ‚Üênat.sub_add_cancel (nat.sub_pos_of_lt hm), pow_succ], simp }
simp
intros
refine one_div_le_one_div_of_le _ _
{ refine one_div_le_one_div_of_le _ _, exact nat.cast_add_one_pos _, simpa }
exact nat.cast_add_one_pos _
simpa
intros
suffices : (list.range l.length).zip_with (((Œª (i a : ‚Ñï), a * b ^ i) ‚àò succ)) l = (list.range l.length).zip_with (Œª i a, b * (a * b ^ i)) l
{ simp [this] }
simp [this]
congr
ext
simp [pow_succ]
ring
intros
have t := dvd_iff_dvd_of_digits 11 10 (-1 : ‚Ñ§) (by norm_num) n
rw of_digits_neg_one at t
exact t
intros
rw [‚Üê some_eq_coe]
simp only [lt_def, exists_prop_of_true, dom_some, forall_true_iff]
refl
intros
{ rw le_coe_iff, refine ‚ü®‚ü®_, h‚ü©, @nat.find_min' P _ _ _ h‚ü© }
rw le_coe_iff
refine ‚ü®‚ü®_, h‚ü©, @nat.find_min' P _ _ _ h‚ü©
intros
induction n with n IH; simp
induction n with n IH
simp
{ have := nat.eq_zero_of_le_zero h, subst m, simp }
have := nat.eq_zero_of_le_zero h
subst m
simp
obtain he | hl := h.eq_or_lt
{ subst m, simp }
subst m
exact (IH (le_of_lt_succ hl)).mul_left _
intros
delta lcm; rw [nat.mul_div_cancel' ((gcd_dvd_left m n).trans (dvd_mul_right m n))]
delta lcm
rw [nat.mul_div_cancel' ((gcd_dvd_left m n).trans (dvd_mul_right m n))]
intros
rw [mul_comm m n, mul_comm k n, mul_comm (gcd m k) n, gcd_mul_left]
intros
{ rw [add_comm a, add_comm b] at h‚ÇÇ, exact h‚ÇÅ.add_left_cancel h‚ÇÇ }
rw [add_comm a, add_comm b] at h‚ÇÇ
exact h‚ÇÅ.add_left_cancel h‚ÇÇ
intros
rw [mul_comm a, mul_comm b]; exact h.mul_left c
rw [mul_comm a, mul_comm b]
exact h.mul_left c
intros
rw [succ_eq_add_one, even_add]; simp [not_even_one]
rw [succ_eq_add_one, even_add]
simp [not_even_one]
intros
simpa only [pow_two] using not_exists_sq (by simpa only [pow_two] using hl) (by simpa only [pow_two] using hr)
intros
rw [‚Üê cast_to_int m, ‚Üê cast_to_int n, int.cast_lt, lt_to_int]
simp [num.of_nat']
intros
simp
intros
cases o; simp
cases o
simp
simp
intros
linarith
intros
simp [node3_l, all_node', and_assoc]
intros
rw [balance_r_eq_balance' hl hr sl sr H, size_balance' sl sr]
intros
rw [‚Üê bind_some_eq_map, bind_map, bind_some_eq_map]
intros
rw [W_dest', W_rec_eq]
intros
by_cases h : j = i
{ subst h, simp only [single_eq_same] }
subst h
simp only [single_eq_same]
{ simp only [single_eq_of_ne h, hf'] }
simp only [single_eq_of_ne h, hf']
intros
{ rw [‚Üê monomial_zero_one, coeff_monomial], simp }
rw [‚Üê monomial_zero_one, coeff_monomial]
simp
intros
simp [coeff_erase]
intros
rw [C_mul_X_pow_eq_monomial]
exact support_monomial' _ _
intros
rw [‚Üê C_1]; exact le_trailing_degree_C
rw [‚Üê C_1]
exact le_trailing_degree_C
intros
rw erase_lead_support
exact card_lt_card (erase_ssubset $ nat_degree_mem_support_of_nonzero h)
intros
induction k with k ih
{ simp, }
simp
{ simp [pow_succ', mul_X_comp, ih], }
simp [pow_succ', mul_X_comp, ih]
intros
rw [‚Üê C_1, hasse_deriv_C k _ hk]
intros
{ rw [lifts_iff_ring_hom_srange, mem_map_srange f], refl }
rw [lifts_iff_ring_hom_srange, mem_map_srange f]
refl
intros
revert h
refine multiset.induction_on t _ (Œª a t ih ht, _)
simp only [multiset.not_mem_zero, forall_prop_of_true, forall_prop_of_false, multiset.map_zero, multiset.prod_zero, multiset.sum_zero, not_false_iff, forall_true_iff]
{ simp only [multiset.not_mem_zero, forall_prop_of_true, forall_prop_of_false, multiset.map_zero, multiset.prod_zero, multiset.sum_zero, not_false_iff, forall_true_iff], rw ‚Üê C_1, rw next_coeff_C_eq_zero }
rw ‚Üê C_1
rw next_coeff_C_eq_zero
rw [multiset.map_cons, multiset.prod_cons, multiset.map_cons, multiset.sum_cons, monic.next_coeff_mul, ih]
{ rw [multiset.map_cons, multiset.prod_cons, multiset.map_cons, multiset.sum_cons, monic.next_coeff_mul, ih], exacts [Œª i hi, ht i (multiset.mem_cons_of_mem hi), ht a (multiset.mem_cons_self _ _), monic_multiset_prod_of_monic _ _ (Œª b bs, ht _ (multiset.mem_cons_of_mem bs))] }
exacts [Œª i hi, ht i (multiset.mem_cons_of_mem hi), ht a (multiset.mem_cons_self _ _), monic_multiset_prod_of_monic _ _ (Œª b bs, ht _ (multiset.mem_cons_of_mem bs))]
intros
{ convert (prime_X_sub_C (0 : R)), simp }
convert (prime_X_sub_C (0 : R))
simp
intros
rw [‚Üê coeff_comp_degree_mul_degree hq, ‚Üê nat_degree_comp]
rw [‚Üê coeff_comp_degree_mul_degree hq, ‚Üê nat_degree_comp]; refl
refl
intros
mv_bisim x‚ÇÄ
rw [Ha,Hb,cofix.dest_corec,cofix.dest_corec]
rw [mvfunctor.map_map,‚Üê append_fun_comp_id]
refine liftr_map_last _ _ _ _ _
intros a
refine ‚ü®a,rfl,rfl‚ü©
intros
cases x with a f; exact Wequiv.abs a f a f rfl
cases x with a f
exact Wequiv.abs a f a f rfl
intros
rw [rat.mul_comm, rat.add_mul, rat.mul_comm, rat.mul_comm c a]
intros
cases d; refl
cases d
refl
intros
exact_mod_cast inv_coe_int_denom (by exact_mod_cast ha0 : 0 < (a : ‚Ñ§))
intros
cases q
{ cases q, refl }
refl
intros
simp [cantor_function_aux, h]
intros
rw mul_comm; apply mul_equiv_zero _ hf
rw mul_comm
apply mul_equiv_zero _ hf
intros
have := h.inv_add_inv_conj
rw [‚Üê eq_sub_iff_add_eq', one_div, inv_eq_iff] at this
field_simp [‚Üê this, h.ne_zero]
intros
rw [div_eq_mul_inv, mul_assoc, inv_mul_cancel h0 hI, mul_one]
intros
simp [ennreal.of_real]
intros
simp
intros
{ unfold_coes, simp [real.to_ereal, option.some_inj] }
unfold_coes
simp [real.to_ereal, option.some_inj]
intros
simp only [abs_sub_lt_iff, sub_lt_iff_lt_add, is_st, and_comm, add_comm]
intros
rw [‚Üê nnreal.coe_le_coe, real.coe_to_nnreal p hp]
intros
rw [div_eq_inv_mul, div_eq_inv_mul, real.to_nnreal_mul (inv_nonneg.2 hy), real.to_nnreal_inv]
intros
induction l with a l IH; simp [ret_mem]; exact think_mem (mem_map _ IH)
induction l with a l IH; simp [ret_mem]
induction l with a l IH
simp [ret_mem]
simp [ret_mem]
exact think_mem (mem_map _ IH)
intros
rw [ite_inter_inter, ite_same]
intros
split
refine Œª h, (Œª a ha b hb, _)
{ refine Œª h, (Œª a ha b hb, _), exact set_coe.ext_iff.2 (@subsingleton.elim s h ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©) }
exact set_coe.ext_iff.2 (@subsingleton.elim s h ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©)
exact Œª h, subsingleton.intro (Œª a b, set_coe.ext (h a.property b.property))
{ exact Œª h, subsingleton.intro (Œª a b, set_coe.ext (h a.property b.property)) }
intros
{ ext ‚ü®x, y‚ü©, simp [and_or_distrib_left] }
ext ‚ü®x, y‚ü©
simp [and_or_distrib_left]
intros
{ ext, simp [pi, or_imp_distrib, forall_and_distrib] }
ext
simp [pi, or_imp_distrib, forall_and_distrib]
intros
ext
split
rintro ‚ü®a, _, ha, ‚ü®b, c, hb, hc, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®a, _, ha, ‚ü®b, c, hb, hc, rfl‚ü©, rfl‚ü©, refine ‚ü®a, b, c, ha, hb, hc, rfl‚ü© }
refine ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©
{ rintro ‚ü®a, b, c, ha, hb, hc, rfl‚ü©, refine ‚ü®a, _, ha, ‚ü®b, c, hb, hc, rfl‚ü©, rfl‚ü© }
refine ‚ü®a, _, ha, ‚ü®b, c, hb, hc, rfl‚ü©, rfl‚ü©
intros
rw ‚Üê image_univ; exact (countable_encodable _).image _
rw ‚Üê image_univ
exact (countable_encodable _).image _
intros
{ ext, rw [set.finite.mem_to_finset, mem_coe] }
ext
rw [set.finite.mem_to_finset, mem_coe]
intros
rw [‚Üêimage_univ, maps_image_to]
intros
{ intros i ht, by_cases hs : i ‚àà s; simp [hf i ht, hg i ht, hs] }
intros i ht
by_cases hs : i ‚àà s
by_cases hs : i ‚àà s; simp [hf i ht, hg i ht, hs]
simp [hf i ht, hg i ht, hs]
simp [hf i ht, hg i ht, hs]
intros
rw [‚Üê Icc_diff_both, diff_diff_cancel_left]
{ rw [‚Üê Icc_diff_both, diff_diff_cancel_left], simp [insert_subset, h] }
simp [insert_subset, h]
intros
ext1 x
simp_rw [mem_union, mem_Ioc, mem_Ioi, min_lt_iff]
by_cases hc : c < x
{ tauto }
tauto
have hxb : x ‚â§ b := (le_of_not_gt hc).trans h‚ÇÅ
{ have hxb : x ‚â§ b := (le_of_not_gt hc).trans h‚ÇÅ, tauto }
tauto
intros
simp [‚Üê Ioi_inter_Iic]
intros
simp
intros
simp [‚Üê Ici_inter_Iio, h]
intros
simp only [eq_univ_iff_forall, mem_Union]
intros
rw [lt_iff_le_not_le, not_le_iff_exists]
intros
intros y
cases y with j y
cases h‚ÇÅ j with i hi
subst j
cases h‚ÇÇ i y with x hx
subst y
exact ‚ü®‚ü®i, x‚ü©, rfl‚ü©
intros
ext i : 1; cases i; refl
ext i : 1; cases i
ext i : 1
cases i
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
{ apply fin.coe_coe_eq_self }
apply fin.coe_coe_eq_self
intros
rw [mul_comm, mul_inv_of_unit a h]
intros
rw [hf.map_mul, hf.map_inv] at h
rw [‚Üêinv_inv (f b), eq_inv_of_mul_eq_one h]
intros
simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)
intros
simpa only [h.comp_eq] using inv_on_fixed_pts_comp f g
intros
let K := p.splitting_field
let L := q.splitting_field
haveI : fact (p.splits (algebra_map F L)) := ‚ü®hpq‚ü©
let œï : (L ‚âÉ‚Çê[K] L) ‚âÉ* (q.map (algebra_map F K)).gal := (is_splitting_field.alg_equiv L (q.map (algebra_map F K))).aut_congr
have œï_inj : function.injective œï.to_monoid_hom := œï.injective
haveI : is_solvable (K ‚âÉ‚Çê[F] K) := hp
haveI : is_solvable (L ‚âÉ‚Çê[K] L) := solvable_of_solvable_injective œï_inj
exact is_solvable_of_is_scalar_tower F p.splitting_field q.splitting_field
intros
obtain ‚ü®v, hv, hxv, hyv‚ü© := lifts.exists_max_two hc hx hy
obtain ‚ü®w, hw, hzw, hvw‚ü© := lifts.exists_max_two hc hz hv
exact ‚ü®w, hw, le_trans hxv hvw, le_trans hyv hvw, hzw‚ü©
intros
cases char_p.exists K with p hp
letI := hp
rcases finite_field.card K p with ‚ü®‚ü®n, npos‚ü©, ‚ü®hp, hn‚ü©‚ü©
haveI : fact p.prime := ‚ü®hp‚ü©
dsimp at hn
rw hn at *
rw ‚Üê map_expand_pow_char
rw [frobenius_pow hn, ring_hom.one_def, map_id]
intros
rw [finset_basis, basis.range_reindex, basis.range_of_vector_space]
intros
haveI : is_galois F p.splitting_field := is_galois.of_separable_splitting_field hp
exact is_galois.card_aut_eq_finrank F p.splitting_field
intros
simp_rw [separable_def, derivative_map, is_coprime_map]
intros
by_cases h : m = m'
rw h at h_expand
{ rw h at h_expand, have expand_deg : ((expand F (q ^ m')) g).nat_degree = (expand F (q ^ m') g').nat_degree, by rw h_expand, rw [nat_degree_expand (q^m') g, nat_degree_expand (q^m') g'] at expand_deg, apply nat.eq_of_mul_eq_mul_left (pow_pos hq.1.pos m'), rw [mul_comm] at expand_deg, rw expand_deg, rw [mul_comm] }
have expand_deg : ((expand F (q ^ m')) g).nat_degree = (expand F (q ^ m') g').nat_degree
rw h_expand
rw h_expand
rw [nat_degree_expand (q^m') g, nat_degree_expand (q^m') g'] at expand_deg
apply nat.eq_of_mul_eq_mul_left (pow_pos hq.1.pos m')
rw [mul_comm] at expand_deg
rw expand_deg
rw [mul_comm]
cases ne.lt_or_lt h
{ cases ne.lt_or_lt h, { exact contraction_degree_eq_aux q g g' m m' h_expand h_1 hg }, { exact (contraction_degree_eq_aux q g' g m' m h_expand.symm h_1 hg').symm, } }
{ exact contraction_degree_eq_aux q g g' m m' h_expand h_1 hg }
exact contraction_degree_eq_aux q g g' m m' h_expand h_1 hg
exact (contraction_degree_eq_aux q g' g m' m h_expand.symm h_1 hg').symm
{ exact (contraction_degree_eq_aux q g' g m' m h_expand.symm h_1 hg').symm, }
intros
rw [remove_factor, nat_degree_div_by_monic _ (monic_X_sub_C _), nat_degree_map, nat_degree_X_sub_C]
intros
rw [angle_comm, angle_smul_right_of_neg y x hr, angle_comm]
intros
simp_rw [sum_points_with_circumcenter, centroid_weights_with_circumcenter, add_zero, ‚Üêfs.sum_centroid_weights_eq_one_of_nonempty ‚Ñù h, set.sum_indicator_subset _ fs.subset_univ]
rcongr
intros
simpa only [ext_chart_at_source] using f.closure_support_subset_ext_chart_at_source
intros
ext x : 1
simp only [mfderiv_within, mfderiv] with mfld_simps
rw mdifferentiable_within_at_univ
intros
haveI : locally_compact_space H := I.locally_compact
haveI : locally_compact_space M := charted_space.locally_compact H
haveI : normal_space M := normal_of_paracompact_t2
have hB := Œª x hx, smooth_bump_function.nhds_basis_support I (hU x hx)
rcases refinement_of_locally_compact_sigma_compact_of_nhds_basis_set hs hB with ‚ü®Œπ, c, f, hf, hsub', hfin‚ü©
choose hcs hfU using hf
rcases exists_subset_Union_closed_subset hs (Œª i, (f i).open_support) (Œª x hx, hfin.point_finite x) hsub' with ‚ü®V, hsV, hVc, hVf‚ü©
choose r hrR hr using Œª i, (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)
refine ‚ü®Œπ, ‚ü®c, Œª i, (f i).update_r (r i) (hrR i), hcs, _, Œª x hx, _‚ü©, Œª i, _‚ü©
{ simpa only [smooth_bump_function.support_update_r] }
simpa only [smooth_bump_function.support_update_r]
refine (mem_Union.1 $ hsV hx).imp (Œª i hi, _)
{ refine (mem_Union.1 $ hsV hx).imp (Œª i hi, _), exact ((f i).update_r _ _).eventually_eq_one_of_dist_lt ((f i).support_subset_source $ hVf _ hi) (hr i hi).2 }
exact ((f i).update_r _ _).eventually_eq_one_of_dist_lt ((f i).support_subset_source $ hVf _ hi) (hr i hi).2
simpa only [coe_mk, smooth_bump_function.support_update_r] using hfU i
{ simpa only [coe_mk, smooth_bump_function.support_update_r] using hfU i }
intros
rw ‚Üê ext_chart_at_source I
{ rw ‚Üê ext_chart_at_source I, exact ext_chart_preimage_open_of_open' I x hs }
exact ext_chart_preimage_open_of_open' I x hs
intros
simp only [times_cont_mdiff_within_at_iff'', continuous_within_at_pi, times_cont_diff_within_at_pi, forall_and_distrib, written_in_ext_chart_at, ext_chart_model_space_eq_id, (‚àò), local_equiv.refl_coe, id]
intros
have key : ‚àÄ g h, quotient.mk' g = quotient.mk' h ‚Üî h * g‚Åª¬π ‚àà H := @quotient.eq' G (quotient_group.right_rel H)
simp_rw [mem_right_transversals_iff_exists_unique_mul_inv_mem, set_like.mem_coe, ‚Üêkey]
exact ‚ü®Œª h q, quotient.induction_on' q h, Œª h g, h (quotient.mk' g)‚ü©
intros
rw map_comp
{ rw map_comp, refl }
refl
intros
have : red ((x1, b1) :: L‚ÇÅ) ([(x2, b2)] ++ L‚ÇÇ)
from H2
rcases to_append_iff.1 this with ‚ü®_ | ‚ü®p, L‚ÇÉ‚ü©, L‚ÇÑ, eq, h‚ÇÅ, h‚ÇÇ‚ü©
{ simp [nil_iff] at h‚ÇÅ, contradiction }
simp [nil_iff] at h‚ÇÅ
contradiction
cases eq
{ cases eq, show red (L‚ÇÉ ++ L‚ÇÑ) ([(x1, bnot b1), (x2, b2)] ++ L‚ÇÇ), apply append_append _ h‚ÇÇ, have h‚ÇÅ : red ((x1, bnot b1) :: (x1, b1) :: L‚ÇÉ) [(x1, bnot b1), (x2, b2)], { exact cons_cons h‚ÇÅ }, have h‚ÇÇ : red ((x1, bnot b1) :: (x1, b1) :: L‚ÇÉ) L‚ÇÉ, { exact step.cons_bnot_rev.to_red }, rcases church_rosser h‚ÇÅ h‚ÇÇ with ‚ü®L', h‚ÇÅ, h‚ÇÇ‚ü©, rw [red_iff_irreducible H1] at h‚ÇÅ, rwa [h‚ÇÅ] at h‚ÇÇ }
show red (L‚ÇÉ ++ L‚ÇÑ) ([(x1, bnot b1), (x2, b2)] ++ L‚ÇÇ)
apply append_append _ h‚ÇÇ
have h‚ÇÅ : red ((x1, bnot b1) :: (x1, b1) :: L‚ÇÉ) [(x1, bnot b1), (x2, b2)]
{ exact cons_cons h‚ÇÅ }
exact cons_cons h‚ÇÅ
have h‚ÇÇ : red ((x1, bnot b1) :: (x1, b1) :: L‚ÇÉ) L‚ÇÉ
{ exact step.cons_bnot_rev.to_red }
exact step.cons_bnot_rev.to_red
rcases church_rosser h‚ÇÅ h‚ÇÇ with ‚ü®L', h‚ÇÅ, h‚ÇÇ‚ü©
rw [red_iff_irreducible H1] at h‚ÇÅ
rwa [h‚ÇÅ] at h‚ÇÇ
intros
rw [‚Üê mk_eq_monoid_of_mk', lift_on‚ÇÇ_mk]
intros
obtain ‚ü®c, hc‚ü© := f.eq_iff_exists.1 h
rw [‚Üêmul_one (g x), ‚Üêis_unit.mul_lift_right_inv (g.mrestrict S) hg c]
show _ * (g c * _) = _
rw [‚Üêmul_assoc, ‚Üêg.map_mul, hc, mul_inv_left hg, g.map_mul, mul_comm]
intros
simpa [‚Üê order_of_of_add_eq_add_order_of, of_add_nsmul] using order_of_pow' _ h
intros
rw ‚Üê lcm_cycle_type
exact dvd_lcm h
intros
rw [‚Üêlcm_cycle_type, ht.cycle_type, multiset.lcm_singleton, normalize_eq]
intros
by_cases hx : f x = x
{ rwa [if_pos hx, cycle_of_eq_one_iff] }
rwa [if_pos hx, cycle_of_eq_one_iff]
{ rwa [if_neg hx, hf.cycle_of_eq] }
rwa [if_neg hx, hf.cycle_of_eq]
intros
rw [cycle_range, of_left_inverse'_eq_of_injective, ‚Üêfunction.embedding.to_equiv_range_eq_of_injective, ‚Üêvia_fintype_embedding, via_fintype_embedding_apply_not_mem_range]
simpa
intros
have h' : nodup (l.rotate 1)
{ simpa using h }
simpa using h
by_cases hl : ‚àÄ (x : Œ±), l ‚â† [x]
have hl' : ‚àÄ (x : Œ±), l.rotate 1 ‚â† [x]
{ have hl' : ‚àÄ (x : Œ±), l.rotate 1 ‚â† [x], { intro, rw [ne.def, rotate_eq_iff], simpa using hl _ }, ext x, by_cases hx : x ‚àà l.rotate 1, { obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem hx, rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h], simp }, { rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem], simpa using hx } }
intro
{ intro, rw [ne.def, rotate_eq_iff], simpa using hl _ }
rw [ne.def, rotate_eq_iff]
simpa using hl _
ext x
by_cases hx : x ‚àà l.rotate 1
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem hx
{ obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem hx, rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h], simp }
rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h]
simp
rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem]
{ rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem], simpa using hx }
simpa using hx
push_neg at hl
{ push_neg at hl, obtain ‚ü®x, rfl‚ü© := hl, simp }
obtain ‚ü®x, rfl‚ü© := hl
simp
intros
intro
simp only [and_imp, perm.coe_mul, function.comp_app, ne.def, mem_support, mem_insert, mem_sdiff, mem_singleton]
push_neg
rintro ha ‚ü®hx, hy‚ü© H
rw [swap_apply_eq_iff, swap_apply_of_ne_of_ne hx hy] at H
exact ha H
intros
induction n with n ih
rwa [derived_series_zero, derived_series_zero, top_le_iff, ‚Üê monoid_hom.range_eq_map, ‚Üê monoid_hom.range_top_iff_surjective.mpr]
{ rwa [derived_series_zero, derived_series_zero, top_le_iff, ‚Üê monoid_hom.range_eq_map, ‚Üê monoid_hom.range_top_iff_surjective.mpr], }
simp only [*, derived_series_succ, commutator_le_map_commutator]
{ simp only [*, derived_series_succ, commutator_le_map_commutator], }
intros
simp_rw [‚Üêset_like.mem_coe] at ha
simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha]
convert set.to_finset_univ
intros
change _ = 2^2
haveI : fact(nat.prime 2) := fact.mk (nat.prime_two)
apply order_of_eq_prime_pow
intro h
{ intro h, simp only [pow_one, xa_sq] at h, injection h with h', apply_fun zmod.val at h', apply_fun ( / n) at h', simp only [zmod.val_nat_cast, zmod.val_zero, nat.zero_div, nat.mod_mul_left_div_self, nat.div_self hpos.1] at h', norm_num at h' }
simp only [pow_one, xa_sq] at h
injection h with h'
apply_fun zmod.val at h'
apply_fun ( / n) at h'
simp only [zmod.val_nat_cast, zmod.val_zero, nat.zero_div, nat.mod_mul_left_div_self, nat.div_self hpos.1] at h'
norm_num at h'
{ norm_num }
norm_num
intros
rw [range_eq_map, range_eq_map]; exact (‚ä§ : subgroup G).map_map g f
rw [range_eq_map, range_eq_map]
exact (‚ä§ : subgroup G).map_map g f
intros
simp only [infi, coe_Inf, set.bInter_range]
intros
simp_rw [set_like.le_def, ‚Üêsylow.smul_eq_iff_mem_normalizer]
simp_rw [set_like.le_def, ‚Üêsylow.smul_eq_iff_mem_normalizer]; exact subtype.forall
exact subtype.forall
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_left k hp, ‚Üêset.insert_eq_of_mem hp, ‚Üêset.insert_diff_singleton, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
{ ext x, fin_cases x; simp }
ext x
fin_cases x
fin_cases x; simp
simp
simp
intros
simp only [line_map_apply_module]
exact add_le_add_left (smul_le_smul_of_nonneg hb hr) _
intros
simp only [‚Üê union_singleton, span_union, mem_sup, mem_span_singleton, exists_prop, exists_exists_eq_and]
rw [exists_comm]
simp only [eq_comm, add_comm, exists_and_distrib_left]
intros
simp [disjoint_def]
intros
simp
intros
rw set_like.le_def
intros m h
change f‚ÇÅ m + f‚ÇÇ m ‚àà q
change f‚ÇÅ m ‚àà q ‚àß f‚ÇÇ m ‚àà q at h
apply q.add_mem h.1 h.2
intros
let f_i : M ‚Üí‚Çó[R] R := { to_fun := Œª x, f x i, map_add' := Œª _ _, by rw [hadd, pi.add_apply], map_smul' := Œª _ _, by { simp [hsmul, pi.smul_apply] } }
have : (finsupp.lapply i) ‚àò‚Çó ‚Üëb.repr = f_i
refine b.ext (Œª j, _)
{ refine b.ext (Œª j, _), show b.repr (b j) i = f (b j) i, rw [b.repr_self, f_eq] }
show b.repr (b j) i = f (b j) i
rw [b.repr_self, f_eq]
calc b.repr x i = f_i x : by { rw ‚Üê this, refl } ... = f x i : rfl
intros
refl
intros
rw [matrix.to_bilin, bilin_form.to_matrix, linear_equiv.symm_trans_apply, ‚Üê matrix.to_bilin']
simp only [congr_symm, congr_apply, linear_equiv.symm_symm, matrix.to_bilin'_apply, basis.equiv_fun_apply]
intros
ext
simp only [linear_map.comp_apply, alg_hom.to_linear_map_apply]
induction x using clifford_algebra.induction
simp
case h_grade0 : { simp }
simp
case h_grade1 : { simp }
case h_mul : a b ha hb { simp only [ha, hb, reverse.map_mul, alg_hom.map_mul], }
case h_add : a b ha hb { simp only [ha, hb, reverse.map_add, alg_hom.map_add], }
intros
haveI := classical.dec_eq M
{ haveI := classical.dec_eq M, rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b] }
rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b]
intros
rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum, linear_map.sum_apply]
simp_rw [linear_map.map_smul, linear_map.smul_apply, to_dual_apply, smul_eq_mul, mul_boole, finset.sum_ite_eq']
split_ifs with h
{ refl }
refl
{ rw finsupp.not_mem_support_iff.mp h }
rw finsupp.not_mem_support_iff.mp h
intros
fsplit
intro h
{ intro h, by_cases h' : finrank K V = 0, { use 0, intro w, use 0, haveI := finrank_zero_iff.mp h', apply subsingleton.elim, }, { replace h' := zero_lt_iff.mpr h', have : finrank K V = 1, { linarith }, obtain ‚ü®v, -, p‚ü© := finrank_eq_one_iff'.mp this, use ‚ü®v, p‚ü©, }, }
by_cases h' : finrank K V = 0
use 0
{ use 0, intro w, use 0, haveI := finrank_zero_iff.mp h', apply subsingleton.elim, }
intro w
use 0
haveI := finrank_zero_iff.mp h'
apply subsingleton.elim
replace h' := zero_lt_iff.mpr h'
{ replace h' := zero_lt_iff.mpr h', have : finrank K V = 1, { linarith }, obtain ‚ü®v, -, p‚ü© := finrank_eq_one_iff'.mp this, use ‚ü®v, p‚ü©, }
have : finrank K V = 1
linarith
{ linarith }
obtain ‚ü®v, -, p‚ü© := finrank_eq_one_iff'.mp this
use ‚ü®v, p‚ü©
rintro ‚ü®v, p‚ü©
{ rintro ‚ü®v, p‚ü©, exact finrank_le_one v p, }
exact finrank_le_one v p
intros
have := dim_self K
rw [‚Üêfinrank_eq_dim] at this
exact_mod_cast this
intros
rw [‚Üê total_single, ‚Üê unique_single l]
intros
let P := (finsupp.linear_equiv_fun_on_fintype R R Œ≤)
let Q := (finsupp.linear_equiv_fun_on_fintype R R Œ±).symm
exact card_le_of_surjective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.surjective.comp i).comp Q.surjective)
intros
convert linear_independent.image_of_comp s f id hs
intros
rw [disjoint_def] at h
have hy : y = 0
from subtype.eq (h y (hxy ‚ñ∏ x.2) y.2)
have hx : x = 0
from subtype.eq (hxy.trans $ congr_arg _ hy)
simp [*]
intros
rw [to_square_block_def', to_square_block_def]
apply equiv_block_det
intro x
apply (fin.ext_iff _ _).symm
intros
simp [det_apply, univ_unique]
intros
simp_rw [linear_map.to_matrix_alg_equiv, alg_equiv.of_linear_equiv_apply, linear_map.to_matrix_id]
intros
simp [transvection, matrix.add_mul, matrix.mul_add, h, h.symm, add_smul, add_assoc, std_basis_matrix_add]
intros
simpa using map_piecewise_smul f c m finset.univ
intros
simp only [linear_map.ext_iff, pi_apply, funext_iff]
simp only [linear_map.ext_iff, pi_apply, funext_iff]; exact ‚ü®Œªh a b, h b a, Œªh a b, h b a‚ü©
exact ‚ü®Œªh a b, h b a, Œªh a b, h b a‚ü©
intros
ext
ext; simp only [map_zero, coprod_apply, inr_apply, zero_add, comp_apply]
simp only [map_zero, coprod_apply, inr_apply, zero_add, comp_apply]
intros
ext
ext; refl
refl
intros
ext b
ext b; simp
simp
intros
rw [lift_compr‚ÇÇ f, lift_mk, linear_map.comp_id]
intros
simp only [‚Üê coe_ltensor_hom, map_neg]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
rw [‚Üê iterate_succ, nat.succ_pred_eq_of_pos hn]
intros
convert measurable.ennreal_tsum h
ext1 x
exact tsum_apply (pi.summable.2 (Œª _, ennreal.summable))
intros
rw [closed_ball_pi _ hr, pi_pi]
intros
simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]
intros
convert integrable_prod_iff (h1f.prod_swap) using 1
{ convert integrable_prod_iff (h1f.prod_swap) using 1, rw [integrable_swap_iff] }
rw [integrable_swap_iff]
intros
rw [h, to_jordan_decomposition_to_signed_measure]
intros
suffices h_and : f ‚â§·µê[Œº.restrict t] 0 ‚àß 0 ‚â§·µê[Œº.restrict t] f
from h_and.1.mp (h_and.2.mono (Œª x hx1 hx2, le_antisymm hx2 hx1))
refine ‚ü®_, ae_nonneg_restrict_of_forall_set_integral_nonneg hf_int_finite (Œª s hs hŒºs, (hf_zero s hs hŒºs).symm.le) ht hŒºt‚ü©
suffices h_neg : 0 ‚â§·µê[Œº.restrict t] -f
refine h_neg.mono (Œª x hx, _)
{ refine h_neg.mono (Œª x hx, _), rw pi.neg_apply at hx, simpa using hx, }
rw pi.neg_apply at hx
simpa using hx
refine ae_nonneg_restrict_of_forall_set_integral_nonneg (Œª s hs hŒºs, (hf_int_finite s hs hŒºs).neg) (Œª s hs hŒºs, _) ht hŒºt
simp_rw pi.neg_apply
rw [integral_neg, neg_nonneg]
exact (hf_zero s hs hŒºs).le
intros
rcases hfm with ‚ü®f', hf'_meas, hf_ae‚ü©
rcases hgm with ‚ü®g', hg'_meas, hg_ae‚ü©
refine ‚ü®f'-g', @measurable.sub _ _ _ _ m _ _ _ hf'_meas hg'_meas, hf_ae.mp (hg_ae.mono (Œª x hx1 hx2, _))‚ü©
simp_rw pi.sub_apply
rw [hx1, hx2]
intros
rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢
{ rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf ‚ä¢, exact hf.inner_const c, }
exact hf.inner_const c
intros
simpa using hg.norm_comp_Lp_sub_le g0 f 0
intros
rw ennreal.tendsto_at_top_zero
intros Œµ hŒµ
have h_B : ‚àÉ (N : ‚Ñï), B N ‚â§ Œµ
suffices h_tendsto_zero : ‚àÉ (N : ‚Ñï), ‚àÄ n : ‚Ñï, N ‚â§ n ‚Üí B n ‚â§ Œµ
{ suffices h_tendsto_zero : ‚àÉ (N : ‚Ñï), ‚àÄ n : ‚Ñï, N ‚â§ n ‚Üí B n ‚â§ Œµ, from ‚ü®h_tendsto_zero.some, h_tendsto_zero.some_spec _ (le_refl _)‚ü©, exact (ennreal.tendsto_at_top_zero.mp (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB)) Œµ hŒµ, }
from ‚ü®h_tendsto_zero.some, h_tendsto_zero.some_spec _ (le_refl _)‚ü©
exact (ennreal.tendsto_at_top_zero.mp (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB)) Œµ hŒµ
cases h_B with N h_B
refine ‚ü®N, Œª n hn, _‚ü©
have h_sub : snorm (f n - f_lim) p Œº ‚â§ at_top.liminf (Œª m, snorm (f n - f m) p Œº)
refine snorm_lim_le_liminf_snorm (Œª m, (hf n).sub (hf m)) (f n - f_lim) _
{ refine snorm_lim_le_liminf_snorm (Œª m, (hf n).sub (hf m)) (f n - f_lim) _, refine h_lim.mono (Œª x hx, _), simp_rw sub_eq_add_neg, exact tendsto.add tendsto_const_nhds (tendsto.neg hx), }
refine h_lim.mono (Œª x hx, _)
simp_rw sub_eq_add_neg
exact tendsto.add tendsto_const_nhds (tendsto.neg hx)
refine h_sub.trans _
refine liminf_le_of_frequently_le' (frequently_at_top.mpr _)
refine Œª N1, ‚ü®max N N1, le_max_right _ _, _‚ü©
exact (h_cau N n (max N N1) hn (le_max_left _ _)).le.trans h_B
intros
{ simp_rw snorm_ess_sup, exact ess_sup_mono_measure hŒºŒΩ, }
simp_rw snorm_ess_sup
exact ess_sup_mono_measure hŒºŒΩ
intros
simpa only [‚Üê pi.list_prod_apply] using l.measurable_prod' hl
intros
rw [integral, norm_eq_integral]
exact (to_simple_func f).norm_integral_le_integral_norm (simple_func.integrable f)
intros
have A := hf.integral_sub_linear_is_o_ae hfm hl (hu.Ioc hv)
have B := hf.integral_sub_linear_is_o_ae hfm hl (hv.Ioc hu)
simp only [integral_const']
convert (A.trans_le _).sub (B.trans_le _)
ext t
{ ext t, simp_rw [interval_integral, sub_smul], abel }
simp_rw [interval_integral, sub_smul]
abel
intro t
all_goals { intro t, cases le_total (u t) (v t) with huv huv; simp [huv] }
cases le_total (u t) (v t) with huv huv; simp [huv]
intro t
cases le_total (u t) (v t) with huv huv
cases le_total (u t) (v t) with huv huv; simp [huv]
simp [huv]
simp [huv]
intros
induction n with n hn
{ simp }
simp
exact (hn (Œª k hk, hint k (hk.trans n.lt_succ_self))).trans (hint n n.lt_succ_self)
{ exact (hn (Œª k hk, hint k (hk.trans n.lt_succ_self))).trans (hint n n.lt_succ_self) }
intros
rw [lintegral_const, one_mul]
intros
simp_rw [mul_comm, lintegral_const_mul'' r hf]
intros
rw [‚Üê lintegral_sum_measure]
exact lintegral_mono' restrict_Union_le (le_refl _)
intros
rw [lintegral]
casesI is_empty_or_nonempty Œ±
{ simp [Œº.eq_zero_of_is_empty] }
simp [Œº.eq_zero_of_is_empty]
{ simp [preimage_const_of_mem] }
simp [preimage_const_of_mem]
intros
rw [fun_mul_inv_snorm, mul_rpow_of_nonneg _ _ (le_of_lt hp0)]
suffices h_inv_rpow : ((‚à´‚Åª (c : Œ±), f c ^ p ‚àÇŒº) ^ (1 / p))‚Åª¬π ^ p = (‚à´‚Åª (c : Œ±), f c ^ p ‚àÇŒº)‚Åª¬π
rw h_inv_rpow
rw h_inv_rpow
rw [inv_rpow, ‚Üê rpow_mul, one_div_mul_cancel hp0.ne', rpow_one]
intros
rw [‚Üê integral_indicator hs, ‚Üê integral_indicator (measurable_set_le hf measurable_const)]
exact integral_mono (hfi.indicator (measurable_set_le hf measurable_const)) (hfi.indicator hs) (indicator_nonpos_le_indicator s f)
intros
intros t ht
rw piecewise_preimage
exact hs.ite (hf ht) (hg ht)
intros
{ rintro ‚ü®e‚ÇÅ, _, _‚ü© ‚ü®e‚ÇÇ, _, _‚ü© (rfl : e‚ÇÅ = e‚ÇÇ), refl }
rintro ‚ü®e‚ÇÅ, _, _‚ü© ‚ü®e‚ÇÇ, _, _‚ü© (rfl : e‚ÇÅ = e‚ÇÇ)
refl
intros
simp only [supr, measurable_set_Sup, exists_range_iff]
intros
have := (classical.some_spec (nonempty_Inter_cl_prehaar K‚ÇÄ)).2
{ have := (classical.some_spec (nonempty_Inter_cl_prehaar K‚ÇÄ)).2, rw [mem_Inter] at this, exact this V }
rw [mem_Inter] at this
exact this V
intros
simpa only [mul_comm] using real.map_volume_mul_left h
intros
by_cases h : a ‚àà s
rw [dirac_apply_of_mem h, indicator_of_mem h, pi.one_apply]
rw [dirac_apply_of_mem h, indicator_of_mem h, pi.one_apply]
rw [indicator_of_not_mem h, ‚Üê nonpos_iff_eq_zero]
calc dirac a s ‚â§ dirac a {a}·∂ú : measure_mono (subset_compl_comm.1 $ singleton_subset_iff.2 h) ... = 0 : by simp [dirac_apply' _ (measurable_set_singleton _).compl]
intros
apply le_antisymm _ bot_le
calc Œº (f ‚Åª¬π' s·∂ú) ‚â§ (map f Œº) s·∂ú : le_map_apply hf s·∂ú ... = 0 : hs
intros
{ filter_upwards [hs_zero], intros, split_ifs, refl }
filter_upwards [hs_zero]
intros
split_ifs
refl
intros
filter_upwards [hst]
intros x hx
replace hx : x ‚àà s ‚Üî x ‚àà t := iff_of_eq hx
by_cases h : x ‚àà s; have h' := h; rw hx at h'; simp [h, h']
by_cases h : x ‚àà s; have h' := h; rw hx at h'
by_cases h : x ‚àà s; have h' := h
by_cases h : x ‚àà s
have h' := h
rw hx at h'
simp [h, h']
have h' := h
rw hx at h'
simp [h, h']
intros
rw [‚Üê coe_to_outer_measure, measure.restrict_to_outer_measure_eq_to_outer_measure_restrict hs, outer_measure.restrict_apply s t _, coe_to_outer_measure]
intros
simp only [induced_outer_measure_eq_infi _ msU m_mono]
symmetry
refine infi_congr (preimage f) f.injective.preimage_surjective _
intro s
refine infi_congr_Prop (Pm s) _
intro hs
refine infi_congr_Prop f.surjective.preimage_subset_preimage_iff _
intro h2s
exact mm s hs
intros
refine (comap_of_function _ _).trans _
refine h.imp (Œª H s t hst, supr_le $ Œª hs, _) id
{ refine h.imp (Œª H s t hst, supr_le $ Œª hs, _) id, have ht : t.nonempty := hs.mono hst, exact (@H ‚ü®s, hs‚ü© ‚ü®t, ht‚ü© hst).trans (le_supr (Œª h : t.nonempty, m t) ht) }
have ht : t.nonempty := hs.mono hst
exact (@H ‚ü®s, hs‚ü© ‚ü®t, ht‚ü© hst).trans (le_supr (Œª h : t.nonempty, m t) ht)
dunfold bounded_by
{ dunfold bounded_by, congr' with s : 1, rw nonempty_image_iff }
congr' with s : 1
rw nonempty_image_iff
intros
simp only [Inf_eq_infi, restrict_binfi, hm, infi_image]
intros
apply le_of_tendsto (f.tendsto_left_lim x)
filter_upwards [self_mem_nhds_within]
assume z hz
exact (f.mono (le_of_lt hz)).trans (f.mono h)
intros
split
intros h s hs
{ intros h s hs, have := h s hs, rwa [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ] at this }
have := h s hs
rwa [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ] at this
intros h s hs
{ intros h s hs, rw [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ], exact h s hs }
rw [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ]
exact h s hs
intros
induction k with k hi
{ exact is_multiplicative_zeta.nat_cast }
exact is_multiplicative_zeta.nat_cast
rw ppow_succ
{ rw ppow_succ, apply hf.pmul hi }
apply hf.pmul hi
{ rw bernoulli'_def, norm_num }
rw bernoulli'_def
norm_num
intros
cases f with f pf
induction pf with i n f g pf pg ihf ihg f g pf pg ihf ihg
apply H1
apply H2
apply H3 _ _ ihf ihg
apply H4 _ _ ihf ihg
ext
{ ext, simp }
simp
intros
obtain ‚ü®a0, b0, c0, hf, hc‚ü© := exists_odd_minimal h
rcases lt_trichotomy 0 c0 with (h1 | rfl | h1)
{ use [a0, b0, c0], tauto }
use [a0, b0, c0]
tauto
{ exfalso, exact ne_zero hf.1 rfl}
exfalso
exact ne_zero hf.1 rfl
use [a0, b0, -c0, neg_of_minimal hf, hc]
{ use [a0, b0, -c0, neg_of_minimal hf, hc], exact neg_pos.mpr h1 }
exact neg_pos.mpr h1
intros
{ ext; { dsimp, ring }, }
ext
ext; { dsimp, ring }
{ dsimp, ring }
dsimp
{ dsimp, ring }
ring
intros
norm_cast
intros
apply int.coe_nat_inj
simp only [padic_val_rat_of_nat, nat.cast_mul]
rw padic_val_rat.mul
norm_cast
exact cast_ne_zero.mpr hq
exact cast_ne_zero.mpr hr
intros
simp [cast_eq_of_rat]
intros
simp [lim_nth_hom]; refl
simp [lim_nth_hom]
refl
intros
intros x y h
by_cases hy : p y
have hx : p x := hp h hy
{ have hx : p x := hp h hy, simpa [hx, hy] using hf h }
simpa [hx, hy] using hf h
by_cases hx : p x
{ by_cases hx : p x, { simpa [hx, hy] using hfg hx hy h }, { simpa [hx, hy] using hg h} }
{ simpa [hx, hy] using hfg hx hy h }
simpa [hx, hy] using hfg hx hy h
{ simpa [hx, hy] using hg h}
simpa [hx, hy] using hg h
intros
rw [eq_top_iff, le_inf_iff]; simp
rw [eq_top_iff, le_inf_iff]
simp
intros
rw [‚Üê f.symm_symm, ‚Üê image_eq_preimage, is_lub_image]
intros
split
split; introsI
introsI
{ exact is_atomistic_of_is_complemented }
exact is_atomistic_of_is_complemented
introsI
{ exact is_complemented_of_is_atomistic }
exact is_complemented_of_is_atomistic
intros
{rw independent_def', tidy}
rw independent_def'
tidy
intros
rw [(union_eq_self_of_subset_left h).symm, infi_union]
rw [(union_eq_self_of_subset_left h).symm, infi_union]; exact inf_le_left
exact inf_le_left
intros
rcases eq_empty_or_nonempty s with (rfl|hne)
{ simp only [cSup_empty, is_lub_empty] }
simp only [cSup_empty, is_lub_empty]
{ exact is_lub_cSup hne hs }
exact is_lub_cSup hne hs
intros
{ rw ‚Üê prod_at_bot_at_bot_eq, exact hf.prod_map hg, }
rw ‚Üê prod_at_bot_at_bot_eq
exact hf.prod_map hg
intros
simp only [eventually_eq_set, mem_inter_eq, and_iff_left_iff_imp]
intros
rw ‚Üê map_comap_of_mem h
exact image_mem_map W_in
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
refine (mem_binfi_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans _
intros t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
{ intros t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ, exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm $ inter_subset_left _ _, gm $ inter_subset_right _ _‚ü© }
exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm $ inter_subset_left _ _, gm $ inter_subset_right _ _‚ü©
simp only [‚Üê (hg _).mem_iff]
{ simp only [‚Üê (hg _).mem_iff], exact hf.exists_iff (Œª t‚ÇÅ t‚ÇÇ ht H, gm ht H) }
exact hf.exists_iff (Œª t‚ÇÅ t‚ÇÇ ht H, gm ht H)
intros
refine ‚ü®Œª hf g hg, hg hf, Œª H, by_contra $ Œª hf, _‚ü©
set g : filter ‚Ü•s·∂ú := comap coe f
haveI : ne_bot g := comap_ne_bot_iff_compl_range.2 (by simpa [compl_set_of])
simpa using H ((of g).map coe) (map_le_iff_le_comap.mpr (of_le g))
intros
induction n with n ihn
exact hn.false.elim
{ exact hn.false.elim }
suffices : x n ‚â§ y n
from (hx n n.lt_succ_self).trans_le ((hf this).trans $ hy n n.lt_succ_self)
cases n
exact h‚ÇÄ
{ exact h‚ÇÄ }
refine (ihn n.zero_lt_succ (Œª k hk, hx _ _) (Œª k hk, hy _ _)).le
refine (ihn n.zero_lt_succ (Œª k hk, hx _ _) (Œª k hk, hy _ _)).le; exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
intros
refine le_Limsup_of_le hlv (Œª c hc, _)
rw filter.eventually_map at hc
simp_rw (gc _ _) at hc ‚ä¢
exact Limsup_le_of_le hv_co hc
intros
exactI {..f.is_preorder, ..f.is_antisymm}
intros
split
split; intro h
intro h
rw [symm_diff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h
{ rw [symm_diff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h, exact h.of_disjoint_inf_of_le le_sup_left, }
exact h.of_disjoint_inf_of_le le_sup_left
intro h
{ exact h.symm_diff_eq_sup, }
exact h.symm_diff_eq_sup
intros
simp only [eq_iff_not_lt_of_le, well_founded_iff_has_min]
intros
apply le_antisymm
intros r hr
{ intros r hr, rcases subsemiring.mem_closure_iff_exists_list.1 hr with ‚ü®L, HL, rfl‚ü©, clear hr, induction L with hd tl ih, { exact zero_mem _ }, rw list.forall_mem_cons at HL, rw [list.map_cons, list.sum_cons], refine submodule.add_mem _ _ (ih HL.2), replace HL := HL.1, clear ih tl, suffices : ‚àÉ z r (hr : r ‚àà submonoid.closure s), has_scalar.smul z r = list.prod hd, { rcases this with ‚ü®z, r, hr, hzr‚ü©, rw ‚Üê hzr, exact smul_mem _ _ (subset_span hr) }, induction hd with hd tl ih, { exact ‚ü®1, 1, (submonoid.closure s).one_mem', one_smul _ _‚ü© }, rw list.forall_mem_cons at HL, rcases (ih HL.2) with ‚ü®z, r, hr, hzr‚ü©, rw [list.prod_cons, ‚Üê hzr], rcases HL.1 with ‚ü®hd, rfl‚ü© | hs, { refine ‚ü®hd * z, r, hr, _‚ü©, rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc] }, { exact ‚ü®z, hd * r, submonoid.mul_mem _ (submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm‚ü© } }
rcases subsemiring.mem_closure_iff_exists_list.1 hr with ‚ü®L, HL, rfl‚ü©
clear hr
induction L with hd tl ih
exact zero_mem _
{ exact zero_mem _ }
rw list.forall_mem_cons at HL
rw [list.map_cons, list.sum_cons]
refine submodule.add_mem _ _ (ih HL.2)
replace HL := HL.1
clear ih tl
suffices : ‚àÉ z r (hr : r ‚àà submonoid.closure s), has_scalar.smul z r = list.prod hd
rcases this with ‚ü®z, r, hr, hzr‚ü©
{ rcases this with ‚ü®z, r, hr, hzr‚ü©, rw ‚Üê hzr, exact smul_mem _ _ (subset_span hr) }
rw ‚Üê hzr
exact smul_mem _ _ (subset_span hr)
induction hd with hd tl ih
exact ‚ü®1, 1, (submonoid.closure s).one_mem', one_smul _ _‚ü©
{ exact ‚ü®1, 1, (submonoid.closure s).one_mem', one_smul _ _‚ü© }
rw list.forall_mem_cons at HL
rcases (ih HL.2) with ‚ü®z, r, hr, hzr‚ü©
rw [list.prod_cons, ‚Üê hzr]
rcases HL.1 with ‚ü®hd, rfl‚ü© | hs
refine ‚ü®hd * z, r, hr, _‚ü©
{ refine ‚ü®hd * z, r, hr, _‚ü©, rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc] }
rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc]
exact ‚ü®z, hd * r, submonoid.mul_mem _ (submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm‚ü©
{ exact ‚ü®z, hd * r, submonoid.mul_mem _ (submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm‚ü© }
refine span_le.2 _
change submonoid.closure s ‚â§ (adjoin R s).to_subsemiring.to_submonoid
exact submonoid.closure_le.2 subset_adjoin
intros
suffices t : ‚àÉ n : ‚Ñï, ‚àÄ m, n ‚â§ m ‚Üí order_dual.to_dual f (m+1) = ‚ä§
obtain ‚ü®n, w‚ü© := t
{ obtain ‚ü®n, w‚ü© := t, use n+1, rintros (_|m) p, { cases p, }, { apply w, exact nat.succ_le_succ_iff.mp p }, }
use n+1
rintros (_|m) p
{ cases p, }
cases p
apply w
{ apply w, exact nat.succ_le_succ_iff.mp p }
exact nat.succ_le_succ_iff.mp p
obtain ‚ü®n, w‚ü© := monotone_stabilizes_iff_artinian.mpr I (partial_sups (order_dual.to_dual ‚àò f))
exact ‚ü®n, (Œª m p, eq_bot_of_disjoint_absorbs (h m) ((eq.symm (w (m + 1) (le_add_right p))).trans (w m p)))‚ü©
intros
{ rw add_comm at h, exact h.of_add_mul_left_left }
rw add_comm at h
exact h.of_add_mul_left_left
intros
simp only [le_antisymm_iff, fractional_ideal.le_span_singleton_mul_iff, fractional_ideal.span_singleton_mul_le_iff]
intros
{ rcases h with ‚ü®I, rfl‚ü©, exact fg_unit I }
rcases h with ‚ü®I, rfl‚ü©
exact fg_unit I
intros
split
rintro ‚ü®a, ha‚ü© rfl
{ rintro ‚ü®a, ha‚ü© rfl, apply ha zero_coeff }
apply ha zero_coeff
contrapose!
{ contrapose!, rw set.not_nonempty_iff_eq_empty, intro h, ext a, have ha := set.not_mem_empty a, rw [‚Üê h, mem_support, not_not] at ha, rw [ha, zero_coeff] }
rw set.not_nonempty_iff_eq_empty
intro h
ext a
have ha := set.not_mem_empty a
rw [‚Üê h, mem_support, not_not] at ha
rw [ha, zero_coeff]
intros
classical
refine s.induction_on _ _
{ rw [multiset.inf_zero], exact le_top }
rw [multiset.inf_zero]
exact le_top
intros a s ih
rw [multiset.prod_cons, multiset.inf_cons]
exact le_trans mul_le_inf (inf_le_inf (le_refl _) ih)
intros
rw ‚Üêmap_prod_comm_prod
apply map_is_prime_of_equiv _
exact is_prime_ideal_prod_top
intros
rw [is_prime_iff_is_prime_disjoint M S, comap_map_of_is_prime_disjoint M S I hp hd]
exact ‚ü®hp, hd‚ü©
intros
simp only [multiplicity, enat.find, dvd_neg]
intros
obtain ‚ü®n, hn‚ü© := hx
obtain ‚ü®m, hm‚ü© := hy
use n + m - 1
rw h_comm.add_pow'
apply finset.sum_eq_zero
rintros ‚ü®i, j‚ü© hij
suffices : x^i * y^j = 0
simp only [this, nsmul_eq_mul, mul_zero]
{ simp only [this, nsmul_eq_mul, mul_zero], }
cases nat.le_or_le_of_add_eq_add_pred (finset.nat.mem_antidiagonal.mp hij) with hi hj
{ rw [pow_eq_zero_of_le hi hn, zero_mul], }
rw [pow_eq_zero_of_le hi hn, zero_mul]
{ rw [pow_eq_zero_of_le hj hm, mul_zero], }
rw [pow_eq_zero_of_le hj hm, mul_zero]
intros
rw is_noetherian_iff_well_founded at h ‚ä¢
refine (submodule.restrict_scalars_embedding R S M).dual.well_founded h
intros
simp [degree]
intros
rw T
intros
simp only [degree_eq_nat_degree (cyclotomic'_ne_zero n R), nat_degree_cyclotomic' h]
intros
ext
{ ext, simp }
simp
intros
have t : p = mat_poly_equiv (mat_poly_equiv.symm p) := by simp
conv_rhs { rw t, }
simp only [mat_poly_equiv_coeff_apply]
intros
rw [X_pow_eq s n, coeff_monomial]
intros
convert exp_mul_exp_eq_exp_add (1 : A) (-1); simp
convert exp_mul_exp_eq_exp_add (1 : A) (-1)
simp
simp
intros
obtain ‚ü®a0, nza, ha'‚ü© := exists_non_zero_rep ha
obtain ‚ü®b0, nzb, hb'‚ü© := exists_non_zero_rep hb
rw [factors_mul, ‚Üê ha', ‚Üê hb', factors_mk a0 nza, factors_mk b0 nzb, ‚Üê factor_set.coe_add, ‚Üê with_top.some_eq_coe, ‚Üê with_top.some_eq_coe, ‚Üê with_top.some_eq_coe, count_some hp, multiset.count_add, count_some hp, count_some hp]
intros
fin_cases i; simp
fin_cases i
simp
simp
intros
funext k
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
rw map_witt_structure_int
refine congr_fun _ k
apply unique_of_exists_unique (witt_structure_rat_exists_unique p (map (int.cast_ring_hom ‚Ñö) Œ¶))
intro n
{ intro n, specialize h n, apply_fun map (int.cast_ring_hom ‚Ñö) at h, simpa only [map_bind‚ÇÅ, ‚Üê eval‚ÇÇ_hom_map_hom, eval‚ÇÇ_hom_C_left, map_rename, map_witt_polynomial, alg_hom.coe_to_ring_hom] using h, }
specialize h n
apply_fun map (int.cast_ring_hom ‚Ñö) at h
simpa only [map_bind‚ÇÅ, ‚Üê eval‚ÇÇ_hom_map_hom, eval‚ÇÇ_hom_C_left, map_rename, map_witt_polynomial, alg_hom.coe_to_ring_hom] using h
{ intro n, apply witt_structure_rat_prop }
intro n
apply witt_structure_rat_prop
intros
{ ext1, rw [ring_hom.comp_apply, truncate_lift] }
ext1
rw [ring_hom.comp_apply, truncate_lift]
intros
rw [_root_.mul_comm b c]; from (quotient.induction_on‚ÇÉ a b c $ assume Œ± Œ≤ Œ≥, quotient.sound ‚ü®equiv.curry Œ≥ Œ≤ Œ±‚ü©)
rw [_root_.mul_comm b c]
from (quotient.induction_on‚ÇÉ a b c $ assume Œ± Œ≤ Œ≥, quotient.sound ‚ü®equiv.curry Œ≥ Œ≤ Œ±‚ü©)
intros
induction n; simp *
induction n
simp *
simp *
rw [‚Üê to_nat_cast 1, nat.cast_one]
intros
{ rw [add_eq_max ha, max_eq_left hb] }
rw [add_eq_max ha, max_eq_left hb]
intros
change ‚ü¶x * (y + -z)‚üß = ‚ü¶x * y‚üß + -‚ü¶x * z‚üß
{ change ‚ü¶x * (y + -z)‚üß = ‚ü¶x * y‚üß + -‚ü¶x * z‚üß, rw [quot_left_distrib, quot_mul_neg] }
rw [quot_left_distrib, quot_mul_neg]
intros
rw [‚Üê not_le, div_le c0, not_lt]
intros
cases o
cases o; refl
refl
refl
intros
{ cases x, cases y, rw mk_lt_mk, refl }
cases x
cases y
rw mk_lt_mk
refl
intros
rw [‚Üêh3, mul_comm n1, mul_assoc n2, ‚Üêmul_assoc n1, h1, ‚Üêmul_assoc n2, mul_comm n2, mul_assoc, h2]
intros
simpa [eq.symm h1, eq.symm h2, int.coe_nat_eq_coe_nat_iff]
intros
rw [‚Üê h‚ÇÉ, ‚Üê h‚ÇÇ]; simp [pow_bit1, h]
rw [‚Üê h‚ÇÉ, ‚Üê h‚ÇÇ]
simp [pow_bit1, h]
intros
rw [prl, prr, prt]
intros
unfold val_except
unfold val
by_cases h1 : n + 1 ‚â§ as.length
have h4 := @val_between_add_val_between v as 0 (n+1) (as.length - (n+1))
{ have h4 := @val_between_add_val_between v as 0 (n+1) (as.length - (n+1)), have h5 : n + 1 + (as.length - (n + 1)) = as.length, { rw [add_comm, nat.sub_add_cancel h1] }, rw h5 at h4, apply eq.trans _ h4, simp only [val_between, zero_add], ring }
have h5 : n + 1 + (as.length - (n + 1)) = as.length
{ rw [add_comm, nat.sub_add_cancel h1] }
rw [add_comm, nat.sub_add_cancel h1]
rw h5 at h4
apply eq.trans _ h4
simp only [val_between, zero_add]
ring
have h2 : (list.length as - (n + 1)) = 0
apply nat.sub_eq_zero_of_le (le_trans (not_lt.1 h1) (nat.le_add_right _ _))
{ apply nat.sub_eq_zero_of_le (le_trans (not_lt.1 h1) (nat.le_add_right _ _)) }
have h3 : val_between v as 0 (list.length as) = val_between v as 0 (n + 1)
simpa only [val] using @val_eq_of_le v as (n+1) (le_trans (not_lt.1 h1) (nat.le_add_right _ _))
{ simpa only [val] using @val_eq_of_le v as (n+1) (le_trans (not_lt.1 h1) (nat.le_add_right _ _)) }
simp only [add_zero, val_between, zero_add, h2, h3]
intros
constructor; intro h1
constructor
intro h1
cases h1 with v h1
{ cases h1 with v h1, cases h1 with h1 h1; [left,right]; refine ‚ü®v,_‚ü©; assumption }
cases h1 with h1 h1
cases h1 with h1 h1; [left,right]; refine ‚ü®v,_‚ü©; assumption
cases h1 with h1 h1; [left,right]; refine ‚ü®v,_‚ü©
cases h1 with h1 h1; [left,right]
left
refine ‚ü®v,_‚ü©
assumption
assumption
right
refine ‚ü®v,_‚ü©
assumption
assumption
intro h1
cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©; [left,right]; assumption
cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©; [left,right]
cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©
cases h1 with h1 h1; cases h1 with v h1
cases h1 with h1 h1
{ cases h1 with h1 h1; cases h1 with v h1; refine ‚ü®v,_‚ü©; [left,right]; assumption }
cases h1 with v h1
refine ‚ü®v,_‚ü©
left
assumption
assumption
cases h1 with v h1
refine ‚ü®v,_‚ü©
right
assumption
assumption
intros
rw [‚Üê mem_compl_iff, compl_range_coe, mem_singleton_iff]
intros
convert is_closed_closure
intros
rcases exists_nhds_one_split hu with ‚ü®W, W1, h‚ü©
rcases exists_nhds_one_split W1 with ‚ü®V, V1, h'‚ü©
use [V, V1]
intros v w s t v_in w_in s_in t_in
simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)
intros
refine (at_top_basis' 1).tendsto_right_iff.2 (Œª b hb, _)
have hb' : 0 < b := zero_lt_one.trans_le hb
filter_upwards [Ioc_mem_nhds_within_Ioi ‚ü®le_rfl, inv_pos.2 hb'‚ü©]
exact Œª x hx, (le_inv hx.1 hb').1 hx.2
intros
nontriviality
haveI : nonempty s := nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫
rcases hs (nonempty_subtype.1 ‚Äπ_‚Ä∫) with ‚ü®a, h, hs‚ü©
ext u
split
rintros ‚ü®t, ht, hts‚ü©
{ rintros ‚ü®t, ht, hts‚ü©, obtain ‚ü®x, ‚ü®hxa : a ‚â§ x, hxb : x < b‚ü©, hxt : Ioo x b ‚äÜ t‚ü© := (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht, obtain ‚ü®y, hxy, hyb‚ü© := exists_between hxb, refine mem_of_superset (mem_at_top ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _, rintros ‚ü®z, hzs‚ü© (hyz : y ‚â§ z), refine hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©); assumption }
obtain ‚ü®x, ‚ü®hxa : a ‚â§ x, hxb : x < b‚ü©, hxt : Ioo x b ‚äÜ t‚ü© := (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht
obtain ‚ü®y, hxy, hyb‚ü© := exists_between hxb
refine mem_of_superset (mem_at_top ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _
rintros ‚ü®z, hzs‚ü© (hyz : y ‚â§ z)
refine hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©); assumption
refine hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©)
assumption
assumption
intros hu
{ intros hu, obtain ‚ü®x : s, hx : ‚àÄ z, x ‚â§ z ‚Üí z ‚àà u‚ü© := mem_at_top_sets.1 hu, exact ‚ü®Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), Œª z hz, hx _ hz.1.le‚ü© }
obtain ‚ü®x : s, hx : ‚àÄ z, x ‚â§ z ‚Üí z ‚àà u‚ü© := mem_at_top_sets.1 hu
exact ‚ü®Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), Œª z hz, hx _ hz.1.le‚ü©
intros
refine eq_univ_of_forall (Œª x, _)
obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := not_bdd_below_iff.1 hb x
obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bdd_above_iff.1 ha x
exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
intros
obtain ‚ü®s : set Œ±, hs, s_dense‚ü© := exists_countable_dense Œ±
cases countable_iff_exists_surjective.mp hs with u hu
exact ‚ü®u, s_dense.mono hu‚ü©
intros
rw [frontier, hs.closure_eq]
intros
simp only [mem_closure_iff_nhds, set.nonempty_inter_iff_exists_right]
intros
rw [ultrafilter.Lim_eq_iff_le_nhds, le_nhds_iff]
tauto
intros
classical
use Œª (j : J), if hj : j ‚àà G then F.map (is_cofiltered.inf_to G H hj) (h (is_cofiltered.inf G H)).some else (h _).some
rintros ‚ü®X, Y, hX, hY, f‚ü© hf
dsimp only
rwa [dif_pos hX, dif_pos hY, ‚Üêcomp_app, ‚ÜêF.map_comp, @is_cofiltered.inf_to_commutes _ _ _ G H]
intros
simp only [induced_generate_from_eq, continuous_map.compact_open]
apply generate_from_mono
rintros b ‚ü®a, ‚ü®c, hc, u, hu, rfl‚ü©, rfl‚ü©
refine ‚ü®coe '' c, hc.image continuous_subtype_coe, u, hu, _‚ü©
ext f
simp only [compact_open.gen, mem_set_of_eq, mem_preimage, continuous_map.coe_restrict]
rw image_comp f (coe : s ‚Üí Œ±)
intros
split
split; intro h
intro h
intros u v hu hv hs huv
{ intros u v hu hv hs huv, specialize h u v hu hv hs, contrapose! huv, rw ne_empty_iff_nonempty, simp [not_subset] at huv, rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©, have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu, have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv, exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü© }
specialize h u v hu hv hs
contrapose! huv
rw ne_empty_iff_nonempty
simp [not_subset] at huv
rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©
have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu
have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv
exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü©
intro h
intros u v hu hv hs hsu hsv
{ intros u v hu hv hs hsu hsv, rw ‚Üê ne_empty_iff_nonempty, intro H, specialize h u v hu hv hs H, contrapose H, apply ne_empty_iff_nonempty.mpr, cases h, { rcases hsv with ‚ü®x, hxs, hxv‚ü©, exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü© }, { rcases hsu with ‚ü®x, hxs, hxu‚ü©, exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü© } }
rw ‚Üê ne_empty_iff_nonempty
intro H
specialize h u v hu hv hs H
contrapose H
apply ne_empty_iff_nonempty.mpr
cases h
{ rcases hsv with ‚ü®x, hxs, hxv‚ü©, exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü© }
rcases hsv with ‚ü®x, hxs, hxv‚ü©
exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü©
{ rcases hsu with ‚ü®x, hxs, hxu‚ü©, exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü© }
rcases hsu with ‚ü®x, hxs, hxu‚ü©
exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü©
intros
{ rw [nhds_prod_eq] at h, exact h.curry }
rw [nhds_prod_eq] at h
exact h.curry
intros
intros x‚ÇÅ x‚ÇÇ hx
obtain ‚ü®_, ‚ü®f, hfA, rfl‚ü©, hf‚ü© := hA hx
let F : C(X, ‚ÑÇ) := f - const (f x‚ÇÇ)
have hFA : F ‚àà A
refine A.sub_mem hfA _
{ refine A.sub_mem hfA _, convert A.smul_mem A.one_mem (f x‚ÇÇ), ext1, simp }
convert A.smul_mem A.one_mem (f x‚ÇÇ)
ext1
simp
refine ‚ü®_, ‚ü®(‚ü®complex.norm_sq, continuous_norm_sq‚ü© : C(‚ÑÇ, ‚Ñù)).comp F, _, rfl‚ü©, _‚ü©
rw [set_like.mem_coe, subalgebra.mem_comap]
{ rw [set_like.mem_coe, subalgebra.mem_comap], convert (A.restrict_scalars ‚Ñù).mul_mem (mem_conj_invariant_subalgebra hA' hFA) hFA, ext1, exact complex.norm_sq_eq_conj_mul_self }
convert (A.restrict_scalars ‚Ñù).mul_mem (mem_conj_invariant_subalgebra hA' hFA) hFA
ext1
exact complex.norm_sq_eq_conj_mul_self
have : f x‚ÇÅ - f x‚ÇÇ ‚â† 0 := sub_ne_zero.mpr hf
{ have : f x‚ÇÅ - f x‚ÇÇ ‚â† 0 := sub_ne_zero.mpr hf, simpa using this }
simpa using this
intros
refine continuous_on_iff'.2 (Œª t ht, ‚ü®f '' (t ‚à© s), _, _‚ü©)
rw ‚Üê image_restrict
{ rw ‚Üê image_restrict, exact h _ (ht.preimage continuous_subtype_coe) }
exact h _ (ht.preimage continuous_subtype_coe)
rw [inter_eq_self_of_subset_left (image_subset f (inter_subset_right t s)), hleft.image_inter']
{ rw [inter_eq_self_of_subset_left (image_subset f (inter_subset_right t s)), hleft.image_inter'] }
intros
rw (is_locally_constant.tfae S.proj).out 0 3
intros x
rcases S.proj_surjective x with ‚ü®x,rfl‚ü©
simp [fiber_eq, (S.clopen x).1]
intros
letI := a.total_space_topology
{ letI := a.total_space_topology, exact a.is_topological_fiber_bundle.continuous_proj, }
exact a.is_topological_fiber_bundle.continuous_proj
intros
simpa only [mul_comm a] using infi_mul_left' h h0
intros
lift a to ‚Ñù using and.intro ha h'a
rw [nhds_coe, tendsto_map'_iff]
exact tendsto_id
intros
induction l with x l ih
simp [nhds_nil, mem_of_mem_nhds, tendsto_pure_left] {contextual := tt}
{ simp [nhds_nil, mem_of_mem_nhds, tendsto_pure_left] {contextual := tt} }
simp_rw [tendsto_cons_iff, prod_cons]
have := continuous_iff_continuous_at.mp continuous_mul (x, l.prod)
rw [continuous_at, nhds_prod_eq] at this
exact this.comp (tendsto_id.prod_map ih)
intros
ext
simp only [of_clopen, nat.one_ne_zero, mem_singleton_iff, coe_mk, fin.zero_eq_one_iff, mem_preimage, ite_eq_right_iff, mem_compl_eq]
tauto
intros
refine closed_embedding_of_embedding_closed ‚ü®‚ü®_‚ü©, h‚ÇÇ‚ü© h‚ÇÉ
apply le_antisymm (continuous_iff_le_induced.mp h‚ÇÅ) _
intro s'
change is_open _ ‚â§ is_open _
rw [‚Üêis_closed_compl_iff, ‚Üêis_closed_compl_iff]
generalize : s'·∂ú = s
rw is_closed_induced_iff
refine Œª hs, ‚ü®f '' s, h‚ÇÉ s hs, _‚ü©
rw preimage_image_eq _ h‚ÇÇ
intros
rw ‚Üê sInter_range
apply dense_sInter_of_open
{ rwa forall_range_iff }
rwa forall_range_iff
{ exact countable_range _ }
exact countable_range _
{ rwa forall_range_iff }
rwa forall_range_iff
intros
rw [add_left_comm, dist_comm x‚ÇÅ, ‚Üê add_assoc]
{ rw [add_left_comm, dist_comm x‚ÇÅ, ‚Üê add_assoc], apply dist_triangle4 }
apply dist_triangle4
intros
rw [edist_nndist, ennreal.coe_lt_coe]
intros
rw ‚Üê ne_bot_iff; exact uniformity_basis_edist.cauchy_iff
rw ‚Üê ne_bot_iff
exact uniformity_basis_edist.cauchy_iff
intros
let F := Kuratowski_embedding (optimal_GH_coupling X Y)
let Œ¶ := F ‚àò optimal_GH_injl X Y
let Œ® := F ‚àò optimal_GH_injr X Y
refine ‚ü®Œ¶, Œ®, _, _, _‚ü©
exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injl X Y)
{ exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injl X Y) }
exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injr X Y)
{ exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injr X Y) }
rw [‚Üê image_univ, ‚Üê image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y), image_univ, ‚Üê Hausdorff_dist_optimal]
{ rw [‚Üê image_univ, ‚Üê image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y), image_univ, ‚Üê Hausdorff_dist_optimal], exact (Hausdorff_dist_image (Kuratowski_embedding.isometry _)).symm }
exact (Hausdorff_dist_image (Kuratowski_embedding.isometry _)).symm
intros
unfold Hausdorff_edist; apply sup_comm
unfold Hausdorff_edist
apply sup_comm
intros
rw continuous_def at h ‚ä¢
assume s hs
exact h _ hs
intros
simp only [‚Üê nhds_within_univ] at hf
rcases countable_cover_nhds_within_of_sigma_compact is_closed_univ (Œª x _, hf x) with ‚ü®s, -, hsc, hsU‚ü©
exact ‚ü®s, hsc, univ_subset_iff.1 hsU‚ü©
intros
obtain ‚ü®t, -, s‚ü© := is_compact.elim_nhds_subcover compact_univ U (Œª x m, hU x)
exact ‚ü®t, by { rw eq_top_iff, exact s }‚ü©
intros
simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity]
exact iff.rfl
intros
rw cauchy_seq_iff_tendsto at hu
exact ((hu.comp $ hf.prod_at_top hg).comp tendsto_at_top_diagonal).subseq_mem hV
intros
rw [is_separated, separated_space.out]
tauto
intros
induction n with n ihn generalizing c
{ exact indicator_nonneg (Œª _ _, zero_le_one) _ }
exact indicator_nonneg (Œª _ _, zero_le_one) _
simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv]
{ simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv], refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _); apply ihn }
refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _)
refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _); apply ihn
apply ihn
apply ihn
intros
cases x; cases x'; simp [show x = x', from funext h]
cases x; cases x'
cases x
cases x'
simp [show x = x', from funext h]
intros
cases b; simp
cases b
simp
simp
intros
rw [‚Üê int.sub_nat_nat_eq_coe]; exact sub_nat_nat_elim m n (Œªm n i, to_nat i = m - n) (Œªi n, by rw [nat.add_sub_cancel_left]; refl) (Œªi n, by rw [nat.add_assoc, nat.sub_eq_zero_of_le (nat.le_add_right _ _)]; refl)
rw [‚Üê int.sub_nat_nat_eq_coe]
exact sub_nat_nat_elim m n (Œªm n i, to_nat i = m - n) (Œªi n, by rw [nat.add_sub_cancel_left]; refl) (Œªi n, by rw [nat.add_assoc, nat.sub_eq_zero_of_le (nat.le_add_right _ _)]; refl)
intros
rw [int.add_assoc, int.add_right_neg, int.add_zero]
intros
have h := int.neg_le_neg h
rwa int.neg_neg at h
intros
have h := int.add_lt_add_right h b
rwa int.sub_add_cancel at h
intros
rw [nat.mul_comm, add_mul_mod_self_left]
intros
revert k m
induction n with n ; intros k m h‚ÇÄ h‚ÇÅ
induction n with n
intros k m h‚ÇÄ h‚ÇÅ
{ exact m.zero_le }
exact m.zero_le
intros k m h‚ÇÄ h‚ÇÅ
cases k with k
{ cases k with k, { apply h‚ÇÅ }, cases m with m, { cases not_succ_le_zero _ h‚ÇÄ }, { simp [succ_sub_succ] at h‚ÇÅ, apply succ_le_succ, apply n_ih _ h‚ÇÅ, apply le_of_succ_le_succ h‚ÇÄ }, }
{ apply h‚ÇÅ }
apply h‚ÇÅ
cases m with m
{ cases not_succ_le_zero _ h‚ÇÄ }
cases not_succ_le_zero _ h‚ÇÄ
simp [succ_sub_succ] at h‚ÇÅ
{ simp [succ_sub_succ] at h‚ÇÅ, apply succ_le_succ, apply n_ih _ h‚ÇÅ, apply le_of_succ_le_succ h‚ÇÄ }
apply succ_le_succ
apply n_ih _ h‚ÇÅ
apply le_of_succ_le_succ h‚ÇÄ
intros
simp [succ_add, add_succ]
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
rw [eq_vadd_iff_vsub_eq, vadd_vsub_assoc, ‚Üê add_right_inj (-v‚ÇÅ), neg_add_cancel_left, eq_comm]
intros
ext
{ ext, simp only [arrow_congr, equiv.coe_fn_mk, alg_hom.comp_apply], congr, exact (e‚ÇÇ.symm_apply_apply _).symm }
simp only [arrow_congr, equiv.coe_fn_mk, alg_hom.comp_apply]
congr
exact (e‚ÇÇ.symm_apply_apply _).symm
intros
haveI : subsingleton (A ‚Üí‚Çê[R] B) := alg_hom.subsingleton
exact ‚ü®Œª f g, alg_equiv.ext (Œª x, alg_hom.ext_iff.mp (subsingleton.elim f.to_alg_hom g.to_alg_hom) x)‚ü©
intros
conv_lhs { rw [finset.eq_sum_range_sub f] }
simp [finset.sum_range_succ', add_comm]
intros
induction m with m hm
{ simp }
simp
rw [nat.add_succ, prod_range_succ, hm, prod_range_succ, mul_assoc]
{ rw [nat.add_succ, prod_range_succ, hm, prod_range_succ, mul_assoc], }
intros
convert finprod_eq_if
intros
rw [‚Üê set.bij_on.image_eq he‚ÇÄ, finprod_mem_image he‚ÇÄ.2.1]
exact finprod_mem_congr rfl he‚ÇÅ
intros
simp only [sub_eq_add_neg]
convert prod_add_ordered s f (Œª i, -g i)
simp
intros
apply tensor_product.ext_threefold
intros x y z
change R at y
dsimp [tensor_hom, associator]
erw [tensor_product.lid_tmul, tensor_product.rid_tmul]
exact (tensor_product.smul_tmul _ _ _).symm
intros
rw [sub_eq_iff_eq_add, add_halves']
intros
cases ifp_n with _ fr
change fr = 0 at nth_fr_eq_zero
simp [int_fract_pair.stream, stream_nth_eq, nth_fr_eq_zero]
intros
simp[denom_eq_conts_b, (first_continuant_eq zeroth_s_eq)]
intros
rw [‚Üê h, mul_div_cancel_left _ ha]
intros
rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]
intros
{ ext, simp [le_floor] }
ext
simp [le_floor]
intros
apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _)
apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _); rw dvd_gcd_iff; refine ‚ü®gcd_dvd_left _ _, _‚ü©
apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _); rw dvd_gcd_iff
rw dvd_gcd_iff
refine ‚ü®gcd_dvd_left _ _, _‚ü©
rcases h with ‚ü®d, hd‚ü©
{ rcases h with ‚ü®d, hd‚ü©, rcases gcd_dvd_right a b with ‚ü®e, he‚ü©, rcases gcd_dvd_left a b with ‚ü®f, hf‚ü©, use e - f * d, rw [mul_sub, ‚Üê he, ‚Üê mul_assoc, ‚Üê hf, ‚Üê hd, sub_sub_cancel] }
rcases gcd_dvd_right a b with ‚ü®e, he‚ü©
rcases gcd_dvd_left a b with ‚ü®f, hf‚ü©
use e - f * d
rw [mul_sub, ‚Üê he, ‚Üê mul_assoc, ‚Üê hf, ‚Üê hd, sub_sub_cancel]
rw dvd_gcd_iff
refine ‚ü®gcd_dvd_left _ _, _‚ü©
rcases h with ‚ü®d, hd‚ü©
{ rcases h with ‚ü®d, hd‚ü©, rcases gcd_dvd_right a c with ‚ü®e, he‚ü©, rcases gcd_dvd_left a c with ‚ü®f, hf‚ü©, use e + f * d, rw [mul_add, ‚Üê he, ‚Üê mul_assoc, ‚Üê hf, ‚Üê hd, ‚Üê add_sub_assoc, add_comm c b, add_sub_cancel] }
rcases gcd_dvd_right a c with ‚ü®e, he‚ü©
rcases gcd_dvd_left a c with ‚ü®f, hf‚ü©
use e + f * d
rw [mul_add, ‚Üê he, ‚Üê mul_assoc, ‚Üê hf, ‚Üê hd, ‚Üê add_sub_assoc, add_comm c b, add_sub_cancel]
intros
rw [‚Üê lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_cons]
{ rw [‚Üê lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_cons], simp }
simp
intros
rw [sub_eq_add_neg, add_neg_cancel_right a b]
intros
rw [divp_eq_iff_mul_eq, mul_comm, ‚Üê divp_assoc, divp_eq_iff_mul_eq, mul_comm y ux]
intros
{ ext a, exact mul_action_hom.congr_fun h a, }
ext a
exact mul_action_hom.congr_fun h a
intros
ring
intros
intros a b hab
cases le_total a 0 with ha ha
cases le_or_lt b 0 with hb hb
{ cases le_or_lt b 0 with hb hb, { rw [‚Üê neg_lt_neg_iff, ‚Üê neg_pow_bit1, ‚Üê neg_pow_bit1], exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n)) }, { exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb) } }
rw [‚Üê neg_lt_neg_iff, ‚Üê neg_pow_bit1, ‚Üê neg_pow_bit1]
{ rw [‚Üê neg_lt_neg_iff, ‚Üê neg_pow_bit1, ‚Üê neg_pow_bit1], exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n)) }
exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n))
{ exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb) }
exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb)
exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n))
{ exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n)) }
intros
tidy
intros
{ ext, exact p, }
ext
exact p
intros
simp only [funext_iff, mul_indicator_apply_eq_one, set.disjoint_left, mem_mul_support, not_imp_not]
intros
simp only [lie_module.ker, lie_hom.mem_ker, linear_map.ext_iff, linear_map.zero_apply, to_endomorphism_apply_apply]
intros
rw comap_bracket_incl
{ rw comap_bracket_incl, rw ‚Üê inf_eq_right at h‚ÇÅ h‚ÇÇ, rw [h‚ÇÅ, h‚ÇÇ], }
rw ‚Üê inf_eq_right at h‚ÇÅ h‚ÇÇ
rw [h‚ÇÅ, h‚ÇÇ]
intros
obtain ‚ü®k, hk‚ü© := h‚ÇÅ
tactic.unfreeze_local_instances
use k
rw [‚Üê lie_ideal.derived_series_map_eq k h‚ÇÇ, hk]
simp only [lie_ideal.map_eq_bot_iff, bot_le]
intros
rw [‚Üê mem_coe_submodule, ‚Üê mem_coe_submodule, ‚Üê mem_coe_submodule, inf_coe_to_submodule, submodule.mem_inf]
intros
rw [‚Üê mem_coe_submodule, sup_coe_to_submodule, submodule.mem_sup]
{ rw [‚Üê mem_coe_submodule, sup_coe_to_submodule, submodule.mem_sup], exact iff.rfl, }
exact iff.rfl
intros
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, ker_coe_submodule, lie_submodule.bot_coe_submodule, linear_map.ker_eq_bot, coe_to_linear_map]
intros
simpa using abv.add_le (a - b) b
intros
{ rw [inv_eq_one_div], exact div_lt_iff' ha }
rw [inv_eq_one_div]
exact div_lt_iff' ha
intros
rw [le_div_iff_of_neg hb, one_mul]
intros
rw [mul_comm b c, ‚Üê div_sub_div _ _ hc hd, sub_nonpos]
intros
rw [abs_le, neg_le_sub_iff_le_add, sub_le_iff_le_add', and_comm, sub_le_iff_le_add']
intros
simpa only [div_eq_mul_inv] using mul_inv_le_mul_inv_iff'
intros
{ convert mul_lt_mul_left h, simp }
convert mul_lt_mul_left h
simp
intros
simp
intros
ext
ext; simp
simp
simp
simp
simp
intros
refine ‚ü®_, _‚ü©
rintros ‚ü®ab, ba‚ü©
{ rintros ‚ü®ab, ba‚ü©, exact ‚ü®‚ü®is_left_regular.of_mul ba.left, is_right_regular.of_mul ab.right‚ü©, ‚ü®is_left_regular.of_mul ab.left, is_right_regular.of_mul ba.right‚ü©‚ü© }
exact ‚ü®‚ü®is_left_regular.of_mul ba.left, is_right_regular.of_mul ab.right‚ü©, ‚ü®is_left_regular.of_mul ab.left, is_right_regular.of_mul ba.right‚ü©‚ü©
rintros ‚ü®ha, hb‚ü©
{ rintros ‚ü®ha, hb‚ü©, exact ‚ü®‚ü®(mul_is_left_regular_iff _ ha.left).mpr hb.left, (mul_is_right_regular_iff _ hb.right).mpr ha.right‚ü©, ‚ü®(mul_is_left_regular_iff _ hb.left).mpr ha.left, (mul_is_right_regular_iff _ ha.right).mpr hb.right‚ü©‚ü© }
exact ‚ü®‚ü®(mul_is_left_regular_iff _ ha.left).mpr hb.left, (mul_is_right_regular_iff _ hb.right).mpr ha.right‚ü©, ‚ü®(mul_is_left_regular_iff _ hb.left).mpr ha.left, (mul_is_right_regular_iff _ ha.right).mpr hb.right‚ü©‚ü©
intros
simp
intros
dsimp [desc_c_app]
ext
simp only [limit.lift_œÄ, nat_trans.naturality, limit.lift_œÄ_assoc, eq_to_hom_map, assoc, pushforward_obj_map, nat_trans.naturality_assoc, op_map, limit_obj_iso_limit_comp_evaluation_inv_œÄ_app_assoc, limit_obj_iso_limit_comp_evaluation_inv_œÄ_app]
dsimp
have w := functor.congr_hom (congr_arg opens.map (colimit.Œπ_desc ((PresheafedSpace.forget C).map_cocone s) (unop j))) (i.unop)
simp only [opens.map_comp_map] at w
replace w := congr_arg quiver.hom.op w
rw w
dsimp
simp
intros
{ rw basic_open_mul f g, exact inf_le_left }
rw basic_open_mul f g
exact inf_le_left
intros
{ rw ‚Üê to_open_germ, refl }
rw ‚Üê to_open_germ
refl
intros
by_cases hK : K = 0
subst K
{ subst K, simp only [gronwall_bound_K0, zero_mul, zero_add], convert ((has_deriv_at_id x).const_mul Œµ).const_add Œ¥, rw [mul_one] }
simp only [gronwall_bound_K0, zero_mul, zero_add]
convert ((has_deriv_at_id x).const_mul Œµ).const_add Œ¥
rw [mul_one]
simp only [gronwall_bound_of_K_ne_0 hK]
{ simp only [gronwall_bound_of_K_ne_0 hK], convert (((has_deriv_at_id x).const_mul K).exp.const_mul Œ¥).add ((((has_deriv_at_id x).const_mul K).exp.sub_const 1).const_mul (Œµ / K)) using 1, simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel' _ hK], ring }
convert (((has_deriv_at_id x).const_mul K).exp.const_mul Œ¥).add ((((has_deriv_at_id x).const_mul K).exp.sub_const 1).const_mul (Œµ / K)) using 1
simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel' _ hK]
ring
intros
rcases hf with ‚ü®r, hf‚ü©
rcases ennreal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ‚ü®r', r'0, h‚ü©
refine (hf.is_O_image_sub_image_sub_deriv_principal h).mono _
exact le_principal_iff.2 (emetric.ball_mem_nhds _ r'0)
intros
have cne0 : ‚à•c‚à• ‚â† 0
from mt norm_eq_zero.mp hc
rw [‚Üêis_o_norm_left]
simp only [norm_smul]
rw [is_o_const_mul_left_iff cne0, is_o_norm_left]
intros
simp only [is_O_iff_eventually_is_O_with, ‚Üê eventually_all]
exact eventually_congr (eventually_at_top.2 ‚ü®0, Œª c, is_O_with_pi‚ü©)
intros
simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left
intros
refine ord_connected.convex ‚ü®_‚ü©
rintros _ ‚ü®a, ha, rfl‚ü© _ ‚ü®b, hb, rfl‚ü© m ‚ü®hma, hmb‚ü©
cases eq_or_lt_of_le hma with hma hma
exact hma ‚ñ∏ mem_image_of_mem f' ha
exact hma ‚ñ∏ mem_image_of_mem f' ha
cases eq_or_lt_of_le hmb with hmb hmb
exact hmb.symm ‚ñ∏ mem_image_of_mem f' hb
exact hmb.symm ‚ñ∏ mem_image_of_mem f' hb
cases le_total a b with hab hab
have : Icc a b ‚äÜ s
{ have : Icc a b ‚äÜ s, from hs.ord_connected.out ha hb, rcases exists_has_deriv_within_at_eq_of_gt_of_lt hab (Œª x hx, (hf x $ this hx).has_deriv_within_at) hma hmb with ‚ü®c, cmem, hc‚ü©, exact ‚ü®c, this cmem, hc‚ü© }
from hs.ord_connected.out ha hb
rcases exists_has_deriv_within_at_eq_of_gt_of_lt hab (Œª x hx, (hf x $ this hx).has_deriv_within_at) hma hmb with ‚ü®c, cmem, hc‚ü©
exact ‚ü®c, this cmem, hc‚ü©
have : Icc b a ‚äÜ s
{ have : Icc b a ‚äÜ s, from hs.ord_connected.out hb ha, rcases exists_has_deriv_within_at_eq_of_lt_of_gt hab (Œª x hx, (hf x $ this hx).has_deriv_within_at) hmb hma with ‚ü®c, cmem, hc‚ü©, exact ‚ü®c, this cmem, hc‚ü© }
from hs.ord_connected.out hb ha
rcases exists_has_deriv_within_at_eq_of_lt_of_gt hab (Œª x hx, (hf x $ this hx).has_deriv_within_at) hmb hma with ‚ü®c, cmem, hc‚ü©
exact ‚ü®c, this cmem, hc‚ü©
intros
rw [‚Üê deriv_fderiv, deriv_inv]
intros
have := (hf.Ioi_of_Ici.limsup_slope_norm_le hr).frequently
refine this.mp (eventually.mono self_mem_nhds_within _)
assume z hxz hz
rwa [real.norm_eq_abs, abs_of_pos (sub_pos_of_lt hxz)] at hz
intros
simp only [deriv_within, fderiv_within_neg hxs, continuous_linear_map.neg_apply]
intros
simp [sub_eq_add_neg]
intros
by_cases h : differentiable_within_at ùïú f (s ‚à© t) x
apply fderiv_within_subset (inter_subset_left _ _) _ ((differentiable_within_at_inter ht).1 h)
{ apply fderiv_within_subset (inter_subset_left _ _) _ ((differentiable_within_at_inter ht).1 h), apply hs.inter ht }
apply hs.inter ht
have : ¬¨ differentiable_within_at ùïú f s x
{ have : ¬¨ differentiable_within_at ùïú f s x, by contrapose! h; rw differentiable_within_at_inter; assumption, rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this] }
contrapose! h
contrapose! h
contrapose! h; rw differentiable_within_at_inter; assumption
contrapose! h; rw differentiable_within_at_inter; assumption
contrapose! h; rw differentiable_within_at_inter
contrapose! h; rw differentiable_within_at_inter
rw differentiable_within_at_inter
rw differentiable_within_at_inter
assumption
assumption
assumption
assumption
rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this]
intros
have : is_complete (univ : set (E ‚ÜíL[ùïú] F)) := complete_univ
convert measurable_set_of_differentiable_at_of_is_complete ùïú f this
simp
intros
refine lhopital_zero_left_on_Ioo hab hff' hgg' hg' _ _ hdiv
rw [‚Üê hfb, ‚Üê nhds_within_Ioo_eq_nhds_within_Iio hab]
{ rw [‚Üê hfb, ‚Üê nhds_within_Ioo_eq_nhds_within_Iio hab], exact ((hcf b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto }
exact ((hcf b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto
rw [‚Üê hgb, ‚Üê nhds_within_Ioo_eq_nhds_within_Iio hab]
{ rw [‚Üê hgb, ‚Üê nhds_within_Ioo_eq_nhds_within_Iio hab], exact ((hcg b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto }
exact ((hcg b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto
intros
classical
simp only [unique_diff_within_at_iff, closure_pi_set] at h ‚ä¢
refine ‚ü®(dense_pi univ (Œª i _, (h i).1)).mono _, Œª i _, (h i).2‚ü©
norm_cast
simp only [‚Üê submodule.supr_map_single, supr_le_iff, linear_map.map_span, submodule.span_le, ‚Üê maps_to']
exact Œª i, (maps_to_tangent_cone_pi $ Œª j hj, (h j).2).mono subset.rfl submodule.subset_span
intros
rw [‚Üê iterated_fderiv_within_univ, ‚Üê iterated_fderiv_within_univ, ‚Üê fderiv_within_univ]
exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _
intros
split
assume h
{ assume h, split, { assume m hm, exact h.continuous_on_iterated_fderiv_within hm hs }, { assume m hm, exact h.differentiable_on_iterated_fderiv_within hm hs } }
split
{ assume m hm, exact h.continuous_on_iterated_fderiv_within hm hs }
assume m hm
exact h.continuous_on_iterated_fderiv_within hm hs
{ assume m hm, exact h.differentiable_on_iterated_fderiv_within hm hs }
assume m hm
exact h.differentiable_on_iterated_fderiv_within hm hs
assume h
{ assume h, exact times_cont_diff_on_of_continuous_on_differentiable_on h.1 h.2 }
exact times_cont_diff_on_of_continuous_on_differentiable_on h.1 h.2
intros
convert segment_eq_image ùïú x y
{ convert segment_eq_image ùïú x y, ext Œ∏, simp only [smul_sub, sub_smul, one_smul], abel }
ext Œ∏
simp only [smul_sub, sub_smul, one_smul]
abel
intros
simpa only [h‚ÇÅ, center_mass, inv_one, one_smul] using hs.center_mass_mem h‚ÇÄ (h‚ÇÅ.symm ‚ñ∏ zero_lt_one) hz
intros
refine ‚ü®hs.subset_to_cone, Œª t ht x hx, _‚ü©
rcases hs.mem_to_cone.1 hx with ‚ü®c, hc, y, hy, rfl‚ü©
exact t.smul_mem hc (ht hy)
intros
have hmem' : ‚àÄ i ‚àà t, (p i, (f ‚àò p) i) ‚àà {p : E √ó Œ≤ | p.1 ‚àà s ‚àß f p.1 ‚â§ p.2}
from Œª i hi, ‚ü®hmem i hi, le_rfl‚ü©
convert (hf.convex_epigraph.center_mass_mem h‚ÇÄ h‚ÇÅ hmem').2
convert (hf.convex_epigraph.center_mass_mem h‚ÇÄ h‚ÇÅ hmem').2; simp only [center_mass, function.comp, prod.smul_fst, prod.fst_sum, prod.smul_snd, prod.snd_sum]
simp only [center_mass, function.comp, prod.smul_fst, prod.fst_sum, prod.smul_snd, prod.snd_sum]
simp only [center_mass, function.comp, prod.smul_fst, prod.fst_sum, prod.smul_snd, prod.snd_sum]
rw ‚Üê fourier_subalgebra_coe
exact congr_arg subalgebra.to_submodule fourier_subalgebra_closure_eq_top
intros
simp [real_inner_eq_re_inner, inner_smul_right]
intros
simp only [inner_sub_left, inner_sub_right]; ring
simp only [inner_sub_left, inner_sub_right]
ring
intros
{ have h := @abs_inner_le_norm ‚Ñù F _ _ x y, simpa using h }
have h := @abs_inner_le_norm ‚Ñù F _ _ x y
simpa using h
intros
have h_mem : v ‚àà K ‚äî K·óÆ := by simp [submodule.sup_orthogonal_of_complete_space]
obtain ‚ü®y, hy, z, hz, hyz‚ü© := submodule.mem_sup.mp h_mem
exact ‚ü®y, hy, z, hz, hyz.symm‚ü©
intros
simpa [‚Üê rpow_mul, ha, hb, hpq.ne_zero, hpq.symm.ne_zero, div_eq_inv_mul] using geom_mean_le_arith_mean2_weighted hpq.one_div_nonneg hpq.symm.one_div_nonneg (rpow_nonneg_of_nonneg ha p) (rpow_nonneg_of_nonneg hb q) hpq.inv_add_inv_conj
intros
simp only [‚Üê nnreal.coe_le_coe, nnreal.coe_add, ‚Üê dist_nndist, dist_vsub_vsub_le]
intros
{ ext, refl }
ext
refl
intros
simpa using norm_sub_rev 0 g
intros
rw [cauchy_seq_finset_iff_vanishing, nhds_basis_ball.forall_iff]
{ simp only [ball_zero_eq, set.mem_set_of_eq] }
simp only [ball_zero_eq, set.mem_set_of_eq]
rintros s t hst ‚ü®s', hs'‚ü©
{ rintros s t hst ‚ü®s', hs'‚ü©, exact ‚ü®s', Œª t' ht', hst $ hs' _ ht'‚ü© }
exact ‚ü®s', Œª t' ht', hst $ hs' _ ht'‚ü©
intros
simp_rw ‚Üê smul_eq_mul; exact is_bounded_bilinear_map_smul
simp_rw ‚Üê smul_eq_mul
exact is_bounded_bilinear_map_smul
intros
set e : PE ‚âÉ·µ¢ PE := ((f.trans $ (point_reflection ‚Ñù $ midpoint ‚Ñù (f x) (f y)).to_isometric).trans f.symm).trans (point_reflection ‚Ñù $ midpoint ‚Ñù x y).to_isometric
have hx : e x = x
simp
simp
have hy : e y = y
simp
simp
have hm := e.midpoint_fixed hx hy
simp only [e, trans_apply] at hm
rwa [‚Üê eq_symm_apply, to_isometric_symm, point_reflection_symm, coe_to_isometric, coe_to_isometric, point_reflection_self, symm_apply_eq, point_reflection_fixed_iff] at hm
intros
simpa only [prod_const] using f.le_op_norm_mul_prod_of_le m hm
intros
refine norm_id_of_nontrivial_seminorm _
obtain ‚ü®x, hx‚ü© := exists_ne (0 : E)
exact ‚ü®x, ne_of_gt (norm_pos_iff.2 hx)‚ü©
intros
simp only [‚Üê rpow_nat_cast, real.summable_nat_rpow_inv, nat.one_lt_cast]
intros
rintro a ha _ ‚ü®_, ‚ü®x, y, hx, hy, rfl‚ü©, rfl‚ü©
rw smul_add
exact ‚ü®_, _, hA‚ÇÅ _ ha ‚ü®_, hx, rfl‚ü©, hA‚ÇÇ _ ha ‚ü®_, hy, rfl‚ü©, rfl‚ü©
have A : tendsto (Œªx:‚Ñù, x + 1) at_top at_top := tendsto_at_top_add_const_right at_top 1 tendsto_id
have B : ‚àÄ·∂† x in at_top, x + 1 ‚â§ exp x := eventually_at_top.2 ‚ü®0, Œªx hx, add_one_le_exp_of_nonneg hx‚ü©
exact tendsto_at_top_mono' at_top B A
rw [continuous_on_iff_continuous_restrict, restrict]
conv in (log _) { rw [log_of_ne_zero (show (x : ‚Ñù) ‚â† 0, from x.2)] }
exact exp_order_iso.symm.continuous.comp (continuous_subtype_mk _ continuous_subtype_coe.norm)
intros
simp only [one_div, integral_inv_one_add_sq]
intros
by_cases h : P = 0
{ simp [h] }
simp [h]
conv_lhs { funext, rw [polynomial.eval_eq_finset_sum, sum_range_succ] }
{ conv_lhs { funext, rw [polynomial.eval_eq_finset_sum, sum_range_succ] }, exact is_equivalent.refl.add_is_o (is_o.sum $ Œª i hi, is_o.const_mul_left (is_o.const_mul_right (Œª hz, h $ leading_coeff_eq_zero.mp hz) $ is_o_pow_pow_at_top_of_lt (mem_range.mp hi)) _) }
exact is_equivalent.refl.add_is_o (is_o.sum $ Œª i hi, is_o.const_mul_left (is_o.const_mul_right (Œª hz, h $ leading_coeff_eq_zero.mp hz) $ is_o_pow_pow_at_top_of_lt (mem_range.mp hi)) _)
intros
rcases em (x = 0) with rfl|hx
replace h := h.neg_resolve_left rfl
{ replace h := h.neg_resolve_left rfl, rw [log_zero, mul_zero], refine (has_strict_deriv_at_const _ 0).congr_of_eventually_eq _, exact (is_open_ne.eventually_mem h).mono (Œª y hy, (zero_cpow hy).symm) }
rw [log_zero, mul_zero]
refine (has_strict_deriv_at_const _ 0).congr_of_eventually_eq _
exact (is_open_ne.eventually_mem h).mono (Œª y hy, (zero_cpow hy).symm)
simpa only [cpow_def_of_ne_zero hx, mul_one] using ((has_strict_deriv_at_id y).const_mul (log x)).cexp
{ simpa only [cpow_def_of_ne_zero hx, mul_one] using ((has_strict_deriv_at_id y).const_mul (log x)).cexp }
intros
simp [rpow_def, *]
intros
rcases eq_or_lt_of_le h‚ÇÅ with rfl|h‚ÇÅ'
refl
{ refl }
rcases eq_or_lt_of_le h‚ÇÇ with rfl|h‚ÇÇ'
simp
{ simp }
exact le_of_lt (rpow_lt_rpow h h‚ÇÅ' h‚ÇÇ')
intros
simpa using (has_strict_deriv_at_const _ _).rpow (has_strict_deriv_at_id x) ha
intros
exact_mod_cast (complex.has_deriv_at_tan (by exact_mod_cast h)).real_of_complex
intros
rw [sub_eq_add_neg, sub_eq_add_neg, coe_add, coe_neg]
intros
simp [arccos]
intros
simpa only [pow_one] using is_o_pow_const_const_pow_of_one_lt 1 hr
intros
by_cases hC : C = 0
subst hC
{ subst hC, simp at h, exact cauchy_seq_of_le_geometric 0 0 zero_lt_one (by simp [h]) }
simp at h
exact cauchy_seq_of_le_geometric 0 0 zero_lt_one (by simp [h])
have : 0 ‚â§ C
{ simpa using (norm_nonneg _).trans (h 0) }
simpa using (norm_nonneg _).trans (h 0)
replace hC : 0 < C
from (ne.symm hC).le_iff_lt.mp this
have : 0 ‚â§ r
have := (norm_nonneg _).trans (h 1)
{ have := (norm_nonneg _).trans (h 1), rw pow_one at this, exact (zero_le_mul_left hC).mp this }
rw pow_one at this
exact (zero_le_mul_left hC).mp this
simp_rw finset.sum_range_succ_comm
have : cauchy_seq u
apply tendsto.cauchy_seq
{ apply tendsto.cauchy_seq, apply squeeze_zero_norm h, rw show 0 = C*0, by simp, exact tendsto_const_nhds.mul (tendsto_pow_at_top_nhds_0_of_lt_1 this hr) }
apply squeeze_zero_norm h
rw show 0 = C*0, by simp
exact tendsto_const_nhds.mul (tendsto_pow_at_top_nhds_0_of_lt_1 this hr)
exact this.add (cauchy_series_of_le_geometric hr h)
intros
rw [equiv.symm_apply_eq]; simp
rw [equiv.symm_apply_eq]
simp
intros
rw [‚Üêequiv.eq_symm_apply, unit_comp_partial_bijective_symm_natural A h, equiv.symm_apply_apply]
intros
{ convert w (ùüô X), tidy }
convert w (ùüô X)
tidy
intros
rw [uncurry_eq, exp_comparison_ev]
intros
simp only [cancel_mono]
intros
{ erw is_limit.fac, refl }
erw is_limit.fac
refl
intros
constructor
{ constructor, intro F, apply has_colimit_of_equivalence_comp e, apply_instance }
intro F
apply has_colimit_of_equivalence_comp e
apply_instance
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
rw [t.left_app_one, t.right_app_one]
intros
{ ext, simp [image.comp_iso] }
ext
simp [image.comp_iso]
intros
{ ext, refl }
ext
refl
intros
{ rw [‚Üêright_unitor_tensor, right_unitor_naturality], simp, }
rw [‚Üêright_unitor_tensor, right_unitor_naturality]
simp
intros
{ ext, rw [‚Üêleft_unitor_hom_f, ‚Üêcomp_f, iso.hom_inv_id], refl, }
ext
rw [‚Üêleft_unitor_hom_f, ‚Üêcomp_f, iso.hom_inv_id]
refl
intros
ext
ext; refl
refl
intros
apply J.transitive sjx R (Œª Y f hf, _)
apply covering_of_eq_top
rw [‚Üê top_le_iff, ‚Üê S.pullback_eq_top_of_mem hf]
apply sieve.pullback_monotone _ Hss
intros
cases h with t ht
intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm
rw [‚Üêht _ h‚ÇÅ, ‚Üêht _ h‚ÇÇ, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, comm]
simp
intros
simp [sieve.ext_iff]
intros
simp [of_mk_le_mk]
intros
simp only [image_subobject_map, category.assoc, image_subobject_arrow']
erw [image.map_Œπ, ‚Üêcategory.assoc, image_subobject_arrow]
intros
dsimp [size_up_to]
convert c.blocks_sum
exact take_all_of_le h
intros
rw ‚Üêto_DFA_correct at hx ‚ä¢
exact M.to_DFA.pumping_lemma hx hlen
intros
simp [pred]; cases v.head; simp
simp [pred]; cases v.head
simp [pred]
cases v.head
simp
simp
intros
simp only [tr_tape, tape.mk'_left, tape.mk'_right‚ÇÄ]
intros
induction n with n IH
refl
{refl}
refine reaches‚ÇÄ.head _ IH
rw [option.mem_def, TM1.step, tr, TM1.step_aux, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_succ_fst, TM1.step_aux, iterate_succ', tape.move_right_left]
refl
intros
induction n with n IH generalizing L R
simp only [list_blank.nth_zero, list_blank.modify_nth, iterate_zero_apply]
{ simp only [list_blank.nth_zero, list_blank.modify_nth, iterate_zero_apply], rw [‚Üê tape.write_mk', list_blank.cons_head_tail] }
rw [‚Üê tape.write_mk', list_blank.cons_head_tail]
simp only [list_blank.head_cons, list_blank.nth_succ, list_blank.modify_nth, tape.move_right_mk', list_blank.tail_cons, iterate_succ_apply, IH]
intros
cases x
cases x; refl
refl
intros
cases x; simp! [sum.traverse] with functor_norm
cases x
simp! [sum.traverse] with functor_norm
simp! [sum.traverse] with functor_norm
intros
by_cases p; by_cases q; simp *
by_cases p; by_cases q
by_cases p
by_cases q
simp *
simp *
by_cases q
simp *
simp *
intros
{ convert bounded.and_then, exact many he }
convert bounded.and_then
exact many he
intros
cases l
rw many_eq_done_nil at h
{ rw many_eq_done_nil at h, exact ‚ü®h.left.symm, rfl‚ü© }
exact ‚ü®h.left.symm, rfl‚ü©
rw many_eq_done at h
{ rw many_eq_done at h, obtain ‚ü®np, hp, -‚ü© := h, exact absurd (bounded.of_done hp) hn.not_lt }
obtain ‚ü®np, hp, -‚ü© := h
exact absurd (bounded.of_done hp) hn.not_lt
intros
simp [foldl_core, and.assoc, pure_eq_done]
intros
dsimp [norm_sq]; ring
dsimp [norm_sq]
ring
intros
rw ‚Üê of_real_inj; simp [cos_two_mul']
rw ‚Üê of_real_inj
simp [cos_two_mul']
intros
have s1 := cos_add ((x + y) / 2) ((x - y) / 2)
have s2 := cos_sub ((x + y) / 2) ((x - y) / 2)
rw [div_add_div_same, add_sub, add_right_comm, add_sub_cancel, half_add_self] at s1
rw [div_sub_div_same, ‚Üêsub_add, add_sub_cancel', half_add_self] at s2
rw [s1, s2]
ring
intros
simp [bit0]
intros
rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs]
{ rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs], exact is_R_or_C.abs_re_le_abs _, }
exact is_R_or_C.abs_re_le_abs _
intros
ext1 j
simp only [dfinsupp.filter_apply, dfinsupp.erase_apply, ite_not]
intros
ext j
{ ext j, by_cases h1 : j = i; by_cases h2 : f j ‚â† 0; simp at h2; simp [h1, h2] }
by_cases h1 : j = i
by_cases h1 : j = i; by_cases h2 : f j ‚â† 0; simp at h2; simp [h1, h2]
by_cases h1 : j = i; by_cases h2 : f j ‚â† 0; simp at h2
by_cases h1 : j = i; by_cases h2 : f j ‚â† 0
by_cases h2 : f j ‚â† 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
by_cases h2 : f j ‚â† 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
intros
{ cases a, cases a_val, refl }
cases a
cases a_val
refl
intros
simp [perm.extend_domain, h]
intros
{ ext i, cases i; refl }
ext i
cases i
cases i; refl
refl
refl
intros
simp [fin_add_flip]
intros
ext x
simp [id_bimap]
intros
simp
intros
cases a; cases b; refl
cases a; cases b
cases a
cases b
refl
intros
rcases i.le_last.eq_or_lt with rfl|H
{ simp }
simp
simp only [ne_of_lt H]
{ simp only [ne_of_lt H], rw ‚Üêcast_succ_cast_pred H, simp }
rw ‚Üêcast_succ_cast_pred H
simp
intros
simp [piecewise]
intros
simp only [not_mem_empty, false_and, exists_false]
intros
simp [noncomm_fold]
intros
simp [to_multiset_apply, add_monoid_hom.map_finsupp_sum, function.id_def]
intros
ext
simp only [finset.mem_union, mem_support_iff, sup_apply, ne.def, ‚Üê bot_eq_zero]
rw sup_eq_bot_iff
tauto
intros
simp [ext_iff, set.ext_iff]
intros
simp
intros
apply bool_iff_false.2; dsimp [contains]; rw [find_empty]; refl
apply bool_iff_false.2; dsimp [contains]; rw [find_empty]
apply bool_iff_false.2; dsimp [contains]
apply bool_iff_false.2
dsimp [contains]
rw [find_empty]
refl
intros
rw [add_comm, int.add_div_of_dvd_right H, add_comm]
intros
rw [mul_comm, mul_comm c, mul_div_mul_of_pos _ _ H]
intros
rw [eq_sub_iff_add_eq, ‚Üê int.add_div_of_dvd_left hcab, sub_add_cancel]
intros
{ rw int.lcm, apply nat.lcm_one_right }
rw int.lcm
apply nat.lcm_one_right
intros
{ rw [mul_comm a, mul_comm b], exact h.mul_left c }
rw [mul_comm a, mul_comm b]
exact h.mul_left c
intros
rw [add_comm, odd_add]
intros
split
split; intros h x y hxy
intros h x y hxy
suffices : [x] = [y]
{ suffices : [x] = [y], { simpa using this }, apply h, simp [hxy] }
simpa using this
{ simpa using this }
apply h
simp [hxy]
intros h x y hxy
induction y generalizing x
{ induction y generalizing x, simpa using hxy, cases x, simpa using hxy, simp at hxy, simp [y_ih hxy.2, h hxy.1] }
simpa using hxy
cases x
simpa using hxy
simp at hxy
simp [y_ih hxy.2, h hxy.1]
intros
simp [drop_append_eq_append_drop, take_all_of_le le_self_add]
intros
simp only [scanl, eq_self_iff_true, singleton_append, and_self]
intros
induction l with hd tl hl generalizing n
simp only [length, pmap] at hn
{ simp only [length, pmap] at hn, exact absurd hn (not_lt_of_le n.zero_le) }
exact absurd hn (not_lt_of_le n.zero_le)
cases n
{ cases n, { simp }, { simpa [hl] } }
{ simp }
simp
{ simpa [hl] }
simpa [hl]
intros
induction l; simp [*, filter]
induction l
simp [*, filter]
simp [*, filter]
intros
rw ‚Üê list.append_assoc; apply infix_append
rw ‚Üê list.append_assoc
apply infix_append
intros
simp only [insert.def, if_pos h]
intros
simp only [list.inter, mem_reverse]; congr
simp only [list.inter, mem_reverse]
intros
simp! [pure,list.ret]
intros
apply relation.refl_trans_gen.head_induction_on h
{ exact ‚ü®[], chain.nil, rfl‚ü© }
exact ‚ü®[], chain.nil, rfl‚ü©
intros c d e t ih
{ intros c d e t ih, obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := ih, refine ‚ü®d :: l, chain.cons e hl‚ÇÅ, _‚ü©, rwa last_cons_cons }
obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := ih
refine ‚ü®d :: l, chain.cons e hl‚ÇÅ, _‚ü©
rwa last_cons_cons
intros
cases le_total n l with hnl hln
{ rw [max_eq_right hnl, filter_le_of_le hnl] }
rw [max_eq_right hnl, filter_le_of_le hnl]
{ rw [max_eq_left hln, filter_le_of_le_bot hln] }
rw [max_eq_left hln, filter_le_of_le_bot hln]
intros
simp
intros
simp only [range_eq_range', nth_range' _ h, zero_add]
intros
rw [rotate_eq_rotate', rotate'_length_mul]
intros
split
split; { intro h, simpa using h.reverse }
{ intro h, simpa using h.reverse }
intro h
{ intro h, simpa using h.reverse }
simpa using h.reverse
intros
cases option.is_some_iff_exists.mp (lookup_is_some.mpr (mem_keys_of_mem h)) with b' h'
cases nd.eq_of_mk_mem h (of_mem_lookup h')
exact h'
intros
unfold_wf
induction xs with x xs
{ simp [list.erase_dupkeys] }
simp [list.erase_dupkeys]
simp only [erase_dupkeys_cons, list.sizeof, kinsert_def, add_le_add_iff_left, sigma.eta]
{ simp only [erase_dupkeys_cons, list.sizeof, kinsert_def, add_le_add_iff_left, sigma.eta], transitivity, apply sizeof_kerase, assumption }
transitivity
apply sizeof_kerase
assumption
intros
simp only [sublists_aux‚ÇÅ_append, sublists_aux‚ÇÅ, append_assoc, append_nil]
intros
induction l with hd tl hl generalizing l' n
{ simp }
simp
cases l'
{ cases l', { simp }, { cases n, { simp }, { simp [hl] } } }
{ simp }
simp
cases n
{ cases n, { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
{ ext i j, simp }
ext i j
simp
intros
ext x y
simp [update_column_apply, subsingleton.elim i x]
intros
simp [dot_product, mul_add, finset.sum_add_distrib]
intros
split
intro h
{ intro h, inhabit n, rw [‚Üê scalar_apply_eq r (arbitrary n), ‚Üê scalar_apply_eq s (arbitrary n), h] }
inhabit n
rw [‚Üê scalar_apply_eq r (arbitrary n), ‚Üê scalar_apply_eq s (arbitrary n), h]
{ rintro rfl, refl }
rintro rfl
refl
intros
ext i j
rcases i
rcases i; rcases j; simp [from_blocks]
rcases i; rcases j
rcases j
simp [from_blocks]
simp [from_blocks]
rcases j
simp [from_blocks]
simp [from_blocks]
intros
{ ext, refl }
ext
refl
intros
revert m1
apply m2.induction_on
intros m h hc
{ intros m h hc, rw [rel_zero_right, ‚Üê card_eq_zero, hc, card_zero] }
rw [rel_zero_right, ‚Üê card_eq_zero, hc, card_zero]
intros a t ih m h hc
{ intros a t ih m h hc, rw card_cons at hc, obtain ‚ü®b, hb‚ü© := card_pos_iff_exists_mem.1 (show 0 < card m, from hc.symm ‚ñ∏ (nat.succ_pos _)), obtain ‚ü®m', rfl‚ü© := exists_cons_of_mem hb, refine rel_cons_right.mpr ‚ü®b, m', h _ _ hb (mem_cons_self _ _), ih _ _, rfl‚ü©, { exact Œª _ _ ha hb, h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb) }, { simpa using hc } }
rw card_cons at hc
obtain ‚ü®b, hb‚ü© := card_pos_iff_exists_mem.1 (show 0 < card m, from hc.symm ‚ñ∏ (nat.succ_pos _))
obtain ‚ü®m', rfl‚ü© := exists_cons_of_mem hb
refine rel_cons_right.mpr ‚ü®b, m', h _ _ hb (mem_cons_self _ _), ih _ _, rfl‚ü©
{ exact Œª _ _ ha hb, h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb) }
exact Œª _ _ ha hb, h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb)
{ simpa using hc }
simpa using hc
intros
rw [add_comm, cons_add, add_comm]
intros
apply hfunext
refl
{ refl }
intros a'' _ h
subst h
apply hfunext
rw [cons_swap]
{ rw [cons_swap] }
intros ha‚ÇÅ ha‚ÇÇ h
by_cases h‚ÇÅ : a'' = a; by_cases h‚ÇÇ : a'' = a'; simp [*, pi.cons_same, pi.cons_ne] at *
by_cases h‚ÇÅ : a'' = a; by_cases h‚ÇÇ : a'' = a'
by_cases h‚ÇÅ : a'' = a
by_cases h‚ÇÇ : a'' = a'
simp [*, pi.cons_same, pi.cons_ne] at *
simp [*, pi.cons_same, pi.cons_ne] at *
{ subst h‚ÇÅ, rw [pi.cons_same, pi.cons_same] }
subst h‚ÇÅ
rw [pi.cons_same, pi.cons_same]
by_cases h‚ÇÇ : a'' = a'
simp [*, pi.cons_same, pi.cons_ne] at *
{ subst h‚ÇÇ, rw [pi.cons_same, pi.cons_same] }
subst h‚ÇÇ
rw [pi.cons_same, pi.cons_same]
simp [*, pi.cons_same, pi.cons_ne] at *
intros
simp [constant_coeff_eq]
intros
{ rw ‚Üê comp_eval‚ÇÇ_hom, refl }
rw ‚Üê comp_eval‚ÇÇ_hom
refl
intros
{ ext1 f, rw [expand_one_apply, alg_hom.id_apply] }
ext1 f
rw [expand_one_apply, alg_hom.id_apply]
intros
simp [algebra.eq_top_iff, mem_supported]
intros
rw [‚Üê mod_add_mod, ‚Üê mod_add_mod k, H]
intros
rw add_assoc
exact add_lt_add_of_lt_of_le hab (nat.succ_le_iff.2 hcd)
intros
by_cases n = m
cases h
{ cases h, simp }
simp
rw test_bit_two_pow_of_ne h
{ rw test_bit_two_pow_of_ne h, simp [h] }
simp [h]
intros
refine one_div_lt_one_div_of_lt _ _
{ refine one_div_lt_one_div_of_lt _ _, exact nat.cast_add_one_pos _, simpa }
exact nat.cast_add_one_pos _
simpa
intros
rw [list.map_with_index_eq_enum_map, list.enum_eq_zip_range, list.map_uncurry_zip_eq_zip_with, of_digits_eq_foldr]
induction L with hd tl hl
{ simp }
simp
simpa [list.range_succ_eq_map, list.zip_with_map_left, of_digits_eq_sum_map_with_index_aux] using or.inl hl
{ simpa [list.range_succ_eq_map, list.zip_with_map_left, of_digits_eq_sum_map_with_index_aux] using or.inl hl }
intros
rcases h with ‚ü®h, b2, m0‚ü©
have b0 : 0 < b := by linarith
have n0 : 0 < n := by linarith [mul_pos b0 m0]
refine ‚ü®_, b2, n0‚ü©
obtain ‚ü®rfl, rfl‚ü© := (nat.div_mod_unique b0).2 ‚ü®e, hr‚ü©
subst h
exact nat.digits_def' b2 n0
intros
induction n with n ih
refl
{ refl }
apply part.ext'
show true ‚Üî ((n : enat).dom ‚àß true)
{ show true ‚Üî ((n : enat).dom ‚àß true), rw [‚Üê ih, and_true], exact iff.rfl }
rw [‚Üê ih, and_true]
exact iff.rfl
intros h H
{ intros h H, show n.succ = (n : enat).get H.1 + 1, rw [nat.cast_succ] at H, revert H, simp only [‚Üê ih], intro, refl }
show n.succ = (n : enat).get H.1 + 1
rw [nat.cast_succ] at H
revert H
simp only [‚Üê ih]
intro
refl
intros
rw gcd_comm at H; exact eq_zero_of_gcd_eq_zero_left H
rw gcd_comm at H
exact eq_zero_of_gcd_eq_zero_left H
intros
rw [modeq_iff_dvd] at *
{ rw [modeq_iff_dvd] at *, exact (dvd_mul_left (n : ‚Ñ§) (m : ‚Ñ§)).trans h }
exact (dvd_mul_left (n : ‚Ñ§) (m : ‚Ñ§)).trans h
intros
induction m with d hd
refl
{refl}
rw [pow_succ, pow_succ]
exact h.mul hd
intros
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.mul_mod]; norm_num
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ; simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.mul_mod]
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ; cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
cases mod_two_eq_zero_or_one m with h‚ÇÅ h‚ÇÅ
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.mul_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.mul_mod]
cases mod_two_eq_zero_or_one n with h‚ÇÇ h‚ÇÇ
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.mul_mod]
simp [even_iff, h‚ÇÅ, h‚ÇÇ, nat.mul_mod]
intros
rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w), pow_le_iff_le_right w]
intros
split
intro h
{ intro h, by_contradiction hn, have := min_fac_prime hn, rw h at this, exact not_prime_one this, }
by_contradiction hn
have := min_fac_prime hn
rw h at this
exact not_prime_one this
{ rintro rfl, refl, }
rintro rfl
refl
intros
refine ‚ü®zero_lt_one, lt_of_le_of_ne _ min_fac_ne_bit0.symm‚ü©
refine @lt_of_le_of_ne ‚Ñï _ _ _ (nat.min_fac_pos _) _
intro e
have := nat.min_fac_prime _
{ rw ‚Üê e at this, exact nat.not_prime_one this }
rw ‚Üê e at this
exact nat.not_prime_one this
{ exact ne_of_gt (nat.bit1_lt h) }
exact ne_of_gt (nat.bit1_lt h)
intros
simp only [shiftr_eq_div_pow]
apply (nat.div_lt_iff_lt_mul' (dec_trivial : 0 < 4)).2
have := nat.mul_lt_mul_of_pos_left (dec_trivial : 1 < 4) (nat.pos_of_ne_zero h)
rwa mul_one at this
intros
rw ‚Üê not_lt; exact not_congr cast_lt
rw ‚Üê not_lt
exact not_congr cast_lt
intros
simp
intros
cases o; simp
cases o
simp
simp
intros
linarith
intros
induction t generalizing a‚ÇÅ a‚ÇÇ
{ simp [erase, raised], exact h }
simp [erase, raised]
exact h
simp [erase]
{ simp [erase], have t_ih_l' := t_ih_l h.left, have t_ih_r' := t_ih_r h.right, clear t_ih_l t_ih_r, cases t_ih_l' with t_l_valid t_l_size, cases t_ih_r' with t_r_valid t_r_size, cases (cmp_le x t_x); simp [erase._match_1]; rw h.sz.1, { suffices h_balanceable, split, { exact valid'.balance_r t_l_valid h.right h_balanceable }, { rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable, repeat { apply raised.add_right }, exact t_l_size }, { left, existsi t_l.size, exact (and.intro t_l_size h.bal.1) } }, { have h_glue := valid'.glue h.left h.right h.bal.1, cases h_glue with h_glue_valid h_glue_sized, split, { exact h_glue_valid }, { right, rw h_glue_sized } }, { suffices h_balanceable, split, { exact valid'.balance_l h.left t_r_valid h_balanceable }, { rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable, apply raised.add_right, apply raised.add_left, exact t_r_size }, { right, existsi t_r.size, exact (and.intro t_r_size h.bal.1) } } }
have t_ih_l' := t_ih_l h.left
have t_ih_r' := t_ih_r h.right
clear t_ih_l t_ih_r
cases t_ih_l' with t_l_valid t_l_size
cases t_ih_r' with t_r_valid t_r_size
cases (cmp_le x t_x); simp [erase._match_1]; rw h.sz.1
cases (cmp_le x t_x); simp [erase._match_1]
cases (cmp_le x t_x)
simp [erase._match_1]
rw h.sz.1
suffices h_balanceable
{ suffices h_balanceable, split, { exact valid'.balance_r t_l_valid h.right h_balanceable }, { rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable, repeat { apply raised.add_right }, exact t_l_size }, { left, existsi t_l.size, exact (and.intro t_l_size h.bal.1) } }
split
{ exact valid'.balance_r t_l_valid h.right h_balanceable }
exact valid'.balance_r t_l_valid h.right h_balanceable
rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable
{ rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable, repeat { apply raised.add_right }, exact t_l_size }
apply raised.add_right
repeat { apply raised.add_right }
apply raised.add_right
apply raised.add_right
exact t_l_size
{ left, existsi t_l.size, exact (and.intro t_l_size h.bal.1) }
left
existsi t_l.size
exact (and.intro t_l_size h.bal.1)
simp [erase._match_1]
rw h.sz.1
have h_glue := valid'.glue h.left h.right h.bal.1
{ have h_glue := valid'.glue h.left h.right h.bal.1, cases h_glue with h_glue_valid h_glue_sized, split, { exact h_glue_valid }, { right, rw h_glue_sized } }
cases h_glue with h_glue_valid h_glue_sized
split
{ exact h_glue_valid }
exact h_glue_valid
{ right, rw h_glue_sized }
right
rw h_glue_sized
simp [erase._match_1]
rw h.sz.1
suffices h_balanceable
{ suffices h_balanceable, split, { exact valid'.balance_l h.left t_r_valid h_balanceable }, { rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable, apply raised.add_right, apply raised.add_left, exact t_r_size }, { right, existsi t_r.size, exact (and.intro t_r_size h.bal.1) } }
split
{ exact valid'.balance_l h.left t_r_valid h_balanceable }
exact valid'.balance_l h.left t_r_valid h_balanceable
rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable
{ rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable, apply raised.add_right, apply raised.add_left, exact t_r_size }
apply raised.add_right
apply raised.add_left
exact t_r_size
{ right, existsi t_r.size, exact (and.intro t_r_size h.bal.1) }
right
existsi t_r.size
exact (and.intro t_r_size h.bal.1)
intros
cases m; simp [node4_l, all_node', all, all_node3_l, and_assoc]
cases m
simp [node4_l, all_node', all, all_node3_l, and_assoc]
simp [node4_l, all_node', all, all_node3_l, and_assoc]
intros
simp [res, @eq_comm _ b]
intros
cases x with a f; rw [W_mk', W_dest'_W_mk, split_drop_fun_last_fun]
cases x with a f
rw [W_mk', W_dest'_W_mk, split_drop_fun_last_fun]
intros
split
split; intro h; try { apply pnat.eq}; rw h; simp
split; intro h; try { apply pnat.eq}; rw h
split; intro h; try { apply pnat.eq}
split; intro h
{ split; intro h; try { apply pnat.eq}; rw h; simp }
intro h
try { apply pnat.eq}
rw h
simp
intro h
try { apply pnat.eq}
apply pnat.eq
rw h
simp
intros
have := prod_of_nat_multiset (l : multiset ‚Ñï) h
{ have := prod_of_nat_multiset (l : multiset ‚Ñï) h, rw [multiset.coe_prod] at this, exact this }
rw [multiset.coe_prod] at this
exact this
intros
simp [coeff_monomial]
intros
simp [coeff_erase, h]
intros
rw ‚Üê card_singleton n
apply card_le_of_subset (support_C_mul_X_pow c n)
intros
{ rw C_mul_X_pow_eq_monomial, exact le_trailing_degree_monomial }
rw C_mul_X_pow_eq_monomial
exact le_trailing_degree_monomial
intros
conv_rhs { rw [‚Üê mod_by_monic_add_div p monic_one] }
conv_rhs { rw [‚Üê mod_by_monic_add_div p monic_one] }; simp
simp
intros
induction n with n ih
{ simp only [eval‚ÇÇ_zero, nat.cast_zero] }
simp only [eval‚ÇÇ_zero, nat.cast_zero]
rw [n.cast_succ, eval‚ÇÇ_add, ih, eval‚ÇÇ_one, n.cast_succ]
{ rw [n.cast_succ, eval‚ÇÇ_add, ih, eval‚ÇÇ_one, n.cast_succ] }
intros
induction k with k ih
{ simp, }
simp
{ simp [ih, pow_succ', ‚Üêmul_assoc, mul_X_comp], }
simp [ih, pow_succ', ‚Üêmul_assoc, mul_X_comp]
intros
rw [‚Üê monomial_one_one_eq_X, hasse_deriv_monomial, nat.choose_eq_zero_of_lt hk, nat.cast_zero, zero_mul, monomial_zero_right]
intros
simp [integral_normalization]
intros
simpa only [sub_eq_add_neg, C_neg] using monic_X_add_C (-x)
intros
split
assume H
{ assume H, rw finset.card_le_one_iff_subset_singleton at H, rcases H with ‚ü®n, hn‚ü©, refine ‚ü®n, f.coeff n, _‚ü©, ext i, by_cases hi : i = n, { simp [hi, coeff_monomial] }, { have : f.coeff i = 0, { rw ‚Üê not_mem_support_iff, exact Œª hi', hi (finset.mem_singleton.1 (hn hi')) }, simp [this, ne.symm hi, coeff_monomial] } }
rw finset.card_le_one_iff_subset_singleton at H
rcases H with ‚ü®n, hn‚ü©
refine ‚ü®n, f.coeff n, _‚ü©
ext i
by_cases hi : i = n
{ simp [hi, coeff_monomial] }
simp [hi, coeff_monomial]
have : f.coeff i = 0
{ have : f.coeff i = 0, { rw ‚Üê not_mem_support_iff, exact Œª hi', hi (finset.mem_singleton.1 (hn hi')) }, simp [this, ne.symm hi, coeff_monomial] }
rw ‚Üê not_mem_support_iff
{ rw ‚Üê not_mem_support_iff, exact Œª hi', hi (finset.mem_singleton.1 (hn hi')) }
exact Œª hi', hi (finset.mem_singleton.1 (hn hi'))
simp [this, ne.symm hi, coeff_monomial]
rintros ‚ü®n, a, rfl‚ü©
{ rintros ‚ü®n, a, rfl‚ü©, rw ‚Üê finset.card_singleton n, apply finset.card_le_of_subset, exact support_monomial' _ _ }
rw ‚Üê finset.card_singleton n
apply finset.card_le_of_subset
exact support_monomial' _ _
intros
rw [‚Üêpolynomial.C_mul', ‚Üêpolynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]
intros
rw [cofix.corec',cofix.dest_corec]
dsimp
congr' with (i|i); rw corec_roll; dsimp [cofix.corec']
congr' with (i|i); rw corec_roll
congr' with (i|i)
rw corec_roll
dsimp [cofix.corec']
mv_bisim i
{ mv_bisim i, rw [Ha,Hb,cofix.dest_corec], dsimp [(‚àò)], repeat { rw [mvfunctor.map_map,‚Üê append_fun_comp_id] }, apply liftr_map_last', dsimp [(‚àò),R], intros, exact ‚ü®_,rfl,rfl‚ü© }
rw [Ha,Hb,cofix.dest_corec]
dsimp [(‚àò)]
rw [mvfunctor.map_map,‚Üê append_fun_comp_id]
repeat { rw [mvfunctor.map_map,‚Üê append_fun_comp_id] }
rw [mvfunctor.map_map,‚Üê append_fun_comp_id]
rw [mvfunctor.map_map,‚Üê append_fun_comp_id]
apply liftr_map_last'
dsimp [(‚àò),R]
intros
exact ‚ü®_,rfl,rfl‚ü©
rw corec_roll
dsimp [cofix.corec']
congr' with y
{ congr' with y, erw [append_fun_id_id], simp [mvfunctor.id_map] }
erw [append_fun_id_id]
simp [mvfunctor.id_map]
intros
rw mk_pnat_denom
apply nat.div_dvd_of_dvd
apply nat.gcd_dvd_right
intros
rw [rat.floor_def]
cases decidable.em (d = 0) with d_eq_zero d_ne_zero
{ simp [d_eq_zero] }
simp [d_eq_zero]
cases decidable.em (n = 0) with n_eq_zero n_ne_zero
{ cases decidable.em (n = 0) with n_eq_zero n_ne_zero, { simp [n_eq_zero] }, { set q := (n : ‚Ñö) / d with q_eq, obtain ‚ü®c, n_eq_c_mul_num, d_eq_c_mul_denom‚ü© : ‚àÉ c, n = c * q.num ‚àß (d : ‚Ñ§) = c * q.denom, by { rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }, suffices : q.num / q.denom = c * q.num / (c * q.denom), by rwa [n_eq_c_mul_num, d_eq_c_mul_denom], suffices : c > 0, by solve_by_elim [int.mul_div_mul_of_pos], have q_denom_mul_c_pos : (0 : ‚Ñ§) < q.denom * c, by { have : (d : ‚Ñ§) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }, suffices : (0 : ‚Ñ§) ‚â§ q.denom, from pos_of_mul_pos_left q_denom_mul_c_pos this, exact_mod_cast (le_of_lt q.pos) } }
{ simp [n_eq_zero] }
simp [n_eq_zero]
set q := (n : ‚Ñö) / d with q_eq
{ set q := (n : ‚Ñö) / d with q_eq, obtain ‚ü®c, n_eq_c_mul_num, d_eq_c_mul_denom‚ü© : ‚àÉ c, n = c * q.num ‚àß (d : ‚Ñ§) = c * q.denom, by { rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }, suffices : q.num / q.denom = c * q.num / (c * q.denom), by rwa [n_eq_c_mul_num, d_eq_c_mul_denom], suffices : c > 0, by solve_by_elim [int.mul_div_mul_of_pos], have q_denom_mul_c_pos : (0 : ‚Ñ§) < q.denom * c, by { have : (d : ‚Ñ§) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }, suffices : (0 : ‚Ñ§) ‚â§ q.denom, from pos_of_mul_pos_left q_denom_mul_c_pos this, exact_mod_cast (le_of_lt q.pos) }
obtain ‚ü®c, n_eq_c_mul_num, d_eq_c_mul_denom‚ü© : ‚àÉ c, n = c * q.num ‚àß (d : ‚Ñ§) = c * q.denom
rw q_eq
rw q_eq
{ rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }
{ rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }
exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero))
exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero))
suffices : q.num / q.denom = c * q.num / (c * q.denom)
rwa [n_eq_c_mul_num, d_eq_c_mul_denom]
rwa [n_eq_c_mul_num, d_eq_c_mul_denom]
suffices : c > 0
solve_by_elim [int.mul_div_mul_of_pos]
solve_by_elim [int.mul_div_mul_of_pos]
have q_denom_mul_c_pos : (0 : ‚Ñ§) < q.denom * c
have : (d : ‚Ñ§) > 0
have : (d : ‚Ñ§) > 0
{ have : (d : ‚Ñ§) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }
{ have : (d : ‚Ñ§) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }
exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero)
exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero)
exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero)
rwa [d_eq_c_mul_denom, mul_comm] at this
rwa [d_eq_c_mul_denom, mul_comm] at this
suffices : (0 : ‚Ñ§) ‚â§ q.denom
from pos_of_mul_pos_left q_denom_mul_c_pos this
exact_mod_cast (le_of_lt q.pos)
intros
cases decidable.em (0 < q) with q_pos q_nonpos
{ simp [rat.lt_def] }
simp [rat.lt_def]
replace q_nonpos : q ‚â§ 0
{ replace q_nonpos : q ‚â§ 0, from not_lt.elim_left q_nonpos, have : q.num < q.denom, by { have : ¬¨0 < q.num ‚Üî ¬¨0 < q, from not_iff_not.elim_right num_pos_iff_pos, simp only [not_lt] at this, exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos) }, simp only [this, (lt_of_le_of_lt q_nonpos zero_lt_one)] }
from not_lt.elim_left q_nonpos
have : q.num < q.denom
have : ¬¨0 < q.num ‚Üî ¬¨0 < q
have : ¬¨0 < q.num ‚Üî ¬¨0 < q
{ have : ¬¨0 < q.num ‚Üî ¬¨0 < q, from not_iff_not.elim_right num_pos_iff_pos, simp only [not_lt] at this, exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos) }
{ have : ¬¨0 < q.num ‚Üî ¬¨0 < q, from not_iff_not.elim_right num_pos_iff_pos, simp only [not_lt] at this, exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos) }
from not_iff_not.elim_right num_pos_iff_pos
from not_iff_not.elim_right num_pos_iff_pos
simp only [not_lt] at this
simp only [not_lt] at this
exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos)
exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos)
simp only [this, (lt_of_le_of_lt q_nonpos zero_lt_one)]
intros
cases h' : f n; simp [h']
{ cases h' : f n; simp [h'], apply pow_nonneg h }
cases h' : f n
simp [h']
simp [h']
apply pow_nonneg h
intros
simpa only [sub_mul, sub_eq_iff_eq_add, one_mul] using h.sub_one_mul_conj
intros
by_cases h0 : x = 0
{ simp only [h0, mul_zero, infi_const] }
simp only [h0, mul_zero, infi_const]
{ exact infi_mul_of_ne h0 h }
exact infi_mul_of_ne h0 h
have := nat.prime.irrational_sqrt (show nat.prime 5, by norm_num)
have := this.rat_add 1
have := this.rat_mul (show (0.5 : ‚Ñö) ‚â† 0, by norm_num)
convert this
field_simp
intros
by_contra rid
rcases exists_eq_X_add_C_of_nat_degree_le_one (not_lt.1 rid) with ‚ü®a, b, rfl‚ü©
clear rid
have : (a : ‚Ñù) * x = -b
simpa [eq_neg_iff_add_eq_zero] using x_is_root
simpa [eq_neg_iff_add_eq_zero] using x_is_root
rcases em (a = 0) with (rfl|ha)
obtain rfl : b = 0
{ obtain rfl : b = 0, by simpa, simpa using p_nonzero }
simpa
simpa
simpa using p_nonzero
rw [mul_comm, ‚Üê eq_div_iff_mul_eq, eq_comm] at this
{ rw [mul_comm, ‚Üê eq_div_iff_mul_eq, eq_comm] at this, refine hx ‚ü®-b / a, _‚ü©, assumption_mod_cast, assumption_mod_cast }
refine hx ‚ü®-b / a, _‚ü©
assumption_mod_cast
assumption_mod_cast
intros
rw [real.sqrt, real.to_nnreal_coe]
intros
rw [sq, mul_self_sqrt x]
intros
dsimp [corec, destruct]
change stream.corec' (corec.F f) (sum.inr b) 0 with corec.F._match_1 (f b)
induction h : f b with a b'
refl
{ refl }
dsimp [corec.F, destruct]
apply congr_arg
apply subtype.eq
dsimp [corec, tail]
rw [stream.corec'_eq, stream.tail_cons]
dsimp [corec.F]
rw h
intros
rw ‚Üêbind_ret; apply mem_bind m; apply ret_mem
rw ‚Üêbind_ret; apply mem_bind m
rw ‚Üêbind_ret
apply mem_bind m
apply ret_mem
intros
rw [‚Üê ite_inter, ‚Üê h, ite_same]
intros
{ ext ‚ü®x, y‚ü©, simp [and_assoc, and.left_comm] }
ext ‚ü®x, y‚ü©
simp [and_assoc, and.left_comm]
intros
{ ext, simp [pi] }
ext
simp [pi]
intros
simp only [image2_image2_left, image2_image2_right, h_assoc]
intros
classical
convert (fintype.pi_finset (Œª d, (ht d).to_finset)).finite_to_set
ext
simp
intros
ext x
simp only [mem_pi, mem_inter_eq, ‚Üê forall_and_distrib]
refine forall_congr (Œª i, _)
by_cases hi : i ‚àà s'; simp *
by_cases hi : i ‚àà s'
simp *
simp *
intros
rw max_comm
{ rw max_comm, apply Ioc_union_Ioc; rw max_comm; exact min_le_max }
apply Ioc_union_Ioc
apply Ioc_union_Ioc; rw max_comm; exact min_le_max
apply Ioc_union_Ioc; rw max_comm
rw max_comm
exact min_le_max
rw max_comm
exact min_le_max
intros
rw [‚Üê Ici_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 left_mem_Ici)]
intros
simp [‚Üê Ici_inter_Iic, inter_comm]
intros
simp
intros
simp [‚Üê Ici_inter_Iic, h]
intros
rw [bUnion_preimage_singleton, preimage_range]
intros
have p : x ‚àà ‚ä§ := set.mem_univ x
simpa only [‚Üêw, set.mem_Union] using p
intros
{ ext, simp only [Inf_image, infi_apply, infi_Prop_eq], refl }
ext
simp only [Inf_image, infi_apply, infi_Prop_eq]
refl
intros
induction i; [refl, erw [typevec.const,@i_ih (drop Œ±) x]]
induction i
refl
erw [typevec.const,@i_ih (drop Œ±) x]
intros
cases v with l hl
subst hl
simp only [list.nodup_iff_nth_le_inj]
split
intros h i j hij
{ intros h i j hij, cases i, cases j, ext, apply h, simpa }
cases i
cases j
ext
apply h
simpa
intros h i j hi hj hij
{ intros h i j hi hj hij, have := @h ‚ü®i, hi‚ü© ‚ü®j, hj‚ü©, simp [nth_eq_nth_le] at *, tauto }
have := @h ‚ü®i, hi‚ü© ‚ü®j, hj‚ü©
simp [nth_eq_nth_le] at *
tauto
intros
cases n
{ rw [int.cast_id a, int.cast_id a], }
rw [int.cast_id a, int.cast_id a]
rw [coe_coe, int.nat_cast_eq_coe_nat, int.cast_coe_nat, fin.coe_coe_eq_self]
{ rw [coe_coe, int.nat_cast_eq_coe_nat, int.cast_coe_nat, fin.coe_coe_eq_self] }
intros
rw [hf.map_mul, hf.map_inv] at h
apply inv_injective
rw eq_inv_of_mul_eq_one h
intros
simpa only [h.comp_eq] using bij_on_fixed_pts_comp g f
intros
{ ext, rw [‚Üê mem_to_subalgebra, ‚Üê mem_to_subalgebra, h] }
ext
rw [‚Üê mem_to_subalgebra, ‚Üê mem_to_subalgebra, h]
intros
casesI hF
rcases hg with ‚ü®g, m, hm‚ü©
{ rcases hg with ‚ü®g, m, hm‚ü©, rw [one_pow, expand_one] at hm, rw hf.eq_degree, rw hm, }
rw [one_pow, expand_one] at hm
rw hf.eq_degree
rw hm
rcases hg with ‚ü®hg, m, hm‚ü©
{ rcases hg with ‚ü®hg, m, hm‚ü©, let g' := classical.some hf, cases (classical.some_spec hf).2 with m' hm', haveI : fact q.prime := fact_iff.2 hF_hprime, apply contraction_degree_eq_or_insep q g g' m m', rw [hm, hm'], exact hg, exact (classical.some_spec hf).1 }
let g' := classical.some hf
cases (classical.some_spec hf).2 with m' hm'
haveI : fact q.prime := fact_iff.2 hF_hprime
apply contraction_degree_eq_or_insep q g g' m m'
rw [hm, hm']
exact hg
exact (classical.some_spec hf).1
intros
rw [nat_degree_remove_factor, hfn, n.add_sub_cancel]
intros
rw [cos_angle, div_mul_cancel_of_imp]
simp [or_imp_distrib] { contextual := tt }
intros
simp_rw [centroid_def, affine_combination_apply, weighted_vsub_of_point_apply, sum_points_with_circumcenter, centroid_weights_with_circumcenter, points_with_circumcenter_point, zero_smul, add_zero, centroid_weights, set.sum_indicator_subset_of_eq_zero (function.const (fin (n + 1)) ((card fs : ‚Ñù)‚Åª¬π)) (Œª i wi, wi ‚Ä¢ (s.points i -·µ• classical.choice add_torsor.nonempty)) fs.subset_univ (Œª i, zero_smul ‚Ñù _), set.indicator_apply]
congr
funext
congr' 2
intros
obtain ‚ü®i‚ÇÉ, h‚ÇÇ‚ÇÉ, h‚ÇÅ‚ÇÉ‚ü© : ‚àÉ i‚ÇÉ, i‚ÇÇ ‚â† i‚ÇÉ ‚àß i‚ÇÅ ‚â† i‚ÇÉ
clear h‚ÇÅ h‚ÇÇ
{ clear h‚ÇÅ h‚ÇÇ, dec_trivial! }
dec_trivial!
rw t.altitude_eq_monge_plane h‚ÇÅ‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ.symm at h‚ÇÅ
rw t.altitude_eq_monge_plane h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ.symm h‚ÇÅ‚ÇÉ.symm at h‚ÇÇ
rw orthocenter_eq_monge_point
have ha : ‚àÄ i, i‚ÇÉ ‚â† i ‚Üí p ‚àà t.monge_plane i‚ÇÉ i
intros i hi
{ intros i hi, have hi‚ÇÅ‚ÇÇ : i‚ÇÅ = i ‚à® i‚ÇÇ = i, { clear h‚ÇÅ h‚ÇÇ, dec_trivial! }, cases hi‚ÇÅ‚ÇÇ, { exact hi‚ÇÅ‚ÇÇ ‚ñ∏ h‚ÇÇ }, { exact hi‚ÇÅ‚ÇÇ ‚ñ∏ h‚ÇÅ } }
have hi‚ÇÅ‚ÇÇ : i‚ÇÅ = i ‚à® i‚ÇÇ = i
clear h‚ÇÅ h‚ÇÇ
{ clear h‚ÇÅ h‚ÇÇ, dec_trivial! }
dec_trivial!
cases hi‚ÇÅ‚ÇÇ
{ exact hi‚ÇÅ‚ÇÇ ‚ñ∏ h‚ÇÇ }
exact hi‚ÇÅ‚ÇÇ ‚ñ∏ h‚ÇÇ
{ exact hi‚ÇÅ‚ÇÇ ‚ñ∏ h‚ÇÅ }
exact hi‚ÇÅ‚ÇÇ ‚ñ∏ h‚ÇÅ
exact eq_monge_point_of_forall_mem_monge_plane ha
intros
refine real.inj_on_cos ‚ü®angle_nonneg _ _, angle_le_pi _ _‚ü© ‚ü®angle_nonneg _ _, angle_le_pi _ _‚ü© _
rw [cos_angle, cos_angle, h, ‚Üêneg_sub, norm_neg, neg_sub, inner_sub_right, inner_sub_right, real_inner_self_eq_norm_sq, real_inner_self_eq_norm_sq, h, real_inner_comm x y]
intros
rw [mfderiv_within, mfderiv_within, ext_chart_preimage_inter_eq, mdifferentiable_within_at_inter ht, fderiv_within_inter (ext_chart_preimage_mem_nhds I x ht) hs]
intros
simp only [times_cont_mdiff_on, times_cont_mdiff, times_cont_mdiff_within_at_univ, forall_prop_of_true, mem_univ]
intros
ext h
rw [mem_stabilizer_iff, ‚Üê smul_left_cancel_iff g‚Åª¬π, smul_smul, smul_smul, smul_smul, mul_left_inv, one_smul, ‚Üê mem_stabilizer_iff, subgroup.mem_map_equiv, mul_aut.conj_symm_apply]
intros
rw mk_eq_monoid_of_mk'_apply; exact mul_equiv_of_quotient_mk' _ _
rw mk_eq_monoid_of_mk'_apply
exact mul_equiv_of_quotient_mk' _ _
intros
refine monotone_nat_of_le_succ _
intros n x hx y
rw [mul_assoc, mul_assoc, ‚Üê mul_assoc y x‚Åª¬π y‚Åª¬π]
exact mul_mem (upper_central_series G n) hx (normal.conj_mem (upper_central_series.subgroup.normal G n) x‚Åª¬π (inv_mem _ hx) y)
intros
convert minimal_period_iterate_eq_div_gcd' h
simp only [order_of, mul_left_iterate]
intros
by_cases hx : f x = x
rw ‚Üêcycle_of_eq_one_iff at hx
{ rw ‚Üêcycle_of_eq_one_iff at hx, simp [hx] }
simp [hx]
refine dvd_of_mem_cycle_type _
{ refine dvd_of_mem_cycle_type _, rw [cycle_type, multiset.mem_map], refine ‚ü®f.cycle_of x, _, _‚ü©, { rwa [‚Üêfinset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support] }, { simp [order_of_is_cycle (is_cycle_cycle_of _ hx)] } }
rw [cycle_type, multiset.mem_map]
refine ‚ü®f.cycle_of x, _, _‚ü©
rwa [‚Üêfinset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support]
{ rwa [‚Üêfinset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support] }
{ simp [order_of_is_cycle (is_cycle_cycle_of _ hx)] }
simp [order_of_is_cycle (is_cycle_cycle_of _ hx)]
intros
rw [‚Üêpow_two, ‚Üêcard_support_eq_three_iff, support_pow_coprime, ht.card_support]
rw [ht.order_of, nat.coprime_iff_gcd_eq_one]
norm_num
intros
rw [cycle_range_of_le h]
{ rw [cycle_range_of_le h], split_ifs with h', { refl }, exact coe_add_one_of_lt (calc (j : ‚Ñï) < i : fin.lt_iff_coe_lt_coe.mp (lt_of_le_of_ne h h') ... ‚â§ n : nat.lt_succ_iff.mp i.2) }
split_ifs with h'
refl
{ refl }
exact coe_add_one_of_lt (calc (j : ‚Ñï) < i : fin.lt_iff_coe_lt_coe.mp (lt_of_le_of_ne h h') ... ‚â§ n : nat.lt_succ_iff.mp i.2)
intros
induction n with n hn
{ simp }
simp
rw [nat.succ_eq_add_one, ‚Üêrotate_rotate, form_perm_rotate_one, hn]
{ rw [nat.succ_eq_add_one, ‚Üêrotate_rotate, form_perm_rotate_one, hn], rwa is_rotated.nodup_iff, exact is_rotated.forall l n }
rwa is_rotated.nodup_iff
exact is_rotated.forall l n
intros
refine eq_top_iff.mpr (Œª x hx, _)
obtain ‚ü®h1, h2‚ü© := subtype.mem (trunc_swap_factors x).out
rw ‚Üê h1
exact subgroup.list_prod_mem _ (Œª y hy, subgroup.subset_closure (h2 y hy))
intros
by_cases hx : f x = x
simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem]
{ simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem] }
ext z
by_cases hzx : z = x
{ simp [hzx] }
simp [hzx]
by_cases hzf : z = f x
{ simp [hzf, hx, h, swap_apply_of_ne_of_ne], }
simp [hzf, hx, h, swap_apply_of_ne_of_ne]
by_cases hzfx : f z = x
{ simp [ne.symm hzx, hzx, ne.symm hzf, hzfx] }
simp [ne.symm hzx, hzx, ne.symm hzf, hzfx]
simp [ne.symm hzx, hzx, ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne]
{ simp [ne.symm hzx, hzx, ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne] }
apply is_cyclic_of_order_of_eq_card
rw [card, mul_one]
exact order_of_xa 0
intros
rw subgroup.eq_bot_iff_forall
intros y hy
rw [‚Üê subgroup.coe_mk H y hy, subsingleton.elim (‚ü®y, hy‚ü© : H) 1, subgroup.coe_one]
intros
revert b
refine add_submonoid.closure_induction ha _ _ _
refine add_submonoid.closure_induction ha _ _ _; clear ha a
clear ha a
exact Œª r hr b hb, add_submonoid.mem_closure.mpr (Œª y hy, hy (S.mul_mem hr hb))
{ exact Œª r hr b hb, add_submonoid.mem_closure.mpr (Œª y hy, hy (S.mul_mem hr hb)) }
clear ha a
exact Œª b hb, by simp only [zero_mul, (add_submonoid.closure (S : set R)).zero_mem]
{ exact Œª b hb, by simp only [zero_mul, (add_submonoid.closure (S : set R)).zero_mem] }
clear ha a
simp_rw add_mul
{ simp_rw add_mul, exact Œª r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb) }
exact Œª r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)
intros
rw [P.sylow_mem_fixed_points_iff, ‚Üêinf_eq_left, hP.inf_normalizer_sylow, inf_eq_left]
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_right k hp, ‚Üêset.insert_eq_of_mem hp, ‚Üêset.insert_diff_singleton, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
intros
rw sum_centroid_weights_indicator
exact s.sum_centroid_weights_eq_one_of_nonempty k h
intros
let f : set.range p ‚Üí Œπ := Œª x, x.property.some
have hf : ‚àÄ x, p (f x) = x := Œª x, x.property.some_spec
let fe : set.range p ‚Ü™ Œπ := ‚ü®f, Œª x‚ÇÅ x‚ÇÇ he, subtype.ext (hf x‚ÇÅ ‚ñ∏ hf x‚ÇÇ ‚ñ∏ he ‚ñ∏ rfl)‚ü©
convert ha.comp_embedding fe
ext
simp [hf]
intros
simp only [line_map_apply_module]
exact add_lt_add_left (smul_lt_smul_of_pos hb hr) _
intros
simpa [disjoint] using @disjoint_ker _ _ _ _ _ _ _ _ _ _ _ f ‚ä§
intros
{ ext ‚ü®b, hb‚ü©, refl }
ext ‚ü®b, hb‚ü©
refl
intros
{ ext A x y, simp [flip_hom_aux] }
ext A x y
simp [flip_hom_aux]
intros
simp [‚Üê to_matrix_eq_to_matrix']
intros
split
intro h
{ intro h, let t := basis.of_vector_space K V, rw [‚Üê t.mk_eq_dim'', cardinal.le_mk_iff_exists_subset] at h, rcases h with ‚ü®s, hst, hsc‚ü©, exact ‚ü®s, hsc, (of_vector_space_index.linear_independent K V).mono hst‚ü© }
let t := basis.of_vector_space K V
rw [‚Üê t.mk_eq_dim'', cardinal.le_mk_iff_exists_subset] at h
rcases h with ‚ü®s, hst, hsc‚ü©
exact ‚ü®s, hsc, (of_vector_space_index.linear_independent K V).mono hst‚ü©
rintro ‚ü®s, rfl, si‚ü©
{ rintro ‚ü®s, rfl, si‚ü©, exact cardinal_le_dim_of_linear_independent si }
exact cardinal_le_dim_of_linear_independent si
intros
apply le_antisymm
{ exact linear_independent_le_basis b v i, }
exact linear_independent_le_basis b v i
haveI : nontrivial R := nontrivial_of_invariant_basis_number R
{ haveI : nontrivial R := nontrivial_of_invariant_basis_number R, exact infinite_basis_le_maximal_linear_independent b v i m, }
exact infinite_basis_le_maximal_linear_independent b v i m
intros
rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum]
simp_rw [linear_map.map_smul, to_dual_apply, smul_eq_mul, mul_boole, finset.sum_ite_eq]
split_ifs with h
{ refl }
refl
{ rw finsupp.not_mem_support_iff.mp h }
rw finsupp.not_mem_support_iff.mp h
intros
rw [submodule.dual_annihilator_comap, ‚Üê module.eval_equiv_to_linear_map]
exact linear_equiv.finrank_eq (linear_equiv.of_submodule' _ _)
intros
rw [‚Üê S.to_submodule_equiv.dim_eq, h, (linear_equiv.of_eq (‚ä• : subalgebra F E).to_submodule _ algebra.to_submodule_bot).dim_eq, dim_span_set]
exacts [mk_singleton _, linear_independent_singleton one_ne_zero]
intros
have h := dim_eq_of_injective _ hinj
rw [‚Üê finrank_eq_dim, ‚Üê finrank_eq_dim, nat_cast_inj] at h
exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)
intros
intro x
obtain ‚ü®y, hy‚ü© := h x
exact ‚ü®finsupp.single y 1, by simp [hy]‚ü©
intros
by_contra h
refine zero_ne_one (eq_of_fin_equiv R _)
haveI := not_nontrivial_iff_subsingleton.1 h
haveI : subsingleton (fin 1 ‚Üí R) := ‚ü®Œª a b, funext $ Œª x, subsingleton.elim _ _‚ü©
refine { .. }; { intros, exact 0 } <|> tidy
refine { .. }
{ intros, exact 0 }
{ intros, exact 0 }
tidy
intros
rw linear_independent_iff'' at hv ‚ä¢
intros s g hgs hsum i
refine (smul_eq_zero_iff_eq (w i)).1 _
refine hv s (Œª i, w i ‚Ä¢ g i) (Œª i hi, _) _ i
dsimp only
{ dsimp only, exact (hgs i hi).symm ‚ñ∏ smul_zero _ }
exact (hgs i hi).symm ‚ñ∏ smul_zero _
rw [‚Üê hsum, finset.sum_congr rfl _]
{ rw [‚Üê hsum, finset.sum_congr rfl _], intros, erw [pi.smul_apply, smul_assoc, smul_comm] }
intros
erw [pi.smul_apply, smul_assoc, smul_comm]
intros
have h : M.charpoly ‚Ä¢ (1 : matrix n n (polynomial R)) = adjugate (charmatrix M) * (charmatrix M) := (adjugate_mul _).symm
apply_fun mat_poly_equiv at h
simp only [mat_poly_equiv.map_mul, mat_poly_equiv_charmatrix] at h
apply_fun (Œª p, p.eval M) at h
rw eval_mul_X_sub_C at h
rw [mat_poly_equiv_smul_one, eval_map] at h
exact h
intros
convert det_unique _
exact unique_of_subsingleton k
intros
ext i j
convert congr_fun (cramer_row_self (1 : matrix n n Œ±) (pi.single i 1) i _) j
{ simp }
simp
intros j
{ intros j, rw [matrix.one_eq_pi_single, pi.single_comm] }
rw [matrix.one_eq_pi_single, pi.single_comm]
intros
simp only [linear_map.to_matrix', linear_equiv.coe_mk]
congr
ext j'
split_ifs with h
{ rw [h, std_basis_same] }
rw [h, std_basis_same]
apply std_basis_ne _ _ _ _ h
intros
rw [‚Üê linear_map.to_matrix_alg_equiv_id v‚ÇÅ, matrix.to_lin_alg_equiv_to_matrix_alg_equiv]
intros
simp [transvection, matrix.add_mul]
intros
let Q : matrix n n ùïú ‚Üí Prop := Œª N, det N ‚â† 0 ‚àß P N
have : Q M
apply diagonal_transvection_induction Q M
{ apply diagonal_transvection_induction Q M, { assume D hD, have detD : det (diagonal D) ‚â† 0, by { rw hD, exact hMdet }, exact ‚ü®detD, hdiag _ detD‚ü© }, { assume t, exact ‚ü®by simp, htransvec t‚ü© }, { assume A B QA QB, exact ‚ü®by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2‚ü© } }
assume D hD
{ assume D hD, have detD : det (diagonal D) ‚â† 0, by { rw hD, exact hMdet }, exact ‚ü®detD, hdiag _ detD‚ü© }
have detD : det (diagonal D) ‚â† 0
rw hD
rw hD
{ rw hD, exact hMdet }
{ rw hD, exact hMdet }
exact hMdet
exact hMdet
exact ‚ü®detD, hdiag _ detD‚ü©
assume t
{ assume t, exact ‚ü®by simp, htransvec t‚ü© }
exact ‚ü®by simp, htransvec t‚ü©
assume A B QA QB
{ assume A B QA QB, exact ‚ü®by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2‚ü© }
exact ‚ü®by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2‚ü©
exact this.2
intros
ext
ext; refl
refl
intros
ext
ext; simp only [prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
simp only [prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
simp only [prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
intros
tidy
intros
ext x
simp only [comp_apply, mem_ker, subtype_apply, sub_apply, id_apply, sub_eq_zero]
exact ‚ü®Œª h, h.symm ‚ñ∏ submodule.coe_mem _, Œª hx, by erw [hf ‚ü®x, hx‚ü©, subtype.coe_mk]‚ü©
intros
ext b
ext b; simp [std_basis_ne R œÜ _ _ h]
simp [std_basis_ne R œÜ _ _ h]
intros
rw [‚Üê lift_mk_compr‚ÇÇ g, H, lift_mk_compr‚ÇÇ]
intros
simp only [‚Üê coe_rtensor_hom, map_neg]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
subst eq; exact h
subst eq
exact h
intros
rw [‚Üê iterate_succ', nat.succ_pred_eq_of_pos hn]
intros
simp_rw [nnreal.tsum_eq_to_nnreal_tsum]
exact (measurable.ennreal_tsum (Œª i, (h i).coe_nnreal_ennreal)).ennreal_to_nnreal
intros
apply measurable_of_Ioi
simp_rw [‚Üê compl_Iic, preimage_compl, measurable_set.compl_iff]
assumption
intros
obtain ‚ü®t, hst, mt, ht‚ü© := exists_measurable_superset_of_null h
simp_rw [measure_prod_null mt] at ht
rw [eventually_le_antisymm_iff]
exact ‚ü®eventually_le.trans_eq (eventually_of_forall $ Œª x, (measure_mono (preimage_mono hst) : _)) ht, eventually_of_forall $ Œª x, zero_le _‚ü©
intros
rw ‚Üê prod_swap at hf
rw [‚Üê integral_map measurable_swap hf, prod_swap]
intros
simp [total_variation, to_jordan_decomposition_neg, add_comm]
intros
refine ae_eq_zero_of_forall_dual ‚Ñù (Œª c, _)
refine ae_eq_zero_restrict_of_forall_set_integral_eq_zero_real _ _ ht hŒºt
assume s hs hŒºs
{ assume s hs hŒºs, exact continuous_linear_map.integrable_comp c (hf_int_finite s hs hŒºs) }
exact continuous_linear_map.integrable_comp c (hf_int_finite s hs hŒºs)
assume s hs hŒºs
{ assume s hs hŒºs, rw [continuous_linear_map.integral_comp_comm c (hf_int_finite s hs hŒºs), hf_zero s hs hŒºs], exact continuous_linear_map.map_zero _ }
rw [continuous_linear_map.integral_comp_comm c (hf_int_finite s hs hŒºs), hf_zero s hs hŒºs]
exact continuous_linear_map.map_zero _
intros
ext1
have hŒºst := ((measure_union_le s t).trans_lt (lt_top_iff_ne_top.mpr (ennreal.add_ne_top.mpr ‚ü®hŒºs, hŒºt‚ü©))).ne
refine (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm (hs.union ht) hŒºst x).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
have hs_eq := condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hŒºs x
have ht_eq := condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm ht hŒºt x
refine eventually_eq.trans _ (eventually_eq.add hs_eq.symm ht_eq.symm)
rw condexp_ind_smul
rw indicator_const_Lp_disjoint_union hs ht hŒºs hŒºt hst (1 : ‚Ñù)
rw (condexp_L2 ‚Ñù hm).map_add
push_cast
rw ((to_span_singleton ‚Ñù x).comp_LpL 2 Œº).map_add
refine (Lp.coe_fn_add _ _).trans _
refine eventually_of_forall (Œª y, _)
refl
intros
refine is_finite_measure_with_density ((lintegral_mono $ Œª x, _).trans_lt hfi).ne
exact real.of_real_le_ennnorm (f x)
intros
refine ‚ü®measurable.ae_measurable hf, _‚ü©
rw [has_finite_integral, lintegral_trim hm _]
{ exact hf_int.2, }
exact hf_int.2
exact @measurable.coe_nnreal_ennreal Œ± m _ (@measurable.nnnorm _ Œ± _ _ _ m _ hf)
{ exact @measurable.coe_nnreal_ennreal Œ± m _ (@measurable.nnnorm _ Œ± _ _ _ m _ hf), }
intros
simp [snorm]
intros
refine (at_top_basis.tendsto_iff nhds_basis_eball).2 (Œª Œµ hŒµ, _)
rcases emetric.mem_closure_iff.1 hx Œµ hŒµ with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©
rw [edist_comm] at hN
exact ‚ü®N, trivial, Œª n hn, (edist_nearest_pt_le e x hn).trans_lt hN‚ü©
intros
simpa only [‚Üê pi.list_prod_apply] using l.ae_measurable_prod' hl
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [set_lintegral_const, one_mul]
intros
simp_rw [mul_comm, lintegral_const_mul_le r f]
intros
rw [set.union_eq_Union, lintegral_Union, tsum_bool, add_comm]
simp only [to_bool_false_eq_ff, to_bool_true_eq_tt, cond]
{ simp only [to_bool_false_eq_ff, to_bool_true_eq_tt, cond] }
{ intros i, exact measurable_set.cond hA hB }
intros i
exact measurable_set.cond hA hB
{ rwa pairwise_disjoint_on_bool }
rwa pairwise_disjoint_on_bool
intros
rw [const_lintegral, measure.restrict_apply measurable_set.univ, univ_inter]
intros
simp_rw fun_mul_inv_snorm_rpow hp0_lt
rw [lintegral_mul_const'' _ (hf.pow_const p), mul_inv_cancel hf_nonzero hf_top]
intros
assume s hs
convert measurable_set.empty
exact eq_empty_of_is_empty _
intros
rwa ‚Üê h
intros
have := chaar_mem_haar_product K‚ÇÄ K (mem_univ _)
{ have := chaar_mem_haar_product K‚ÇÄ K (mem_univ _), rw mem_Icc at this, exact this.1 }
rw mem_Icc at this
exact this.1
intros
haveI : ‚àÄ n, encodable (Œπ n)
from Œª n, fintype.encodable _
simpa only [tsum_fintype] using mk_metric_le_liminf_tsum s r hr t ht hst m
intros
rw [measure_eq_extend (measurable_set.Union h), extend_Union measurable_set.empty _ measurable_set.Union _ hn h]
{ simp [measure_eq_extend, h] }
simp [measure_eq_extend, h]
{ exact Œº.empty }
exact Œº.empty
{ exact Œº.m_Union }
exact Œº.m_Union
intros
by_cases h : measurable f
change range f ‚àà (map f Œº).ae
{ change range f ‚àà (map f Œº).ae, rw mem_ae_map_iff h hf, apply eventually_of_forall, exact mem_range_self }
rw mem_ae_map_iff h hf
apply eventually_of_forall
exact mem_range_self
{ simp [map_of_not_measurable h] }
simp [map_of_not_measurable h]
intros
have := ennreal.lt_add_right hs hŒµ
conv at this {to_lhs, rw induced_outer_measure_eq_infi _ msU m_mono }
simp only [infi_lt_iff] at this
rcases this with ‚ü®t, h1t, h2t, h3t‚ü©
exact ‚ü®t, h1t, h2t, le_trans (le_of_eq $ induced_outer_measure_eq' _ msU m_mono h1t) (le_of_lt h3t)‚ü©
intros
simp only [smul_apply, dirac_apply, ‚Üê indicator_mul_right _ (Œª _, a), mul_one]
intros
simp [is_caratheodory, m.empty, diff_empty]
intros
apply ge_of_tendsto (f.tendsto_left_lim y)
apply mem_nhds_within_Iio_iff_exists_Ioo_subset.2 ‚ü®x, h, _‚ü©
assume z hz
exact f.mono hz.1.le
intros
intros j hj‚ÇÅ
rw [restrict_apply _ hi hj‚ÇÅ, restrict_apply _ hi hj‚ÇÅ, neg_apply, neg_apply]
refine neg_le_neg _
rw [‚Üê restrict_apply _ hi hj‚ÇÅ, ‚Üê restrict_apply _ hi hj‚ÇÅ]
exact h j hj‚ÇÅ
intros
refine ‚ü®_, generate_has.compl‚ü©
{ refine ‚ü®_, generate_has.compl‚ü©, intro h, convert generate_has.compl h, simp }
intro h
convert generate_has.compl h
simp
intros
refine nnreal.summable_of_le (assume a, _) p.summable_coe
suffices : p a * f a b ‚â§ p a * 1
simpa
{ simpa }
exact mul_le_mul_of_nonneg_left ((f a).coe_le_one _) (p a).2
intros
cases n
{ simp }
simp
rw [divisors_eq_proper_divisors_insert_self_of_pos (nat.succ_pos _)]
apply subset_insert
intros
rw [sq, sq]
exact (is_coprime.mul_left h2 h2).mul_add_left_left r
intros
{ ext; { dsimp, ring }, }
ext
ext; { dsimp, ring }
{ dsimp, ring }
dsimp
{ dsimp, ring }
ring
intros
by_cases b_split : (b = 0)
{ simp [b_split], }
simp [b_split]
have split_frac : padic_val_rat p (b / p) = padic_val_rat p b - padic_val_rat p p := padic_val_rat.div p (nat.cast_ne_zero.mpr b_split) (nat.cast_ne_zero.mpr (nat.prime.ne_zero p_prime.1))
{ have split_frac : padic_val_rat p (b / p) = padic_val_rat p b - padic_val_rat p p := padic_val_rat.div p (nat.cast_ne_zero.mpr b_split) (nat.cast_ne_zero.mpr (nat.prime.ne_zero p_prime.1)), rw padic_val_rat.padic_val_rat_self (nat.prime.one_lt p_prime.1) at split_frac, have r : 1 ‚â§ padic_val_nat p b := one_le_padic_val_nat_of_dvd b_split dvd, exact_mod_cast split_frac, }
rw padic_val_rat.padic_val_rat_self (nat.prime.one_lt p_prime.1) at split_frac
have r : 1 ‚â§ padic_val_nat p b := one_le_padic_val_nat_of_dvd b_split dvd
exact_mod_cast split_frac
intros
simp [cast_eq_of_rat]
intros
obtain ‚ü®l, m, n, ‚ü®‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, co‚ü©‚ü© := hc
use [k * l, m, n]
{ use [k * l, m, n], apply and.intro _ co, left, split; ring }
apply and.intro _ co
left
split
split; ring
ring
ring
use [k * l, m, n]
{ use [k * l, m, n], apply and.intro _ co, right, split; ring }
apply and.intro _ co
right
split
split; ring
ring
ring
intros
refine ‚ü®Œª ha, ext.mpr _, Œª h, by rw [h, norm_zero]‚ü©
delta norm at ha
rw sub_eq_zero at ha
by_cases h : 0 ‚â§ d
obtain ‚ü®d', rfl‚ü© := int.eq_coe_of_zero_le h
{ obtain ‚ü®d', rfl‚ü© := int.eq_coe_of_zero_le h, haveI : nonsquare d' := ‚ü®Œª n h, h_nonsquare n $ by exact_mod_cast h‚ü©, exact divides_sq_eq_zero_z ha, }
haveI : nonsquare d' := ‚ü®Œª n h, h_nonsquare n $ by exact_mod_cast h‚ü©
exact divides_sq_eq_zero_z ha
push_neg at h
{ push_neg at h, suffices : a.re * a.re = 0, { rw eq_zero_of_mul_self_eq_zero this at ha ‚ä¢, simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero, h.ne, false_or, or_self] using ha }, apply _root_.le_antisymm _ (mul_self_nonneg _), rw [ha, mul_assoc], exact mul_nonpos_of_nonpos_of_nonneg h.le (mul_self_nonneg _) }
suffices : a.re * a.re = 0
rw eq_zero_of_mul_self_eq_zero this at ha ‚ä¢
{ rw eq_zero_of_mul_self_eq_zero this at ha ‚ä¢, simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero, h.ne, false_or, or_self] using ha }
simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero, h.ne, false_or, or_self] using ha
apply _root_.le_antisymm _ (mul_self_nonneg _)
rw [ha, mul_assoc]
exact mul_nonpos_of_nonpos_of_nonneg h.le (mul_self_nonneg _)
intros
rw [is_lub_preimage, f.apply_symm_apply]
intros
simpa only [disjoint.comm] using @supr_disjoint_iff _ _ _ a f
intros
simp
intros
{ contrapose! h, exact cSup_le' h }
contrapose! h
exact cSup_le' h
intros
have : ‚àÄ·∂† x in at_top, a ‚â§ x ‚àß b ‚â§ u x := (eventually_ge_at_top a).and (h.eventually $ eventually_ge_at_top b)
haveI : nonempty Œ± := ‚ü®a‚ü©
rcases this.exists with ‚ü®a', ha, hb‚ü©
exact ‚ü®a', ha, hb‚ü©
intros
{ rw ‚Üê prod_at_top_at_top_eq, exact hf.prod_map hg, }
rw ‚Üê prod_at_top_at_top_eq
exact hf.prod_map hg
intros
rw [inter_comm, inter_eventually_eq_left]
intros
simp only [filter_eq_bot_of_is_empty la, tendsto_bot]
intros
simp only [le_principal_iff, iff_self, mem_principal]
intros
simpa using infi_principal_finset finset.univ f
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
rw [prod_def, lift_lift'_assoc]
apply congr_arg
funext x
rw [lift'_lift'_assoc]
exact hg‚ÇÇ
exact set.monotone_prod monotone_const monotone_id
exact hg‚ÇÅ
exact (monotone_lift' monotone_const $ monotone_lam $ assume x, set.monotone_prod monotone_id monotone_const)
intros
cases n
{ cases n, exacts [h‚ÇÄ, hf.seq_pos_lt_seq_of_lt_of_le n.zero_lt_succ h‚ÇÄ.le hx hy] }
exacts [h‚ÇÄ, hf.seq_pos_lt_seq_of_lt_of_le n.zero_lt_succ h‚ÇÄ.le hx hy]
intros
refine le_antisymm (g.to_galois_connection.l_limsup_le hgu hu_co) _
rw [‚Üê(g.symm.symm_apply_apply (f.limsup (Œª (x : Œ±), g (u x)))), g.symm_symm]
refine g.monotone _
have hf : u = Œª i, g.symm (g (u i))
from funext (Œª i, (g.symm_apply_apply (u i)).symm)
nth_rewrite 0 hf
refine g.symm.to_galois_connection.l_limsup_le _ hgu_co
simp_rw g.symm_apply_apply
exact hu
intros
exactI {..f.is_partial_order, ..f.is_total}
intros
rw [well_founded_on_iff, rel_embedding.well_founded_iff_no_descending_seq]
refine ‚ü®Œª h f con, begin refine h.elim' ‚ü®‚ü®f, f.injective‚ü©, Œª a b, _‚ü©, simp only [con (mem_range_self a), con (mem_range_self b), and_true, gt_iff_lt, function.embedding.coe_fn_mk, f.map_rel_iff] end, Œª h, ‚ü®Œª con, _‚ü©‚ü©
rcases con with ‚ü®f, hf‚ü©
have hfs' : ‚àÄ n : ‚Ñï, f n ‚àà s := Œª n, (hf.2 n.lt_succ_self).2.2
refine h ‚ü®f, Œª a b, _‚ü© (Œª n hn, _)
rw ‚Üê hf
{ rw ‚Üê hf, exact ‚ü®Œª h, ‚ü®h, hfs' _, hfs' _‚ü©, Œª h, h.1‚ü© }
exact ‚ü®Œª h, ‚ü®h, hfs' _, hfs' _‚ü©, Œª h, h.1‚ü©
rcases set.mem_range.1 hn with ‚ü®m, hm‚ü©
{ rcases set.mem_range.1 hn with ‚ü®m, hm‚ü©, rw ‚Üê hm, apply hfs' }
rw ‚Üê hm
apply hfs'
intros
rw [adjoin_eq_span, span_le]
intros
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R); split; apply_instance
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R); split
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R)
haveI := subsingleton_of_zero_eq_one h01
haveI := fintype.of_subsingleton (0:R)
split
intros
{ rw add_comm at h, exact h.of_add_mul_right_left }
rw add_comm at h
exact h.of_add_mul_right_left
intros
suffices : of' R M '' (‚ãÉ f ‚àà S, (f.support : set M)) = ‚ãÉ f ‚àà S, (of' R M '' (f.support : set M))
rw this
{ rw this, exact support_gen_of_gen hS }
exact support_gen_of_gen hS
simp only [set.image_Union]
intros
intros g hg
contrapose! hg
rw [mem_support, emb_domain_notin_image_support hg, not_not]
intros
rw [lt_iff_le_not_le, span_singleton_le_span_singleton, span_singleton_le_span_singleton, dvd_and_not_dvd_iff]
intros
cases nat.exists_eq_add_of_le h with k hk
rw [hk, pow_add]
exact le_trans (mul_le_inf) (inf_le_left)
intros
split
rw ideal_prod_eq I
{ rw ideal_prod_eq I, introsI hI, rcases ideal_prod_prime_aux hI with (h|h), { right, rw h at hI ‚ä¢, exact ‚ü®_, ‚ü®is_prime_of_is_prime_prod_top' hI, rfl‚ü©‚ü© }, { left, rw h at hI ‚ä¢, exact ‚ü®_, ‚ü®is_prime_of_is_prime_prod_top hI, rfl‚ü©‚ü© } }
introsI hI
rcases ideal_prod_prime_aux hI with (h|h)
right
{ right, rw h at hI ‚ä¢, exact ‚ü®_, ‚ü®is_prime_of_is_prime_prod_top' hI, rfl‚ü©‚ü© }
rw h at hI ‚ä¢
exact ‚ü®_, ‚ü®is_prime_of_is_prime_prod_top' hI, rfl‚ü©‚ü©
left
{ left, rw h at hI ‚ä¢, exact ‚ü®_, ‚ü®is_prime_of_is_prime_prod_top hI, rfl‚ü©‚ü© }
rw h at hI ‚ä¢
exact ‚ü®_, ‚ü®is_prime_of_is_prime_prod_top hI, rfl‚ü©‚ü©
rintro (‚ü®p, ‚ü®h, rfl‚ü©‚ü©|‚ü®p, ‚ü®h, rfl‚ü©‚ü©)
{ rintro (‚ü®p, ‚ü®h, rfl‚ü©‚ü©|‚ü®p, ‚ü®h, rfl‚ü©‚ü©), { exactI is_prime_ideal_prod_top }, { exactI is_prime_ideal_prod_top' } }
{ exactI is_prime_ideal_prod_top }
exactI is_prime_ideal_prod_top
{ exactI is_prime_ideal_prod_top' }
exactI is_prime_ideal_prod_top'
intros
generalize hS : (‚Üë(p.map $ algebra_map A B).frange : set B) = S
have coeffs_mem : ‚àÄ i, (p.map $ algebra_map A B).coeff i ‚àà adjoin R S
intro i
{ intro i, by_cases hi : (p.map $ algebra_map A B).coeff i = 0, { rw hi, exact subalgebra.zero_mem _ }, rw ‚Üê hS, exact subset_adjoin (coeff_mem_frange _ _ hi) }
by_cases hi : (p.map $ algebra_map A B).coeff i = 0
{ rw hi, exact subalgebra.zero_mem _ }
rw hi
exact subalgebra.zero_mem _
rw ‚Üê hS
exact subset_adjoin (coeff_mem_frange _ _ hi)
obtain ‚ü®q, hq‚ü© : ‚àÉ q : polynomial (adjoin R S), q.map (algebra_map (adjoin R S) B) = (p.map $ algebra_map A B)
rw ‚Üê set.mem_range
{ rw ‚Üê set.mem_range, exact (polynomial.mem_map_range _).2 (Œª i, ‚ü®‚ü®_, coeffs_mem i‚ü©, rfl‚ü©) }
exact (polynomial.mem_map_range _).2 (Œª i, ‚ü®‚ü®_, coeffs_mem i‚ü©, rfl‚ü©)
use q
split
suffices h : (q.map (algebra_map (adjoin R S) B)).monic
{ suffices h : (q.map (algebra_map (adjoin R S) B)).monic, { refine monic_of_injective _ h, exact subtype.val_injective }, { rw hq, exact monic_map _ pmonic } }
refine monic_of_injective _ h
{ refine monic_of_injective _ h, exact subtype.val_injective }
exact subtype.val_injective
{ rw hq, exact monic_map _ pmonic }
rw hq
exact monic_map _ pmonic
convert hp using 1
{ convert hp using 1, replace hq := congr_arg (eval x) hq, convert hq using 1; symmetry; apply eval_map }
replace hq := congr_arg (eval x) hq
convert hq using 1; symmetry; apply eval_map
convert hq using 1; symmetry
convert hq using 1
symmetry
apply eval_map
symmetry
apply eval_map
intros
apply le_antisymm
apply enat.le_of_lt_add_one
{ apply enat.le_of_lt_add_one, cases enat.ne_top_iff.mp (enat.ne_top_of_lt h) with k hk, rw [hk], rw_mod_cast [multiplicity_lt_iff_neg_dvd], intro h_dvd, rw [‚Üê dvd_add_iff_right] at h_dvd, apply multiplicity.is_greatest _ h_dvd, rw [hk], apply_mod_cast nat.lt_succ_self, rw [pow_dvd_iff_le_multiplicity, nat.cast_add, ‚Üê hk, nat.cast_one], exact enat.add_one_le_of_lt h }
cases enat.ne_top_iff.mp (enat.ne_top_of_lt h) with k hk
rw [hk]
rw_mod_cast [multiplicity_lt_iff_neg_dvd]
intro h_dvd
rw [‚Üê dvd_add_iff_right] at h_dvd
apply multiplicity.is_greatest _ h_dvd
rw [hk]
apply_mod_cast nat.lt_succ_self
rw [pow_dvd_iff_le_multiplicity, nat.cast_add, ‚Üê hk, nat.cast_one]
exact enat.add_one_le_of_lt h
convert min_le_multiplicity_add
{ convert min_le_multiplicity_add, rw [min_eq_right (le_of_lt h)] }
rw [min_eq_right (le_of_lt h)]
intros
obtain ‚ü®n, hn‚ü© := h
use n
rw [h_comm.mul_pow, hn, zero_mul]
intros
simp [nat_degree]
intros
obtain ‚ü®n, rfl‚ü© := nat.exists_eq_add_of_le h
rw add_comm
exact T_add_two R n
intros
{ rw cyclotomic', exact roots_prod_X_sub_C (primitive_roots n R) }
rw cyclotomic'
exact roots_prod_X_sub_C (primitive_roots n R)
intros
rw [homogeneous_component_apply, sum_eq_zero]
intros d hd
rw mem_filter at hd
exfalso
exact h _ hd.1 hd.2
intros
intro h
have : p.coeff p.nat_degree ‚â† 0 := mt leading_coeff_eq_zero.mp hp
have : (scale_roots p s).coeff p.nat_degree = 0 := congr_fun (congr_arg (coeff : polynomial R ‚Üí ‚Ñï ‚Üí R) h) p.nat_degree
rw [coeff_scale_roots_nat_degree] at this
contradiction
intros
ext m i j
simp only [coeff_map, one_apply, algebra_map_matrix_apply, mul_boole, pi.smul_apply, mat_poly_equiv_coeff_apply]
split_ifs; simp
split_ifs
simp
simp
intros
simp
intros
simpa using coeff_add_mul_monomial n 0 œÜ a
intros
induction k with k h
simp only [rescale_zero, constant_coeff_exp, function.comp_app, map_one, cast_zero, pow_zero, coe_comp]
{ simp only [rescale_zero, constant_coeff_exp, function.comp_app, map_one, cast_zero, pow_zero, coe_comp], }
simpa only [succ_eq_add_one, cast_add, ‚Üêexp_mul_exp_eq_exp_add (k : A), ‚Üêh, cast_one, id_apply, rescale_one] using pow_succ' (exp A) k
intros
rw [primitive_roots, mem_filter, multiset.mem_to_finset, mem_nth_roots h0, and_iff_right_iff_imp]
exact is_primitive_root.pow_eq_one
intros
ext1 n
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
rw ‚Üê function.funext_iff at h
replace h := congr_arg (Œª fam, bind‚ÇÅ (mv_polynomial.map (int.cast_ring_hom ‚Ñö) ‚àò fam) (X_in_terms_of_W p ‚Ñö n)) h
simpa only [function.comp, map_bind‚ÇÅ, map_witt_polynomial, ‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_witt_polynomial_X_in_terms_of_W, bind‚ÇÅ_X_right] using h
intros
{ rw [add_comm, add_eq_left hb ha] }
rw [add_comm, add_eq_left hb ha]
intros
simp only [quot_mul_comm, quot_left_distrib]
intros
simp only [Inf, conditionally_complete_lattice.Inf, omin, conditionally_complete_linear_order.Inf, conditionally_complete_linear_order_bot.Inf, hs, dif_pos]
congr
rw subtype.range_val
intros
induction n; [refl, simp only [card_add, card_one, nat.cast_succ, *]]
induction n
refl
simp only [card_add, card_one, nat.cast_succ, *]
intros
rw [lift_card, ‚Üêtype_subrel_lt, card_type]
intros
cases o
cases o; refl
refl
refl
intros
rw [le_def_lt]
conv { to_lhs, simp only [lt_def_le] }
intros
rw [‚Üêh3, mul_assoc, mul_div_comm, h2, ‚Üêmul_assoc, h1, mul_comm, one_mul]
intros
simpa [eq.symm h1, eq.symm h2, int.coe_nat_le]
intros
rwa h‚ÇÅ
intros
{ ext, simp }
ext
simp
intros
simpa only [set.indicator_range_comp] using (hi.summable_iff _).2 (hf.indicator (set.range i))
exact Œª x hx, set.indicator_of_not_mem hx _
intros
rw [tsum_fintype, finset.sum_eq_add]; simp
{ rw [tsum_fintype, finset.sum_eq_add]; simp }
rw [tsum_fintype, finset.sum_eq_add]
simp
simp
simp
simp
intros
{ intros f g H, cases f, cases g, congr' }
intros f g H
cases f
cases g
congr'
intros
rcases exists_open_nhds_one_split hU with ‚ü®V, Vo, V1, hV‚ü©
use [V, Vo, V1]
rintros _ ‚ü®x, y, hx, hy, rfl‚ü©
exact hV _ hx _ hy
intros
simp only [div_eq_mul_inv]
{ simp only [div_eq_mul_inv], exact mul_zero a ‚ñ∏ h.mul (tendsto_inv_at_top_zero.comp hg) }
exact mul_zero a ‚ñ∏ h.mul (tendsto_inv_at_top_zero.comp hg)
intros
simp [nhds_eq_order (‚ä§:Œ±)]
intros
{ rw [dense_range, range_comp], exact hg.dense_image cg hf }
rw [dense_range, range_comp]
exact hg.dense_image cg hf
intros
rw [hs.frontier_eq, inter_diff_self]
intros
simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, set.nonempty_inter_iff_exists_right]
intros
ext
rw mem_closure_iff_ultrafilter
split
rintro ‚ü®F, h1, h2‚ü©
{ rintro ‚ü®F, h1, h2‚ü©, exact ‚ü®F, h1, le_nhds_of_str_eq _ _ h2‚ü© }
exact ‚ü®F, h1, le_nhds_of_str_eq _ _ h2‚ü©
rintro ‚ü®F, h1, h2‚ü©
{ rintro ‚ü®F, h1, h2‚ü©, exact ‚ü®F, h1, str_eq_of_le_nhds _ _ h2‚ü© }
exact ‚ü®F, h1, str_eq_of_le_nhds _ _ h2‚ü©
intros
simp
intros
rw algebra.eq_top_iff
let I : C(X, ‚Ñù) ‚Üí‚Çó[‚Ñù] C(X, ‚ÑÇ) := of_real_clm.comp_left_continuous ‚Ñù X
have key : I.range ‚â§ (A.to_submodule.restrict_scalars ‚Ñù).topological_closure
let A‚ÇÄ : submodule ‚Ñù C(X, ‚Ñù) := (A.to_submodule.restrict_scalars ‚Ñù).comap I
{ let A‚ÇÄ : submodule ‚Ñù C(X, ‚Ñù) := (A.to_submodule.restrict_scalars ‚Ñù).comap I, have SW : A‚ÇÄ.topological_closure = ‚ä§, { have := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.complex_to_real hA'), exact congr_arg subalgebra.to_submodule this }, rw [‚Üê submodule.map_top, ‚Üê SW], have h‚ÇÅ := A‚ÇÄ.topological_closure_map (of_real_clm.comp_left_continuous_compact X), have h‚ÇÇ := (A.to_submodule.restrict_scalars ‚Ñù).map_comap_le I, exact h‚ÇÅ.trans (submodule.topological_closure_mono h‚ÇÇ) }
have SW : A‚ÇÄ.topological_closure = ‚ä§
have := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.complex_to_real hA')
{ have := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.complex_to_real hA'), exact congr_arg subalgebra.to_submodule this }
exact congr_arg subalgebra.to_submodule this
rw [‚Üê submodule.map_top, ‚Üê SW]
have h‚ÇÅ := A‚ÇÄ.topological_closure_map (of_real_clm.comp_left_continuous_compact X)
have h‚ÇÇ := (A.to_submodule.restrict_scalars ‚Ñù).map_comap_le I
exact h‚ÇÅ.trans (submodule.topological_closure_mono h‚ÇÇ)
intros f
let f_re : C(X, ‚Ñù) := (‚ü®complex.re, complex.re_clm.continuous‚ü© : C(‚ÑÇ, ‚Ñù)).comp f
let f_im : C(X, ‚Ñù) := (‚ü®complex.im, complex.im_clm.continuous‚ü© : C(‚ÑÇ, ‚Ñù)).comp f
have h_f_re : I f_re ‚àà A.topological_closure := key ‚ü®f_re, rfl‚ü©
have h_f_im : I f_im ‚àà A.topological_closure := key ‚ü®f_im, rfl‚ü©
convert A.topological_closure.add_mem h_f_re (A.topological_closure.smul_mem h_f_im complex.I)
ext
ext; simp [I]
simp [I]
simp [I]
intros
simpa [nhds_within] using nhds_within_pi_eq finite_univ s x
intros
rw [‚Üê image_univ]
exact (hf.restrict is_open_univ).continuous_on_image_of_left_inv_on (Œª x _, hleft x)
intros
rw [e.source_eq, mem_preimage]
intros
{ erw [mem_prod], simp only [and_true, mem_univ] }
erw [mem_prod]
simp only [and_true, mem_univ]
intros
rw ‚Üênat.cofinite_eq_at_top
{ rw ‚Üênat.cofinite_eq_at_top, exact tendsto_cofinite_zero_of_tsum_ne_top hf }
exact tendsto_cofinite_zero_of_tsum_ne_top hf
intros
cases e; cases e'; refl
cases e; cases e'
cases e
cases e'
refl
intros
simp only [set.ext_iff, mem_singleton_iff, mem_preimage] at h
ext1 x
have := h x
set a := f x
set b := g x
fin_cases a; fin_cases b; finish
fin_cases a; fin_cases b
fin_cases a
fin_cases b
finish
finish
fin_cases b
finish
finish
intros
rw [edist_nndist, ennreal.coe_le_coe]
intros
rw [‚Üê nhds_within_univ b, tendsto_nhds_within_nhds_within]
{ rw [‚Üê nhds_within_univ b, tendsto_nhds_within_nhds_within], simp only [mem_univ, true_and] }
simp only [mem_univ, true_and]
intros
refine continuous_of_le_add_edist 2 (by simp) _
rintros ‚ü®x, s‚ü© ‚ü®y, t‚ü©
calc inf_edist x (s.val) ‚â§ inf_edist x (t.val) + Hausdorff_edist (t.val) (s.val) : inf_edist_le_inf_edist_add_Hausdorff_edist ... ‚â§ (inf_edist y (t.val) + edist x y) + Hausdorff_edist (t.val) (s.val) : add_le_add_right inf_edist_le_inf_edist_add_edist _ ... = inf_edist y (t.val) + (edist x y + Hausdorff_edist (s.val) (t.val)) : by simp [add_comm, add_left_comm, Hausdorff_edist_comm, -subtype.val_eq_coe] ... ‚â§ inf_edist y (t.val) + (edist (x, s) (y, t) + edist (x, s) (y, t)) : add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _ ... = inf_edist y (t.val) + 2 * edist (x, s) (y, t) : by rw [‚Üê mul_two, mul_comm]
intros
refine ‚ü®Œª H Œµ hŒµ, H _ (edist_mem_uniformity hŒµ), Œª H u hu, _‚ü©
rcases mem_uniformity_edist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©
exact (H Œµ Œµpos).mono (Œª n hs x hx, hŒµ (hs x hx))
intros
refine Hausdorff_edist_le_of_inf_edist _ _
assume x xs
{ assume x xs, rcases H1 x xs with ‚ü®y, yt, hy‚ü©, exact le_trans (inf_edist_le_edist_of_mem yt) hy }
rcases H1 x xs with ‚ü®y, yt, hy‚ü©
exact le_trans (inf_edist_le_edist_of_mem yt) hy
assume x xt
{ assume x xt, rcases H2 x xt with ‚ü®y, ys, hy‚ü©, exact le_trans (inf_edist_le_edist_of_mem ys) hy }
rcases H2 x xt with ‚ü®y, ys, hy‚ü©
exact le_trans (inf_edist_le_edist_of_mem ys) hy
intros
apply Hausdorff_dist_le_of_inf_dist hr
assume x xs
{ assume x xs, rcases H1 x xs with ‚ü®y, yt, hy‚ü©, exact le_trans (inf_dist_le_dist_of_mem yt) hy }
rcases H1 x xs with ‚ü®y, yt, hy‚ü©
exact le_trans (inf_dist_le_dist_of_mem yt) hy
assume x xt
{ assume x xt, rcases H2 x xt with ‚ü®y, ys, hy‚ü©, exact le_trans (inf_dist_le_dist_of_mem ys) hy }
rcases H2 x xt with ‚ü®y, ys, hy‚ü©
exact le_trans (inf_dist_le_dist_of_mem ys) hy
intros
rw continuous_def at h‚ÇÇ ‚ä¢
assume s h
exact h‚ÇÅ _ (h‚ÇÇ s h)
intros
{ ext, refl }
ext
refl
intros
rcases h.exists_path_through_family p hp with ‚ü®Œ≥, hŒ≥‚ü©
rcases hŒ≥ with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
simp only [range, mem_set_of_eq] at h‚ÇÇ
rw range_subset_iff at h‚ÇÅ
choose! t ht using h‚ÇÇ
exact ‚ü®Œ≥, t, h‚ÇÅ, ht‚ü©
intros
refine ‚ü®assume s t hs ht st, _‚ü©
simp only [disjoint_iff]
exact compact_compact_separated hs.is_compact ht.is_compact st.eq_bot
intros
{ rw [nhds_eq_comap_uniformity], exact h.comap (prod.mk x) }
rw [nhds_eq_comap_uniformity]
exact h.comap (prod.mk x)
intros
simpa only [cauchy_seq_iff_tendsto]
intros
split
split ; rintro ‚ü®c‚ü©
rintro ‚ü®c‚ü©
have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c
{ have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c, obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ is_open_univ trivial, exact ‚ü®a‚ü© }
obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ is_open_univ trivial
exact ‚ü®a‚ü©
rintro ‚ü®c‚ü©
{ exact ‚ü®pure_cauchy c‚ü© }
exact ‚ü®pure_cauchy c‚ü©
intros
induction n with n ihn generalizing c
exact indicator_apply_le' (Œª _, le_rfl) (Œª _, zero_le_one)
{ exact indicator_apply_le' (Œª _, le_rfl) (Œª _, zero_le_one) }
simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv, smul_eq_mul, ‚Üê div_eq_inv_mul]
{ simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv, smul_eq_mul, ‚Üê div_eq_inv_mul], refine iff.mpr (div_le_one zero_lt_two) (add_le_add _ _); apply ihn }
refine iff.mpr (div_le_one zero_lt_two) (add_le_add _ _)
refine iff.mpr (div_le_one zero_lt_two) (add_le_add _ _); apply ihn
apply ihn
apply ihn
intros
cases b; simp
cases b
simp
simp
intros
rw [‚Üê int.neg_neg a, ‚Üê int.neg_neg b, h]
intros
rw [int.add_assoc, int.add_left_neg, int.add_zero]
intros
have h := int.neg_le_neg h
rwa int.neg_neg at h
intros
have h := int.add_lt_add_right h (-b)
rwa int.add_neg_cancel_right at h
intros
rw [nat.mul_comm, mul_mod_right]
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
simp
intros
{ ext, refl }
ext
refl
intros
haveI : subsingleton (B ‚âÉ‚Çê[R] A) := alg_equiv.subsingleton_left
exact ‚ü®Œª f g, eq.trans (alg_equiv.symm_symm _).symm (by rw [subsingleton.elim f.symm g.symm, alg_equiv.symm_symm])‚ü©
intros
rw [prime, _root_.prime, forall_associated]
transitivity
apply and_congr
{ apply and_congr, refl, apply and_congr, refl, apply forall_congr, assume a, exact forall_associated }
refl
apply and_congr
refl
apply forall_congr
assume a
exact forall_associated
apply and_congr
{ rw [(‚â†), mk_eq_zero] }
rw [(‚â†), mk_eq_zero]
apply and_congr
{ rw [is_unit_mk], }
rw [is_unit_mk]
apply forall_congr
assume a
apply forall_congr
assume b
rw [mk_mul_mk, mk_dvd_mk, mk_dvd_mk, mk_dvd_mk]
intros
rw [range_zero, prod_empty]
intros
rw [‚Üê mem_mul_support, finprod_eq_mul_indicator_apply, mul_indicator_mul_support]
intros
rw [‚Üê finprod_mem_range, subtype.range_coe]
exact subtype.coe_injective
intros
{ rw prod_sub_ordered, simp }
rw prod_sub_ordered
simp
intros
rw [‚Üê neg_sub, sub_half]
intros
cases stream_nth_eq : (int_fract_pair.stream v n) with ifp
simp [stream_nth_eq, int_fract_pair.stream]
case option.none : { simp [stream_nth_eq, int_fract_pair.stream] }
case option.some : { cases ifp with _ fr, cases decidable.em (fr = 0); finish [int_fract_pair.stream] }
cases ifp with _ fr
cases decidable.em (fr = 0); finish [int_fract_pair.stream]
cases decidable.em (fr = 0)
finish [int_fract_pair.stream]
finish [int_fract_pair.stream]
intros
simp [convergents']
intros
rw [‚Üê div_neg_eq_neg_div]
intros
rw [gcd_comm _ a, gcd_comm _ a, gcd_eq_of_dvd_sub_right h]
intros
rw [div_eq_mul_inv, one_mul]
intros
rw [sub_eq_add_neg, add_assoc, ‚Üêsub_eq_add_neg]
intros
induction i with i hi
{ simp }
simp
{ simp [pow_succ, hi] }
simp [pow_succ, hi]
intros
rw [‚Üê divp_divp_eq_divp_mul, divp_assoc, mul_comm x, divp_assoc, mul_comm]
intros
ring
intros
induction m with m ih
{ rw [pow_zero, pow_zero], exact nat.cast_one }
rw [pow_zero, pow_zero]
exact nat.cast_one
{ rw [pow_succ', pow_succ', nat.cast_mul, ih] }
rw [pow_succ', pow_succ', nat.cast_mul, ih]
intros
{ ext, refl }
ext
refl
intros
refine ‚ü®‚ü®subobject.of_le _ _ p.ge, _‚ü©‚ü©
dsimp [image_to_kernel]
simp only [subobject.of_le_comp_of_le, subobject.of_le_refl]
simp
intros
change ite (2 = 1 + 1) (ùüô X‚ÇÇ ‚â´ d‚ÇÅ) 0 = d‚ÇÅ
{ change ite (2 = 1 + 1) (ùüô X‚ÇÇ ‚â´ d‚ÇÅ) 0 = d‚ÇÅ, rw [if_pos rfl, category.id_comp] }
rw [if_pos rfl, category.id_comp]
intros
{ ext, simp [p], }
ext
simp [p]
intros
apply le_antisymm
let s := {m : M | ‚àÉ (x : ‚Ü•I) (n : ‚Ü•N), ‚ÅÖ(x : L), (n : M)‚ÅÜ = m}
{ let s := {m : M | ‚àÉ (x : ‚Ü•I) (n : ‚Ü•N), ‚ÅÖ(x : L), (n : M)‚ÅÜ = m}, have aux : ‚àÄ (y : L) (m' ‚àà submodule.span R s), ‚ÅÖy, m'‚ÅÜ ‚àà submodule.span R s, { intros y m' hm', apply submodule.span_induction hm', { rintros m'' ‚ü®x, n, hm''‚ü©, rw [‚Üê hm'', leibniz_lie], refine submodule.add_mem _ _ _; apply submodule.subset_span, { use [‚ü®‚ÅÖy, ‚Üëx‚ÅÜ, I.lie_mem x.property‚ü©, n], refl, }, { use [x, ‚ü®‚ÅÖy, ‚Üën‚ÅÜ, N.lie_mem n.property‚ü©], refl, }, }, { simp only [lie_zero, submodule.zero_mem], }, { intros m‚ÇÅ m‚ÇÇ hm‚ÇÅ hm‚ÇÇ, rw lie_add, exact submodule.add_mem _ hm‚ÇÅ hm‚ÇÇ, }, { intros t m'' hm'', rw lie_smul, exact submodule.smul_mem _ t hm'', }, }, change _ ‚â§ ‚Üë({ lie_mem := aux, ..submodule.span R s } : lie_submodule R L M), rw [coe_submodule_le_coe_submodule, lie_ideal_oper_eq_span, lie_span_le], exact submodule.subset_span, }
have aux : ‚àÄ (y : L) (m' ‚àà submodule.span R s), ‚ÅÖy, m'‚ÅÜ ‚àà submodule.span R s
intros y m' hm'
{ intros y m' hm', apply submodule.span_induction hm', { rintros m'' ‚ü®x, n, hm''‚ü©, rw [‚Üê hm'', leibniz_lie], refine submodule.add_mem _ _ _; apply submodule.subset_span, { use [‚ü®‚ÅÖy, ‚Üëx‚ÅÜ, I.lie_mem x.property‚ü©, n], refl, }, { use [x, ‚ü®‚ÅÖy, ‚Üën‚ÅÜ, N.lie_mem n.property‚ü©], refl, }, }, { simp only [lie_zero, submodule.zero_mem], }, { intros m‚ÇÅ m‚ÇÇ hm‚ÇÅ hm‚ÇÇ, rw lie_add, exact submodule.add_mem _ hm‚ÇÅ hm‚ÇÇ, }, { intros t m'' hm'', rw lie_smul, exact submodule.smul_mem _ t hm'', }, }
apply submodule.span_induction hm'
rintros m'' ‚ü®x, n, hm''‚ü©
{ rintros m'' ‚ü®x, n, hm''‚ü©, rw [‚Üê hm'', leibniz_lie], refine submodule.add_mem _ _ _; apply submodule.subset_span, { use [‚ü®‚ÅÖy, ‚Üëx‚ÅÜ, I.lie_mem x.property‚ü©, n], refl, }, { use [x, ‚ü®‚ÅÖy, ‚Üën‚ÅÜ, N.lie_mem n.property‚ü©], refl, }, }
rw [‚Üê hm'', leibniz_lie]
refine submodule.add_mem _ _ _; apply submodule.subset_span
refine submodule.add_mem _ _ _
apply submodule.subset_span
use [‚ü®‚ÅÖy, ‚Üëx‚ÅÜ, I.lie_mem x.property‚ü©, n]
{ use [‚ü®‚ÅÖy, ‚Üëx‚ÅÜ, I.lie_mem x.property‚ü©, n], refl, }
refl
apply submodule.subset_span
use [x, ‚ü®‚ÅÖy, ‚Üën‚ÅÜ, N.lie_mem n.property‚ü©]
{ use [x, ‚ü®‚ÅÖy, ‚Üën‚ÅÜ, N.lie_mem n.property‚ü©], refl, }
refl
{ simp only [lie_zero, submodule.zero_mem], }
simp only [lie_zero, submodule.zero_mem]
{ intros m‚ÇÅ m‚ÇÇ hm‚ÇÅ hm‚ÇÇ, rw lie_add, exact submodule.add_mem _ hm‚ÇÅ hm‚ÇÇ, }
intros m‚ÇÅ m‚ÇÇ hm‚ÇÅ hm‚ÇÇ
rw lie_add
exact submodule.add_mem _ hm‚ÇÅ hm‚ÇÇ
{ intros t m'' hm'', rw lie_smul, exact submodule.smul_mem _ t hm'', }
intros t m'' hm''
rw lie_smul
exact submodule.smul_mem _ t hm''
change _ ‚â§ ‚Üë({ lie_mem := aux, ..submodule.span R s } : lie_submodule R L M)
rw [coe_submodule_le_coe_submodule, lie_ideal_oper_eq_span, lie_span_le]
exact submodule.subset_span
rw lie_ideal_oper_eq_span
{ rw lie_ideal_oper_eq_span, apply submodule_span_le_lie_span, }
apply submodule_span_le_lie_span
intros
split
split; introsI h
introsI h
{ exact e.symm.injective.lie_algebra_is_solvable, }
exact e.symm.injective.lie_algebra_is_solvable
introsI h
{ exact e.injective.lie_algebra_is_solvable, }
exact e.injective.lie_algebra_is_solvable
intros
{ rw eq_bot_iff, exact iff.rfl, }
rw eq_bot_iff
exact iff.rfl
intros
{ rw eq_bot_iff, exact iff.rfl, }
rw eq_bot_iff
exact iff.rfl
intros
rw [‚Üê lie_subalgebra.coe_to_submodule_eq_iff, range_coe_submodule, lie_subalgebra.top_coe_submodule]
exact linear_map.range_eq_top
intros
simp
intros
rw [mul_comm, div_le_iff_of_neg hc]
intros
rw [div_le_iff_of_neg hb, one_mul]
intros
rw [‚Üê mul_div_assoc] at h
rwa [mul_comm b, ‚Üê div_le_iff hc]
intros
rw [abs_lt, neg_lt_sub_iff_lt_add', sub_lt_iff_lt_add', and_comm, sub_lt_iff_lt_add']
intros
rw [‚Üê mul_le_mul_iff_right b, one_mul, inv_mul_cancel_right]
intros
rw [le_div_iff_mul_le, mul_comm]
intros
simp [lt_top_iff_ne_top, add_eq_top, not_or_distrib]
intros
haveI := @linear_order.decidable_le Œ± _; exact have h' : a * c ‚â§ b * c, from calc a * c ‚â§ b : h ... = b * 1 : by rewrite mul_one ... ‚â§ b * c : decidable.mul_le_mul_of_nonneg_left hc hb, le_of_mul_le_mul_right h' (zero_lt_one.trans_le hc)
haveI := @linear_order.decidable_le Œ± _
exact have h' : a * c ‚â§ b * c, from calc a * c ‚â§ b : h ... = b * 1 : by rewrite mul_one ... ‚â§ b * c : decidable.mul_le_mul_of_nonneg_left hc hb, le_of_mul_le_mul_right h' (zero_lt_one.trans_le hc)
intros
{ convert mul_lt_mul_right h, simp }
convert mul_lt_mul_right h
simp
intros
simp [two_mul, ‚Üê add_assoc, h _]
intros
rw [‚Üê image_mul_left', image_singleton]
intros
simp only [‚Üê image2_mul, image_image2, image2_image_left, image2_image_right, m.map_mul]
{ simp only [‚Üê image2_mul, image_image2, image2_image_left, image2_image_right, m.map_mul] }
intros
simpa using multiset_prod_X_sub_C_coeff_card_pred (s.1.map f) (by simpa using hs)
intros
apply @mul_right_cancel _ _ _ (act x)
ext z
simp only [inv_mul_cancel_right]
apply self_distrib.symm
intros
rw [h, coe_re]
intros
refine ‚ü®Œª h, h.subsingleton, _‚ü©
intros H a b h
exact @subsingleton.elim _ H a b
intros
simp only [semiconj_by, left_distrib, right_distrib, h.eq, h'.eq]
intros
simp
intros
convert units.is_unit E.disc_unit
exact E.disc_unit_eq.symm
intros
{ rw basic_open_mul f g, exact inf_le_right }
rw basic_open_mul f g
exact inf_le_right
intros
convert (has_deriv_at_gronwall_bound Œ¥ K Œµ _).comp x ((has_deriv_at_id x).sub_const a)
rw [id, mul_one]
intros
let c : composition 0 := composition.ones 0
dsimp [formal_multilinear_series.comp]
have : {c} = (finset.univ : finset (composition 0))
apply finset.eq_of_subset_of_card_le; simp [finset.card_univ, composition_card 0]
apply finset.eq_of_subset_of_card_le
{ apply finset.eq_of_subset_of_card_le; simp [finset.card_univ, composition_card 0] }
simp [finset.card_univ, composition_card 0]
simp [finset.card_univ, composition_card 0]
rw [‚Üê this, finset.sum_singleton, comp_along_composition_apply]
symmetry
congr'
intros
have N : 0 < n + 2
dec_trivial
dec_trivial
refine sum_congr rfl (Œª c hc, p.congr rfl (Œª j hj1 hj2, _))
have : ‚àÄ k, c.blocks_fun k < n + 2
simp only [set.mem_to_finset, set.mem_set_of_eq] at hc
{ simp only [set.mem_to_finset, set.mem_set_of_eq] at hc, simp [‚Üê composition.ne_single_iff N, composition.eq_single_iff_length, ne_of_gt hc] }
simp [‚Üê composition.ne_single_iff N, composition.eq_single_iff_length, ne_of_gt hc]
simp [apply_composition, this]
intros
have cne0 : ‚à•c‚à• ‚â† 0
from mt norm_eq_zero.mp hc
rw [‚Üêis_O_norm_right]
simp only [norm_smul]
rw [is_O_const_mul_right_iff cne0, is_O_norm_right]
intros
simpa only [neg_sub] using h.neg_left
intros
rw differentiable_at.fderiv_within (differentiable_at_inv.2 x_ne_zero) hxs
exact fderiv_inv
intros
unfold deriv_within
{ unfold deriv_within, rw fderiv_within_zero_of_not_differentiable_within_at, simp, assumption }
rw fderiv_within_zero_of_not_differentiable_within_at
simp
assumption
intros
simp only [deriv, fderiv_neg, continuous_linear_map.neg_apply]
intros
simp [sub_eq_add_neg]
intros
have : s = univ ‚à© s
simp only [univ_inter]
simp only [univ_inter]
rw [this, ‚Üê fderiv_within_univ]
exact fderiv_within_inter h (unique_diff_on_univ _ (mem_univ _))
intros
refine measurable_of_is_closed (Œª s hs, _)
have : fderiv ùïú f ‚Åª¬π' s = {x | differentiable_at ùïú f x ‚àß fderiv ùïú f x ‚àà s} ‚à™ {x | (0 : E ‚ÜíL[ùïú] F) ‚àà s} ‚à© {x | ¬¨differentiable_at ùïú f x} := set.ext (Œª x, mem_preimage.trans fderiv_mem_iff)
rw this
exact (measurable_set_of_differentiable_at_of_is_complete _ _ hs.is_complete).union ((measurable_set.const _).inter (measurable_set_of_differentiable_at _ _).compl)
intros
cases hc with hE hc
refine ‚ü®univ, is_open.mem_nhds is_open_univ trivial, Œª x hx y hy, _‚ü©
{ refine ‚ü®univ, is_open.mem_nhds is_open_univ trivial, Œª x hx y hy, _‚ü©, simp [@subsingleton.elim E hE x y] }
simp [@subsingleton.elim E hE x y]
have := hf.def hc
rw [nhds_prod_eq, filter.eventually, mem_prod_same_iff] at this
rcases this with ‚ü®s, has, hs‚ü©
exact ‚ü®s, has, Œª x hx y hy, hs (mk_mem_prod hx hy)‚ü©
intros
simpa only [zero_mul, sub_nonneg] using hD.mul_sub_le_image_sub_of_le_deriv hf hf' hf'_nonneg
intros
assume x xs
rcases hs with ‚ü®y, hy‚ü©
suffices : y - x ‚àà interior (tangent_cone_at ‚Ñù s x)
refine ‚ü®dense.of_closure _, subset_closure xs‚ü©
{ refine ‚ü®dense.of_closure _, subset_closure xs‚ü©, simp [(submodule.span ‚Ñù (tangent_cone_at ‚Ñù s x)).eq_top_of_nonempty_interior' ‚ü®y - x, interior_mono submodule.subset_span this‚ü©] }
simp [(submodule.span ‚Ñù (tangent_cone_at ‚Ñù s x)).eq_top_of_nonempty_interior' ‚ü®y - x, interior_mono submodule.subset_span this‚ü©]
rw [mem_interior_iff_mem_nhds] at hy ‚ä¢
apply mem_of_superset ((is_open_map_sub_right x).image_mem_nhds hy)
rintros _ ‚ü®z, zs, rfl‚ü©
exact mem_tangent_cone_of_segment_subset (conv.segment_subset xs zs)
intros
rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]
{ rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply], refl }
refl
intros
rw ‚Üê times_cont_diff_on_univ at ‚ä¢ hf
rw [‚Üê fderiv_within_univ, ‚Üê univ_prod_univ]
exact times_cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn
intros
rw times_cont_diff_on_succ_iff_deriv_within hs.unique_diff_on
congr' 2
rw ‚Üê iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact deriv_within_of_open hs hx
intros
simpa [ext_iff, add_re, add_im, conj_re, conj_im, ‚Üêtwo_mul, (show (2 : ‚Ñù) ‚â† 0, by simp [two_ne_zero'])] using (h‚ÇÉ z).symm
intros
convert open_segment_eq_image ùïú x y
{ convert open_segment_eq_image ùïú x y, ext Œ∏, simp only [smul_sub, sub_smul, one_smul], abel }
ext Œ∏
simp only [smul_sub, sub_smul, one_smul]
abel
intros
rintro p q ‚ü®ap, bp, hap, hbp, habp, rfl‚ü© ‚ü®aq, bq, haq, hbq, habq, rfl‚ü© a b ha hb hab
refine ‚ü®a * ap + b * aq, a * bp + b * bq, add_nonneg (mul_nonneg ha hap) (mul_nonneg hb haq), add_nonneg (mul_nonneg ha hbp) (mul_nonneg hb hbq), _, _‚ü©
rw [add_add_add_comm, ‚Üêmul_add, ‚Üêmul_add, habp, habq, mul_one, mul_one, hab]
{ rw [add_add_add_comm, ‚Üêmul_add, ‚Üêmul_add, habp, habq, mul_one, mul_one, hab] }
simp_rw [add_smul, mul_smul, smul_add]
{ simp_rw [add_smul, mul_smul, smul_add], exact add_add_add_comm _ _ _ _ }
exact add_add_add_comm _ _ _ _
intros
simpa only [center_mass, h‚ÇÅ, inv_one, one_smul] using hf.map_center_mass_le h‚ÇÄ (h‚ÇÅ.symm ‚ñ∏ zero_lt_one) hmem
intros
letI : inner_product_space ‚Ñù E := inner_product_space.is_R_or_C_to_real ùïú E
letI : is_scalar_tower ‚Ñù ùïú E := restrict_scalars.is_scalar_tower _ _ _
exact is_bounded_bilinear_map_inner.continuous
intros
have : ‚ü™y, x‚ü´_‚Ñù = ‚ü™x, y‚ü´_‚Ñù := by rw [‚Üêinner_conj_sym]; refl
simp [inner_sub_sub_self, this]
ring
intros
simp
intros
nth_rewrite 0 ‚Üê real.coe_to_nnreal p hpq.nonneg
nth_rewrite 0 ‚Üê real.coe_to_nnreal q hpq.symm.nonneg
exact young_inequality a b hpq.one_lt_nnreal hpq.inv_add_inv_conj_nnreal
intros
simpa only [dist_add_left, dist_add_right] using dist_triangle (g‚ÇÅ + g‚ÇÇ) (h‚ÇÅ + g‚ÇÇ) (h‚ÇÅ + h‚ÇÇ)
intros
rw summable_iff_cauchy_seq_finset
{ rw summable_iff_cauchy_seq_finset, exact cauchy_seq_finset_of_norm_bounded g hg h }
exact cauchy_seq_finset_of_norm_bounded g hg h
intros
simp_rw [metric.tendsto_nhds_nhds, dist_eq_norm]
intros
{ rw [‚Üê zero_smul ùïú (0:V), e.map_smul], norm_num }
rw [‚Üê zero_smul ùïú (0:V), e.map_smul]
norm_num
intros
simpa only [fintype.card_fin] using f.le_op_norm_mul_pow_card_of_le m (Œª i, (norm_le_pi_norm m i).trans hm)
intros
simp
intros
refine ‚ü®_, continuous_at_log‚ü©
rintros h rfl
exact not_tendsto_nhds_of_tendsto_at_bot tendsto_log_nhds_within_zero _ (h.tendsto.mono_left inf_le_left)
intros
refine ‚ü®Œª h, _, Œª h, tendsto_at_top_of_leading_coeff_nonneg P h.1 h.2‚ü©
have : tendsto (Œª x, P.leading_coeff * x ^ P.nat_degree) at_top at_top := is_equivalent.tendsto_at_top (is_equivalent_at_top_lead P) h
rw tendsto_const_mul_pow_at_top_iff P.leading_coeff P.nat_degree at this
rw [degree_eq_nat_degree (leading_coeff_ne_zero.mp (ne_of_lt this.2).symm), ‚Üê nat.cast_one]
refine ‚ü®with_bot.coe_le_coe.mpr this.1, le_of_lt this.2‚ü©
intros
rw zero_rpow_def
{ rw zero_rpow_def, split_ifs, exacts [zero_mul _, one_mul _, top_mul_top] }
split_ifs
exacts [zero_mul _, one_mul _, top_mul_top]
intros
simp [rpow_def]
intros
simp [cpow_def, *]
intros
simpa using (has_strict_fderiv_at_rpow_of_neg (a, x) ha).comp_has_strict_deriv_at x ((has_strict_deriv_at_const _ _).prod (has_strict_deriv_at_id _))
intros
simp only [cosh, div_eq_mul_inv]
convert ((has_strict_deriv_at_exp x).sub (has_strict_deriv_at_id x).neg.cexp).mul_const (2:‚ÑÇ)‚Åª¬π
rw [id, mul_neg_one, sub_eq_add_neg, neg_neg]
intros
simpa using add_monoid_hom.map_nsmul ‚ü®coe, coe_zero, coe_add‚ü© _ _
intros
unfold arccos; linarith [neg_pi_div_two_le_arcsin x]
unfold arccos
linarith [neg_pi_div_two_le_arcsin x]
intros
by_cases h0 : r‚ÇÅ = 0
refine (is_o_zero _ _).congr' (mem_at_top_sets.2 $ ‚ü®1, Œª n hn, _‚ü©) eventually_eq.rfl
{ refine (is_o_zero _ _).congr' (mem_at_top_sets.2 $ ‚ü®1, Œª n hn, _‚ü©) eventually_eq.rfl, simp [zero_pow (zero_lt_one.trans_le hn), h0] }
simp [zero_pow (zero_lt_one.trans_le hn), h0]
rw [‚Üê ne.def, ‚Üê norm_pos_iff] at h0
have A : is_o (Œª n, n ^ k : ‚Ñï ‚Üí R) (Œª n, (r‚ÇÇ / ‚à•r‚ÇÅ‚à•) ^ n) at_top
from is_o_pow_const_const_pow_of_one_lt k ((one_lt_div h0).2 h)
suffices : is_O (Œª n, r‚ÇÅ ^ n) (Œª n, ‚à•r‚ÇÅ‚à• ^ n) at_top
simpa [div_mul_cancel _ (pow_pos h0 _).ne'] using A.mul_is_O this
simpa [div_mul_cancel _ (pow_pos h0 _).ne'] using A.mul_is_O this
exact is_O.of_bound 1 (by simpa using eventually_norm_pow_le r‚ÇÅ)
intros
set v : ‚Ñï ‚Üí Œ± := Œª n, if n < N then 0 else u n
have hC : 0 ‚â§ C
from (zero_le_mul_right $ pow_pos hr‚ÇÄ N).mp ((norm_nonneg _).trans $ h N $ le_refl N)
have : ‚àÄ n ‚â• N, u n = v n
intros n hn
{ intros n hn, simp [v, hn, if_neg (not_lt.mpr hn)] }
simp [v, hn, if_neg (not_lt.mpr hn)]
refine cauchy_seq_sum_of_eventually_eq this (normed_group.cauchy_series_of_le_geometric' hr‚ÇÅ _)
{ exact C }
exact C
intro n
dsimp [v]
split_ifs with H H
rw norm_zero
{ rw norm_zero, exact mul_nonneg hC (pow_nonneg hr‚ÇÄ.le _) }
exact mul_nonneg hC (pow_nonneg hr‚ÇÄ.le _)
push_neg at H
{ push_neg at H, exact h _ H }
exact h _ H
intros
rw [‚Üêcancel_mono (i.map ((of_right_adjoint i).counit.app ((left_adjoint i).obj X))), ‚Üêi.map_comp]
simp
intros
split_ifs; refl
{ split_ifs; refl }
split_ifs
refl
refl
intros
simp
intros
{ ext, simp, }
ext
simp
intros
simp only [cancel_mono]
intros
classical
let O := (finset.univ.image F.obj)
let H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) := finset.univ.bUnion (Œª X : J, finset.univ.bUnion (Œª Y : J, finset.univ.image (Œª f : X ‚ü∂ Y, ‚ü®F.obj X, F.obj Y, by simp, by simp, F.map f‚ü©)))
obtain ‚ü®Z, f, w‚ü© := inf_exists O H
refine ‚ü®‚ü®Z, ‚ü®Œª X, f (by simp), _‚ü©‚ü©‚ü©
intros j j' g
dsimp
simp only [category.id_comp]
symmetry
apply w
simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left, exists_prop_of_true, finset.mem_image]
exact ‚ü®j, rfl, j', g, (by simp)‚ü©
intros
ext
ext; erw [assoc, limit.post_œÄ, ‚ÜêH.map_comp, limit.post_œÄ, limit.post_œÄ]; refl
ext; erw [assoc, limit.post_œÄ, ‚ÜêH.map_comp, limit.post_œÄ, limit.post_œÄ]
erw [assoc, limit.post_œÄ, ‚ÜêH.map_comp, limit.post_œÄ, limit.post_œÄ]
refl
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
tidy
intros
rw ‚Üêimage.lift_fac (mono_factorisation_zero X Y)
simp
intros
rw ‚Üê((iso.eq_comp_inv _).mp (pentagon_inv W X Y Z))
slice_rhs 1 2 { rw [‚Üêid_tensor_comp, iso.hom_inv_id] }
simp only [tensor_id, assoc, id_comp]
intros
{ ext, rw [‚Üêright_unitor_hom_f, ‚Üêcomp_f, iso.hom_inv_id], refl, }
ext
rw [‚Üêright_unitor_hom_f, ‚Üêcomp_f, iso.hom_inv_id]
refl
intros
ext
ext; refl
refl
intros
apply J.transitive rj _ (Œª Y f Hf, _)
rw [sieve.pullback_inter, R.pullback_eq_top_of_mem Hf]
simp [sj]
intros
intros Y f hf
dsimp [family_of_elements.sieve_extend]
rw [‚Üêht _, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, (some_spec (some_spec (some_spec hf))).2]
intros
simp [sieve.ext_iff]
intros
simp [of_le, ‚Üêfunctor.map_comp underlying]
intros
simp [equalizer_subobject_iso]
intros
{ dsimp, simp }
dsimp
simp
intros
conv_rhs { rw [‚Üê c.blocks_sum, ‚Üê sum_take_add_sum_drop _ i] }
exact nat.le_add_right _ _
intros
simp [split_wrt_composition_aux]
intros
have h1 : ‚àÄ a : fin (n+1), card ({a}·∂ú : set (fin (n+1))) = card (fin n)
intro a
{ intro a, simp only [fintype.card_fin, finset.card_fin, fintype.card_of_finset, finset.filter_ne' _ a, set.mem_compl_singleton_iff, finset.card_erase_of_mem (finset.mem_univ a), nat.pred_succ] }
simp only [fintype.card_fin, finset.card_fin, fintype.card_of_finset, finset.filter_ne' _ a, set.mem_compl_singleton_iff, finset.card_erase_of_mem (finset.mem_univ a), nat.pred_succ]
have h2 : card (fin (n+2)) = card (option (fin (n+1)))
{ simp only [card_fin, card_option] }
simp only [card_fin, card_option]
simp only [card_derangements_invariant h2, card_congr (@derangements_recursion_equiv (fin (n+1)) _), card_sigma, card_sum, card_derangements_invariant (h1 _), finset.sum_const, nsmul_eq_mul, finset.card_fin, mul_add, nat.cast_id]
intros
cases n; unfold encode_num decode_num
cases n
unfold encode_num decode_num
{ refl }
refl
unfold encode_num decode_num
rw decode_encode_pos_num n
rw pos_num.cast_to_num
exact if_neg (encode_pos_num_nonempty n)
intros
simpa using hf.comp' (hg.cons $ hh.cons primrec'.nil)
simp [primrec‚ÇÇ, primrec]; constructor
simp [primrec‚ÇÇ, primrec]
constructor
intros
suffices : ‚àÉ c : code, ‚àÄ v : vector ‚Ñï m, c.eval v.1 = subtype.val <$> vector.m_of_fn (Œª i, g i v)
obtain ‚ü®cf, hf‚ü© := hf
{ obtain ‚ü®cf, hf‚ü© := hf, obtain ‚ü®cg, hg‚ü© := this, exact ‚ü®cf.comp cg, Œª v, by { simp [hg, hf, map_bind, seq_bind_eq, (‚àò), -subtype.val_eq_coe], refl }‚ü© }
obtain ‚ü®cg, hg‚ü© := this
exact ‚ü®cf.comp cg, Œª v, by { simp [hg, hf, map_bind, seq_bind_eq, (‚àò), -subtype.val_eq_coe], refl }‚ü©
clear hf f
induction n with n IH
{ exact ‚ü®nil, Œª v, by simp [vector.m_of_fn]; refl‚ü© }
exact ‚ü®nil, Œª v, by simp [vector.m_of_fn]; refl‚ü©
obtain ‚ü®cg, hg‚ÇÅ‚ü© := hg 0
{ obtain ‚ü®cg, hg‚ÇÅ‚ü© := hg 0, obtain ‚ü®cl, hl‚ü© := IH (Œª i, hg i.succ), exact ‚ü®cons cg cl, Œª v, by { simp [vector.m_of_fn, hg‚ÇÅ, map_bind, seq_bind_eq, bind_assoc, (‚àò), hl, -subtype.val_eq_coe], refl }‚ü© }
obtain ‚ü®cl, hl‚ü© := IH (Œª i, hg i.succ)
exact ‚ü®cons cg cl, Œª v, by { simp [vector.m_of_fn, hg‚ÇÅ, map_bind, seq_bind_eq, bind_assoc, (‚àò), hl, -subtype.val_eq_coe], refl }‚ü©
intros
simp only [tr_normal_run, step_run]
have hgo := tr_respects_aux‚ÇÅ M o q v (hT k) _ (le_refl _)
obtain ‚ü®T', hT', hrun‚ü© := tr_respects_aux‚ÇÇ hT o
have hret := tr_respects_aux‚ÇÉ M _
have := hgo.tail' rfl
rw [tr, TM1.step_aux, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_snd, stk_nth_val _ (hT k), list.nth_len_le (le_of_eq (list.length_reverse _)), option.is_none, cond, hrun, TM1.step_aux] at this
obtain ‚ü®c, gc, rc‚ü© := IH hT'
refine ‚ü®c, gc, (this.to‚ÇÄ.trans hret c (trans_gen.head' rfl _)).to_refl‚ü©
rw [tr, TM1.step_aux, tape.mk'_head, add_bottom_head_fst]
exact rc
intros
cases T; cases d; simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self, list_blank.tail_map]
cases T; cases d
cases T
cases d
simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self, list_blank.tail_map]
simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self, list_blank.tail_map]
intros
cases x
cases x; refl
refl
intros
cases x; refl
cases x
refl
refl
intros
rw [‚Üêrev_list_reverse, ‚Üêrev_list_reverse, push_back_rev_list, list.reverse_cons]
intros
cases cs with hd tl
{ simp [one_of', static.bind], }
simp [one_of', static.bind]
have : one_of' (hd :: tl) (hd :: tl).to_buffer 0 = done 1 ()
{ have : one_of' (hd :: tl) (hd :: tl).to_buffer 0 = done 1 (), { simp [one_of'_eq_done] }, simpa using not_of_ne this zero_ne_one }
{ simp [one_of'_eq_done] }
simp [one_of'_eq_done]
simpa using not_of_ne this zero_ne_one
intros
constructor
intros cb n hn
haveI : (parser.fix_core F (cb.size - n + 1)).bounded := fix_core hF _
obtain ‚ü®np, errp, hp‚ü© := bounded.exists (parser.fix_core F (cb.size - n + 1)) hn
simp [fix, hp]
intros
induction l with hd tl hl generalizing n n'
{ simpa using h }
simpa using h
obtain ‚ü®k, hk‚ü© : ‚àÉ k, n' = n + k + 1 := nat.exists_eq_add_of_lt (prog.of_done h)
{ obtain ‚ü®k, hk‚ü© : ‚àÉ k, n' = n + k + 1 := nat.exists_eq_add_of_lt (prog.of_done h), subst hk, simp only [many1_eq_done] at h, obtain ‚ü®_, hp, h‚ü© := h, have := step.of_done hp, subst this, cases tl, { simp only [many_eq_done_nil, add_left_inj, exists_and_distrib_right, self_eq_add_right] at h, rcases h with ‚ü®rfl, -‚ü©, simp }, rw ‚Üêmany1_eq_done_iff_many_eq_done at h, specialize hl h, simp [hl, add_comm, add_assoc, nat.sub_succ] }
subst hk
simp only [many1_eq_done] at h
obtain ‚ü®_, hp, h‚ü© := h
have := step.of_done hp
subst this
cases tl
simp only [many_eq_done_nil, add_left_inj, exists_and_distrib_right, self_eq_add_right] at h
{ simp only [many_eq_done_nil, add_left_inj, exists_and_distrib_right, self_eq_add_right] at h, rcases h with ‚ü®rfl, -‚ü©, simp }
rcases h with ‚ü®rfl, -‚ü©
simp
rw ‚Üêmany1_eq_done_iff_many_eq_done at h
specialize hl h
simp [hl, add_comm, add_assoc, nat.sub_succ]
intros
simp [foldl_core, eq_comm]
intros
rw ‚Üê of_real_inj; simp [sin_two_mul]
rw ‚Üê of_real_inj
simp [sin_two_mul]
intros
linarith [add_one_le_exp_of_nonneg hx]
intros
have h2 : (2:‚ÑÇ) ‚â† 0 := by norm_num
calc cos x + cos y = cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2) : _ ... = (cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)) + (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) : _ ... = 2 * cos ((x + y) / 2) * cos ((x - y) / 2) : _
congr; field_simp [h2]; ring
congr; field_simp [h2]
{ congr; field_simp [h2]; ring }
congr
field_simp [h2]
field_simp [h2]
ring
{ rw [cos_add, cos_sub] }
rw [cos_add, cos_sub]
ring
intros
simp only [bit1, add_right_eq_self, add_monoid_hom.map_add, bit0_im, one_im]
intros
induction n; simp [*, of_real_mul, pow_succ]
induction n
simp [*, of_real_mul, pow_succ]
simp [*, of_real_mul, pow_succ]
intros
rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs]
{ rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs], exact is_R_or_C.abs_im_le_abs _, }
exact is_R_or_C.abs_im_le_abs _
intros
simp
intros
rw ‚Üêfilter_ne_eq_erase f i
congr' with j
exact ne_comm
intros
ext j
rcases eq_or_ne i j with rfl|hi
{ simp [h] }
simp [h]
{ simp [hi.symm] }
simp [hi.symm]
intros
{ cases a, cases a_val, refl }
cases a
cases a_val
refl
intros
simp [perm.extend_domain, h]
intros
rw [‚Üê update_comp_eq_of_injective _ g.injective, g.apply_symm_apply]
intros
simp [fin_add_flip]
intros
{ change univ ‚à© id‚Åª¬π' s = s, simp }
change univ ‚à© id‚Åª¬π' s = s
simp
intros
{ rw [succ_above], exact if_pos h }
rw [succ_above]
exact if_pos h
intros
rcases i.le_last.eq_or_lt with rfl|H
{ simp }
simp
simp only [H]
{ simp only [H], rw ‚Üêcast_succ_cast_pred H, simp }
rw ‚Üêcast_succ_cast_pred H
simp
intros
rcases (le_last i).eq_or_lt with rfl|h
{ simp }
simp
{ simpa [h.ne] using coe_add_one_of_lt h }
simpa [h.ne] using coe_add_one_of_lt h
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
simp only [mem_insert, or_and_distrib_right, exists_or_distrib, exists_eq_left]
intros
refine ‚ü®Œª h, _, finset.mem_image_of_mem f‚ü©
obtain ‚ü®y, hy, heq‚ü© := mem_image.1 h
exact hf heq ‚ñ∏ hy
intros
exact_mod_cast @set.ssubset_iff_insert Œ± s t
intros
intros a a_in
rw finset.mem_inter at a_in ‚ä¢
exact ‚ü®h a_in.1, h' a_in.2‚ü©
intros
classical
exact le_antisymm (supr_le $ assume b, le_supr_of_le {b} $ le_supr_of_le b $ le_supr_of_le (by simp) $ le_refl _) (supr_le $ assume t, supr_le $ assume b, supr_le $ assume hb, le_supr _ _)
intros
induction s using quotient.induction_on
simp
intros
{ ext, simp, }
ext
simp
intros
refine f.induction _ _
rw [to_multiset_zero, multiset.map_zero, map_domain_zero, to_multiset_zero]
{ rw [to_multiset_zero, multiset.map_zero, map_domain_zero, to_multiset_zero] }
assume a n f _ _ ih
{ assume a n f _ _ ih, rw [to_multiset_add, multiset.map_add, ih, map_domain_add, map_domain_single, to_multiset_single, to_multiset_add, to_multiset_single, ‚Üê multiset.coe_map_add_monoid_hom, (multiset.map_add_monoid_hom g).map_nsmul], refl }
rw [to_multiset_add, multiset.map_add, ih, map_domain_add, map_domain_single, to_multiset_single, to_multiset_add, to_multiset_single, ‚Üê multiset.coe_map_add_monoid_hom, (multiset.map_add_monoid_hom g).map_nsmul]
refl
intros
dunfold split
rw comap_domain_apply
intros
simp [ext_iff]
intros
simp
intros
rw [fintype.prod_eq_mul_prod_compl x, ‚Üê fin.image_succ_above_univ, prod_image]
exact Œª _ _ _ _ h, x.succ_above.injective h
intros
suffices : ‚àÄ (l : list Œ£ a, Œ≤ a) (t : bucket_array Œ± Œ≤ n') sz, valid hash_fn t sz ‚Üí ((l ++ t.as_list).map sigma.fst).nodup ‚Üí valid hash_fn (l.foldl (Œªr (a : Œ£ a, Œ≤ a), reinsert_aux hash_fn r a.1 a.2) t) (sz + l.length)
have p := this bkts.as_list _ _ (mk_valid _ _)
{ have p := this bkts.as_list _ _ (mk_valid _ _), rw [mk_as_list, list.append_nil, zero_add, v.len] at p, rw bucket_array.foldl_eq, exact p (v.as_list_nodup _) }
rw [mk_as_list, list.append_nil, zero_add, v.len] at p
rw bucket_array.foldl_eq
exact p (v.as_list_nodup _)
intro l
induction l with c l IH
induction l with c l IH; intros t sz v nd
intros t sz v nd
exact v
{exact v}
intros t sz v nd
rw show sz + (c :: l).length = sz + 1 + l.length, by simp [add_comm, add_assoc]
rcases (show (l.map sigma.fst).nodup ‚àß ((bucket_array.as_list t).map sigma.fst).nodup ‚àß c.fst ‚àâ l.map sigma.fst ‚àß c.fst ‚àâ (bucket_array.as_list t).map sigma.fst ‚àß (l.map sigma.fst).disjoint ((bucket_array.as_list t).map sigma.fst), by simpa [list.nodup_append, not_or_distrib, and_comm, and.left_comm] using nd) with ‚ü®nd1, nd2, nm1, nm2, dj‚ü©
have v' := v.insert _ _ c.2 (ŒªHc, nm2 $ (v.contains_aux_iff _ c.1).1 Hc)
apply IH _ _ v'
suffices : ‚àÄ ‚¶Éa : Œ±‚¶Ñ (b : Œ≤ a), sigma.mk a b ‚àà l ‚Üí ‚àÄ (b' : Œ≤ a), sigma.mk a b' ‚àà (reinsert_aux hash_fn t c.1 c.2).as_list ‚Üí false
simpa [list.nodup_append, nd1, v'.as_list_nodup _, list.disjoint]
{ simpa [list.nodup_append, nd1, v'.as_list_nodup _, list.disjoint] }
intros a b m1 b' m2
rcases (reinsert_aux hash_fn t c.1 c.2).mem_as_list.1 m2 with ‚ü®i, im‚ü©
have : sigma.mk a b' ‚àâ array.read t i
intro m3
{ intro m3, have : a ‚àà list.map sigma.fst t.as_list := list.mem_map_of_mem sigma.fst (t.mem_as_list.2 ‚ü®_, m3‚ü©), exact dj (list.mem_map_of_mem sigma.fst m1) this }
have : a ‚àà list.map sigma.fst t.as_list := list.mem_map_of_mem sigma.fst (t.mem_as_list.2 ‚ü®_, m3‚ü©)
exact dj (list.mem_map_of_mem sigma.fst m1) this
by_cases h : mk_idx n' (hash_fn c.1) = i
subst h
{ subst h, have e : sigma.mk a b' = ‚ü®c.1, c.2‚ü©, { simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im }, injection e with e, subst a, exact nm1.elim (@list.mem_map_of_mem _ _ sigma.fst _ _ m1) }
have e : sigma.mk a b' = ‚ü®c.1, c.2‚ü©
simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im
{ simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im }
injection e with e
subst a
exact nm1.elim (@list.mem_map_of_mem _ _ sigma.fst _ _ m1)
apply this
{ apply this, simpa [reinsert_aux, bucket_array.modify, array.read_write_of_ne _ _ h] using im }
simpa [reinsert_aux, bucket_array.modify, array.read_write_of_ne _ _ h] using im
intros
rw [neg_succ, succ_pred]
intros
rw [mul_comm, int.mul_div_cancel _ H]
intros
ext (x | x)
{ exact (monoid_hom.congr_fun h_nat x : _), }
exact (monoid_hom.congr_fun h_nat x : _)
rw [int.neg_succ_of_nat_eq, ‚Üê neg_one_mul, f.map_mul, g.map_mul]
{ rw [int.neg_succ_of_nat_eq, ‚Üê neg_one_mul, f.map_mul, g.map_mul], congr' 1, exact_mod_cast (monoid_hom.congr_fun h_nat (x + 1) : _), }
congr' 1
exact_mod_cast (monoid_hom.congr_fun h_nat (x + 1) : _)
intros
rw int.lcm
{ rw int.lcm, apply coe_nat_dvd_right.mpr, apply nat.dvd_lcm_left }
apply coe_nat_dvd_right.mpr
apply nat.dvd_lcm_left
intros
rw [modeq_iff_dvd] at *; exact (dvd_mul_left n m).trans h
rw [modeq_iff_dvd] at *
exact (dvd_mul_left n m).trans h
intros
split
intro h
{ intro h, by_contradiction h', have h‚ÇÇ : ‚àÉ h, l.nth_le n h = l.nth_le n (lt_of_not_ge h') := ‚ü®lt_of_not_ge h', rfl‚ü©, rw [‚Üê nth_eq_some, h] at h‚ÇÇ, cases h‚ÇÇ }
by_contradiction h'
have h‚ÇÇ : ‚àÉ h, l.nth_le n h = l.nth_le n (lt_of_not_ge h') := ‚ü®lt_of_not_ge h', rfl‚ü©
rw [‚Üê nth_eq_some, h] at h‚ÇÇ
cases h‚ÇÇ
{ solve_by_elim [nth_len_le] }
solve_by_elim [nth_len_le]
intros
have A : length (take i L) = i
simp [le_of_lt (lt_of_le_of_lt (nat.le.intro rfl) h)]
simp [le_of_lt (lt_of_le_of_lt (nat.le.intro rfl) h)]
rw [nth_le_of_eq (take_append_drop i L).symm h, nth_le_append_right]
rw [nth_le_of_eq (take_append_drop i L).symm h, nth_le_append_right]; simp [A]
simp [A]
simp [A]
intros
cases l
{ simp only [nth, scanl_nil] }
simp only [nth, scanl_nil]
{ simp only [nth, scanl_cons, singleton_append] }
simp only [nth, scanl_cons, singleton_append]
intros
{ cases L, { simp at h, cases h, }, { simp, }, }
cases L
simp at h
{ simp at h, cases h, }
cases h
simp
{ simp, }
intros
simp only [mem_append, or_imp_distrib, forall_and_distrib]
intros
induction l with a l IH
{ exact iff_of_true rfl (forall_mem_nil _) }
exact iff_of_true rfl (forall_mem_nil _)
rw forall_mem_cons
by_cases h : p a
simp only [find_cons_of_pos _ h, h, not_true, false_and]
{ simp only [find_cons_of_pos _ h, h, not_true, false_and] }
rwa [find_cons_of_neg _ h, iff_true_intro h, true_and]
{ rwa [find_cons_of_neg _ h, iff_true_intro h, true_and] }
intros
simp
intros
{ rw tails_eq_inits l, simp [reverse_involutive.comp_self], }
rw tails_eq_inits l
simp [reverse_involutive.comp_self]
intros
induction l‚ÇÇ with b l‚ÇÇ ih generalizing l‚ÇÅ a
{ simp_rw [diff_cons, diff_nil] }
simp_rw [diff_cons, diff_nil]
rw [diff_cons, diff_cons, erase_comm, ‚Üê diff_cons, ih, ‚Üê diff_cons]
{ rw [diff_cons, diff_cons, erase_comm, ‚Üê diff_cons, ih, ‚Üê diff_cons] }
intros
cases as; refl
cases as
refl
refl
intros
{ transitivity, rw [‚Üê bind_singleton' l, bind_map], refl }
transitivity
rw [‚Üê bind_singleton' l, bind_map]
refl
intros
have r : min m (n + 1) = n + 1 := (@inf_eq_right _ _ m (n + 1)).mpr hnm
simp [filter_lt n m (n + 1), r]
intros
induction l with hd tl hl
{ simp }
simp
specialize hl (nodup_of_nodup_cons h)
{ specialize hl (nodup_of_nodup_cons h), by_cases hx : tl = [x], { simpa [hx, and.comm, and_or_distrib_left] using h }, { rw [‚Üêne.def, hl] at hx, rcases hx with rfl | ‚ü®y, hy, hx‚ü©, { simp }, { have : tl ‚â† [] := ne_nil_of_mem hy, suffices : ‚àÉ (y : Œ±) (H : y ‚àà hd :: tl), y ‚â† x, { simpa [ne_nil_of_mem hy] }, exact ‚ü®y, mem_cons_of_mem _ hy, hx‚ü© } } }
by_cases hx : tl = [x]
{ simpa [hx, and.comm, and_or_distrib_left] using h }
simpa [hx, and.comm, and_or_distrib_left] using h
rw [‚Üêne.def, hl] at hx
{ rw [‚Üêne.def, hl] at hx, rcases hx with rfl | ‚ü®y, hy, hx‚ü©, { simp }, { have : tl ‚â† [] := ne_nil_of_mem hy, suffices : ‚àÉ (y : Œ±) (H : y ‚àà hd :: tl), y ‚â† x, { simpa [ne_nil_of_mem hy] }, exact ‚ü®y, mem_cons_of_mem _ hy, hx‚ü© } }
rcases hx with rfl | ‚ü®y, hy, hx‚ü©
{ simp }
simp
have : tl ‚â† [] := ne_nil_of_mem hy
{ have : tl ‚â† [] := ne_nil_of_mem hy, suffices : ‚àÉ (y : Œ±) (H : y ‚àà hd :: tl), y ‚â† x, { simpa [ne_nil_of_mem hy] }, exact ‚ü®y, mem_cons_of_mem _ hy, hx‚ü© }
suffices : ‚àÉ (y : Œ±) (H : y ‚àà hd :: tl), y ‚â† x
simpa [ne_nil_of_mem hy]
{ simpa [ne_nil_of_mem hy] }
exact ‚ü®y, mem_cons_of_mem _ hy, hx‚ü©
intros
simp only [range_eq_range', range'_concat, zero_add]
intros
simp [is_rotated_reverse_comm_iff]
intros
ext b
ext b; simp [mem_lookup_iff, nd‚ÇÅ, nd‚ÇÇ]; exact p.mem_iff
ext b; simp [mem_lookup_iff, nd‚ÇÅ, nd‚ÇÇ]
simp [mem_lookup_iff, nd‚ÇÅ, nd‚ÇÇ]
exact p.mem_iff
intros
rw [‚Üê zip_map, map_id]
intros
simp_rw [‚Üêdrop_one, zip_with_distrib_drop]
intros
ext i j
apply dot_product_comm
intros
ext i' j'
rw [update_row_apply, map_apply, map_apply, update_row_apply]
exact apply_ite f _ _ _
intros
{ ext, simp [mul_comm] }
ext
simp [mul_comm]
intros
simp only [conj_transpose, from_blocks_transpose, from_blocks_map]
intros
{ ext, refl }
ext
refl
intros
have := card_powerset s; rwa [‚Üê antidiagonal_map_fst, card_map] at this
have := card_powerset s
rwa [‚Üê antidiagonal_map_fst, card_map] at this
intros
rw ‚Üê eq_union_left h‚ÇÇ; exact union_le_union_right h‚ÇÅ t
rw ‚Üê eq_union_left h‚ÇÇ
exact union_le_union_right h‚ÇÅ t
intros
induction n; simp [*, succ_nsmul', succ_mul, zero_nsmul]
induction n
simp [*, succ_nsmul', succ_mul, zero_nsmul]
simp [*, succ_nsmul', succ_mul, zero_nsmul]
intros
induction n with n ih
rw zero_nsmul at h
{ rw zero_nsmul at h, exact absurd h (not_mem_zero _) }
exact absurd h (not_mem_zero _)
rw [succ_nsmul, mem_add] at h
{ rw [succ_nsmul, mem_add] at h, exact h.elim id ih }
exact h.elim id ih
intros
rw [‚Üê mem_coe, sort_eq]
intros
simp [constant_coeff_eq]
intros
suffices : eval‚ÇÇ_hom f (0 : œÉ ‚Üí S‚ÇÇ) = f.comp constant_coeff
from ring_hom.congr_fun this p
ext
ext; simp
simp
simp
intros
apply alg_hom_ext
{ apply alg_hom_ext, intro i, simp only [alg_hom.comp_apply, bind‚ÇÅ_X_right], }
intro i
simp only [alg_hom.comp_apply, bind‚ÇÅ_X_right]
intros
simp [supported_eq_adjoin_X]
intros
rw [‚Üê C_0]; exact total_degree_C (0 : R)
rw [‚Üê C_0]
exact total_degree_C (0 : R)
intros
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
intros
{ refine le_trans _ h, simp }
refine le_trans _ h
simp
intros
{ dunfold decreasing_induction, rw [le_rec_on_succ'] }
dunfold decreasing_induction
rw [le_rec_on_succ']
intros
induction n; simp *
induction n
simp *
simp *
intros
simp [of_digits]
intros
have b2 : 2 ‚â§ b := by linarith
refine ‚ü®_, b2, n0‚ü©
rw [nat.digits_def' b2 n0, nat.mod_eq_of_lt nb, (nat.div_eq_zero_iff (by linarith : 0 < b)).2 nb, nat.digits_zero]
intros
rw [‚Üê some_eq_coe]
rw [‚Üê some_eq_coe]; trivial
trivial
intros
rw [modeq_iff_dvd, int.coe_nat_add, int.coe_nat_add, add_sub_comm]
exact dvd_add h‚ÇÅ.dvd h‚ÇÇ.dvd
intros
simp [not_or_distrib] with parity_simps
intros
split
intro h
{ intro h, convert min_fac_dvd _, rw h, }
convert min_fac_dvd _
rw h
intro h
{ intro h, have ub := min_fac_le_of_dvd (le_refl 2) h, have lb := min_fac_pos n, cases h : n.min_fac with m, { rw h at lb, cases lb, }, { cases m with m, { simp at h, subst h, cases h with n h, cases n; cases h, }, { cases m with m, { refl, }, { rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, } } } }
have ub := min_fac_le_of_dvd (le_refl 2) h
have lb := min_fac_pos n
cases h : n.min_fac with m
{ rw h at lb, cases lb, }
rw h at lb
cases lb
cases m with m
{ cases m with m, { simp at h, subst h, cases h with n h, cases n; cases h, }, { cases m with m, { refl, }, { rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, } } }
{ simp at h, subst h, cases h with n h, cases n; cases h, }
simp at h
subst h
cases h with n h
cases n
cases n; cases h
cases h
cases h
cases m with m
{ cases m with m, { refl, }, { rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, } }
refl
{ refl, }
rw h at ub
{ rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, }
cases ub with _ ub
cases ub with _ ub
cases ub
intros
rw ‚Üê e
refine ‚ü®nat.succ_pos _, (lt_of_le_of_ne (lt_of_le_of_ne _ _ : k+1+k < _) min_fac_ne_bit0.symm : bit0 (k+1) < _)‚ü©
{ rw add_right_comm, exact h.2 }
rw add_right_comm
exact h.2
{ rw add_right_comm, exact np.symm }
rw add_right_comm
exact np.symm
intros
rw sqrt_aux; simp
rw sqrt_aux
simp
intros
rw [‚Üê cast_to_int m, ‚Üê cast_to_int n, int.cast_inj, to_int_inj]
intros
simp
intros
cases o; simp
cases o
simp
simp
intros
induction t generalizing a‚ÇÅ a‚ÇÇ h h_mem
{ contradiction }
contradiction
have t_ih_l' := t_ih_l h.left
{ have t_ih_l' := t_ih_l h.left, have t_ih_r' := t_ih_r h.right, clear t_ih_l t_ih_r, unfold has_mem.mem mem at h_mem, unfold erase, cases (cmp_le x t_x); simp [mem._match_1] at h_mem; simp [erase._match_1], { have t_ih_l := t_ih_l' h_mem, clear t_ih_l' t_ih_r', have t_l_h := valid'.erase_aux x h.left, cases t_l_h with t_l_valid t_l_size, rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1))), rw [t_ih_l, h.sz.1], have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem, cases t_l.size with t_l_size, { cases h_pos_t_l_size }, simp [nat.succ_add] }, { rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1], refl }, { have t_ih_r := t_ih_r' h_mem, clear t_ih_l' t_ih_r', have t_r_h := valid'.erase_aux x h.right, cases t_r_h with t_r_valid t_r_size, rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1))), rw [t_ih_r, h.sz.1], have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem, cases t_r.size with t_r_size, { cases h_pos_t_r_size }, simp [nat.succ_add, nat.add_succ] } }
have t_ih_r' := t_ih_r h.right
clear t_ih_l t_ih_r
unfold has_mem.mem mem at h_mem
unfold erase
cases (cmp_le x t_x); simp [mem._match_1] at h_mem; simp [erase._match_1]
cases (cmp_le x t_x); simp [mem._match_1] at h_mem
cases (cmp_le x t_x)
simp [mem._match_1] at h_mem
simp [erase._match_1]
have t_ih_l := t_ih_l' h_mem
{ have t_ih_l := t_ih_l' h_mem, clear t_ih_l' t_ih_r', have t_l_h := valid'.erase_aux x h.left, cases t_l_h with t_l_valid t_l_size, rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1))), rw [t_ih_l, h.sz.1], have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem, cases t_l.size with t_l_size, { cases h_pos_t_l_size }, simp [nat.succ_add] }
clear t_ih_l' t_ih_r'
have t_l_h := valid'.erase_aux x h.left
cases t_l_h with t_l_valid t_l_size
rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1)))
rw [t_ih_l, h.sz.1]
have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem
cases t_l.size with t_l_size
cases h_pos_t_l_size
{ cases h_pos_t_l_size }
simp [nat.succ_add]
simp [mem._match_1] at h_mem
simp [erase._match_1]
{ rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1], refl }
rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1]
refl
simp [mem._match_1] at h_mem
simp [erase._match_1]
have t_ih_r := t_ih_r' h_mem
{ have t_ih_r := t_ih_r' h_mem, clear t_ih_l' t_ih_r', have t_r_h := valid'.erase_aux x h.right, cases t_r_h with t_r_valid t_r_size, rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1))), rw [t_ih_r, h.sz.1], have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem, cases t_r.size with t_r_size, { cases h_pos_t_r_size }, simp [nat.succ_add, nat.add_succ] }
clear t_ih_l' t_ih_r'
have t_r_h := valid'.erase_aux x h.right
cases t_r_h with t_r_valid t_r_size
rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1)))
rw [t_ih_r, h.sz.1]
have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem
cases t_r.size with t_r_size
cases h_pos_t_r_size
{ cases h_pos_t_r_size }
simp [nat.succ_add, nat.add_succ]
intros
cases m; simp [node4_r, all_node', all, all_node3_r, and_assoc]
cases m
simp [node4_r, all_node', all, all_node3_r, and_assoc]
simp [node4_r, all_node', all, all_node3_r, and_assoc]
intros
rw [show f = id, from funext H]; exact id_map o
rw [show f = id, from funext H]
exact id_map o
intros
apply ext'; intro n; refl
apply ext'; intro n
apply ext'
intro n
refl
intros
induction n with n ih; [refl, rw [pow_succ', pow_succ, mul_coe, mul_comm, ih]]
induction n with n ih
refl
rw [pow_succ', pow_succ, mul_coe, mul_comm, ih]
intros
have := prod_of_pnat_multiset (l : multiset ‚Ñï+) h
{ have := prod_of_pnat_multiset (l : multiset ‚Ñï+) h, rw [multiset.coe_prod] at this, exact this }
rw [multiset.coe_prod] at this
exact this
intros
rw [coeff_X, if_neg hn.symm]
intros
rw ‚Üê finset.card_range (p.nat_degree + 1)
exact finset.card_le_of_subset supp_subset_range_nat_degree_succ
intros
by_cases hn : n = 0
rw [hn, pow_zero, ‚ÜêC_1, ‚Üêring_hom.map_sub, nat_degree_C]
{ rw [hn, pow_zero, ‚ÜêC_1, ‚Üêring_hom.map_sub, nat_degree_C] }
exact nat_degree_eq_of_degree_eq_some (degree_X_pow_sub_C (pos_iff_ne_zero.mpr hn) r)
{ exact nat_degree_eq_of_degree_eq_some (degree_X_pow_sub_C (pos_iff_ne_zero.mpr hn) r) }
intros
apply coeff_eq_zero_of_trailing_degree_lt
by_cases hp : p = 0
rw [hp, trailing_degree_zero]
{ rw [hp, trailing_degree_zero], exact with_top.coe_lt_top n, }
exact with_top.coe_lt_top n
rwa [trailing_degree_eq_nat_trailing_degree hp, with_top.coe_lt_coe]
{ rwa [trailing_degree_eq_nat_trailing_degree hp, with_top.coe_lt_coe] }
intros
induction k with k ih generalizing f
{ simp [nat.iterate], }
simp [nat.iterate]
{ simp [nat.iterate, ih], }
simp [nat.iterate, ih]
intros
intro
{ intro, simp [integral_normalization, coeff_monomial, mem_support_iff] {contextual := tt} }
simp [integral_normalization, coeff_monomial, mem_support_iff] {contextual := tt}
intros
obtain ‚ü®r, rfl‚ü© := set.mem_range.1 h
use C r
simp only [coe_map_ring_hom, map_C, set.mem_univ, subsemiring.coe_top, eq_self_iff_true, and_self]
intros
simpa [sub_eq_add_neg] using monic_X_pow_add (show degree (-p) ‚â§ n, by rwa ‚Üêdegree_neg p at H)
intros
set f' := f.comp (to_finsupp_iso R).symm.to_ring_hom with hf'
set g' := g.comp (to_finsupp_iso R).symm.to_ring_hom with hg'
have A : f' = g'
ext
{ ext, { simp [h‚ÇÅ, ring_equiv.to_ring_hom_eq_coe] }, { simpa [ring_equiv.to_ring_hom_eq_coe] using h‚ÇÇ, } }
{ simp [h‚ÇÅ, ring_equiv.to_ring_hom_eq_coe] }
simp [h‚ÇÅ, ring_equiv.to_ring_hom_eq_coe]
{ simpa [ring_equiv.to_ring_hom_eq_coe] using h‚ÇÇ, }
simpa [ring_equiv.to_ring_hom_eq_coe] using h‚ÇÇ
have B : f = f'.comp (to_finsupp_iso R)
rw [hf', ring_hom.comp_assoc]
rw [hf', ring_hom.comp_assoc]
{ rw [hf', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
{ rw [hf', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
ext x
ext x
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
have C : g = g'.comp (to_finsupp_iso R)
rw [hg', ring_hom.comp_assoc]
rw [hg', ring_hom.comp_assoc]
{ rw [hg', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
{ rw [hg', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
ext x
ext x
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
rw [B, C, A]
intros
rw root_multiplicity_eq_multiplicity
split_ifs
refl
{ refl }
rw [‚Üê enat.coe_inj, enat.coe_get, multiplicity.multiplicity_eq_zero_of_not_dvd, nat.cast_zero]
intro hdvd
exact h (dvd_iff_is_root.mp hdvd)
intros
split
intro h
{ intro h, have key : p.nat_degree = 0 ‚à® q.nat_degree = 0, { rw [‚Üêmul_eq_zero, ‚Üênat_degree_comp, h, nat_degree_zero] }, replace key := or.imp eq_C_of_nat_degree_eq_zero eq_C_of_nat_degree_eq_zero key, cases key, { rw [key, C_comp] at h, exact or.inl (key.trans h) }, { rw [key, comp_C, C_eq_zero] at h, exact or.inr ‚ü®h, key‚ü© }, }
have key : p.nat_degree = 0 ‚à® q.nat_degree = 0
{ rw [‚Üêmul_eq_zero, ‚Üênat_degree_comp, h, nat_degree_zero] }
rw [‚Üêmul_eq_zero, ‚Üênat_degree_comp, h, nat_degree_zero]
replace key := or.imp eq_C_of_nat_degree_eq_zero eq_C_of_nat_degree_eq_zero key
cases key
rw [key, C_comp] at h
{ rw [key, C_comp] at h, exact or.inl (key.trans h) }
exact or.inl (key.trans h)
rw [key, comp_C, C_eq_zero] at h
{ rw [key, comp_C, C_eq_zero] at h, exact or.inr ‚ü®h, key‚ü© }
exact or.inr ‚ü®h, key‚ü©
exact Œª h, or.rec (Œª h, by rw [h, zero_comp]) (Œª h, by rw [h.2, comp_C, h.1, C_0]) h
{ exact Œª h, or.rec (Œª h, by rw [h, zero_comp]) (Œª h, by rw [h.2, comp_C, h.1, C_0]) h }
intros
rw [cofix.corec‚ÇÅ,cofix.dest_corec',‚Üê h]; refl
rw [cofix.corec‚ÇÅ,cofix.dest_corec',‚Üê h]
refl
intros
{ cases q‚ÇÅ, cases q‚ÇÇ, apply mk_pnat_denom_dvd }
cases q‚ÇÅ
cases q‚ÇÇ
apply mk_pnat_denom_dvd
intros
rw [(eq_sub_of_add_eq $ int.mod_add_div n d), rat.floor_int_div_nat_eq_div]
intros
simp [cantor_function_aux, h]
intros
simpa only [mul_comm] using infi_mul h
intros
{ simp only [mul_comm a], exact sub_mul h }
simp only [mul_comm a]
exact sub_mul h
have := nat.prime.irrational_sqrt (show nat.prime 5, by norm_num)
have := this.rat_sub 1
have := this.rat_mul (show (0.5 : ‚Ñö) ‚â† 0, by norm_num)
convert this
field_simp
intros
simp only [irrational, rat.forall, cast_mk, not_exists, set.mem_range, cast_coe_int, cast_div, eq_comm]
intros
rw [‚Üê nnreal.coe_lt_coe, real.coe_to_nnreal r ha]
intros
simp [nnabs]
intros
simp [sqrt, real.to_nnreal_eq_zero.2 h]
intros
rw [sq, sqrt_mul_self x]
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
simp only [subset_def, ‚Üê forall_and_distrib]
refine forall_congr (Œª x, _)
by_cases hx : x ‚àà t; simp [*, set.ite]
by_cases hx : x ‚àà t
simp [*, set.ite]
simp [*, set.ite]
intros
simp
intros
ext ‚ü®x, y‚ü©
{ ext ‚ü®x, y‚ü©, simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt} }
simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt}
intros
simp [pi, or_imp_distrib, forall_and_distrib, set_of_and]
intros
ext
split
rintro ‚ü®_, ‚ü®a, b, ha, hb, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®_, ‚ü®a, b, ha, hb, rfl‚ü©, rfl‚ü©, refine ‚ü®a, b, ha, hb, rfl‚ü© }
refine ‚ü®a, b, ha, hb, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
{ rintro ‚ü®a, b, ha, hb, rfl‚ü©, refine ‚ü®_, ‚ü®a, b, ha, hb, rfl‚ü©, rfl‚ü© }
refine ‚ü®_, ‚ü®a, b, ha, hb, rfl‚ü©, rfl‚ü©
intros
haveI := (Œª a, (ht a).to_encodable); rw Union_eq_range_sigma; apply countable_range
haveI := (Œª a, (ht a).to_encodable); rw Union_eq_range_sigma
haveI := (Œª a, (ht a).to_encodable)
rw Union_eq_range_sigma
apply countable_range
intros
rw ‚Üê bUnion_range
exact h.bUnion (Œª y hy, y.finite_to_set)
intros
rwa [surj_on, ‚Üê H.image_eq]
intros
simp
intros
rw [‚Üê Iic_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 right_mem_Iic)]
intros
ext1 x
simp_rw [mem_union, mem_Icc, mem_Ici, min_le_iff]
by_cases hc : c ‚â§ x
{ tauto }
tauto
have hxb : x ‚â§ b := (le_of_not_ge hc).trans h‚ÇÅ
{ have hxb : x ‚â§ b := (le_of_not_ge hc).trans h‚ÇÅ, tauto }
tauto
intros
simp [‚Üê Ioi_inter_Iio, inter_comm]
intros
simp
intros
simpa only [mul_comm] using preimage_mul_const_Iio_of_neg a h
intros
have : Ioc m (y i‚ÇÄ) = Ioi m ‚à© Ioc (x i‚ÇÄ) (y i‚ÇÄ)
rw [‚Üê Ioi_inter_Iic, ‚Üê Ioi_inter_Iic, ‚Üê inter_assoc, inter_eq_self_of_subset_left (Ioi_subset_Ioi hm)]
rw [‚Üê Ioi_inter_Iic, ‚Üê Ioi_inter_Iic, ‚Üê inter_assoc, inter_eq_self_of_subset_left (Ioi_subset_Ioi hm)]
simp_rw [univ_pi_update i‚ÇÄ _ _ (Œª i z, Ioc z (y i)), ‚Üê pi_inter_compl ({i‚ÇÄ} : set Œπ), singleton_pi', ‚Üê inter_assoc, this]
refl
intros
simp only [‚Üê preimage_mul_const_interval ha, mul_comm]
intros
{ ext, simp }
ext
simp
intros
obtain ‚ü®x, m, -‚ü© := exists_set_mem_of_union_eq_top t s w H.some
exact ‚ü®x, m‚ü©
intros
simp only [eq_univ_iff_forall, mem_sUnion]
intros
rw sup_eq_eqv_gen; refl
rw sup_eq_eqv_gen
refl
intros
classical
rw other_eq_other' at hb ‚ä¢
convert other_invol' ha hb
rw other_eq_other'
intros
rw [nth_eq_nth_le]; exact list.nth_le_mem _ _ _
rw [nth_eq_nth_le]
exact list.nth_le_mem _ _ _
intros
cases v
cases v; refl
refl
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
refl
intros
induction h
case in_closure.basic : a ha { existsi ([a]), simp [ha] }
existsi ([])
case in_closure.one { existsi ([]), simp }
simp
case in_closure.mul : a b _ _ ha hb { rcases ha with ‚ü®la, ha, eqa‚ü©, rcases hb with ‚ü®lb, hb, eqb‚ü©, existsi (la ++ lb), simp [eqa.symm, eqb.symm, or_imp_distrib], exact assume a, ‚ü®ha a, hb a‚ü© }
intros
simpa only [h.comp_eq] using bij_on_fixed_pts_comp f g
intros
haveI := char_is_prime_of_pos R p
obtain ‚ü®a, b, hab‚ü© := zmod.sq_add_sq p x
refine ‚ü®a.val, b.val, _‚ü©
simpa using congr_arg (zmod.cast_hom dvd_rfl R) hab
intros
obtain ‚ü®m, rfl‚ü© := hf.2
use m
rw nat_degree_expand
intros
convert dim_mul_dim' F K A; rw lift_id
convert dim_mul_dim' F K A
rw lift_id
rw lift_id
rw lift_id
intros
{ convert dist_orthocenter_reflection_circumcenter _ h, simp }
convert dist_orthocenter_reflection_circumcenter _ h
simp
intros
{ simp only [chart, mem_prod], mfld_set_tac }
simp only [chart, mem_prod]
mfld_set_tac
intros
apply times_cont_mdiff_of_support (Œª x hx, _)
have : x ‚àà (chart_at H c).source
calc x ‚àà closure (support (Œª x, f x ‚Ä¢ g x)) : hx ... ‚äÜ closure (support f) : closure_mono (support_smul_subset_left _ _) ... ‚äÜ (chart_at _ c).source : f.closure_support_subset_chart_at_source
exact f.smooth_at.smul ((hg _ this).times_cont_mdiff_at $ is_open.mem_nhds (chart_at _ _).open_source this)
intros
split
assume x hx
{ assume x hx, simp only with mfld_simps at hx, exact ((he'.mdifferentiable_at hx.2).comp _ (he.mdifferentiable_at hx.1)).mdifferentiable_within_at }
simp only with mfld_simps at hx
exact ((he'.mdifferentiable_at hx.2).comp _ (he.mdifferentiable_at hx.1)).mdifferentiable_within_at
assume x hx
{ assume x hx, simp only with mfld_simps at hx, exact ((he.symm.mdifferentiable_at hx.2).comp _ (he'.symm.mdifferentiable_at hx.1)).mdifferentiable_within_at }
simp only with mfld_simps at hx
exact ((he.symm.mdifferentiable_at hx.2).comp _ (he'.symm.mdifferentiable_at hx.1)).mdifferentiable_within_at
intros
simp only [tangent_map_within] with mfld_simps
rw mfderiv_within_subset st hs h
intros
rw ext_chart_at_source
{ rw ext_chart_at_source, exact fs.mem_chart_at_source_of_eq_one h }
exact fs.mem_chart_at_source_of_eq_one h
intros
rw [ext_chart_at_map_nhds_within_eq_image' I x hy, nhds_within_inter, ‚Üê nhds_within_ext_chart_target_eq' _ _ hy, ‚Üê nhds_within_inter, (ext_chart_at I x).image_source_inter_eq', inter_comm]
intros
rw [times_cont_mdiff_within_at, lift_prop_within_at, times_cont_diff_within_at_prop]
congr' 3
mfld_set_tac
intros
ext
ext; refl
refl
intros
rw mk_eq_monoid_of_mk'_apply; exact mul_equiv_of_quotient_symm_mk' _ _
rw mk_eq_monoid_of_mk'_apply
exact mul_equiv_of_quotient_symm_mk' _ _
intros
rw mul_comm
show _ * (_ * _) = _ ‚Üî _
rw [‚Üêmul_assoc, mul_inv_left hg, mul_comm]
intros
simp [‚Üê order_of_of_add_eq_add_order_of, of_add_nsmul, order_of_pow'' _ n (is_of_fin_order_of_add_iff.mpr h)]
intros
{ convert iff.rfl, simp [is_periodic_pt_mul_iff_pow_eq_one] }
convert iff.rfl
simp [is_periodic_pt_mul_iff_pow_eq_one]
intros
suffices h : support (swap a b * swap a c) = {a, b, c}
rw [‚Üêcard_support_eq_three_iff, h]
{ rw [‚Üêcard_support_eq_three_iff, h], simp [ab, ac, bc] }
simp [ab, ac, bc]
apply le_antisymm ((support_mul_le _ _).trans (Œª x, _)) (Œª x hx, _)
{ simp [ab, ac, bc] }
simp [ab, ac, bc]
simp only [finset.mem_insert, finset.mem_singleton] at hx
{ simp only [finset.mem_insert, finset.mem_singleton] at hx, rw mem_support, simp only [perm.coe_mul, function.comp_app, ne.def], obtain rfl | rfl | rfl := hx, { rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm], exact ac.symm }, { rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right], exact ab }, { rw [swap_apply_right, swap_apply_left], exact bc } }
rw mem_support
simp only [perm.coe_mul, function.comp_app, ne.def]
obtain rfl | rfl | rfl := hx
rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm]
{ rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm], exact ac.symm }
exact ac.symm
rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right]
{ rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right], exact ab }
exact ab
rw [swap_apply_right, swap_apply_left]
{ rw [swap_apply_right, swap_apply_left], exact bc }
exact bc
intros
refine ‚ü®Œª h, _, Œª h, by simpa using (is_cycle_cycle_of _ h).two_le_card_support‚ü©
contrapose! h
rw ‚Üêcycle_of_eq_one_iff at h
simp [h]
intros
rw [cycle_range_of_le h.le, if_neg h.ne]
intros
obtain ‚ü®n, rfl‚ü© := h
exact (form_perm_rotate l hd n).symm
intros
simp [equiv.perm.extend_domain]
intros
rw [range_eq_map, ‚Üê set_like.coe_set_eq, coe_map, subgroup.coe_subtype]
{ rw [range_eq_map, ‚Üê set_like.coe_set_eq, coe_map, subgroup.coe_subtype], ext, simp }
ext
simp
intros
rw mem_direction_iff_eq_vsub ‚ü®p, hp‚ü© at hv
rcases hv with ‚ü®p1, hp1, p2, hp2, hv‚ü©
rw hv
convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp
rw one_smul
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_right k (set.mem_image_of_mem p hi), ‚Üêset.insert_eq_of_mem hi, ‚Üêset.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
intros
rw sum_centroid_weights_indicator
exact s.sum_centroid_weights_eq_one_of_card_eq_add_one k h
intros
cases is_empty_or_nonempty Œπ with h h
haveI := h
{ haveI := h, apply affine_independent_of_subsingleton, }
apply affine_independent_of_subsingleton
obtain ‚ü®i‚ü© := h
rw affine_independent_iff_linear_independent_vsub k p i
simp_rw [affine_independent_iff_linear_independent_vsub k (f ‚àò p) i, function.comp_app, ‚Üê f.linear_map_vsub] at hai
exact linear_independent.of_comp f.linear hai
intros
rcases h‚ÇÄ.eq_or_lt with (rfl|h‚ÇÄ)
simpa
{ simpa }
exact (line_map_mono_left ha.le h‚ÇÅ).trans_lt (line_map_strict_mono_right hb h‚ÇÄ)
intros
apply œÉ.induction_on' (Œª œÉ, _)
dsimp only [quotient.lift_on'_mk', quotient.map'_mk', mul_action.quotient.smul_mk, dom_coprod.summand]
rw [perm.sign_mul, perm.sign_swap hij]
simp only [one_mul, units.neg_mul, function.comp_app, units.neg_smul, perm.coe_mul, units.coe_neg, multilinear_map.smul_apply, multilinear_map.neg_apply, multilinear_map.dom_dom_congr_apply, multilinear_map.dom_coprod_apply]
convert add_right_neg _; { ext k, rw equiv.apply_swap_eq_self hv }
convert add_right_neg _
{ ext k, rw equiv.apply_swap_eq_self hv }
{ ext k, rw equiv.apply_swap_eq_self hv }
ext k
rw equiv.apply_swap_eq_self hv
intros
rw [‚Üêsingleton_zero, span_singleton_eq_bot]
intros
rw [‚Üê map_top, of_le, linear_map.map_cod_restrict, map_top, range_subtype]
intros
obtain ‚ü®g, hg‚ü© := hf.has_right_inverse
suffices : left_inverse (fun_left R M g) (fun_left R M f)
{ exact this.injective }
exact this.injective
intro x
rw [‚Üêlinear_map.comp_apply, ‚Üê fun_left_comp, hg.id, fun_left_id]
intros
ext M
{ ext M, simp only [matrix.to_bilin_apply, matrix.to_bilin'_apply, pi.basis_fun_repr] }
simp only [matrix.to_bilin_apply, matrix.to_bilin'_apply, pi.basis_fun_repr]
intros
unfold linear_map.det
split_ifs with h
convert hb _ h.some_spec.some
{ convert hb _ h.some_spec.some, apply det_aux_def' }
apply det_aux_def'
{ exact h1 }
exact h1
intros
simp only [le_dim_iff_exists_linear_independent, cardinal.mk_eq_nat_iff_finset]
split
rintro ‚ü®s, ‚ü®t, rfl, rfl‚ü©, si‚ü©
{ rintro ‚ü®s, ‚ü®t, rfl, rfl‚ü©, si‚ü©, exact ‚ü®t, rfl, si‚ü© }
exact ‚ü®t, rfl, si‚ü©
rintro ‚ü®s, rfl, si‚ü©
{ rintro ‚ü®s, rfl, si‚ü©, exact ‚ü®s, ‚ü®s, rfl, rfl‚ü©, si‚ü© }
exact ‚ü®s, ‚ü®s, rfl, rfl‚ü©, si‚ü©
intros
rw [‚Üê b.to_dual_total_left, b.total_repr]
intros
rw [finrank_dual_annihilator_comap_eq, W.quot_equiv_annihilator.finrank_eq.symm, add_comm, submodule.finrank_quotient_add_finrank, subspace.dual_finrank_eq]
intros
{ rw ‚Üê algebra.top_to_submodule, refl }
rw ‚Üê algebra.top_to_submodule
refl
intros
have : module.rank K (Œπ ‚Üí K) = fintype.card Œπ := dim_fun'
rwa [‚Üê finrank_eq_dim, nat_cast_inj] at this
intros
rw [range_eq_top, ker_eq_bot, injective_iff_surjective]
intros
ext l
ext l; simp [total_apply, finsupp.sum_map_domain_index, add_smul, h]
simp [total_apply, finsupp.sum_map_domain_index, add_smul, h]
intros
rw linear_independent_iff'' at hv ‚ä¢
intros s g hgs hsum i
rw ‚Üê (w i).mul_left_eq_zero
refine hv s (Œª i, g i ‚Ä¢ w i) (Œª i hi, _) _ i
dsimp only
{ dsimp only, exact (hgs i hi).symm ‚ñ∏ zero_smul _ _ }
exact (hgs i hi).symm ‚ñ∏ zero_smul _ _
rw [‚Üê hsum, finset.sum_congr rfl _]
{ rw [‚Üê hsum, finset.sum_congr rfl _], intros, erw [pi.smul_apply, smul_assoc], refl }
intros
erw [pi.smul_apply, smul_assoc]
refl
intros
erw [sup_apply _ ‚ü®x', hx'‚ü© ‚ü®c ‚Ä¢ x, _‚ü©, mk_span_singleton_apply]
refl
exact mem_span_singleton.2 ‚ü®c, rfl‚ü©
intros
simp only [charmatrix, sub_left_inj, pi.sub_apply, scalar_apply_eq, ring_hom.map_matrix_apply, map_apply, dmatrix.sub_apply]
intros
haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
exact det_eq_elem_of_subsingleton _ _
intros
rw [‚Üê det_transpose, det_succ_row _ j]
{ rw [‚Üê det_transpose, det_succ_row _ j], refine finset.sum_congr rfl (Œª i _, _), rw [add_comm, ‚Üê det_transpose, transpose_apply, transpose_minor, transpose_transpose] }
refine finset.sum_congr rfl (Œª i _, _)
rw [add_comm, ‚Üê det_transpose, transpose_apply, transpose_minor, transpose_transpose]
intros
rw [cramer_apply, det_eq_elem_of_subsingleton _ i, update_column_self]
intros
{ ext, simp [linear_map.one_apply, std_basis_apply] }
ext
simp [linear_map.one_apply, std_basis_apply]
intros
simp_rw [linear_map.to_matrix_alg_equiv_apply, basis.reindex_range_self, basis.reindex_range_repr]
intros
simp [transvection, matrix.mul_add, mul_comm]
intros
simp [transvection]
intros
ext
ext; simp
simp
intros
rw eq_top_iff
rintro ‚ü®m, n‚ü© -
rw [show (m, n) = (m, 0) + (0, n), by simp]
apply submodule.add_mem (submodule.fst R M M‚ÇÇ ‚äî submodule.snd R M M‚ÇÇ)
exact submodule.mem_sup_left (submodule.mem_comap.mpr (by simp))
{ exact submodule.mem_sup_left (submodule.mem_comap.mpr (by simp)), }
exact submodule.mem_sup_right (submodule.mem_comap.mpr (by simp))
{ exact submodule.mem_sup_right (submodule.mem_comap.mpr (by simp)), }
intros
split
rintros x ‚ü®hpx, hfx‚ü©
{ rintros x ‚ü®hpx, hfx‚ü©, erw [set_like.mem_coe, mem_ker, hf ‚ü®x, hpx‚ü©, mk_eq_zero] at hfx, simp only [hfx, set_like.mem_coe, zero_mem] }
erw [set_like.mem_coe, mem_ker, hf ‚ü®x, hpx‚ü©, mk_eq_zero] at hfx
simp only [hfx, set_like.mem_coe, zero_mem]
intros x hx
{ intros x hx, rw [mem_sup'], refine ‚ü®f x, ‚ü®x - f x, _‚ü©, add_sub_cancel'_right _ _‚ü©, rw [mem_ker, linear_map.map_sub, hf, sub_self] }
rw [mem_sup']
refine ‚ü®f x, ‚ü®x - f x, _‚ü©, add_sub_cancel'_right _ _‚ü©
rw [mem_ker, linear_map.map_sub, hf, sub_self]
intros
simp [associated_apply, ‚Üêpolar_to_quadratic_form, polar]
intros
ext
ext; simp
simp
intros
rw [uncurry, linear_map.flip_apply, lift.tmul]
rw [uncurry, linear_map.flip_apply, lift.tmul]; refl
refl
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
{ subst h‚ÇÅ, subst h‚ÇÇ }
subst h‚ÇÅ
subst h‚ÇÇ
intros
simp_rw [ennreal.tsum_eq_supr_sum]
{ simp_rw [ennreal.tsum_eq_supr_sum], apply ae_measurable_supr, exact Œª s, finset.ae_measurable_sum s (Œª i _, h i) }
apply ae_measurable_supr
exact Œª s, finset.ae_measurable_sum s (Œª i _, h i)
intros
apply measurable_of_Iio
simp_rw [‚Üê compl_Ici, preimage_compl, measurable_set.compl_iff]
assumption
intros
refine integral_congr_ae _
filter_upwards [hf.prod_right_ae, hg.prod_right_ae]
intros x h2f h2g
simp [integral_add h2f h2g]
intros
rw [‚Üê lintegral_indicator _ hA, ‚Üê lintegral_indicator f, ‚Üê lintegral_indicator g, ‚Üê lintegral_add]
refine lintegral_mono (Œª a, _)
{ refine lintegral_mono (Œª a, _), by_cases haA : a ‚àà A, { by_cases f a ‚â§ g a, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero], simp only [le_refl, max_le_iff, and_true, h], { rintro ‚ü®_, hc‚ü©, exact false.elim ((not_lt.2 h) hc) }, { exact ‚ü®haA, h‚ü© } }, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add], simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)], { rintro ‚ü®_, hc‚ü©, exact false.elim (h hc) }, { exact ‚ü®haA, not_le.1 h‚ü© } } }, { simp [set.indicator_of_not_mem haA] } }
by_cases haA : a ‚àà A
by_cases f a ‚â§ g a
{ by_cases f a ‚â§ g a, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero], simp only [le_refl, max_le_iff, and_true, h], { rintro ‚ü®_, hc‚ü©, exact false.elim ((not_lt.2 h) hc) }, { exact ‚ü®haA, h‚ü© } }, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add], simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)], { rintro ‚ü®_, hc‚ü©, exact false.elim (h hc) }, { exact ‚ü®haA, not_le.1 h‚ü© } } }
simp only
{ simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero], simp only [le_refl, max_le_iff, and_true, h], { rintro ‚ü®_, hc‚ü©, exact false.elim ((not_lt.2 h) hc) }, { exact ‚ü®haA, h‚ü© } }
rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero]
simp only [le_refl, max_le_iff, and_true, h]
rintro ‚ü®_, hc‚ü©
{ rintro ‚ü®_, hc‚ü©, exact false.elim ((not_lt.2 h) hc) }
exact false.elim ((not_lt.2 h) hc)
exact ‚ü®haA, h‚ü©
{ exact ‚ü®haA, h‚ü© }
simp only
{ simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add], simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)], { rintro ‚ü®_, hc‚ü©, exact false.elim (h hc) }, { exact ‚ü®haA, not_le.1 h‚ü© } }
rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add]
simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)]
rintro ‚ü®_, hc‚ü©
{ rintro ‚ü®_, hc‚ü©, exact false.elim (h hc) }
exact false.elim (h hc)
exact ‚ü®haA, not_le.1 h‚ü©
{ exact ‚ü®haA, not_le.1 h‚ü© }
{ simp [set.indicator_of_not_mem haA] }
simp [set.indicator_of_not_mem haA]
exact measurable.indicator hg.1 (hA.inter (measurable_set_le hf.1 hg.1))
{ exact measurable.indicator hg.1 (hA.inter (measurable_set_le hf.1 hg.1)) }
exact measurable.indicator hf.1 (hA.inter (measurable_set_lt hg.1 hf.1))
{ exact measurable.indicator hf.1 (hA.inter (measurable_set_lt hg.1 hf.1)) }
{ exact hA.inter (measurable_set_le hf.1 hg.1) }
exact hA.inter (measurable_set_le hf.1 hg.1)
{ exact hA.inter (measurable_set_lt hg.1 hf.1) }
exact hA.inter (measurable_set_lt hg.1 hf.1)
intros
simp only [condexp_ind_L1, and.intro hs hŒºs, dif_pos, ne.def, not_false_iff, and_self]
intros
have F_le_bound := all_ae_of_real_F_le_bound h_bound
rw ‚Üê ae_all_iff at F_le_bound
apply F_le_bound.mp ((all_ae_tendsto_of_real_norm h_lim).mono _)
assume a tendsto_norm F_le_bound
exact le_of_tendsto' tendsto_norm (F_le_bound)
intros
obtain ‚ü®hf_meas_ae, hf‚ü© := hf_int
refine ‚ü®ae_measurable_of_ae_measurable_trim hm hf_meas_ae, _‚ü©
rw has_finite_integral at hf ‚ä¢
rwa lintegral_trim_ae hm _ at hf
exact @ae_measurable.coe_nnreal_ennreal Œ± m _ _ (@ae_measurable.nnnorm H Œ± _ _ _ m _ _ hf_meas_ae)
intros
ext1
refine (coe_fn_comp_Lp' (L + L') f).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
refine eventually_eq.trans _ (eventually_eq.add (L.coe_fn_comp_Lp' f).symm (L'.coe_fn_comp_Lp' f).symm)
refine eventually_of_forall (Œª x, _)
refl
intros
convert snorm_zero
intros
rw [snorm', lintegral_smul_measure, ennreal.mul_rpow_of_nonneg, snorm']
{ rw [snorm', lintegral_smul_measure, ennreal.mul_rpow_of_nonneg, snorm'], simp [hp], }
simp [hp]
intros
apply simple_func.uniform_embedding.dense_embedding
assume f
rw mem_closure_iff_seq_limit
have hfi' : mem_‚Ñíp f p Œº := Lp.mem_‚Ñíp f
refine ‚ü®Œª n, ‚Üë(to_Lp (simple_func.approx_on f (Lp.measurable f) univ 0 trivial n) (simple_func.mem_‚Ñíp_approx_on_univ (Lp.measurable f) hfi' n)), Œª n, mem_range_self _, _‚ü©
convert simple_func.tendsto_approx_on_univ_Lp hp_ne_top (Lp.measurable f) hfi'
rw to_Lp_coe_fn f (Lp.mem_‚Ñíp f)
intros
rcases l with ‚ü®l‚ü©
{ rcases l with ‚ü®l‚ü©, simpa using l.measurable_prod' (by simpa using hl) }
simpa using l.measurable_prod' (by simpa using hl)
intros
simp_rw [mul_comm, lintegral_const_mul' r f hr]
intros
rw [‚Üê lintegral_add_measure, measure.restrict_add_restrict_compl hA]
intros
rw [restrict_lintegral_eq_lintegral_restrict _ hs, const_lintegral_restrict]
intros
ext1
refine (ae_restrict_of_ae (Lp.coe_fn_add f g)).mp _
refine (Lp.coe_fn_add (mem_‚Ñíp.to_Lp f ((Lp.mem_‚Ñíp f).restrict s)) (mem_‚Ñíp.to_Lp g ((Lp.mem_‚Ñíp g).restrict s))).mp _
refine (mem_‚Ñíp.coe_fn_to_Lp ((Lp.mem_‚Ñíp f).restrict s)).mp _
refine (mem_‚Ñíp.coe_fn_to_Lp ((Lp.mem_‚Ñíp g).restrict s)).mp _
refine (mem_‚Ñíp.coe_fn_to_Lp ((Lp.mem_‚Ñíp (f+g)).restrict s)).mono (Œª x hx1 hx2 hx3 hx4 hx5, _)
rw [hx4, hx1, pi.add_apply, hx2, hx3, hx5, pi.add_apply]
intros
casesI is_empty_or_nonempty Œ≤
{ exact measurable_of_empty f }
exact measurable_of_empty f
convert measurable_const
{ convert measurable_const, exact funext (Œª x, hf x h.some) }
exact funext (Œª x, hf x h.some)
intros
have := Œº.sup_disjoint' ‚ä• ‚ä•
simpa [apply_eq_coe_to_fun] using this
intros
let eval : (compacts G ‚Üí ‚Ñù) ‚Üí ‚Ñù := Œª f, f ‚ä•
have : continuous eval := continuous_apply ‚ä•
show chaar K‚ÇÄ ‚àà eval ‚Åª¬π' {(0 : ‚Ñù)}
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K‚ÇÄ ‚ü®set.univ, is_open_univ, mem_univ _‚ü©)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©
{ rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©, apply prehaar_empty }
apply prehaar_empty
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_singleton }
exact is_closed_singleton
intros
rw [add_haar_closed_ball' Œº x hr, add_haar_closed_unit_ball_eq_add_haar_unit_ball]
intros
simp only [ae_iff, ‚Üê compl_set_of, restrict_apply hp.compl]
congr' with x
simp [and_comm]
intros
simp [‚Üê restrict‚Çó_apply, restrict‚Çó, ht]
intros
rw is_caratheodory_iff_le
split
{ intros h t ht, exact h t }
intros h t ht
exact h t
intros h u
{ intros h u, conv_rhs { rw induced_outer_measure_eq_infi _ msU m_mono }, refine le_infi _, intro t, refine le_infi _, intro ht, refine le_infi _, intro h2t, refine le_trans _ (le_trans (h t ht) $ le_of_eq $ induced_outer_measure_eq' _ msU m_mono ht), refine add_le_add (mono' _ $ set.inter_subset_inter_left _ h2t) (mono' _ $ diff_subset_diff_left h2t) }
conv_rhs { rw induced_outer_measure_eq_infi _ msU m_mono }
refine le_infi _
intro t
refine le_infi _
intro ht
refine le_infi _
intro h2t
refine le_trans _ (le_trans (h t ht) $ le_of_eq $ induced_outer_measure_eq' _ msU m_mono ht)
refine add_le_add (mono' _ $ set.inter_subset_inter_left _ h2t) (mono' _ $ diff_subset_diff_left h2t)
intros
refine restrict_le_restrict_of_subset_le v w (Œª a ha‚ÇÅ ha‚ÇÇ, _)
have ha‚ÇÉ : (‚ãÉ n, a ‚à© disjointed f n) = a
rwa [‚Üê inter_Union, Union_disjointed, inter_eq_left_iff_subset]
{ rwa [‚Üê inter_Union, Union_disjointed, inter_eq_left_iff_subset] }
have ha‚ÇÑ : pairwise (disjoint on (Œª n, a ‚à© disjointed f n))
exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) }
rw [‚Üê ha‚ÇÉ, v.of_disjoint_Union_nat _ ha‚ÇÑ, w.of_disjoint_Union_nat _ ha‚ÇÑ]
refine tsum_le_tsum (Œª n, (restrict_le_restrict_iff v w (hf‚ÇÅ n)).1 (hf‚ÇÇ n) _ _) _ _
{ exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)) }
exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n))
{ exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
{ exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
exact set.subset.trans (set.inter_subset_right _ _) (disjointed_subset _ _)
{ exact set.subset.trans (set.inter_subset_right _ _) (disjointed_subset _ _) }
refine (v.m_Union (Œª n, _) _).summable
{ refine (v.m_Union (Œª n, _) _).summable, { exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }, { exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) } }
{ exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)) }
exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n))
{ exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
{ exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) }
exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) }
refine (w.m_Union (Œª n, _) _).summable
{ refine (w.m_Union (Œª n, _) _).summable, { exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }, { exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) } }
{ exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)) }
exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n))
{ exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
{ exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) }
exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (Œª i j, disjoint.mono inf_le_right inf_le_right) }
intro n
{ intro n, exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)) }
exact Œª n, ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
{ exact Œª n, ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n))
intro n
{ intro n, exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)) }
exact Œª n, ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n)
{ exact Œª n, ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n) }
exact (ha‚ÇÅ.inter (measurable_set.disjointed hf‚ÇÅ n))
intros
{ ext, simp, }
ext
simp
simp [card_factors]
ext
{ ext, simp }
simp
intros
apply is_coprime.mul_right (int.coprime_of_sq_sum (is_coprime_comm.mp h))
rw add_comm
apply int.coprime_of_sq_sum h
intros
rw [‚Üê norm_int_le_pow_iff_dvd, norm_le_pow_iff_mem_span_pow, ideal.mem_span_singleton]
intros
apply @nat.cast_injective ‚Ñ§
push_cast
exact padic_val_rat.pow _ (cast_ne_zero.mpr hq)
intros
simp [cast_eq_of_rat]
intros
cases int.mod_two_eq_zero_or_one x with hx hx
cases int.mod_two_eq_zero_or_one x with hx hx; cases int.mod_two_eq_zero_or_one y with hy hy
cases int.mod_two_eq_zero_or_one y with hy hy
exfalso
{ exfalso, apply nat.not_coprime_of_dvd_of_dvd (dec_trivial : 1 < 2) _ _ hc, { apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hx }, { apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hy } }
apply nat.not_coprime_of_dvd_of_dvd (dec_trivial : 1 < 2) _ _ hc
{ apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hx }
apply int.dvd_nat_abs_of_of_nat_dvd
apply int.dvd_of_mod_eq_zero hx
{ apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hy }
apply int.dvd_nat_abs_of_of_nat_dvd
apply int.dvd_of_mod_eq_zero hy
{ left, exact ‚ü®hx, hy‚ü© }
left
exact ‚ü®hx, hy‚ü©
cases int.mod_two_eq_zero_or_one y with hy hy
{ right, exact ‚ü®hx, hy‚ü© }
right
exact ‚ü®hx, hy‚ü©
exfalso
{ exfalso, obtain ‚ü®x0, y0, rfl, rfl‚ü© : ‚àÉ x0 y0, x = x0* 2 + 1 ‚àß y = y0 * 2 + 1, { cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hx) with x0 hx2, cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hy) with y0 hy2, rw sub_eq_iff_eq_add at hx2 hy2, exact ‚ü®x0, y0, hx2, hy2‚ü© }, apply int.sq_ne_two_mod_four z, rw show z * z = 4 * (x0 * x0 + x0 + y0 * y0 + y0) + 2, by { rw ‚Üê h.eq, ring }, norm_num [int.add_mod] }
obtain ‚ü®x0, y0, rfl, rfl‚ü© : ‚àÉ x0 y0, x = x0* 2 + 1 ‚àß y = y0 * 2 + 1
cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hx) with x0 hx2
{ cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hx) with x0 hx2, cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hy) with y0 hy2, rw sub_eq_iff_eq_add at hx2 hy2, exact ‚ü®x0, y0, hx2, hy2‚ü© }
cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hy) with y0 hy2
rw sub_eq_iff_eq_add at hx2 hy2
exact ‚ü®x0, y0, hx2, hy2‚ü©
apply int.sq_ne_two_mod_four z
rw show z * z = 4 * (x0 * x0 + x0 + y0 * y0 + y0) + 2, by { rw ‚Üê h.eq, ring }
norm_num [int.add_mod]
intros
ext ‚ü®x_re, x_im‚ü©
simp [decompose, h]
intros
rw [infi_insert, infi_singleton]
intros
{ contrapose! h, exact csupr_le' h }
contrapose! h
exact csupr_le' h
intros
{ rw ‚Üê prod_at_bot_at_bot_eq, exact hf.prod_map_prod_at_bot hg, }
rw ‚Üê prod_at_bot_at_bot_eq
exact hf.prod_map_prod_at_bot hg
intros
simp only [‚Üê principal_singleton, has_basis_principal]
intros
simpa using (eventually_eq.sub (eventually_eq.refl l f) h).symm
intros
rw [‚Üê image_mem_map_iff inj, map_comap_of_mem large]
intros
rw [tendsto, tendsto, map_congr hl]
intros
simp only [filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]
intros
simp only [le_antisymm_iff, le_principal_iff, mem_principal]
simp only [le_antisymm_iff, le_principal_iff, mem_principal]; refl
refl
intros
lift s to finset Œπ using hs
exact_mod_cast infi_principal_finset s f
intros
refine hle.mp (h.mono $ Œª x hf hgf, _)
rw ‚Üê hfga
exact le_trans hgf hf
intros
refine ‚ü®Œª t, (hf.mem_lift_iff hg gm).trans _‚ü©
simp [sigma.exists, and_assoc, exists_and_distrib_left]
intros
simpa only [tendsto_iff_comap] using le_iff_ultrafilter
intros
simp [is_bounded, exists_true_iff_nonempty]
intros
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf; apply pi.omega_complete_partial_order.flip‚ÇÇ_continuous'; intro; apply map_continuous' _ _ hg
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf; apply pi.omega_complete_partial_order.flip‚ÇÇ_continuous'; intro
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf; apply pi.omega_complete_partial_order.flip‚ÇÇ_continuous'
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf
simp only [seq_eq_bind_map]
apply bind_continuous' _ _ hf
apply pi.omega_complete_partial_order.flip‚ÇÇ_continuous'
intro
apply map_continuous' _ _ hg
intros
exactI {..f.is_irrefl, ..f.is_trans}
intros
simp [is_wf, well_founded_on_iff]
intros
ext ‚ü®a1, a2‚ü©
rw [mem_mul_antidiagonal, finset.mem_singleton, prod.ext_iff]
split
rintro ‚ü®hast, has, hat‚ü©
{ rintro ‚ü®hast, has, hat‚ü©, cases eq_or_lt_of_le (hs.min_le hns has) with heq hlt, { refine ‚ü®heq.symm, _‚ü©, rw heq at hast, exact mul_left_cancel hast }, { contrapose hast, exact ne_of_gt (mul_lt_mul_of_lt_of_le hlt (ht.min_le hnt hat)) } }
cases eq_or_lt_of_le (hs.min_le hns has) with heq hlt
refine ‚ü®heq.symm, _‚ü©
{ refine ‚ü®heq.symm, _‚ü©, rw heq at hast, exact mul_left_cancel hast }
rw heq at hast
exact mul_left_cancel hast
contrapose hast
{ contrapose hast, exact ne_of_gt (mul_lt_mul_of_lt_of_le hlt (ht.min_le hnt hat)) }
exact ne_of_gt (mul_lt_mul_of_lt_of_le hlt (ht.min_le hnt hat))
rintro ‚ü®ha1, ha2‚ü©
{ rintro ‚ü®ha1, ha2‚ü©, rw [ha1, ha2], exact ‚ü®rfl, hs.min_mem _, ht.min_mem _‚ü© }
rw [ha1, ha2]
exact ‚ü®rfl, hs.min_mem _, ht.min_mem _‚ü©
intros
apply_instance
intros
{ rw add_comm at h, exact h.of_add_mul_left_right }
rw add_comm at h
exact h.of_add_mul_left_right
intros
rw [‚Üê coeff_zero_eq_eval_zero, ‚Üê eq_zero_iff_mem, ‚Üê coeff_map, coeff_zero_eq_eval_zero, hq, eval_mul, eval_pow, eval_X, zero_pow hn0, mul_zero]
intros
obtain ‚ü®S, hS‚ü© := h
unfreezingI { obtain ‚ü®S, hS‚ü© := h }
letI : decidable_eq M := classical.dec_eq M
use finset.bUnion S (Œª f, f.support)
have : (finset.bUnion S (Œª f, f.support) : set M) = ‚ãÉ f ‚àà S, (f.support : set M)
{ simp only [finset.set_bUnion_coe, finset.coe_bUnion] }
simp only [finset.set_bUnion_coe, finset.coe_bUnion]
rw [this]
exact support_gen_of_gen' hS
intros
rw [add_val_apply_of_ne (ne_zero_of_coeff_ne_zero h), with_top.coe_le_coe]
exact order_le_of_coeff_ne_zero h
intros
{ ext, simp [emb_domain_notin_image_support] }
ext
simp [emb_domain_notin_image_support]
intros
rintros ‚ü®u, hu‚ü©
apply hy
suffices : is_unit ((‚Üëu‚Åª¬π : R) * y)
rcases this with ‚ü®s, hs‚ü©
{ rcases this with ‚ü®s, hs‚ü©, use u * s, convert congr_arg (Œª z, (u : R) * z) hs, rw ‚Üê mul_assoc, simp }
use u * s
convert congr_arg (Œª z, (u : R) * z) hs
rw ‚Üê mul_assoc
simp
rw show (‚Üëu‚Åª¬π * y) = (1 - ‚Üëu‚Åª¬π * x), { rw eq_sub_iff_add_eq, replace hu := congr_arg (Œª z, (‚Üëu‚Åª¬π : R) * z) hu.symm, simpa [mul_add, add_comm] using hu }
apply is_unit_one_sub_self_of_mem_nonunits
exact mul_mem_nonunits_right hx
intros
rw [finite_int_iff_nat_abs_finite, finite_nat_iff, pos_iff_ne_zero, int.nat_abs_ne_zero]
intros
rcases hx with ‚ü®p, pmonic, hp‚ü©
let S : set B := ‚Üë(p.map $ algebra_map A B).frange
refine is_integral_of_mem_of_fg (adjoin R (S ‚à™ {x})) _ _ (subset_adjoin $ or.inr rfl)
refine fg_trans (fg_adjoin_of_finite (finset.finite_to_set _) (Œª x hx, _)) _
rw [finset.mem_coe, frange, finset.mem_image] at hx
{ rw [finset.mem_coe, frange, finset.mem_image] at hx, rcases hx with ‚ü®i, _, rfl‚ü©, rw coeff_map, exact is_integral_alg_hom (is_scalar_tower.to_alg_hom R A B) (A_int _) }
rcases hx with ‚ü®i, _, rfl‚ü©
rw coeff_map
exact is_integral_alg_hom (is_scalar_tower.to_alg_hom R A B) (A_int _)
apply fg_adjoin_singleton_of_integral
{ apply fg_adjoin_singleton_of_integral, exact is_integral_trans_aux _ pmonic hp }
exact is_integral_trans_aux _ pmonic hp
intros
rw [sub_eq_add_neg, multiplicity_add_of_gt]; rwa [multiplicity.neg]
rw [sub_eq_add_neg, multiplicity_add_of_gt]
{ rw [sub_eq_add_neg, multiplicity_add_of_gt]; rwa [multiplicity.neg] }
rwa [multiplicity.neg]
rwa [multiplicity.neg]
intros
{ rw h_comm.eq, exact h_comm.symm.is_nilpotent_mul_left h, }
rw h_comm.eq
exact h_comm.symm.is_nilpotent_mul_left h
intros
simp_rw [monic, leading_coeff, nat_degree_to_subring, ‚Üê coeff_to_subring p T hp]
exact ‚ü®Œª H, by { rw H, refl }, Œª H, subtype.coe_injective H‚ü©
intros
cases n
{ simp [bernstein_polynomial], }
simp [bernstein_polynomial]
{ apply derivative_succ_aux, }
apply derivative_succ_aux
intros
apply homogeneous_component_eq_zero'
rw [total_degree, finset.sup_lt_iff] at h
{ intros d hd, exact ne_of_lt (h d hd), }
intros d hd
exact ne_of_lt (h d hd)
{ exact lt_of_le_of_lt (nat.zero_le _) h, }
exact lt_of_le_of_lt (nat.zero_le _) h
intros
{ intro, simpa using left_ne_zero_of_mul }
intro
simpa using left_ne_zero_of_mul
intros
assume k
contrapose
simp only [not_mem_support_iff]
assume hk
rw [‚Üê mat_poly_equiv_coeff_apply, hk]
refl
intros
simp
intros
induction n using enat.cases_on
rw order_eq_top
{ rw order_eq_top, split, { rintro rfl, split; intros, { exfalso, exact enat.coe_ne_top ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ }, { exact (coeff _ _).map_zero } }, { rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ext i, exact h‚ÇÇ i (enat.coe_lt_top i) } }
split
rintro rfl
{ rintro rfl, split; intros, { exfalso, exact enat.coe_ne_top ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ }, { exact (coeff _ _).map_zero } }
split
split; intros
intros
{ exfalso, exact enat.coe_ne_top ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ }
exfalso
exact enat.coe_ne_top ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
intros
{ exact (coeff _ _).map_zero }
exact (coeff _ _).map_zero
{ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ext i, exact h‚ÇÇ i (enat.coe_lt_top i) }
rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
ext i
exact h‚ÇÇ i (enat.coe_lt_top i)
{ simpa [enat.coe_inj] using order_eq_nat }
simpa [enat.coe_inj] using order_eq_nat
intros
have : ¬¨single s 1 ‚â§ 0
from Œª h, by simpa using h s
simp only [X, coeff_mul_monomial, if_neg this]
intros
simp only [exp_pow_eq_rescale_exp, rescale]
ext
simp only [one_div, coeff_mk, coe_mk, coeff_exp, factorial, linear_map.map_sum]
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
simp
intros
map_fun_tac
intros
ext1 n
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
rw ‚Üê function.funext_iff at h
replace h := congr_arg (Œª fam, bind‚ÇÅ (mv_polynomial.map (int.cast_ring_hom ‚Ñö) ‚àò fam) (X_in_terms_of_W p ‚Ñö n)) h
simpa only [function.comp, map_bind‚ÇÅ, map_witt_polynomial, ‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_witt_polynomial_X_in_terms_of_W, bind‚ÇÅ_X_right] using h
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [map_rename, map_witt_structure_int, witt_structure_rat, rename_bind‚ÇÅ, rename_rename, bind‚ÇÅ_rename]
refl
intros
rcases le_mk_iff_exists_set.1 hŒ∏ with ‚ü®s, rfl‚ü©
cases infinite_pigeonhole (f ‚àò subtype.val : s ‚Üí Œ±) h‚ÇÅ h‚ÇÇ with a ha
use a
rw [‚Üêha, @preimage_comp _ _ _ subtype.val f]
apply mk_preimage_of_injective _ _ subtype.val_injective
intros
change ‚ü¶(y + -z) * x‚üß = ‚ü¶y * x‚üß + -‚ü¶z * x‚üß
{ change ‚ü¶(y + -z) * x‚üß = ‚ü¶y * x‚üß + -‚ü¶z * x‚üß, rw [quot_right_distrib, quot_neg_mul] }
rw [quot_right_distrib, quot_neg_mul]
intros
unfold collapse_F
rw well_founded.fix_eq
exact well_founded.not_lt_min _ _ _ (show b ‚àà {b | ‚àÄ a' (h : r a' a), s (collapse_F f a').1 b}, from h)
intros
rw [lt_def_le]
conv { to_lhs, simp only [le_def_lt] }
intros
cases x with xl xr xL xR
exact o.2.1 i
intros
have ae := ext_iff.2 H
simp [pair] at ae
have : x = x'
cases (ae {x}).1 (by simp) with h h
{ cases (ae {x}).1 (by simp) with h h, { exact singleton_inj h }, { have m : x' ‚àà ({x} : Set), { rw h, simp }, simp at m, simp [*] } }
{ exact singleton_inj h }
exact singleton_inj h
have m : x' ‚àà ({x} : Set)
{ have m : x' ‚àà ({x} : Set), { rw h, simp }, simp at m, simp [*] }
{ rw h, simp }
rw h
simp
simp at m
simp [*]
subst x'
have he : y = x ‚Üí y = y'
intro yx
{ intro yx, subst y, cases (ae {x, y'}).2 (by simp only [eq_self_iff_true, or_true]) with xy'x xy'xx, { rw [eq_comm, ‚Üêmem_singleton, ‚Üêxy'x, mem_pair], exact or.inr rfl }, { have yxx := (ext_iff.2 xy'xx y').1 (by simp), simp at yxx, subst y' } }
subst y
cases (ae {x, y'}).2 (by simp only [eq_self_iff_true, or_true]) with xy'x xy'xx
rw [eq_comm, ‚Üêmem_singleton, ‚Üêxy'x, mem_pair]
{ rw [eq_comm, ‚Üêmem_singleton, ‚Üêxy'x, mem_pair], exact or.inr rfl }
exact or.inr rfl
have yxx := (ext_iff.2 xy'xx y').1 (by simp)
{ have yxx := (ext_iff.2 xy'xx y').1 (by simp), simp at yxx, subst y' }
simp at yxx
subst y'
have xyxy' := (ae {x, y}).1 (by simp)
cases xyxy' with xyx xyy'
have yx := (ext_iff.2 xyx y).1 (by simp)
{ have yx := (ext_iff.2 xyx y).1 (by simp), simp at yx, simp [he yx] }
simp at yx
simp [he yx]
have yxy' := (ext_iff.2 xyy' y).1 (by simp)
{ have yxy' := (ext_iff.2 xyy' y).1 (by simp), simp at yxy', cases yxy' with yx yy', { simp [he yx] }, { simp [yy'] } }
simp at yxy'
cases yxy' with yx yy'
{ simp [he yx] }
simp [he yx]
{ simp [yy'] }
simp [yy']
intros
simp *
intros
rw [‚Üê h, ‚Üê hm, nat.add_mul_div_right _ _ (lt_of_le_of_lt (nat.zero_le _) h‚ÇÇ), nat.div_eq_of_lt h‚ÇÇ, zero_add]
intros
suffices : tendsto (range_factorization f) at_top at_top
from (Sup_convergence_class.tendsto_coe_at_top_is_lub _ _ ha).comp this
exact h_mono.range_factorization.tendsto_at_top_at_top (Œª b, b.2.imp $ Œª a ha, ha.ge)
intros
simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]
intros
simp [nhds_eq_order (‚ä•:Œ±)]
intros
convert (is_topological_basis_pi cond).inducing (inducing_infi_to_pi _)
ext V
split
rintros ‚ü®U, F, h1, h2‚ü©
{ rintros ‚ü®U, F, h1, h2‚ü©, have : (F : set Œπ).pi U = (‚ãÇ (i : Œπ) (hi : i ‚àà F), (Œª (z : Œ† j, X j), z i) ‚Åª¬π' (U i)), by { ext, simp }, refine ‚ü®(F : set Œπ).pi U, ‚ü®U, F, h1, rfl‚ü©, _‚ü©, rw [this, h2, set.preimage_Inter], congr' 1, ext1, rw set.preimage_Inter, refl }
have : (F : set Œπ).pi U = (‚ãÇ (i : Œπ) (hi : i ‚àà F), (Œª (z : Œ† j, X j), z i) ‚Åª¬π' (U i))
ext
ext
{ ext, simp }
{ ext, simp }
simp
simp
refine ‚ü®(F : set Œπ).pi U, ‚ü®U, F, h1, rfl‚ü©, _‚ü©
rw [this, h2, set.preimage_Inter]
congr' 1
ext1
rw set.preimage_Inter
refl
rintros ‚ü®U, ‚ü®U, F, h1, rfl‚ü©, h‚ü©
{ rintros ‚ü®U, ‚ü®U, F, h1, rfl‚ü©, h‚ü©, refine ‚ü®U, F, h1, _‚ü©, have : (F : set Œπ).pi U = (‚ãÇ (i : Œπ) (hi : i ‚àà F), (Œª (z : Œ† j, X j), z i) ‚Åª¬π' (U i)), by { ext, simp }, rw [‚Üê h, this, set.preimage_Inter], congr' 1, ext1, rw set.preimage_Inter, refl }
refine ‚ü®U, F, h1, _‚ü©
have : (F : set Œπ).pi U = (‚ãÇ (i : Œπ) (hi : i ‚àà F), (Œª (z : Œ† j, X j), z i) ‚Åª¬π' (U i))
ext
ext
{ ext, simp }
{ ext, simp }
simp
simp
rw [‚Üê h, this, set.preimage_Inter]
congr' 1
ext1
rw set.preimage_Inter
refl
intros
rw frontier_eq_closure_inter_closure; exact is_closed.inter is_closed_closure is_closed_closure
rw frontier_eq_closure_inter_closure
exact is_closed.inter is_closed_closure is_closed_closure
intros
rw continuous_iff_ultrafilter
intros x _ h
rw [tendsto, ‚Üê coe_map]
apply le_nhds_of_str_eq
rw [‚Üê str_hom_commute, str_eq_of_le_nhds _ x h]
intros
{ rw continuous_iff_le_induced, exact compact_open_le_induced s }
rw continuous_iff_le_induced
exact compact_open_le_induced s
intros
{ ext, simp, }
ext
simp
intros
ext
simp only [continuous_map.comp_coe, function.comp_app, continuous_map.attach_bound_apply_coe, polynomial.to_continuous_map_on_to_fun, polynomial.aeval_subalgebra_coe, polynomial.aeval_continuous_map_apply, polynomial.to_continuous_map_to_fun]
intros
assume x hx
unfold continuous_within_at
have A := (h x (h‚ÇÅ hx)).mono h‚ÇÅ
unfold continuous_within_at at A
rw ‚Üê h' hx at A
exact A.congr' h'.eventually_eq_nhds_within.symm
intros
ext
{ ext, refl }
refl
intros
rw [e.target_eq, prod_univ, mem_preimage]
intros
split
ext x
{ ext x, simp only [mem_local_triv_as_local_equiv_target] with mfld_simps, refl, }
simp only [mem_local_triv_as_local_equiv_target] with mfld_simps
refl
rintros ‚ü®x, v‚ü© hx
{ rintros ‚ü®x, v‚ü© hx, simp only [triv_change, local_triv_as_local_equiv, local_equiv.symm, true_and, prod.mk.inj_iff, prod_mk_mem_set_prod_eq, local_equiv.trans_source, mem_inter_eq, and_true, mem_preimage, proj, mem_univ, local_equiv.coe_mk, eq_self_iff_true, local_equiv.coe_trans, bundle.proj] at hx ‚ä¢, simp only [Z.coord_change_comp, hx, mem_inter_eq, and_self, mem_base_set_at], }
simp only [triv_change, local_triv_as_local_equiv, local_equiv.symm, true_and, prod.mk.inj_iff, prod_mk_mem_set_prod_eq, local_equiv.trans_source, mem_inter_eq, and_true, mem_preimage, proj, mem_univ, local_equiv.coe_mk, eq_self_iff_true, local_equiv.coe_trans, bundle.proj] at hx ‚ä¢
simp only [Z.coord_change_comp, hx, mem_inter_eq, and_self, mem_base_set_at]
intros
simp [tendsto_subtype_rng, ‚Üêsubtype.val_eq_coe, cons_val]
{ simp [tendsto_subtype_rng, ‚Üêsubtype.val_eq_coe, cons_val], exact tendsto_fst.cons (tendsto.comp continuous_at_subtype_coe tendsto_snd) }
exact tendsto_fst.cons (tendsto.comp continuous_at_subtype_coe tendsto_snd)
intros
rcases classical.em (nonempty X) with ‚ü®‚ü®x‚ü©‚ü©|hX
{ exact ‚ü®f x, f.eq_const x‚ü© }
exact ‚ü®f x, f.eq_const x‚ü©
exact ‚ü®classical.arbitrary Y, ext $ Œª x, (hX ‚ü®x‚ü©).elim‚ü©
{ exact ‚ü®classical.arbitrary Y, ext $ Œª x, (hX ‚ü®x‚ü©).elim‚ü© }
intros
rw ‚Üê sInter_range
exact dense_sInter_of_GŒ¥ (forall_range_iff.2 ‚Äπ_‚Ä∫) (countable_range _) (forall_range_iff.2 ‚Äπ_‚Ä∫)
intros
rwa [bounded_iff_ediam_ne_top, not_not] at h
intros
rw [dist_nndist, real.to_nnreal_coe]
intros
rw [continuous_at, tendsto_nhds_nhds]
intros
simp only [‚Üê tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, mem_univ, forall_const, exists_prop, nhds_within_univ]
intros
have ha : isometry (coe : p.val ‚Üí X) := isometry_subtype_coe
have hb : isometry (coe : q.val ‚Üí X) := isometry_subtype_coe
have A : dist p q = Hausdorff_dist p.val q.val := rfl
have I : p.val = range (coe : p.val ‚Üí X)
simp
simp
have J : q.val = range (coe : q.val ‚Üí X)
simp
simp
rw [I, J] at A
rw A
exact GH_dist_le_Hausdorff_dist ha hb
intros
rw Hausdorff_edist_def
refine le_trans _ le_sup_left
exact le_bsupr x h
intros
rcases hs with ‚ü®x, xs‚ü©
rcases ht with ‚ü®y, yt‚ü©
refine Hausdorff_dist_le_of_mem_dist diam_nonneg _ _
exact Œªz hz, ‚ü®y, yt, dist_le_diam_of_mem (bounded_union.2 ‚ü®bs, bt‚ü©) (subset_union_left _ _ hz) (subset_union_right _ _ yt)‚ü©
{ exact Œªz hz, ‚ü®y, yt, dist_le_diam_of_mem (bounded_union.2 ‚ü®bs, bt‚ü©) (subset_union_left _ _ hz) (subset_union_right _ _ yt)‚ü© }
exact Œªz hz, ‚ü®x, xs, dist_le_diam_of_mem (bounded_union.2 ‚ü®bs, bt‚ü©) (subset_union_right _ _ hz) (subset_union_left _ _ xs)‚ü©
{ exact Œªz hz, ‚ü®x, xs, dist_le_diam_of_mem (bounded_union.2 ‚ü®bs, bt‚ü©) (subset_union_right _ _ hz) (subset_union_left _ _ xs)‚ü© }
intros
split
{ apply le_œâSup, }
apply le_œâSup
{ apply œâSup_le, }
apply œâSup_le
intros
rw continuous_def at h‚ÇÇ ‚ä¢
assume s h
exact h‚ÇÇ s (h‚ÇÅ s h)
intros
ext x
simp only [mem_range, path.symm, has_coe_to_fun.coe, coe_fn, unit_interval.symm, set_coe.exists, comp_app, subtype.coe_mk, subtype.val_eq_coe]
split
split; rintros ‚ü®y, hy, hxy‚ü©; refine ‚ü®1-y, mem_iff_one_sub_mem.mp hy, _‚ü©; convert hxy
split; rintros ‚ü®y, hy, hxy‚ü©; refine ‚ü®1-y, mem_iff_one_sub_mem.mp hy, _‚ü©
split; rintros ‚ü®y, hy, hxy‚ü©
rintros ‚ü®y, hy, hxy‚ü©
refine ‚ü®1-y, mem_iff_one_sub_mem.mp hy, _‚ü©
convert hxy
rintros ‚ü®y, hy, hxy‚ü©
refine ‚ü®1-y, mem_iff_one_sub_mem.mp hy, _‚ü©
convert hxy
simp
intros
rw [continuous_at, tendsto_nhds_right]
intros
replace h := h.comap prod.swap
rw [‚Üê map_swap_eq_comap_swap, ‚Üê uniformity_eq_symm] at h
exact nhds_basis_uniformity' h
intros
simp [cauchy_seq_iff', filter.eventually_at_top_prod_self', prod_map]
intros
refine ‚ü®is_complete_of_complete_image hm, Œª c, _‚ü©
haveI : complete_space s := c.complete_space_coe
set m' : s ‚Üí Œ≤ := m ‚àò coe
suffices : is_complete (range m')
rwa [range_comp, subtype.range_coe] at this
rwa [range_comp, subtype.range_coe] at this
have hm' : uniform_inducing m' := hm.comp uniform_embedding_subtype_coe.to_uniform_inducing
intros f hf hfm
rw filter.le_principal_iff at hfm
have cf' : cauchy (comap m' f) := hf.comap' hm'.comap_uniformity.le (ne_bot.comap_of_range_mem hf.1 hfm)
rcases complete_space.complete cf' with ‚ü®x, hx‚ü©
rw [hm'.inducing.nhds_eq_comap, comap_le_comap_iff hfm] at hx
use [m' x, mem_range_self _, hx]
intros
by_cases hx : x ‚àà c‚ÇÅ.U
calc approx n‚ÇÇ c‚ÇÇ x = 0 : approx_of_mem_C _ _ (h hx) ... ‚â§ approx n‚ÇÅ c‚ÇÅ x : approx_nonneg _ _ _
{ calc approx n‚ÇÇ c‚ÇÇ x = 0 : approx_of_mem_C _ _ (h hx) ... ‚â§ approx n‚ÇÅ c‚ÇÅ x : approx_nonneg _ _ _ }
calc approx n‚ÇÇ c‚ÇÇ x ‚â§ 1 : approx_le_one _ _ _ ... = approx n‚ÇÅ c‚ÇÅ x : (approx_of_nmem_U _ _ hx).symm
{ calc approx n‚ÇÇ c‚ÇÇ x ‚â§ 1 : approx_le_one _ _ _ ... = approx n‚ÇÅ c‚ÇÅ x : (approx_of_nmem_U _ _ hx).symm }
intros
rw [congr_fun linear_order.min_def a, min_default]
intros
cases b; simp
cases b
simp
simp
intros
rw [int.mul_comm, int.one_mul]
intros
rw [int.sub_eq_add_neg, int.add_right_neg]
intros
have h := int.neg_lt_neg h
rwa int.neg_neg at h
intros
have h := int.add_lt_add_left h b
rwa int.add_neg_cancel_left at h
intros
rw [‚Üê nat.add_sub_cancel x k, nat.sub_le_sub_right_iff _ _ _ h, nat.add_sub_cancel]
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
rw [mul_assoc, commutes, ‚Üêmul_assoc]
intros
{ ext, refl }
ext
refl
intros
{ delta finset.prod, apply multiset.prod_hom_rel; assumption }
delta finset.prod
apply multiset.prod_hom_rel
apply multiset.prod_hom_rel; assumption
assumption
assumption
intros
apply @prod_singleton Œ≤ ‚Ñï 0 f
intros
have A : mul_support (f ‚àò plift.down) = equiv.plift.symm '' mul_support f
rw mul_support_comp_eq_preimage
{ rw mul_support_comp_eq_preimage, exact (equiv.plift.symm.image_eq_preimage _).symm }
exact (equiv.plift.symm.image_eq_preimage _).symm
have : mul_support (f ‚àò plift.down) ‚äÜ s.map equiv.plift.symm.to_embedding
{ rw [A, finset.coe_map], exact image_subset _ h }
rw [A, finset.coe_map]
exact image_subset _ h
rw [finprod_eq_prod_plift_of_mul_support_subset this]
simp
intros
rw [‚Üê finprod_mem_union', inter_union_diff]
exacts [Œª x hx, hx.2.2 hx.1.2, h.subset (Œª x hx, ‚ü®hx.1.1, hx.2‚ü©), h.subset (Œª x hx, ‚ü®hx.1.1, hx.2‚ü©)]
intros
apply tensor_product.ext'
intros x y
refl
intros
{ assume _ hyp, simp [int_fract_pair.stream, hyp] }
assume _ hyp
simp [int_fract_pair.stream, hyp]
intros
simp [*, continuants_aux, next_continuants, next_denominator, next_numerator]
intros
refl
intros
{ rw gcd, exact if_pos rfl }
rw gcd
exact if_pos rfl
intros
rw [(left_distrib (1 / a)), (one_div_mul_cancel ha), right_distrib, one_mul, mul_assoc, (mul_one_div_cancel hb), mul_one, add_comm]
intros
have := (commute.one_right x).geom_sum‚ÇÇ_mul_add n
rw [one_pow, geom_sum‚ÇÇ_with_one] at this
exact this
intros
rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]
intros
{ ext z, rw [function.comp_apply, @is_associative.assoc _ f] }
ext z
rw [function.comp_apply, @is_associative.assoc _ f]
intros
ext
{ ext, simp only [mul_apply, function.comp_app, map_mul, coe_comp] }
simp only [mul_apply, function.comp_app, map_mul, coe_comp]
intros
{ rcases h with ‚ü®‚ü®a, b, hab, _‚ü©, rfl‚ü©, exact ‚ü®b, hab‚ü© }
rcases h with ‚ü®‚ü®a, b, hab, _‚ü©, rfl‚ü©
exact ‚ü®b, hab‚ü©
intros
ring
intros
induction m with m ih; [exact int.coe_nat_one, rw [pow_succ', pow_succ', int.coe_nat_mul, ih]]
induction m with m ih
exact int.coe_nat_one
rw [pow_succ', pow_succ', int.coe_nat_mul, ih]
intros
conv {to_lhs, rw ‚Üê nat.mod_add_div n 2}; rw [pow_add, pow_mul, units_sq, one_pow, mul_one]
conv {to_lhs, rw ‚Üê nat.mod_add_div n 2}
rw [pow_add, pow_mul, units_sq, one_pow, mul_one]
intros
simp [hb]
intros
tidy
intros
change ite (1 = 0 + 1) (ùüô X‚ÇÅ ‚â´ d‚ÇÄ) 0 = d‚ÇÄ
{ change ite (1 = 0 + 1) (ùüô X‚ÇÅ ‚â´ d‚ÇÄ) 0 = d‚ÇÄ, rw [if_pos rfl, category.id_comp] }
rw [if_pos rfl, category.id_comp]
intros
{ simp, refl, }
simp
refl
intros
{ apply inv_of_eq_right_inv, rw [h, mul_inv_of_self], }
apply inv_of_eq_right_inv
rw [h, mul_inv_of_self]
intros
{ ext, refl, }
ext
refl
intros
have : of L j y = of L i (hij.rec_on y)
exact eq.drec (eq.refl _) hij
{ exact eq.drec (eq.refl _) hij, }
rw [this, ‚Üê lie_algebra_of_apply R Œπ L i ‚ÅÖx, hij.rec_on y‚ÅÜ, lie_hom.map_lie, lie_algebra_of_apply, lie_algebra_of_apply]
intros
{ rw lie_ideal_oper_eq_span, apply subset_lie_span, use [x, m], }
rw lie_ideal_oper_eq_span
apply subset_lie_span
use [x, m]
intros
apply subsingleton_of_bot_eq_top
ext ‚ü®x, hx‚ü©
change x ‚àà ‚ä• at hx
rw submodule.mem_bot at hx
subst hx
simp only [true_iff, eq_self_iff_true, submodule.mk_eq_zero, mem_bot]
intros
apply subsingleton_of_bot_eq_top
ext ‚ü®x, hx‚ü©
change x ‚àà ‚ä• at hx
rw submodule.mem_bot at hx
subst hx
simp only [true_iff, eq_self_iff_true, submodule.mk_eq_zero, lie_submodule.mem_bot]
intros
rw ‚Üê f.range_eq_top at h
rw [ideal_range_eq_lie_span_range, h, ‚Üê lie_subalgebra.coe_to_submodule, ‚Üê lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule, lie_subalgebra.top_coe_submodule, lie_submodule.coe_lie_span_submodule_eq_iff]
use ‚ä§
exact lie_submodule.top_coe_submodule
intros
apply lie_module.weight_vector_multiplication L L M M (to_module_hom R L M) œá‚ÇÅ œá‚ÇÇ
simp only [lie_module_hom.coe_to_linear_map, function.comp_app, linear_map.coe_comp, tensor_product.map_incl, linear_map.mem_range]
use [‚ü®x, hx‚ü© ‚äó‚Çú ‚ü®m, hm‚ü©]
simp only [submodule.subtype_apply, to_module_hom_apply, tensor_product.map_tmul]
refl
intros
{ rw [‚Üêzero_smul R (0 : M), map_smul‚Çõ‚Çó], simp }
rw [‚Üêzero_smul R (0 : M), map_smul‚Çõ‚Çó]
simp
intros
refine finsupp.induction_linear f _ (Œª f g hf hg, hadd f g hf hg) (Œª g r, _)
simpa using hsmul 0 (of k G (multiplicative.of_add 0)) (hM 0)
{ simpa using hsmul 0 (of k G (multiplicative.of_add 0)) (hM 0) }
convert hsmul r (of k G (multiplicative.of_add g)) (hM g)
{ convert hsmul r (of k G (multiplicative.of_add g)) (hM g), simp only [mul_one, to_add_of_add, smul_single', of_apply] }
simp only [mul_one, to_add_of_add, smul_single', of_apply]
intros
suffices : (lift_nc ‚Üëf g).comp (smul_add_hom k (monoid_algebra k G) c) = (add_monoid_hom.mul_left (f c)).comp (lift_nc ‚Üëf g)
from add_monoid_hom.congr_fun this œÜ
ext a b
simp [mul_assoc]
intros
apply_fun add_monoid_algebra.to_direct_sum
{ simp }
simp
apply function.left_inverse.injective
{ apply function.left_inverse.injective, apply add_monoid_algebra.to_direct_sum_to_add_monoid_algebra }
apply add_monoid_algebra.to_direct_sum_to_add_monoid_algebra
intros
haveI := classical.dec; exact decidable.eq_iff_le_not_lt
haveI := classical.dec
exact decidable.eq_iff_le_not_lt
intros
rw [lt_div_iff_of_neg hb, one_mul]
intros
rw [div_mul_eq_div_mul_one_div, div_mul_eq_div_mul_one_div]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 he)
intros
rw [inv_le_div_iff_le_mul, mul_comm]
intros
haveI := @linear_order.decidable_le Œ± _; exact le_of_not_gt (Œªhab, (decidable.mul_self_lt_mul_self hb hab).not_le h)
haveI := @linear_order.decidable_le Œ± _
exact le_of_not_gt (Œªhab, (decidable.mul_self_lt_mul_self hb hab).not_le h)
intros
by_cases ba : b ‚â§ a
simp [ba.antisymm h‚ÇÅ]
{ simp [ba.antisymm h‚ÇÅ] }
by_cases c0 : c ‚â§ 0
simp [c0.antisymm h‚ÇÇ]
{ simp [c0.antisymm h‚ÇÇ] }
exact (mul_lt_mul_of_pos_left (h‚ÇÅ.lt_of_not_le ba) (h‚ÇÇ.lt_of_not_le c0)).le
intros
rw [bit0, bit0, ‚Üê two_mul, ‚Üê two_mul, mul_le_mul_left (zero_lt_two : 0 < (2:Œ±))]
intros
simpa only [zero_add] using h 0
intros
rw [‚Üê image_mul_right', image_singleton]
intros
rintros _ ‚ü®_, _, _, _, rfl‚ü©
{ rintros _ ‚ü®_, _, _, _, rfl‚ü©, exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, (m.map_mul _ _).symm ‚ü© }
exact ‚ü®_, _, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, (m.map_mul _ _).symm ‚ü©
intros
apply nat_degree_prod'
rw prod_ne_zero_iff
intros x hx
simp [h x hx]
intros
simp [ext_iff, neg_eq_iff_add_eq_zero, add_self_eq_zero]
intros
refine ‚ü®Œª h, h.subsingleton, _‚ü©
intros H a b h
exact @subsingleton.elim _ H a b
intros
simpa only [sub_eq_add_neg, neg_mul_eq_mul_neg] using mul_add a b (-c)
intros
erw ‚Üê germ_to_open R (basic_open (f : R)) ‚ü®x, f.2‚ü© (f : R)
{ erw ‚Üê germ_to_open R (basic_open (f : R)) ‚ü®x, f.2‚ü© (f : R), exact ring_hom.is_unit_map _ (is_unit_to_basic_open_self R f) }
exact ring_hom.is_unit_map _ (is_unit_to_basic_open_self R f)
intros
by_cases hK : K = 0
simp only [gronwall_bound, if_pos hK, mul_zero, add_zero]
{ simp only [gronwall_bound, if_pos hK, mul_zero, add_zero] }
simp only [gronwall_bound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one, add_zero]
{ simp only [gronwall_bound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one, add_zero] }
intros
{ ext v, exact q.comp_coeff_zero p _ _ }
ext v
exact q.comp_coeff_zero p _ _
intros
have cne0 : ‚à•c‚à• ‚â† 0
from mt norm_eq_zero.mp hc
rw [‚Üêis_o_norm_right]
simp only [norm_smul]
rw [is_o_const_mul_right_iff cne0, is_o_norm_right]
intros
unfold is_o
{ unfold is_o, exact (forall_congr $ Œª c, forall_congr $ Œª hc, e.is_O_with_congr hb) }
exact (forall_congr $ Œª c, forall_congr $ Œª hc, e.is_O_with_congr hb)
intros
convert (has_deriv_at_inv hx).comp_has_deriv_within_at x hc
field_simp
intros
unfold deriv
{ unfold deriv, rw fderiv_zero_of_not_differentiable_at, simp, assumption }
rw fderiv_zero_of_not_differentiable_at
simp
assumption
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
simp [sub_eq_add_neg]
intros
simpa only [compl_eq_univ_diff] using (has_fderiv_within_at_univ.2 h).eventually_ne hf'
intros
rw ‚Üê fderiv_within_univ
exact fderiv_within_subset (subset_univ _) hs h.differentiable_within_at
intros
simpa only [fderiv_deriv] using measurable_fderiv_apply_const ùïú f 1
intros
split
rw [‚Üê times_cont_diff_on_univ, ‚Üê has_ftaylor_series_up_to_on_univ_iff, ‚Üê ftaylor_series_within_univ]
{ rw [‚Üê times_cont_diff_on_univ, ‚Üê has_ftaylor_series_up_to_on_univ_iff, ‚Üê ftaylor_series_within_univ], exact Œª h, times_cont_diff_on.ftaylor_series_within h unique_diff_on_univ }
exact Œª h, times_cont_diff_on.ftaylor_series_within h unique_diff_on_univ
{ assume h, exact ‚ü®ftaylor_series ùïú f, h‚ü© }
assume h
exact ‚ü®ftaylor_series ùïú f, h‚ü©
intros
rw [‚Üê times_cont_diff_within_at_univ] at *; exact hf.add hg
rw [‚Üê times_cont_diff_within_at_univ] at *
exact hf.add hg
intros
rw [segment_eq_image', segment_eq_image']
refine exists_congr (Œª Œ∏, and_congr iff.rfl _)
simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]
intros
rw convex_iff_open_segment_subset
rintro p q ‚ü®ap, bp, hap, hbp, habp, rfl‚ü© ‚ü®aq, bq, haq, hbq, habq, rfl‚ü© z ‚ü®a, b, ha, hb, hab, rfl‚ü©
refine ‚ü®a * ap + b * aq, a * bp + b * bq, add_pos (mul_pos ha hap) (mul_pos hb haq), add_pos (mul_pos ha hbp) (mul_pos hb hbq), _, _‚ü©
rw [add_add_add_comm, ‚Üêmul_add, ‚Üêmul_add, habp, habq, mul_one, mul_one, hab]
{ rw [add_add_add_comm, ‚Üêmul_add, ‚Üêmul_add, habp, habq, mul_one, mul_one, hab] }
simp_rw [add_smul, mul_smul, smul_add]
{ simp_rw [add_smul, mul_smul, smul_add], exact add_add_add_comm _ _ _ _ }
exact add_add_add_comm _ _ _ _
intros
rw [affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one _ w _ hw‚ÇÇ (0 : E), finset.weighted_vsub_of_point_apply, vadd_eq_add, add_zero, t.center_mass_eq_of_sum_1 _ hw‚ÇÇ]
simp_rw [vsub_eq_sub, sub_zero]
intros
rw [‚Üê @of_real_inj ùïú, im_eq_conj_sub]; simp
rw [‚Üê @of_real_inj ùïú, im_eq_conj_sub]
simp
intros
simp [inner_add_add_self, inner_sub_sub_self, two_mul, sub_eq_add_neg, add_comm, add_left_comm]
intros
have h := @parallelogram_law_with_norm ‚Ñù F _ _ x y
{ have h := @parallelogram_law_with_norm ‚Ñù F _ _ x y, simpa using h }
simpa using h
intros
refine le_antisymm _ _
convert submodule.orthogonal_orthogonal_monotone K.submodule_topological_closure
{ convert submodule.orthogonal_orthogonal_monotone K.submodule_topological_closure, haveI : complete_space K.topological_closure := K.is_closed_topological_closure.complete_space_coe, rw K.topological_closure.orthogonal_orthogonal }
haveI : complete_space K.topological_closure := K.is_closed_topological_closure.complete_space_coe
rw K.topological_closure.orthogonal_orthogonal
exact K.topological_closure_minimal K.le_orthogonal_orthogonal K·óÆ.is_closed_orthogonal
{ exact K.topological_closure_minimal K.le_orthogonal_orthogonal K·óÆ.is_closed_orthogonal }
intros
simp [metric.cauchy_seq_iff, dist_eq_norm]
intros
have : ‚àÄ·∂† y in l, 1 + ‚à•x‚à• ‚â§ ‚à•f y‚à• := h (mem_at_top (1 + ‚à•x‚à•))
refine this.mono (Œª y hy hxy, _)
subst x
exact not_le_of_lt zero_lt_one (add_le_iff_nonpos_left.1 hy)
intros
{ ext, refl }
ext
refl
intros
rw [exp_sub, div_eq_one_iff_eq (exp_ne_zero _)]
intros
have : (n : ‚Ñù) + 2 ‚â† 0 := by exact_mod_cast succ_ne_zero n.succ
field_simp
convert eq_sub_iff_add_eq.mp (integral_sin_pow_aux n)
ring
intros
refine ‚ü®Œª h, _, Œª h, tendsto_at_bot_of_leading_coeff_nonpos P h.1 h.2‚ü©
have : tendsto (Œª x, P.leading_coeff * x ^ P.nat_degree) at_top at_bot := (is_equivalent.tendsto_at_bot (is_equivalent_at_top_lead P) h)
rw tendsto_neg_const_mul_pow_at_top_iff P.leading_coeff P.nat_degree at this
rw [degree_eq_nat_degree (leading_coeff_ne_zero.mp (ne_of_lt this.2)), ‚Üê nat.cast_one]
refine ‚ü®with_bot.coe_le_coe.mpr this.1, le_of_lt this.2‚ü©
intros
simp [rpow_def]
intros
rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]
repeat {rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]}
rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]
rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]
rw exp_lt_exp
exact mul_lt_mul_of_pos_left hyz (log_pos hx)
intros
refine ‚ü®Œª hc h‚ÇÄ, _, Œª h, (has_deriv_at_tan h).continuous_at‚ü©
exact not_tendsto_nhds_of_tendsto_at_top (tendsto_abs_tan_of_cos_eq_zero h‚ÇÄ) _ (hc.norm.tendsto.mono_left inf_le_left)
intros
rw [‚Üê sub_lt_zero, cos_sub_cos]
have : 0 < sin ((y + x) / 2)
refine sin_pos_of_pos_of_lt_pi _ _; linarith
{ refine sin_pos_of_pos_of_lt_pi _ _; linarith }
refine sin_pos_of_pos_of_lt_pi _ _
linarith
linarith
have : 0 < sin ((y - x) / 2)
refine sin_pos_of_pos_of_lt_pi _ _; linarith
{ refine sin_pos_of_pos_of_lt_pi _ _; linarith }
refine sin_pos_of_pos_of_lt_pi _ _
linarith
linarith
nlinarith
intros
unfold arccos; linarith [arcsin_le_pi_div_two x]
unfold arccos
linarith [arcsin_le_pi_div_two x]
intros
by_cases h0 : r = 0
exact tendsto_const_nhds.congr' (mem_at_top_sets.2 ‚ü®1, Œª n hn, by simp [zero_lt_one.trans_le hn, h0]‚ü©)
{ exact tendsto_const_nhds.congr' (mem_at_top_sets.2 ‚ü®1, Œª n hn, by simp [zero_lt_one.trans_le hn, h0]‚ü©) }
have hr' : 1 < (abs r)‚Åª¬π
from one_lt_inv (abs_pos.2 h0) hr
rw tendsto_zero_iff_norm_tendsto_zero
simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'
intros
have h1 : summable (Œª (n:‚Ñï), ‚à•x‚à• ^ n) := summable_geometric_of_lt_1 (norm_nonneg _) h
refine summable_of_norm_bounded_eventually _ h1 _
rw nat.cofinite_eq_at_top
exact eventually_norm_pow_le x
intros
split_ifs; refl
{ split_ifs; refl }
split_ifs
refl
refl
intros
simp
intros
cases F with F_obj _ _ _
cases G with G_obj _ _ _
have : F_obj = G_obj
ext X
ext X
ext X; apply h_obj
ext X; apply h_obj
apply h_obj
apply h_obj
subst this
congr
funext X Y f
simpa using h_map X Y f
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
tidy
intros
apply (cancel_epi f).mp
simp [hom_inv_id]
intros
obtain ‚ü®a, rfl‚ü© := concrete.from_union_surjective_of_is_colimit F hD x
exact ‚ü®a.1, a.2, rfl‚ü©
intros
ext
ext; erw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.pre_œÄ, assoc, limit.pre_œÄ, limit.post_œÄ]; refl
ext; erw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.pre_œÄ, assoc, limit.pre_œÄ, limit.post_œÄ]
erw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.pre_œÄ, assoc, limit.pre_œÄ, limit.post_œÄ]
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
erw [fork.condition, has_zero_morphisms.comp_zero]
intros
tidy
intros
{ rw image.eq_fac h, simp }
rw image.eq_fac h
simp
intros
rw [‚Üêtensor_left_iff, id_tensor_comp, braiding_right_unitor_aux‚ÇÇ]
intros
apply (cancel_mono (ùüô X ‚äó (Œª_ Y).hom)).1
simp only [assoc, triangle_assoc_comp_left]
rw [‚Üêcomp_tensor_id, iso.inv_hom_id, ‚Üêid_tensor_comp, iso.inv_hom_id]
intros
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
rintro ‚ü®‚ü©
rintro ‚ü®‚ü©; { dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
dsimp [tensor_hom]
simp
intros
rw [covers, (sieve.pullback_eq_top_iff_mem f).1 hf]
apply J.top_mem
intros
split
intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
{ intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ, apply h (x.restrict (le_generate R)) t‚ÇÅ t‚ÇÇ _ _, { exact is_amalgamation_restrict _ x t‚ÇÅ ht‚ÇÅ }, { exact is_amalgamation_restrict _ x t‚ÇÇ ht‚ÇÇ } }
apply h (x.restrict (le_generate R)) t‚ÇÅ t‚ÇÇ _ _
{ exact is_amalgamation_restrict _ x t‚ÇÅ ht‚ÇÅ }
exact is_amalgamation_restrict _ x t‚ÇÅ ht‚ÇÅ
{ exact is_amalgamation_restrict _ x t‚ÇÇ ht‚ÇÇ }
exact is_amalgamation_restrict _ x t‚ÇÇ ht‚ÇÇ
intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
{ intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ, apply h (x.sieve_extend), { exact is_amalgamation_sieve_extend x t‚ÇÅ ht‚ÇÅ }, { exact is_amalgamation_sieve_extend x t‚ÇÇ ht‚ÇÇ } }
apply h (x.sieve_extend)
{ exact is_amalgamation_sieve_extend x t‚ÇÅ ht‚ÇÅ }
exact is_amalgamation_sieve_extend x t‚ÇÅ ht‚ÇÅ
{ exact is_amalgamation_sieve_extend x t‚ÇÇ ht‚ÇÇ }
exact is_amalgamation_sieve_extend x t‚ÇÇ ht‚ÇÇ
intros
simp [sieve.ext_iff]
intros
tidy
intros
simp [of_mk_le, of_le_mk, of_le, ‚Üêfunctor.map_comp_assoc underlying]
intros
rw [‚Üêequalizer_subobject_arrow, category.assoc, category.assoc, equalizer.condition]
intros
{ simp only [size_up_to], rw sum_take_succ _ _ h }
simp only [size_up_to]
rw sum_take_succ _ _ h
intros
induction n with n hn
{ refl }
refl
simp only [num_derangements_add_two, hn, pow_succ, int.coe_nat_mul, int.coe_nat_add, int.coe_nat_succ]
{ simp only [num_derangements_add_two, hn, pow_succ, int.coe_nat_mul, int.coe_nat_add, int.coe_nat_succ], ring }
ring
intros
conv_rhs {rw ‚Üê num.to_of_nat n}
exact congr_arg coe (decode_encode_num ‚Üën)
intros
induction n with n ihn generalizing x
simp only [mem_one, pow_zero, list.length_eq_zero]
{ simp only [mem_one, pow_zero, list.length_eq_zero], split, { rintro rfl, exact ‚ü®[], rfl, rfl, Œª y h, h.elim‚ü© }, { rintro ‚ü®_, rfl, rfl, _‚ü©, refl } }
split
{ rintro rfl, exact ‚ü®[], rfl, rfl, Œª y h, h.elim‚ü© }
rintro rfl
exact ‚ü®[], rfl, rfl, Œª y h, h.elim‚ü©
{ rintro ‚ü®_, rfl, rfl, _‚ü©, refl }
rintro ‚ü®_, rfl, rfl, _‚ü©
refl
simp only [pow_succ, mem_mul, ihn]
{ simp only [pow_succ, mem_mul, ihn], split, { rintro ‚ü®a, b, ha, ‚ü®S, rfl, rfl, hS‚ü©, rfl‚ü©, exact ‚ü®a :: S, rfl, rfl, list.forall_mem_cons.2 ‚ü®ha, hS‚ü©‚ü© }, { rintro ‚ü®_|‚ü®a, S‚ü©, rfl, hn, hS‚ü©; cases hn, rw list.forall_mem_cons at hS, exact ‚ü®a, _, hS.1, ‚ü®S, rfl, rfl, hS.2‚ü©, rfl‚ü© } }
split
rintro ‚ü®a, b, ha, ‚ü®S, rfl, rfl, hS‚ü©, rfl‚ü©
{ rintro ‚ü®a, b, ha, ‚ü®S, rfl, rfl, hS‚ü©, rfl‚ü©, exact ‚ü®a :: S, rfl, rfl, list.forall_mem_cons.2 ‚ü®ha, hS‚ü©‚ü© }
exact ‚ü®a :: S, rfl, rfl, list.forall_mem_cons.2 ‚ü®ha, hS‚ü©‚ü©
rintro ‚ü®_|‚ü®a, S‚ü©, rfl, hn, hS‚ü©; cases hn
rintro ‚ü®_|‚ü®a, S‚ü©, rfl, hn, hS‚ü©
{ rintro ‚ü®_|‚ü®a, S‚ü©, rfl, hn, hS‚ü©; cases hn, rw list.forall_mem_cons at hS, exact ‚ü®a, _, hS.1, ‚ü®S, rfl, rfl, hS.2‚ü©, rfl‚ü© }
cases hn
cases hn
rw list.forall_mem_cons at hS
exact ‚ü®a, _, hS.1, ‚ü®S, rfl, rfl, hS.2‚ü©, rfl‚ü©
intros
simpa using comp' (prec hg hh) (hf.cons idv)
intros
obtain ‚ü®a, L, rfl‚ü© := L.exists_cons
simp only [tr_tape', list_blank.cons_bind, list_blank.head_cons, list_blank.tail_cons]
suffices : ‚àÄ {L' R' l‚ÇÅ l‚ÇÇ} (e : vector.to_list (enc a) = list.reverse_core l‚ÇÅ l‚ÇÇ), tape.move dir.left^[l‚ÇÅ.length] (tape.mk' (list_blank.append l‚ÇÅ L') (list_blank.append l‚ÇÇ R')) = tape.mk' L' (list_blank.append (vector.to_list (enc a)) R')
simpa only [list.length_reverse, vector.to_list_length] using this (list.reverse_reverse _).symm
{ simpa only [list.length_reverse, vector.to_list_length] using this (list.reverse_reverse _).symm }
intros
induction l‚ÇÅ with b l‚ÇÅ IH generalizing l‚ÇÇ
{ cases e, refl }
cases e
refl
simp only [list.length, list.cons_append, iterate_succ_apply]
convert IH e
simp only [list_blank.tail_cons, list_blank.append, tape.move_left_mk', list_blank.head_cons]
intros
simp only [tape.mk', tape.map, list_blank.head_map, eq_self_iff_true, and_self, list_blank.tail_map]
intros
cases x; simp! with functor_norm; refl
cases x; simp! with functor_norm
cases x
simp! with functor_norm
refl
simp! with functor_norm
refl
simp
intros
simp [str_eq_char_buf, char_buf_iff, ‚Üêstring.to_list_inj, buffer.ext_iff]
intros
induction l with hd tl hl generalizing n n'
{ simpa using h }
simpa using h
simp only [many1_eq_done] at h
{ simp only [many1_eq_done] at h, obtain ‚ü®np, hp, h‚ü© := h, have := step.of_done hp, subst this, cases tl, { simp only [many_eq_done_nil, exists_and_distrib_right] at h, simpa [‚Üêh.left] using bounded.of_done hp }, { rw ‚Üêmany1_eq_done_iff_many_eq_done at h, exact hl h } }
obtain ‚ü®np, hp, h‚ü© := h
have := step.of_done hp
subst this
cases tl
simp only [many_eq_done_nil, exists_and_distrib_right] at h
{ simp only [many_eq_done_nil, exists_and_distrib_right] at h, simpa [‚Üêh.left] using bounded.of_done hp }
simpa [‚Üêh.left] using bounded.of_done hp
rw ‚Üêmany1_eq_done_iff_many_eq_done at h
{ rw ‚Üêmany1_eq_done_iff_many_eq_done at h, exact hl h }
exact hl h
intros
simp [foldl_core, and_comm]
intros
rw [‚Üêof_real_zero]; exact of_real_inj
rw [‚Üêof_real_zero]
exact of_real_inj
intros
rw ‚Üê zero_eq_mul_self
have : re a * re a = re a * re a + im a * im a
convert is_R_or_C.mul_self_abs a; linarith [re_le_abs a]
convert is_R_or_C.mul_self_abs a
{ convert is_R_or_C.mul_self_abs a; linarith [re_le_abs a] }
linarith [re_le_abs a]
linarith [re_le_abs a]
linarith [re_le_abs a]
linarith [re_le_abs a]
linarith
intros
rw [‚Üêfilter_ne_eq_erase, filter_single, ite_not]
intros
{ cases a, cases a_val, refl }
cases a
cases a_val
refl
intros
simp [perm.extend_domain]
intros
ext i
by_cases h : i ‚àà s
rw [dif_pos h, function.update_apply_equiv_apply, equiv.symm_symm, function.comp, function.update_apply, function.update_apply, dif_pos h]
{ rw [dif_pos h, function.update_apply_equiv_apply, equiv.symm_symm, function.comp, function.update_apply, function.update_apply, dif_pos h], have h_coe : (‚ü®i, h‚ü© : s) = e j ‚Üî i = e j := subtype.ext_iff.trans (by rw subtype.coe_mk), simp_rw h_coe, congr, }
have h_coe : (‚ü®i, h‚ü© : s) = e j ‚Üî i = e j := subtype.ext_iff.trans (by rw subtype.coe_mk)
simp_rw h_coe
have : i ‚â† e j
{ have : i ‚â† e j, by { contrapose! h, have : (e j : Œ±) ‚àà s := (e j).2, rwa ‚Üê h at this }, simp [h, this] }
contrapose! h
contrapose! h
{ contrapose! h, have : (e j : Œ±) ‚àà s := (e j).2, rwa ‚Üê h at this }
{ contrapose! h, have : (e j : Œ±) ‚àà s := (e j).2, rwa ‚Üê h at this }
have : (e j : Œ±) ‚àà s := (e j).2
have : (e j : Œ±) ‚àà s := (e j).2
rwa ‚Üê h at this
rwa ‚Üê h at this
simp [h, this]
intros
apply of_nat_of_decode; show option.map _ _ = _; simp
apply of_nat_of_decode; show option.map _ _ = _
apply of_nat_of_decode
show option.map _ _ = _
simp
intros
convert fin_add_flip_apply_cast_add ‚ü®k, h‚ü© n
intros
rw fin.succ_above_below
{ refl }
refl
{ exact bot_lt_iff_ne_bot.mpr ha }
exact bot_lt_iff_ne_bot.mpr ha
intros
simp [tail, cons]
intros
simp_rw [‚Üê insert_nth_sub, ‚Üê insert_nth_zero_right, pi.sub_def, sub_self, pi.zero_def]
intros
ext
simp only [bit1, bit0] at h
simp only [bit1, bit0, coe_add, coe_one', coe_mk, ‚Üênat.add_mod, nat.mod_eq_of_lt h]
intros
{ ext, congr }
ext
congr
intros
simp only [mem_insert, or_imp_distrib, forall_and_distrib, forall_eq]
intros
simp [finset.nonempty]
intros
simpa only [card_map] using (s.1.map f).to_finset_card_le
intros
intro x
simp only [and_imp, mem_bUnion, exists_prop]
exact Exists.imp (Œª a ha, ‚ü®h ha.1, ha.2‚ü©)
intros
{ ext, simp, }
ext
simp
intros
refine f.induction _ _
rw [to_multiset_zero, multiset.prod_zero, finsupp.prod_zero_index]
{ rw [to_multiset_zero, multiset.prod_zero, finsupp.prod_zero_index] }
assume a n f _ _ ih
{ assume a n f _ _ ih, rw [to_multiset_add, multiset.prod_add, ih, to_multiset_single, finsupp.prod_add_index, finsupp.prod_single_index, multiset.prod_nsmul, multiset.prod_singleton], { exact pow_zero a }, { exact pow_zero }, { exact pow_add } }
rw [to_multiset_add, multiset.prod_add, ih, to_multiset_single, finsupp.prod_add_index, finsupp.prod_single_index, multiset.prod_nsmul, multiset.prod_singleton]
{ exact pow_zero a }
exact pow_zero a
{ exact pow_zero }
exact pow_zero
{ exact pow_add }
exact pow_add
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
simpa [mul_comm] using fin.prod_univ_succ_above f (fin.last n)
intros
rw [eq_neg_of_eq_neg (neg_succ (-a)).symm, neg_neg]
intros
have := int.mul_div_cancel 1 H; rwa one_mul at this
have := int.mul_div_cancel 1 H
rwa one_mul at this
intros
{ ext, rw pi.int_apply }
ext
rw pi.int_apply
intros
rw int.lcm
{ rw int.lcm, apply coe_nat_dvd_right.mpr, apply nat.dvd_lcm_right }
apply coe_nat_dvd_right.mpr
apply nat.dvd_lcm_right
intros
rw [‚Üê add_zero ((a : ‚Ñ§) * _), nat.gcd_eq_gcd_ab]
{ rw [‚Üê add_zero ((a : ‚Ñ§) * _), nat.gcd_eq_gcd_ab], exact (dvd_mul_right _ _).zero_modeq_int.add_left _ }
exact (dvd_mul_right _ _).zero_modeq_int.add_left _
intros
rw [odd_iff_not_even, even_sub, not_iff, odd_iff_not_even]
intros
induction l with b l' ih
{cases h}
cases h
rcases h with rfl | h
{rcases h with rfl | h, {exact or.inl rfl}, {exact or.inr (ih h)}}
{exact or.inl rfl}
exact or.inl rfl
{exact or.inr (ih h)}
exact or.inr (ih h)
intros
split
assume H j hj
{ assume H j hj, exact H (f j) (mem_map_of_mem f hj) }
exact H (f j) (mem_map_of_mem f hj)
assume H i hi
{ assume H i hi, rcases mem_map.1 hi with ‚ü®j, hj, ji‚ü©, rw ‚Üê ji, exact H j hj }
rcases mem_map.1 hi with ‚ü®j, hj, ji‚ü©
rw ‚Üê ji
exact H j hj
intros
{ induction as, { refl }, { simp! [*, apply_ite (map f)] } }
induction as
refl
{ refl }
simp! [*, apply_ite (map f)]
{ simp! [*, apply_ite (map f)] }
intros
cases l
{ simp only [nth_le, scanl_nil] }
simp only [nth_le, scanl_nil]
{ simp only [nth_le, scanl_cons, singleton_append] }
simp only [nth_le, scanl_cons, singleton_append]
intros
simp [join_filter_empty_eq_ff, ‚Üê empty_iff_eq_nil]
intros
induction l with b l IH
contradiction
{contradiction}
by_cases h : p b
{ rw find_cons_of_pos _ h at H, cases H, exact h }
rw find_cons_of_pos _ h at H
cases H
exact h
{ rw find_cons_of_neg _ h at H, exact IH H }
rw find_cons_of_neg _ h at H
exact IH H
intros
{ rw inits_eq_tails l, simp [reverse_involutive.comp_self], }
rw inits_eq_tails l
simp [reverse_involutive.comp_self]
intros
rw insert_of_mem h
intros
rw [‚Üê diff_cons_right, diff_cons]
intros
induction l; simp *
induction l
simp *
simp *
intros
induction p with _ a c l r p IH generalizing b
induction p with _ a c l r p IH generalizing b; constructor; [exact Hab r, exact IH (@HRS _)]
induction p with _ a c l r p IH generalizing b; constructor
constructor
constructor
exact Hab r
exact IH (@HRS _)
intros
obtain ‚ü®x, y, hxy, hx, hy‚ü© := h
induction s using quot.induction_on with l
rcases l with (_ | ‚ü®hd, _ | ‚ü®hd', tl‚ü©‚ü©)
{ simpa using hx }
simpa using hx
simp only [mem_coe_iff, mk_eq_coe, mem_singleton] at hx hy
{ simp only [mem_coe_iff, mk_eq_coe, mem_singleton] at hx hy, simpa [hx, hy] using hxy }
simpa [hx, hy] using hxy
{ simp [bit0] }
simp [bit0]
intros
rw [antidiagonal, mem_map]
split
rintros ‚ü®i, hi, rfl‚ü©
{ rintros ‚ü®i, hi, rfl‚ü©, rw [mem_range, lt_succ_iff] at hi, exact nat.add_sub_of_le hi }
rw [mem_range, lt_succ_iff] at hi
exact nat.add_sub_of_le hi
rintro rfl
{ rintro rfl, refine ‚ü®x.fst, _, _‚ü©, { rw [mem_range, add_assoc, lt_add_iff_pos_right], exact zero_lt_succ _ }, { exact prod.ext rfl (nat.add_sub_cancel_left _ _) } }
refine ‚ü®x.fst, _, _‚ü©
{ rw [mem_range, add_assoc, lt_add_iff_pos_right], exact zero_lt_succ _ }
rw [mem_range, add_assoc, lt_add_iff_pos_right]
exact zero_lt_succ _
{ exact prod.ext rfl (nat.add_sub_cancel_left _ _) }
exact prod.ext rfl (nat.add_sub_cancel_left _ _)
intros
split
intro H
{ intro H, induction H with xs ys y H IH xs ys x H IH, { simp }, { obtain ‚ü®f, hf‚ü© := IH, refine ‚ü®f.trans (order_embedding.of_strict_mono (+ 1) (Œª _, by simp)), _‚ü©, simpa using hf }, { obtain ‚ü®f, hf‚ü© := IH, refine ‚ü®order_embedding.of_map_le_iff (Œª (ix : ‚Ñï), if ix = 0 then 0 else (f ix.pred).succ) _, _‚ü©, { rintro ‚ü®_|a‚ü© ‚ü®_|b‚ü©; simp [nat.succ_le_succ_iff] }, { rintro ‚ü®_|i‚ü©, { simp }, { simpa using hf _ } } } }
induction H with xs ys y H IH xs ys x H IH
{ simp }
simp
obtain ‚ü®f, hf‚ü© := IH
{ obtain ‚ü®f, hf‚ü© := IH, refine ‚ü®f.trans (order_embedding.of_strict_mono (+ 1) (Œª _, by simp)), _‚ü©, simpa using hf }
refine ‚ü®f.trans (order_embedding.of_strict_mono (+ 1) (Œª _, by simp)), _‚ü©
simpa using hf
obtain ‚ü®f, hf‚ü© := IH
{ obtain ‚ü®f, hf‚ü© := IH, refine ‚ü®order_embedding.of_map_le_iff (Œª (ix : ‚Ñï), if ix = 0 then 0 else (f ix.pred).succ) _, _‚ü©, { rintro ‚ü®_|a‚ü© ‚ü®_|b‚ü©; simp [nat.succ_le_succ_iff] }, { rintro ‚ü®_|i‚ü©, { simp }, { simpa using hf _ } } }
refine ‚ü®order_embedding.of_map_le_iff (Œª (ix : ‚Ñï), if ix = 0 then 0 else (f ix.pred).succ) _, _‚ü©
rintro ‚ü®_|a‚ü© ‚ü®_|b‚ü©; simp [nat.succ_le_succ_iff]
rintro ‚ü®_|a‚ü© ‚ü®_|b‚ü©
{ rintro ‚ü®_|a‚ü© ‚ü®_|b‚ü©; simp [nat.succ_le_succ_iff] }
simp [nat.succ_le_succ_iff]
simp [nat.succ_le_succ_iff]
simp [nat.succ_le_succ_iff]
simp [nat.succ_le_succ_iff]
rintro ‚ü®_|i‚ü©
{ rintro ‚ü®_|i‚ü©, { simp }, { simpa using hf _ } }
simp
{ simp }
simpa using hf _
{ simpa using hf _ }
rintro ‚ü®f, hf‚ü©
{ rintro ‚ü®f, hf‚ü©, exact sublist_of_order_embedding_nth_eq f hf }
exact sublist_of_order_embedding_nth_eq f hf
intros
induction l‚ÇÅ with hd tl IH generalizing l‚ÇÇ
{ simp }
simp
have : hd ‚àà l‚ÇÇ
{ have : hd ‚àà l‚ÇÇ, { rw ‚Üêcount_pos, exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _)) }, replace this : l‚ÇÇ ~ hd :: l‚ÇÇ.erase hd := perm_cons_erase this, refine perm.trans _ this.symm, rw [cons_append, diff_cons, perm_cons], refine IH (Œª x hx, _), specialize h x (mem_cons_of_mem _ hx), rw (perm_iff_count.mp this) at h, by_cases hx : x = hd, { subst hd, simpa [nat.succ_le_succ_iff] using h }, { simpa [hx] using h } }
rw ‚Üêcount_pos
{ rw ‚Üêcount_pos, exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _)) }
exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _))
replace this : l‚ÇÇ ~ hd :: l‚ÇÇ.erase hd := perm_cons_erase this
refine perm.trans _ this.symm
rw [cons_append, diff_cons, perm_cons]
refine IH (Œª x hx, _)
specialize h x (mem_cons_of_mem _ hx)
rw (perm_iff_count.mp this) at h
by_cases hx : x = hd
subst hd
{ subst hd, simpa [nat.succ_le_succ_iff] using h }
simpa [nat.succ_le_succ_iff] using h
{ simpa [hx] using h }
simpa [hx] using h
intros
rw rotate_eq_rotate'
induction n with n hn generalizing l
{ simp }
simp
cases l with hd tl
{ cases l with hd tl, { simp }, { rw rotate'_cons_succ, exact (hn _).trans (perm_append_singleton _ _) } }
{ simp }
simp
rw rotate'_cons_succ
{ rw rotate'_cons_succ, exact (hn _).trans (perm_append_singleton _ _) }
exact (hn _).trans (perm_append_singleton _ _)
intros
simp only [sublists, sublists_aux_cons_eq_sublists_aux‚ÇÅ, sublists_aux‚ÇÅ_append, bind_eq_bind, sublists_aux‚ÇÅ_bind]
congr
funext x
apply congr_arg _
rw [‚Üê bind_ret_eq_map, sublists_aux‚ÇÅ_bind]
exact (append_nil _).symm
intros
induction as generalizing bs
{ simp }
simp
cases bs; simp *
{ cases bs; simp * }
cases bs
simp *
simp *
intros
induction l with hd tl hl generalizing l'
have : l' = [] := eq_nil_of_length_eq_zero (by simpa using h.symm)
{ have : l' = [] := eq_nil_of_length_eq_zero (by simpa using h.symm), simp [this], }
simp [this]
cases l'
{ cases l', { simpa using h }, { simp only [add_left_inj, length] at h, simp [hl _ h] } }
{ simpa using h }
simpa using h
simp only [add_left_inj, length] at h
{ simp only [add_left_inj, length] at h, simp [hl _ h] }
simp [hl _ h]
intros
{ ext i j, refl }
ext i j
refl
intros
ext i' j'
rw [update_column_apply, map_apply, map_apply, update_column_apply]
exact apply_ite f _ _ _
intros
ext i j
rcases i
rcases i; rcases j; simp [from_blocks]
rcases i; rcases j
rcases j
simp [from_blocks]
simp [from_blocks]
rcases j
simp [from_blocks]
simp [from_blocks]
intros
{ ext i j, refine fin.cases _ _ j; simp }
ext i j
refine fin.cases _ _ j
refine fin.cases _ _ j; simp
simp
simp
intros
{ rw [‚Üê rel_flip], exact rel_repeat_left }
rw [‚Üê rel_flip]
exact rel_repeat_left
intros
rw [‚Üêsingleton_add, nsmul_add]
intros
{ ext, simp only [aeval_tower_X, aeval_X] }
ext
simp only [aeval_tower_X, aeval_X]
intros
rw [constant_coeff_eq, coeff_monomial]
intros
rw [‚Üê alg_hom.comp_apply, expand_comp_bind‚ÇÅ]
intros
simp [mem_supported]
intros
rw [total_degree, support_X]
simp only [finset.sup, sum_single_index, finset.fold_singleton, sup_bot_eq]
intros
{ convert bit1_le_bit0_iff, refl, }
convert bit1_le_bit0_iff
refl
intros
rw [add_succ, succ_sub_one]
intros
induction nk with k nk ih
{ induction nk with k nk ih, rw [decreasing_induction_self], rw [decreasing_induction_succ h (le_trans mn nk), ih, decreasing_induction_succ] }
rw [decreasing_induction_self]
rw [decreasing_induction_succ h (le_trans mn nk), ih, decreasing_induction_succ]
intros
simp [lxor]
intros
induction n; simp *
induction n
simp *
simp *
intros
simp [of_digits]
intros
rcases b with _|‚ü®_|‚ü®_‚ü©‚ü©; simp [digits, digits_aux_0, digits_aux_1]
rcases b with _|‚ü®_|‚ü®_‚ü©‚ü©
simp [digits, digits_aux_0, digits_aux_1]
simp [digits, digits_aux_0, digits_aux_1]
simp [digits, digits_aux_0, digits_aux_1]
intros
simpa only [‚Üê some_eq_coe] using part.ne_none_iff
intros
{ intro h, simpa [h, hm, hn] using gcd_mul_lcm m n, }
intro h
simpa [h, hm, hn] using gcd_mul_lcm m n
intros
rw [nat.modeq, nat.mod_zero, nat.mod_zero]
intros
induction n with n ih; simp [*, pow_succ', even_mul]
{ induction n with n ih; simp [*, pow_succ', even_mul], tauto }
induction n with n ih
simp [*, pow_succ', even_mul]
simp [*, pow_succ', even_mul]
tauto
intros
rw ‚Üêpow_one p; exact pow_dvd_of_le_of_pow_dvd hk hpk
rw ‚Üêpow_one p
exact pow_dvd_of_le_of_pow_dvd hk hpk
intros
cases nat.eq_zero_or_pos (gcd m n) with g0 g1
rw [eq_zero_of_gcd_eq_zero_left g0, eq_zero_of_gcd_eq_zero_right g0] at H
{ rw [eq_zero_of_gcd_eq_zero_left g0, eq_zero_of_gcd_eq_zero_right g0] at H, exfalso, exact H 2 prime_two (dvd_zero _) (dvd_zero _) }
exfalso
exact H 2 prime_two (dvd_zero _) (dvd_zero _)
apply eq.symm
change 1 ‚â§ _ at g1
apply (lt_or_eq_of_le g1).resolve_left
intro g2
obtain ‚ü®p, hp, hpdvd‚ü© := exists_prime_and_dvd g2
apply H p hp; apply dvd_trans hpdvd
apply H p hp
apply dvd_trans hpdvd
{ exact gcd_dvd_left _ _ }
exact gcd_dvd_left _ _
apply dvd_trans hpdvd
{ exact gcd_dvd_right _ _ }
exact gcd_dvd_right _ _
intros
refine min_fac_helper_1 e _ h
intro e‚ÇÅ
rw ‚Üê e‚ÇÅ at np
exact np (nat.min_fac_prime $ ne_of_gt $ nat.bit1_lt h.n_pos)
intros
rw sqrt_aux; simp only [h, h‚ÇÇ, if_false]
rw sqrt_aux
simp only [h, h‚ÇÇ, if_false]
cases int.eq_neg_succ_of_lt_zero (sub_lt_zero.2 (int.coe_nat_lt_coe_nat_of_lt h‚ÇÇ)) with k e
rw [e, sqrt_aux._match_1]
intros
cases n
cases n; refl
refl
refl
intros
rcases o with _|_|_; simp
rcases o with _|_|_
simp
simp
simp
intros
cases o; simp
{cases o; simp}
cases o
simp
simp
intros
rw h.1; refl
rw h.1
intros
rw [‚Üê all_dual, dual_rotate_r, all_rotate_l]; simp [all_dual, and_comm, and.left_comm]
rw [‚Üê all_dual, dual_rotate_r, all_rotate_l]
simp [all_dual, and_comm, and.left_comm]
intros
rw [bind_some_eq_map]; simp [map_id']
rw [bind_some_eq_map]
simp [map_id']
intros
{ cases x, refl }
cases x
refl
intros
dsimp only [ichildren,pfunctor.obj.iget]
{ dsimp only [ichildren,pfunctor.obj.iget], congr' with h, apply ext', dsimp only [children',M.mk,approx.s_mk], intros, refl }
congr' with h
apply ext'
dsimp only [children',M.mk,approx.s_mk]
intros
refl
intros
rcases p
{ rcases p, rcases q, simp [coeff, sub_eq_add_neg, add_to_finsupp, neg_to_finsupp] }
rcases q
simp [coeff, sub_eq_add_neg, add_to_finsupp, neg_to_finsupp]
intros
rcases p
rcases q
simp only [coeff, mul_to_finsupp]
exact add_monoid_algebra.mul_apply_antidiagonal p q n _ (Œª x, nat.mem_antidiagonal)
intros
rw [degree_eq_nat_degree hp, with_bot.coe_eq_coe]
intros
simpa only [C_1, one_mul] using le_trailing_degree_C_mul_X_pow n (1:R)
intros
simp [derivative_comp]
intros
classical
induction s using finset.induction with p hp s hs
simp
rw [sum_insert, eval‚ÇÇ_add, hs, sum_insert]
rw [sum_insert, eval‚ÇÇ_add, hs, sum_insert]; assumption
assumption
assumption
assumption
assumption
intros
apply polynomial.induction_on' p
{ intros p q hp hq, simp [hp, hq, mul_add], }
intros p q hp hq
simp [hp, hq, mul_add]
{ intros n b, simp [mul_assoc], }
intros n b
simp [mul_assoc]
intros
apply sum_add_index; simp [add_mul]
{ apply sum_add_index; simp [add_mul] }
apply sum_add_index
simp [add_mul]
simp [add_mul]
intros
rw [integral_normalization_coeff, if_pos hi]
intros
obtain ‚ü®k, hk‚ü© := nat.exists_eq_succ_of_ne_zero h
convert monic_X_pow_sub _
exact le_trans degree_C_le nat.with_bot.coe_nonneg
intros
classical; by_contradiction hp; exact fintype.false ‚ü®p.roots.to_finset, Œª x, multiset.mem_to_finset.mpr ((mem_roots hp).mpr (h _))‚ü©
classical; by_contradiction hp
classical
by_contradiction hp
exact fintype.false ‚ü®p.roots.to_finset, Œª x, multiset.mem_to_finset.mpr ((mem_roots hp).mpr (h _))‚ü©
intros
intros b‚ÇÅ b‚ÇÇ h
{ intros b‚ÇÅ b‚ÇÇ h, simpa only [true_and, prod.mk.inj_iff, eq_self_iff_true] using h }
simpa only [true_and, prod.mk.inj_iff, eq_self_iff_true] using h
intros
rw [corecF, M.dest_corec]
intros
cases n; simp [mk_pnat]; change int.nat_abs 0 with 0; simp *; refl
cases n; simp [mk_pnat]; change int.nat_abs 0 with 0; simp *
cases n; simp [mk_pnat]; change int.nat_abs 0 with 0
cases n; simp [mk_pnat]
cases n
simp [mk_pnat]
change int.nat_abs 0 with 0
simp *
refl
intros
{ cases q‚ÇÅ, cases q‚ÇÇ, apply mk_pnat_denom_dvd }
cases q‚ÇÅ
cases q‚ÇÇ
apply mk_pnat_denom_dvd
intros
have : (n : ‚Ñ§) % d = n - d * ‚åä(n : ‚Ñö)/ d‚åã
from int.mod_nat_eq_sub_mul_floor_rat_div
rw ‚Üêthis
have : d.coprime n
from n_coprime_d.symm
rwa [nat.coprime, nat.gcd_rec] at this
intros
{ ext n, cases h : f (n + 1); simp [h, pow_succ] }
ext n
cases h : f (n + 1)
cases h : f (n + 1); simp [h, pow_succ]
simp [h, pow_succ]
simp [h, pow_succ]
intros
rw [‚Üêreal.to_nnreal_one, real.to_nnreal_lt_to_nnreal_iff h.pos]
exact h.one_lt
intros
rw [div_eq_mul_inv, ‚Üê mul_add, inv_two_add_inv_two, mul_one]
intros
simpa only [mul_comm] using infi_mul_of_ne h0 h
intros
rw [fib_rec, linear_recurrence.char_poly]
simp [finset.sum_fin_eq_sum_range, finset.sum_range_succ', monomial_eq_smul_X]
intros
cases (lt_or_gt_of_ne h0) with hn hp
exact or.inr (infinite_neg_iff_infinitesimal_inv_neg.mpr ‚ü®hi, inv_lt_zero.mpr hn‚ü©)
{ exact or.inr (infinite_neg_iff_infinitesimal_inv_neg.mpr ‚ü®hi, inv_lt_zero.mpr hn‚ü©) }
exact or.inl (infinite_pos_iff_infinitesimal_inv_pos.mpr ‚ü®hi, inv_pos.mpr hp‚ü©)
{ exact or.inl (infinite_pos_iff_infinitesimal_inv_pos.mpr ‚ü®hi, inv_pos.mpr hp‚ü©) }
intros
{ rintro ‚ü®a, rfl‚ü©, exact tr (is_algebraic_algebra_map a) }
rintro ‚ü®a, rfl‚ü©
exact tr (is_algebraic_algebra_map a)
intros
cases le_total 0 p
{ rw [‚Üê nnreal.coe_lt_coe, real.coe_to_nnreal p h] }
rw [‚Üê nnreal.coe_lt_coe, real.coe_to_nnreal p h]
rw [to_nnreal_eq_zero.2 h]
{ rw [to_nnreal_eq_zero.2 h], split, { intro, have := not_lt_of_le (zero_le r), contradiction }, { intro rp, have : ¬¨(p ‚â§ 0) := not_le_of_lt (lt_of_le_of_lt (nnreal.coe_nonneg _) rp), contradiction } }
split
{ intro, have := not_lt_of_le (zero_le r), contradiction }
intro
have := not_lt_of_le (zero_le r)
contradiction
intro rp
{ intro rp, have : ¬¨(p ‚â§ 0) := not_le_of_lt (lt_of_le_of_lt (nnreal.coe_nonneg _) rp), contradiction }
have : ¬¨(p ‚â§ 0) := not_le_of_lt (lt_of_le_of_lt (nnreal.coe_nonneg _) rp)
contradiction
intros
{ ext, simp [coe_to_nnreal x h, abs_of_nonneg h] }
ext
simp [coe_to_nnreal x h, abs_of_nonneg h]
intros
rw [sqrt, ‚Üê nnreal.coe_mul, nnreal.mul_self_sqrt, real.coe_to_nnreal _ h]
intros
{ ext x, simp [mem_image] }
ext x
simp [mem_image]
intros
induction l; simp [*, stream.nil_append_stream, stream.cons_append_stream]
induction l
simp [*, stream.nil_append_stream, stream.cons_append_stream]
simp [*, stream.nil_append_stream, stream.cons_append_stream]
intros
{ congr' with x, apply_assumption }
congr' with x
apply_assumption
intros
ext ‚ü®x, y‚ü©
{ ext ‚ü®x, y‚ü©, simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt} }
simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt}
intros
rw [‚Üê union_pi, union_compl_self]
intros
ext
split
rintro ‚ü®a, _, ha, ‚ü®b, hb, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®a, _, ha, ‚ü®b, hb, rfl‚ü©, rfl‚ü©, refine ‚ü®a, b, ha, hb, rfl‚ü© }
refine ‚ü®a, b, ha, hb, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
{ rintro ‚ü®a, b, ha, hb, rfl‚ü©, refine ‚ü®a, _, ha, ‚ü®b, hb, rfl‚ü©, rfl‚ü© }
refine ‚ü®a, _, ha, ‚ü®b, hb, rfl‚ü©, rfl‚ü©
intros
rw sUnion_eq_bUnion; exact hs.bUnion h
rw sUnion_eq_bUnion
exact hs.bUnion h
intros
casesI hs
choose f hf using show ‚àÄ x : s, ‚àÉ i, x.1 ‚àà t i, {simpa [subset_def] using h}
refine ‚ü®range f, finite_range f, Œª x hx, _‚ü©
rw [bUnion_range, mem_Union]
exact ‚ü®‚ü®x, hx‚ü©, hf _‚ü©
intros
intros y hy
rcases h‚ÇÅ hy.1 with ‚ü®x‚ÇÅ, hx‚ÇÅ, rfl‚ü©
rcases h‚ÇÇ hy.2 with ‚ü®x‚ÇÇ, hx‚ÇÇ, heq‚ü©
have : x‚ÇÅ = x‚ÇÇ
from h (or.inl hx‚ÇÅ) (or.inr hx‚ÇÇ) heq.symm
subst x‚ÇÇ
exact mem_image_of_mem f ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
intros
rintros y ‚ü®x, hxt, rfl‚ü©
rcases ha hxt with ‚ü®x, hxs, rfl‚ü©
rw [h x]
exact mem_image_of_mem _ (mem_image_of_mem _ hxs)
intros
cases lt_or_le x y with h' h'
{ use x, simp [*, not_le.2 h'] }
use x
simp [*, not_le.2 h']
{ use max x (x + dy), simp [*, le_refl] }
use max x (x + dy)
simp [*, le_refl]
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ioi_of_neg a h
intros
have : Ioc (x i‚ÇÄ) m = Iic m ‚à© Ioc (x i‚ÇÄ) (y i‚ÇÄ)
rw [‚Üê Ioi_inter_Iic, ‚Üê Ioi_inter_Iic, inter_left_comm, inter_eq_self_of_subset_left (Iic_subset_Iic.2 hm)]
rw [‚Üê Ioi_inter_Iic, ‚Üê Ioi_inter_Iic, inter_left_comm, inter_eq_self_of_subset_left (Iic_subset_Iic.2 hm)]
simp_rw [univ_pi_update i‚ÇÄ y m (Œª i z, Ioc (x i) z), ‚Üê pi_inter_compl ({i‚ÇÄ} : set Œπ), singleton_pi', ‚Üê inter_assoc, this]
refl
intros
{ ext, simp }
ext
simp
intros
simp [set.eq_empty_iff_forall_not_mem]
intros
cases n
{ exact congr_arg ((‚àò) int.cast) zmod.cast_id', }
exact congr_arg ((‚àò) int.cast) zmod.cast_id'
{ ext, simp }
ext
simp
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
have h0 : C 0 := add_neg_self (1:R) ‚ñ∏ ha h1 hneg1
rcases exists_list_of_mem_closure hx with ‚ü®L, HL, rfl‚ü©
clear hx
induction L with hd tl ih
exact h0
{ exact h0 }
rw list.forall_mem_cons at HL
suffices : C (list.prod hd)
rw [list.map_cons, list.sum_cons]
{ rw [list.map_cons, list.sum_cons], exact ha this (ih HL.2) }
exact ha this (ih HL.2)
replace HL := HL.1
clear ih tl
suffices : ‚àÉ L : list R, (‚àÄ x ‚àà L, x ‚àà s) ‚àß (list.prod hd = list.prod L ‚à® list.prod hd = -list.prod L)
rcases this with ‚ü®L, HL', HP | HP‚ü©
{ rcases this with ‚ü®L, HL', HP | HP‚ü©, { rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }, rw HP, clear HP HL hd, induction L with hd tl ih, { exact hneg1 }, rw [list.prod_cons, neg_mul_eq_mul_neg], rw list.forall_mem_cons at HL', exact hs _ HL'.1 _ (ih HL'.2) }
rw HP
{ rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }
clear HP HL hd
induction L with hd tl ih
exact h1
{ exact h1 }
rw list.forall_mem_cons at HL'
rw list.prod_cons
exact hs _ HL'.1 _ (ih HL'.2)
rw HP
clear HP HL hd
induction L with hd tl ih
exact hneg1
{ exact hneg1 }
rw [list.prod_cons, neg_mul_eq_mul_neg]
rw list.forall_mem_cons at HL'
exact hs _ HL'.1 _ (ih HL'.2)
induction hd with hd tl ih
{ exact ‚ü®[], list.forall_mem_nil _, or.inl rfl‚ü© }
exact ‚ü®[], list.forall_mem_nil _, or.inl rfl‚ü©
rw list.forall_mem_cons at HL
rcases ih HL.2 with ‚ü®L, HL', HP | HP‚ü©
rcases ih HL.2 with ‚ü®L, HL', HP | HP‚ü©; cases HL.1 with hhd hhd
cases HL.1 with hhd hhd
exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]‚ü©
{ exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]‚ü© }
exact ‚ü®L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]‚ü©
{ exact ‚ü®L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]‚ü© }
cases HL.1 with hhd hhd
exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]‚ü©
{ exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]‚ü© }
exact ‚ü®L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]‚ü©
{ exact ‚ü®L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]‚ü© }
intros
refine f.tendsto_translation_number_aux.congr_dist (squeeze_zero (Œª _, dist_nonneg) _ _)
{ exact Œª n, C / 2^n }
exact Œª n, C / 2^n
intro n
{ intro n, have : 0 < (2^n:‚Ñù) := pow_pos zero_lt_two _, convert (div_le_div_right this).2 (H (2^n)), rw [transnum_aux_seq, real.dist_eq, ‚Üê sub_div, abs_div, abs_of_pos this, real.dist_eq] }
have : 0 < (2^n:‚Ñù) := pow_pos zero_lt_two _
convert (div_le_div_right this).2 (H (2^n))
rw [transnum_aux_seq, real.dist_eq, ‚Üê sub_div, abs_div, abs_of_pos this, real.dist_eq]
exact mul_zero C ‚ñ∏ tendsto_const_nhds.mul (tendsto_inv_at_top_zero.comp $ tendsto_pow_at_top_at_top_of_one_lt one_lt_two)
{ exact mul_zero C ‚ñ∏ tendsto_const_nhds.mul (tendsto_inv_at_top_zero.comp $ tendsto_pow_at_top_at_top_of_one_lt one_lt_two) }
intros
convert hx
intros
conv_lhs { rw ‚Üê nat.mod_add_div n (minimal_period f x) }
rw [iterate_add, mul_comm, iterate_mul, comp_app]
congr
exact is_periodic_pt.iterate (is_periodic_pt_minimal_period _ _) _
intros
ext
{ ext, rw [mem_lift2, mem_bot], exact set.ext_iff.mp subtype.range_coe x }
rw [mem_lift2, mem_bot]
exact set.ext_iff.mp subtype.range_coe x
intros
rw [‚Üê card_units_eq_totient, pow_card_eq_one]
intros
rw is_scalar_tower.aeval_apply R K
{ rw is_scalar_tower.aeval_apply R K, exact eval‚ÇÇ_eq_zero_of_dvd_of_eval‚ÇÇ_eq_zero (algebra_map K U) y (minpoly.dvd_map_of_is_scalar_tower R K x) hy }
exact eval‚ÇÇ_eq_zero_of_dvd_of_eval‚ÇÇ_eq_zero (algebra_map K U) y (minpoly.dvd_map_of_is_scalar_tower R K x) hy
intros
rw [angle, ‚Üê real_inner_div_norm_mul_norm_eq_neg_one_iff, real.arccos_eq_pi, has_le.le.le_iff_eq]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1
intros
have hd' : finrank ‚Ñù (‚ä§ : affine_subspace ‚Ñù P).direction = 2
rw [direction_top, finrank_top]
{ rw [direction_top, finrank_top], exact hd }
exact hd
exact eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd' (mem_top ‚Ñù V _) (mem_top ‚Ñù V _) (mem_top ‚Ñù V _) (mem_top ‚Ñù V _) (mem_top ‚Ñù V _) hc hp hp‚ÇÅc‚ÇÅ hp‚ÇÇc‚ÇÅ hpc‚ÇÅ hp‚ÇÅc‚ÇÇ hp‚ÇÇc‚ÇÇ hpc‚ÇÇ
intros
refine span_points_subset_coe_of_subset_coe _
rw [set.insert_subset, set.singleton_subset_iff]
exact ‚ü®t.orthocenter_mem_altitude, t.mem_altitude i‚ü©
intros
{ simp only [chart], mfld_set_tac }
simp only [chart]
mfld_set_tac
intros
simp only [f.eq_on_source hs, (‚àò), f.to_times_cont_diff_bump.one_of_mem_closed_ball hd]
intros
ext p : 1
{ ext p : 1, simp only [tangent_map_within, tangent_map] with mfld_simps }
simp only [tangent_map_within, tangent_map] with mfld_simps
intros
simp [fs.apply_ind x hx]
intros
rw [‚Üê ext_chart_at_map_nhds_within' I x hy, map_map, map_congr, map_id]
exact (ext_chart_at I x).left_inv_on.eq_on.eventually_eq_of_mem (ext_chart_at_source_mem_nhds_within' _ _ hy)
intros
rw [times_cont_mdiff_within_at_iff, and.congr_right_iff]
set e := ext_chart_at I x
set e' := ext_chart_at I' (f x)
refine Œª hc, times_cont_diff_within_at_congr_nhds _
rw [‚Üê e.image_source_inter_eq', ‚Üê ext_chart_at_map_nhds_within_eq_image, ‚Üê ext_chart_at_map_nhds_within, inter_comm, nhds_within_inter_of_mem]
exact hc (ext_chart_at_source_mem_nhds _ _)
intros
ext
ext; rcases x; refl
ext; rcases x
rcases x
refl
intros
induction h with L‚ÇÇ L‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ ih
{ exact ‚ü®0, rfl‚ü© }
exact ‚ü®0, rfl‚ü©
rcases ih with ‚ü®n, eq‚ü©
{ rcases ih with ‚ü®n, eq‚ü©, existsi (1 + n), simp [mul_add, eq, (step.length h‚ÇÇ‚ÇÉ).symm, add_assoc] }
existsi (1 + n)
simp [mul_add, eq, (step.length h‚ÇÇ‚ÇÉ).symm, add_assoc]
intros
ext h
rw [mem_stabilizer_iff, ‚Üê vadd_left_cancel_iff (-g) , vadd_vadd, vadd_vadd, vadd_vadd, add_left_neg, zero_vadd, ‚Üê mem_stabilizer_iff, add_subgroup.mem_map_equiv, add_aut.conj_symm_apply]
intros
rw [smul_smul, mul_left_inv, one_smul]
intros
rw f.lift_mk' hg; exact mul_inv_left hg _ _ _
rw f.lift_mk' hg
exact mul_inv_left hg _ _ _
intros
by_cases bc : b = c
subst bc
{ subst bc, simp [one_mem] }
simp [one_mem]
exact subset_closure (is_three_cycle_swap_mul_swap_same ab ac bc)
intros
rw [‚Üêtwo_le_card_support_cycle_of_iff, ‚Üênat.succ_le_iff]
exact ‚ü®Œª h, or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_le‚ü©
intros
rw [coe_cycle_range_of_le h.le, if_neg h.ne]
intros
simp only [fin_pairs_lt, fin.lt_iff_coe_lt_coe, true_and, mem_attach_fin, mem_range, mem_univ, mem_sigma]
intros
letI : fintype ‚Ü•(show set Œ±, from p) := ‚Äπfintype {x // p x}‚Ä∫
exact perm_inv_maps_to_of_maps_to f h hx
intros
rw disjoint_iff_disjoint_support at h ‚ä¢
intros a ha
exact h (mem_inter_of_mem (hf (mem_of_mem_inter_left ha)) (hg (mem_of_mem_inter_right ha)))
intros
ext k
refine exists_congr _
simp [subtype.ext_iff]
intros
haveI : fintype (H : set G) := ‚Äπfintype H‚Ä∫
rw [set_like.ext'_iff, coe_top, ‚Üê finset.coe_univ, ‚Üê (H : set G).coe_to_finset, finset.coe_inj, ‚Üê finset.card_eq_iff_eq_univ, ‚Üê h, set.to_finset_card]
congr
intros
rw [vector_span_eq_span_vsub_set_left k (set.mem_range_self i0), ‚Üêset.range_comp]
intros
cases is_empty_or_nonempty Œπ with h h
haveI := h
{ haveI := h, apply affine_independent_of_subsingleton, }
apply affine_independent_of_subsingleton
obtain ‚ü®i‚ü© := h
rw affine_independent_iff_linear_independent_vsub k p i at hai
simp_rw [affine_independent_iff_linear_independent_vsub k (f ‚àò p) i, function.comp_app, ‚Üê f.linear_map_vsub]
have hf' : f.linear.ker = ‚ä•
rwa [linear_map.ker_eq_bot, f.injective_iff_linear_injective]
{ rwa [linear_map.ker_eq_bot, f.injective_iff_linear_injective], }
exact linear_independent.map' hai f.linear hf'
intros
simp only [line_map_apply_module]
rw [‚Üê lt_sub_iff_add_lt, add_sub_assoc, ‚Üê sub_lt_iff_lt_add', ‚Üê sub_smul, ‚Üê sub_smul, sub_sub_sub_cancel_left, smul_lt_smul_iff_of_pos (sub_pos.2 h)]
apply_instance
intros
rw submodule.span_image
exact submodule.mem_map_of_mem h
intros
rw [ker, eq_bot_iff, map_le_iff_le_comap]
intros
ext
ext; cases i; simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
ext; cases i
{ ext; cases i; simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app] }
cases i
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
cases i
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, add_left, neg_left]
intros
ext B
{ ext B, rw [bilin_form.to_matrix_apply, bilin_form.to_matrix'_apply, pi.basis_fun_apply, pi.basis_fun_apply] }
rw [bilin_form.to_matrix_apply, bilin_form.to_matrix'_apply, pi.basis_fun_apply, pi.basis_fun_apply]
intros
by_cases H : ‚àÉ (s : finset M), nonempty (basis s ùïú M)
haveI : finite_dimensional ùïú M
{ haveI : finite_dimensional ùïú M, { rcases H with ‚ü®s, ‚ü®hs‚ü©‚ü©, exact finite_dimensional.of_finset_basis hs }, simp only [‚Üê det_to_matrix (finite_dimensional.fin_basis ùïú M), linear_equiv.map_smul, fintype.card_fin, det_smul] }
{ rcases H with ‚ü®s, ‚ü®hs‚ü©‚ü©, exact finite_dimensional.of_finset_basis hs }
rcases H with ‚ü®s, ‚ü®hs‚ü©‚ü©
exact finite_dimensional.of_finset_basis hs
simp only [‚Üê det_to_matrix (finite_dimensional.fin_basis ùïú M), linear_equiv.map_smul, fintype.card_fin, det_smul]
classical
{ classical, have : finite_dimensional.finrank ùïú M = 0 := finrank_eq_zero_of_not_exists_basis H, simp [coe_det, H, this] }
have : finite_dimensional.finrank ùïú M = 0 := finrank_eq_zero_of_not_exists_basis H
simp [coe_det, H, this]
intros
rcases f.range_restrict.exists_right_inverse_of_surjective f.range_range_restrict with ‚ü®g, hg‚ü©
have fg : left_inverse f.range_restrict g
from linear_map.congr_fun hg
refine ‚ü®Œª h, _, _‚ü©
rcases le_dim_iff_exists_linear_independent.1 h with ‚ü®s, rfl, si‚ü©
{ rcases le_dim_iff_exists_linear_independent.1 h with ‚ü®s, rfl, si‚ü©, refine ‚ü®g '' s, cardinal.mk_image_eq_lift _ _ fg.injective, _‚ü©, replace fg : ‚àÄ x, f (g x) = x, by { intro x, convert congr_arg subtype.val (fg x) }, replace si : linear_independent K (Œª x : s, f (g x)), by simpa only [fg] using si.map' _ (ker_subtype _), exact si.image_of_comp s g f }
refine ‚ü®g '' s, cardinal.mk_image_eq_lift _ _ fg.injective, _‚ü©
replace fg : ‚àÄ x, f (g x) = x
intro x
intro x
{ intro x, convert congr_arg subtype.val (fg x) }
{ intro x, convert congr_arg subtype.val (fg x) }
convert congr_arg subtype.val (fg x)
convert congr_arg subtype.val (fg x)
replace si : linear_independent K (Œª x : s, f (g x))
simpa only [fg] using si.map' _ (ker_subtype _)
simpa only [fg] using si.map' _ (ker_subtype _)
exact si.image_of_comp s g f
rintro ‚ü®s, hsc, si‚ü©
{ rintro ‚ü®s, hsc, si‚ü©, have : linear_independent K (Œª x : s, f.range_restrict x), from linear_independent.of_comp (f.range.subtype) (by convert si), convert cardinal_le_dim_of_linear_independent this.image, rw [‚Üê cardinal.lift_inj, ‚Üê hsc, cardinal.mk_image_eq_of_inj_on_lift], exact inj_on_iff_injective.2 this.injective }
have : linear_independent K (Œª x : s, f.range_restrict x)
from linear_independent.of_comp (f.range.subtype) (by convert si)
convert cardinal_le_dim_of_linear_independent this.image
rw [‚Üê cardinal.lift_inj, ‚Üê hsc, cardinal.mk_image_eq_of_inj_on_lift]
exact inj_on_iff_injective.2 this.injective
intros
rw [‚Üê b.to_dual_total_right, b.total_repr]
intros
{ ext, refl }
ext
refl
intros
{ rw ‚Üê algebra.top_to_submodule, refl }
rw ‚Üê algebra.top_to_submodule
refl
intros
simp
intros
simp [total_apply, finsupp.sum, support_emb_domain, emb_domain_apply]
intros
fsplit
rintros p Œ∫ w i' j rfl
{ rintros p Œ∫ w i' j rfl, specialize p (range w) i'.coe_range (range_comp_subset_range _ _), rw [range_comp, ‚Üê@image_univ _ _ w] at p, exact range_iff_surjective.mp (image_injective.mpr i'.injective p), }
specialize p (range w) i'.coe_range (range_comp_subset_range _ _)
rw [range_comp, ‚Üê@image_univ _ _ w] at p
exact range_iff_surjective.mp (image_injective.mpr i'.injective p)
intros p w i' h
{ intros p w i' h, specialize p w (coe : w ‚Üí M) i' (Œª i, ‚ü®v i, range_subset_iff.mp h i‚ü©) (by { ext, simp, }), have q := congr_arg (Œª s, (coe : w ‚Üí M) '' s) p.range_eq, dsimp at q, rw [‚Üêimage_univ, image_image] at q, simpa using q, }
specialize p w (coe : w ‚Üí M) i' (Œª i, ‚ü®v i, range_subset_iff.mp h i‚ü©) (by { ext, simp, })
have q := congr_arg (Œª s, (coe : w ‚Üí M) '' s) p.range_eq
dsimp at q
rw [‚Üêimage_univ, image_image] at q
simpa using q
intros
simp only [charmatrix, pi.sub_apply, scalar_apply_ne _ _ _ h, zero_sub, ring_hom.map_matrix_apply, map_apply, dmatrix.sub_apply]
intros
simp [matrix.det_succ_row_zero, fin.sum_univ_succ]
ring
intros
ext i j
obtain ‚ü®j', hj'‚ü© : ‚àÉ j', j' ‚â† j := exists_ne j
apply det_eq_zero_of_column_eq_zero j'
intro j''
simp [update_column_ne hj']
intros
rw [‚Üê(inv_eq_left_inv h), ‚Üê(inv_eq_left_inv g)]
intros
ext
{ ext, rw [matrix.one_apply, linear_map.to_matrix'_apply, id_apply] }
rw [matrix.one_apply, linear_map.to_matrix'_apply, id_apply]
intros
simp [transvection, matrix.add_mul, ha]
intros
tidy
intros
simpa using (comap_mono bot_le : p.mkq.ker ‚â§ comap p.mkq p')
intros
rw [h]
intros
refine integral_congr_ae _
filter_upwards [hf.prod_right_ae, hg.prod_right_ae]
intros x h2f h2g
simp [integral_sub h2f h2g]
intros
split
split; intro h
intro h
refine measure.absolutely_continuous.mk (Œª S hS‚ÇÅ hS‚ÇÇ, _)
{ refine measure.absolutely_continuous.mk (Œª S hS‚ÇÅ hS‚ÇÇ, _), obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hpos, hneg‚ü© := s.to_jordan_decomposition_spec, rw [total_variation, measure.add_apply, hpos, hneg, to_measure_of_zero_le_apply _ _ _ hS‚ÇÅ, to_measure_of_le_zero_apply _ _ _ hS‚ÇÅ], rw ‚Üê vector_measure.absolutely_continuous.ennreal_to_measure at h, simp [h (measure_mono_null (i.inter_subset_right S) hS‚ÇÇ), h (measure_mono_null (i·∂ú.inter_subset_right S) hS‚ÇÇ)], refl }
obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hpos, hneg‚ü© := s.to_jordan_decomposition_spec
rw [total_variation, measure.add_apply, hpos, hneg, to_measure_of_zero_le_apply _ _ _ hS‚ÇÅ, to_measure_of_le_zero_apply _ _ _ hS‚ÇÅ]
rw ‚Üê vector_measure.absolutely_continuous.ennreal_to_measure at h
simp [h (measure_mono_null (i.inter_subset_right S) hS‚ÇÇ), h (measure_mono_null (i·∂ú.inter_subset_right S) hS‚ÇÇ)]
intro h
refine vector_measure.absolutely_continuous.mk (Œª S hS‚ÇÅ hS‚ÇÇ, _)
{ refine vector_measure.absolutely_continuous.mk (Œª S hS‚ÇÅ hS‚ÇÇ, _), rw ‚Üê vector_measure.ennreal_to_measure_apply hS‚ÇÅ at hS‚ÇÇ, exact null_of_total_variation_zero s (h hS‚ÇÇ) }
rw ‚Üê vector_measure.ennreal_to_measure_apply hS‚ÇÅ at hS‚ÇÇ
exact null_of_total_variation_zero s (h hS‚ÇÇ)
intros
simp only [condexp_ind_L1, hŒºs, eq_self_iff_true, not_true, ne.def, dif_neg, not_false_iff, and_false]
intros
ext1
refine (coe_fn_comp_Lp' (c ‚Ä¢ L) f).trans _
refine eventually_eq.trans _ (Lp.coe_fn_smul _ _).symm
refine (L.coe_fn_comp_Lp' f).mono (Œª x hx, _)
rw [pi.smul_apply, hx]
refl
intros
{ simp_rw [snorm_ess_sup], exact ess_sup_smul_measure hc, }
simp_rw [snorm_ess_sup]
exact ess_sup_smul_measure hc
intros
haveI : nonempty s := ‚ü®‚ü®y‚ÇÄ, h‚ÇÄ‚ü©‚ü©
suffices : ‚àÄ n, (nat.cases_on n y‚ÇÄ (coe ‚àò dense_seq s) : Œ±) ‚àà s
apply this
{ apply this }
rintro (_|n)
exacts [h‚ÇÄ, subtype.mem _]
intros
rcases l with ‚ü®l‚ü©
{ rcases l with ‚ü®l‚ü©, simpa using l.ae_measurable_prod' (by simpa using hl) }
simpa using l.ae_measurable_prod' (by simpa using hl)
intros
simp [interval_integral]
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
ext1
refine (ae_restrict_of_ae (Lp.coe_fn_smul c f)).mp _
refine (mem_‚Ñíp.coe_fn_to_Lp ((Lp.mem_‚Ñíp f).restrict s)).mp _
refine (mem_‚Ñíp.coe_fn_to_Lp ((Lp.mem_‚Ñíp (c ‚Ä¢ f)).restrict s)).mp _
refine (Lp.coe_fn_smul c (mem_‚Ñíp.to_Lp f ((Lp.mem_‚Ñíp f).restrict s))).mono (Œª x hx1 hx2 hx3 hx4, _)
rw [hx2, hx1, pi.smul_apply, hx3, hx4, pi.smul_apply]
intros
assume t ht
have : g ‚Åª¬π' t = (g ‚Åª¬π' t ‚à© {x | f x = g x}·∂ú) ‚à™ (g ‚Åª¬π' t ‚à© {x | f x = g x})
simp [‚Üê inter_union_distrib_left]
simp [‚Üê inter_union_distrib_left]
rw this
apply measurable_set.union (h.mono (inter_subset_right _ _)).measurable_set
have : g ‚Åª¬π' t ‚à© {x : Œ± | f x = g x} = f ‚Åª¬π' t ‚à© {x : Œ± | f x = g x}
ext x
ext x
{ ext x, simp {contextual := tt} }
{ ext x, simp {contextual := tt} }
simp {contextual := tt}
simp {contextual := tt}
rw this
exact (hf ht).inter h.measurable_set.of_compl
intros
refine le_antisymm _ (zero_le _)
rw ‚ÜêŒº.empty
refine bsupr_le (Œª K hK, _)
have : K = ‚ä•
ext1
{ ext1, rw [subset_empty_iff.mp hK, compacts.bot_val] }
rw [subset_empty_iff.mp hK, compacts.bot_val]
rw this
refl'
intros
let eval : (compacts G ‚Üí ‚Ñù) ‚Üí ‚Ñù := Œª f, f ‚ü®K‚ÇÄ.1, K‚ÇÄ.2.1‚ü©
have : continuous eval := continuous_apply _
show chaar K‚ÇÄ ‚àà eval ‚Åª¬π' {(1 : ‚Ñù)}
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K‚ÇÄ ‚ü®set.univ, is_open_univ, mem_univ _‚ü©)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©
{ rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©, apply prehaar_self, rw h2U.interior_eq, exact ‚ü®1, h3U‚ü© }
apply prehaar_self
rw h2U.interior_eq
exact ‚ü®1, h3U‚ü©
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_singleton }
exact is_closed_singleton
intros
rcases h.eq_or_lt with rfl|h
exact le_rfl
{ exact le_rfl }
cases hausdorff_measure_zero_or_top h s with hs hs
{ rw hs, exact zero_le _ }
rw hs
exact zero_le _
{ rw hs, exact le_top }
rw hs
exact le_top
intros
simp only [ae_iff] at h ‚ä¢
simpa [set_of_and, inter_comm] using measure_inter_eq_zero_of_restrict h
intros
intro t
by_cases ht : (0 : Œ≤) ‚àà t
rw mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs
{ rw mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs, exact id, }
exact id
rw [mem_map_indicator_ae_iff_of_zero_nmem ht, mem_map_restrict_ae_iff hs]
exact Œª h, measure_mono_null ((set.inter_subset_left _ _).trans (set.subset_union_left _ _)) h
intros
refine le_infi _
intro h‚ÇÇ
have := extend_union measurable_set.empty m0 measurable_set.Union mU disjoint_diff h‚ÇÅ (h‚ÇÇ.diff h‚ÇÅ)
rw union_diff_cancel hs at this
rw ‚Üê extend_eq m
exact le_iff_exists_add.2 ‚ü®_, this‚ü©
intros
by_cases hf : measurable f
refine mk (Œª s hs hws, _)
{ refine mk (Œª s hs hws, _), rw map_apply _ hf hs at hws ‚ä¢, exact h hws }
rw map_apply _ hf hs at hws ‚ä¢
exact h hws
intros s hs
{ intros s hs, rw [map_not_measurable v hf, zero_apply] }
rw [map_not_measurable v hf, zero_apply]
intros
{ congr, exact h }
congr
exact h
ext
simp only [finset.not_mem_empty, nat.dvd_one, not_and, not_lt, mem_proper_divisors, iff_false]
apply ge_of_eq
intros
by_cases hn : n = 0
{ subst hn, simp at not_dvd, trivial, }
subst hn
simp at not_dvd
trivial
rw padic_val_nat_def hn
{ rw padic_val_nat_def hn, exact (@multiplicity.unique' _ _ _ p n 0 (by simp) (by simpa using not_dvd)).symm, assumption, }
exact (@multiplicity.unique' _ _ _ p n 0 (by simp) (by simpa using not_dvd)).symm
assumption
intros
simp [cast_eq_of_rat]
intros
have : (p : ‚Ñù) ^ (-n : ‚Ñ§) = ‚Üë((p ^ (-n : ‚Ñ§) : ‚Ñö))
simp
{simp}
rw [show (k : ‚Ñö_[p]) = ((k : ‚Ñö) : ‚Ñö_[p]), by norm_cast, eq_padic_norm, this]
norm_cast
rw padic_norm.dvd_iff_norm_le
intros
ext1 r
apply eq_of_forall_dist_le
intros Œµ hŒµ
obtain ‚ü®n, hn‚ü© := exists_pow_neg_lt p hŒµ
apply le_trans _ (le_of_lt hn)
rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, ‚Üê ker_to_zmod_pow, ring_hom.mem_ker, ring_hom.map_sub, ‚Üê ring_hom.comp_apply, ‚Üê ring_hom.comp_apply, lift_spec, hg, sub_self]
intros
have := pell_zd_succ_succ a1 n
unfold pell_zd at this
rw [‚Üê int.cast_coe_nat, zsqrtd.smul_val] at this
injection this with h‚ÇÅ h‚ÇÇ
split
split; apply int.coe_nat_inj; [simpa using h‚ÇÅ, simpa using h‚ÇÇ]
split; apply int.coe_nat_inj
apply int.coe_nat_inj
simpa using h‚ÇÅ
apply int.coe_nat_inj
simpa using h‚ÇÇ
intros
by_cases h0 : int.gcd x y = 0
have hx : x = 0
{ have hx : x = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }, have hy : y = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }, have hz : z = 0, { simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }, simp only [hz, dvd_zero], }
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hy : y = 0
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }
apply nat.eq_zero_of_gcd_eq_zero_right h0
have hz : z = 0
simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h
{ simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }
simp only [hz, dvd_zero]
obtain ‚ü®k, x0, y0, k0, h2, rfl, rfl‚ü© : ‚àÉ (k : ‚Ñï) x0 y0, 0 < k ‚àß int.gcd x0 y0 = 1 ‚àß x = x0 * k ‚àß y = y0 * k := int.exists_gcd_one' (nat.pos_of_ne_zero h0)
rw [int.gcd_mul_right, h2, int.nat_abs_of_nat, one_mul]
rw [‚Üê int.pow_dvd_pow_iff (dec_trivial : 0 < 2), sq z, ‚Üê h.eq]
rw (by ring : x0 * k * (x0 * k) + y0 * k * (y0 * k) = k ^ 2 * (x0 * x0 + y0 * y0))
exact dvd_mul_right _ _
intros
intros x y k
contrapose k
rw [‚Üêne.def, ne_iff_lt_or_gt] at k
cases k
{ apply h _ _ k }
apply h _ _ k
rw eq_comm
{ rw eq_comm, apply h _ _ k }
apply h _ _ k
intros
rw [sdiff_inf, sdiff_self, sup_bot_eq]
intros
rw [supr_insert, supr_singleton]
intros
obtain ‚ü®k : ‚Ñï, hkn : k ‚â§ N, hku : ‚àÄ l ‚â§ N, u l ‚â§ u k‚ü© : ‚àÉ k ‚â§ N, ‚àÄ l ‚â§ N, u l ‚â§ u k
from exists_max_image _ u (finite_le_nat N) ‚ü®N, le_refl N‚ü©
have ex : ‚àÉ n ‚â• N, u k < u n
from exists_lt_of_tendsto_at_top hu _ _
obtain ‚ü®n : ‚Ñï, hnN : n ‚â• N, hnk : u k < u n, hn_min : ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k‚ü© : ‚àÉ n ‚â• N, u k < u n ‚àß ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k
rcases nat.find_x ex with ‚ü®n, ‚ü®hnN, hnk‚ü©, hn_min‚ü©
{ rcases nat.find_x ex with ‚ü®n, ‚ü®hnN, hnk‚ü©, hn_min‚ü©, push_neg at hn_min, exact ‚ü®n, hnN, hnk, hn_min‚ü© }
push_neg at hn_min
exact ‚ü®n, hnN, hnk, hn_min‚ü©
use [n, hnN]
rintros (l : ‚Ñï) (hl : l < n)
have hlk : u l ‚â§ u k
cases (le_total l N : l ‚â§ N ‚à® N ‚â§ l) with H H
{ cases (le_total l N : l ‚â§ N ‚à® N ‚â§ l) with H H, { exact hku l H }, { exact hn_min l hl H } }
{ exact hku l H }
exact hku l H
{ exact hn_min l hl H }
exact hn_min l hl H
calc u l ‚â§ u k : hlk ... < u n : hnk
intros
{ rw ‚Üê prod_at_top_at_top_eq, exact hf.prod_map_prod_at_top hg, }
rw ‚Üê prod_at_top_at_top_eq
exact hf.prod_map_prod_at_top hg
intros
simp [filter.prod]
intros
rw is_extr_filter at *
rwa [‚Üê heq.is_max_filter_iff hfga, ‚Üê heq.is_min_filter_iff hfga]
intros
refine iff.trans ‚ü®Œª h, h.1, Œª h, ‚ü®h‚ü©‚ü© _
simp [lift'_principal monotone_powerset, -mem_prod, -prod.forall, forall_prod_set]
intros
simp only [filter.lift, tendsto_infi]
intros
refine ‚ü®Œª H f hf, H f f.ne_bot hf, _‚ü©
introsI H f hf hfg
exact hp (of_le f) (H _ ((of_le f).trans hfg))
intros
simp [is_bounded, eq_univ_iff_forall]
intros
{ simp [subtype.order_iso_of_nat] }
simp [subtype.order_iso_of_nat]
intros
cases IF.F.nonempty
apply is_proper_of_not_mem (_ : w ‚àâ IF.I)
rwa ‚Üê IF.compl_I_eq_F at h
intros
exactI {..f.is_trichotomous, ..f.is_strict_order}
intros
rw [symm_diff_symm_diff_left, symm_diff_symm_diff_right]
intros
rw [is_wf, well_founded_on_iff] at *
refine subrelation.wf (Œª x y xy, _) h
exact ‚ü®xy.1, st xy.2.1, st xy.2.2‚ü©
intros
intros a _ b _ hab
obtain h | h | h := @trichotomous _ r _ a b
{ exact or.inl h }
exact or.inl h
{ exact (hab h).elim }
exact (hab h).elim
{ exact or.inr h }
exact or.inr h
intros
rw is_artinian_iff_well_founded at h ‚ä¢
refine (submodule.restrict_scalars_embedding R S M).well_founded h
intros
{ rw add_comm at h, exact h.of_add_mul_right_right }
rw add_comm at h
exact h.of_add_mul_right_right
intros
rw [eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm), is_unit_C]
refine hu _ _
rw [‚Üê eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm)]
exact dvd_mul_right _ _
intros
refine ‚ü®Œª h, _, Œª h, submodule.subset_span $ set.mem_image_of_mem (of R M) h‚ü©
rw [of', ‚Üê finsupp.supported_eq_span_single, finsupp.mem_supported, finsupp.support_single_ne_zero (@one_ne_zero R _ (by apply_instance))] at h
simpa using h
intros
apply (x.is_wf_support.is_pwo.add_submonoid_closure (Œª g hg, _)).mono _
exact with_top.coe_le_coe.1 (le_trans (le_of_lt hx) (add_val_le_of_coeff_ne_zero hg))
{ exact with_top.coe_le_coe.1 (le_trans (le_of_lt hx) (add_val_le_of_coeff_ne_zero hg)) }
refine set.Union_subset (Œª n, _)
induction n with n ih; intros g hn
induction n with n ih
intros g hn
simp only [exists_prop, and_true, set.mem_singleton_iff, set.set_of_eq_eq_singleton, mem_support, ite_eq_right_iff, ne.def, not_false_iff, one_ne_zero, pow_zero, not_forall, one_coeff] at hn
{ simp only [exists_prop, and_true, set.mem_singleton_iff, set.set_of_eq_eq_singleton, mem_support, ite_eq_right_iff, ne.def, not_false_iff, one_ne_zero, pow_zero, not_forall, one_coeff] at hn, rw [hn, set_like.mem_coe], exact add_submonoid.zero_mem _ }
rw [hn, set_like.mem_coe]
exact add_submonoid.zero_mem _
intros g hn
obtain ‚ü®i, j, hi, hj, rfl‚ü© := support_mul_subset_add_support hn
{ obtain ‚ü®i, j, hi, hj, rfl‚ü© := support_mul_subset_add_support hn, exact set_like.mem_coe.2 (add_submonoid.add_mem _ (add_submonoid.subset_closure hi) (ih hj)) }
exact set_like.mem_coe.2 (add_submonoid.add_mem _ (add_submonoid.subset_closure hi) (ih hj))
intros
ext g'
by_cases h : g' = f g
{ simp [h] }
simp [h]
rw [emb_domain_notin_image_support, single_coeff_of_ne h]
by_cases hr : r = 0
{ simp [hr] }
simp [hr]
rwa [support_single_of_ne hr, set.image_singleton, set.mem_singleton_iff]
intros
rcases h with ‚ü®p, ‚ü®hp, hp'‚ü©‚ü©
refine ‚ü®p, ‚ü®hp, _‚ü©‚ü©
rw [is_scalar_tower.algebra_map_eq R A B, ‚Üê eval‚ÇÇ_map, eval‚ÇÇ_hom, ‚Üê ring_hom.map_zero (algebra_map A B)] at hp'
rw [eval‚ÇÇ_eq_eval_map]
exact H hp'
intros
rw [coe_submodule, submodule.map_bot]
intros
rw ‚Üê neg_right_iff at h_comm
rw ‚Üê is_nilpotent_neg_iff at hy
rw sub_eq_add_neg
exact h_comm.is_nilpotent_add hx hy
intros
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at H ‚ä¢
exact order_embedding.well_founded (ideal.order_embedding_of_surjective f hf).dual H
intros
{ ext i, simp }
ext i
simp
intros
dsimp [bernstein_polynomial]
simp [polynomial.derivative_pow]
intros
rw [content, content, finset.gcd_def, finset.gcd_def]
refine congr rfl _
have h : (X * p).support = p.support.map ‚ü®nat.succ, nat.succ_injective‚ü©
{ ext a, simp only [exists_prop, finset.mem_map, function.embedding.coe_fn_mk, ne.def, mem_support_iff], cases a, { simp [coeff_X_mul_zero, nat.succ_ne_zero] }, rw [mul_comm, coeff_mul_X], split, { intro h, use a, simp [h] }, { rintros ‚ü®b, ‚ü®h1, h2‚ü©‚ü©, rw ‚Üê nat.succ_injective h2, apply h1 } }
ext a
simp only [exists_prop, finset.mem_map, function.embedding.coe_fn_mk, ne.def, mem_support_iff]
cases a
{ simp [coeff_X_mul_zero, nat.succ_ne_zero] }
simp [coeff_X_mul_zero, nat.succ_ne_zero]
rw [mul_comm, coeff_mul_X]
split
intro h
{ intro h, use a, simp [h] }
use a
simp [h]
rintros ‚ü®b, ‚ü®h1, h2‚ü©‚ü©
{ rintros ‚ü®b, ‚ü®h1, h2‚ü©‚ü©, rw ‚Üê nat.succ_injective h2, apply h1 }
rw ‚Üê nat.succ_injective h2
apply h1
rw h
simp only [finset.map_val, function.comp_app, function.embedding.coe_fn_mk, multiset.map_map]
refine congr (congr rfl _) rfl
ext a
rw mul_comm
simp [coeff_mul_X]
intros
apply splits_prod (ring_hom.id K)
intros z hz
simp only [splits_X_sub_C (ring_hom.id K)]
intros
rw [cyclotomic_eq_minpoly (is_primitive_root_exp n hpos.ne') hpos]
apply minpoly.irreducible
exact (is_primitive_root_exp n hpos.ne').is_integral hpos
intros
ext1 d
suffices : œÜ.total_degree < d.support.sum d ‚Üí 0 = coeff d œÜ
simpa [coeff_sum, coeff_homogeneous_component]
simpa [coeff_sum, coeff_homogeneous_component]
exact Œª h, (coeff_eq_zero_of_total_degree_lt h).symm
intros
ext (_ | n)
simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, mul_zero, ring_hom.map_mul]
{ simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, mul_zero, ring_hom.map_mul], }
simp only [coeff_succ_mul_X, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero]
{ simp only [coeff_succ_mul_X, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero], }
intros
have : ¬¨single s 1 ‚â§ 0
from Œª h, by simpa using h s
simp only [X, coeff_monomial_mul, if_neg this]
intros
rw [‚Üê coeff_zero_eq_constant_coeff_apply, coeff_inv_units_sub, zero_add, pow_one]
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
map_fun_tac
intros
simp only [witt_structure_rat, bind‚ÇÅ, map_aeval, X_in_terms_of_W_zero, constant_coeff_rename, constant_coeff_witt_polynomial, aeval_X, constant_coeff_comp_algebra_map, eval‚ÇÇ_hom_zero', ring_hom.id_apply]
intros
{ ext i, rw [coeff_mk] }
ext i
rw [coeff_mk]
intros
simp
intros
rw [to_enat_apply_of_lt_omega (nat_lt_omega n), to_nat_cast]
intros
{ rw [add_comm, add_eq_left_iff] }
rw [add_comm, add_eq_left_iff]
intros
cases infinite_pigeonhole_card f Œ∏ hŒ∏ h‚ÇÅ h‚ÇÇ with a ha
refine ‚ü®a, {x | ‚àÉ(h : x ‚àà s), f ‚ü®x, h‚ü© = a}, _, _, _‚ü©
{ rintro x ‚ü®hx, hx'‚ü©, exact hx }
rintro x ‚ü®hx, hx'‚ü©
exact hx
refine le_trans ha _
{ refine le_trans ha _, apply ge_of_eq, apply quotient.sound, constructor, refine equiv.trans _ (equiv.subtype_subtype_equiv_subtype_exists _ _).symm, simp only [set_coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_set_of_eq] }
apply ge_of_eq
apply quotient.sound
constructor
refine equiv.trans _ (equiv.subtype_subtype_equiv_subtype_exists _ _).symm
simp only [set_coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_set_of_eq]
rintro x ‚ü®hx, hx'‚ü©
exact hx'
intros
refl
intros
rw [list.sorted, list.pairwise_map]; exact CNF_pairwise b o
rw [list.sorted, list.pairwise_map]
exact CNF_pairwise b o
intros
simp only [le_antisymm_iff, H.le_iff]
intros
rw le_def
dsimp
simp [forall_pempty, exists_pempty]
intros
simp [left_distrib, *]
intros
simp *
intros
rw [‚Üê h, ‚Üê hm, int.add_mul_div_right _ _ (ne_of_gt (lt_of_le_of_lt h‚ÇÅ h‚ÇÇ)), int.div_eq_zero_of_lt h‚ÇÅ h‚ÇÇ, zero_add]
intros
simp [pra, prt]
intros
cases t with b as
simp only [val, neg_add, neg, val, coeffs.val_neg]
intros
cc
intros
simp [is_open_def, h]
intros
simp only [has_sum, tendsto, hg.map_at_top_finset_sum_eq hf]
intros
erw [‚Üê tsum_prod' h h‚ÇÅ, ‚Üê tsum_prod' h.prod_symm h‚ÇÇ, ‚Üê (equiv.prod_comm Œ≤ Œ≥).tsum_eq]
refl
assumption
intros
rw [‚Üê coe_id, coe_inj]
intros
rw mem_nhds_within_Ici_iff_exists_Ico_subset
split
rintros ‚ü®u, au, as‚ü©
{ rintros ‚ü®u, au, as‚ü©, rcases exists_between au with ‚ü®v, hv‚ü©, exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© }
rcases exists_between au with ‚ü®v, hv‚ü©
exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©
rintros ‚ü®u, au, as‚ü©
{ rintros ‚ü®u, au, as‚ü©, exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü©
intros
rcases eq_empty_or_nonempty (Iio b) with (hb'|‚ü®a, ha‚ü©)
rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty]
{ rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty], exact ‚ü®Œª x, hb'.subset (hb x.2)‚ü© }
exact ‚ü®Œª x, hb'.subset (hb x.2)‚ü©
rw [‚Üê comap_coe_nhds_within_Iio_of_Ioo_subset hb (Œª _, hs a ha), map_comap_of_mem]
{ rw [‚Üê comap_coe_nhds_within_Iio_of_Ioo_subset hb (Œª _, hs a ha), map_comap_of_mem], rw subtype.range_coe, exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha) }
rw subtype.range_coe
exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)
intros
casesI is_empty_or_nonempty Œπ
exacts [tendsto_of_is_empty, tendsto_at_top_is_lub h_mono (is_lub_csupr hbdd)]
intros
rcases second_countable_topology.is_open_generated_countable Œ≤ with ‚ü®b, hb, eq‚ü©
refine { is_open_generated_countable := ‚ü®preimage f '' b, hb.image _, _‚ü© }
rw [eq, induced_generate_from_eq]
intros
by_cases p; simp *
by_cases p
simp *
simp *
intros
split
split; intro h
intro h
intros u v hu hv hs huv
{ intros u v hu hv hs huv, rw is_preconnected_closed_iff at h, specialize h u v hu hv hs, contrapose! huv, rw ne_empty_iff_nonempty, simp [not_subset] at huv, rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©, have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu, have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv, exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü© }
rw is_preconnected_closed_iff at h
specialize h u v hu hv hs
contrapose! huv
rw ne_empty_iff_nonempty
simp [not_subset] at huv
rcases huv with ‚ü®‚ü®x, hxs, hxu‚ü©, ‚ü®y, hys, hyv‚ü©‚ü©
have hxv : x ‚àà v := or_iff_not_imp_left.mp (hs hxs) hxu
have hyu : y ‚àà u := or_iff_not_imp_right.mp (hs hys) hyv
exact h ‚ü®y, hys, hyu‚ü© ‚ü®x, hxs, hxv‚ü©
intro h
rw is_preconnected_closed_iff
{ rw is_preconnected_closed_iff, intros u v hu hv hs hsu hsv, rw ‚Üê ne_empty_iff_nonempty, intro H, specialize h u v hu hv hs H, contrapose H, apply ne_empty_iff_nonempty.mpr, cases h, { rcases hsv with ‚ü®x, hxs, hxv‚ü©, exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü© }, { rcases hsu with ‚ü®x, hxs, hxu‚ü©, exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü© } }
intros u v hu hv hs hsu hsv
rw ‚Üê ne_empty_iff_nonempty
intro H
specialize h u v hu hv hs H
contrapose H
apply ne_empty_iff_nonempty.mpr
cases h
{ rcases hsv with ‚ü®x, hxs, hxv‚ü©, exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü© }
rcases hsv with ‚ü®x, hxs, hxv‚ü©
exact ‚ü®x, hxs, ‚ü®h hxs, hxv‚ü©‚ü©
{ rcases hsu with ‚ü®x, hxs, hxu‚ü©, exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü© }
rcases hsu with ‚ü®x, hxs, hxu‚ü©
exact ‚ü®x, hxs, ‚ü®hxu, h hxs‚ü©‚ü©
intros
rw [is_open_iff_nhds]
simp_rw [le_principal_iff, prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, prod.exists, exists_prop]
simp only [and_assoc, and.left_comm]
intros
rw polynomial_comp_attach_bound
apply set_like.coe_mem
intros
have : s = univ ‚à© s
rw univ_inter
rw univ_inter
rwa [this, continuous_within_at_inter hs, continuous_within_at_univ] at h
intros
ext
{ ext, refl }
refl
intros
have := (e.coe_fst (e.to_local_equiv.map_target hx)).symm
rwa [‚Üê e.coe_coe, e.to_local_equiv.right_inv hx] at this
intros
apply continuous_of_le_add_edist 2 (by norm_num)
rintros ‚ü®x, y‚ü© ‚ü®x', y'‚ü©
calc edist x y ‚â§ edist x x' + edist x' y' + edist y' y : edist_triangle4 _ _ _ _ ... = edist x' y' + (edist x x' + edist y y') : by simp [edist_comm]; cc ... ‚â§ edist x' y' + (edist (x, y) (x', y') + edist (x, y) (x', y')) : add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _ ... = edist x' y' + 2 * edist (x, y) (x', y') : by rw [‚Üê mul_two, mul_comm]
intros
refine ‚ü®Œª h, _, Œª h, tendsto.comp (ennreal.tendsto_to_real hx) h‚ü©
have h_eq : f = (Œª n, ennreal.of_real (f n).to_real)
ext1 n
ext1 n
{ ext1 n, rw ennreal.of_real_to_real (hf n), }
{ ext1 n, rw ennreal.of_real_to_real (hf n), }
rw ennreal.of_real_to_real (hf n)
rw ennreal.of_real_to_real (hf n)
rw [h_eq, ‚Üê ennreal.of_real_to_real hx]
exact ennreal.tendsto_of_real h
intros
rw [trans_of_set, restr_source_inter]
intros
rw bInter_eq_Inter
haveI := hS.to_encodable
exact dense_Inter_of_GŒ¥ (Œª s, ho s s.2) (Œª s, hd s s.2)
intros
{ rw [add_right_comm, dist_comm y‚ÇÅ], apply dist_triangle4 }
rw [add_right_comm, dist_comm y‚ÇÅ]
apply dist_triangle4
intros
simpa only [dist_nndist, nnreal.coe_eq] using dist_comm x y
intros
rw [continuous_within_at, tendsto_nhds_within_nhds]
intros
simp only [‚Üê tendsto_uniformly_on_univ, tendsto_uniformly_on_iff, mem_univ, forall_const]
intros
rw [sUnion_eq_bUnion, dimH_bUnion hS]
intros
rw continuous_def at h‚ÇÅ h‚ÇÇ ‚ä¢
assume s h
exact ‚ü®h‚ÇÅ s h, h‚ÇÇ s h‚ü©
intros
simp
intros
constructor
rintros x - y - hxy
obtain ‚ü®u, v, hu, hv, xu, yv, disj‚ü© := t2_separation hxy
obtain ‚ü®w, hw : is_clopen w, xw, wu‚ü© := (is_topological_basis.mem_nhds_iff h).1 (is_open.mem_nhds hu xu)
refine ‚ü®w, w·∂ú, hw.1, (is_clopen_compl_iff.2 hw).1, xw, _, _, set.inter_compl_self w‚ü©
intro h
{ intro h, have : y ‚àà u ‚à© v := ‚ü®wu h, yv‚ü©, rwa disj at this }
have : y ‚àà u ‚à© v := ‚ü®wu h, yv‚ü©
rwa disj at this
rw set.union_compl_self
intros
simpa only [inter_univ] using hf.finite_nonempty_inter_compact compact_univ
intros
rw [continuous_at, tendsto_nhds_left]
intros
rw [nhds_eq_comap_uniformity, mem_comap]
exact iff.rfl
intros
have : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, ‚àÄ l ‚â• k, (u l, u k) ‚àà V n
intro n
{ intro n, rw [cauchy_seq_iff] at hu, rcases hu _ (hV n) with ‚ü®N, H‚ü©, exact ‚ü®N, Œª k hk l hl, H _ (le_trans hk hl) _ hk ‚ü© }
rw [cauchy_seq_iff] at hu
rcases hu _ (hV n) with ‚ü®N, H‚ü©
exact ‚ü®N, Œª k hk l hl, H _ (le_trans hk hl) _ hk ‚ü©
obtain ‚ü®œÜ : ‚Ñï ‚Üí ‚Ñï, œÜ_extr : strict_mono œÜ, hœÜ : ‚àÄ n, ‚àÄ l ‚â• œÜ n, (u l, u $ œÜ n) ‚àà V n‚ü© := extraction_forall_of_eventually' this
exact ‚ü®œÜ, œÜ_extr, Œª n, hœÜ _ _ (œÜ_extr $ lt_add_one n).le‚ü©
intros
rw [complete_space_iff_is_complete_univ, ‚Üê is_complete_image_iff hf, image_univ]
intros
rw [nth_succ, tail_iterate]
intros
rw [congr_fun linear_order.max_def a, max_default]
intros
cases b; simp
cases b
simp
simp
intros
dunfold sub_nat_nat
rw [nat.sub_eq_zero_of_le]
dunfold sub_nat_nat._match_1
rw [nat.add_sub_cancel_left]
apply nat.le_add_right
intros
rw [h, int.sub_self]
intros
have h := int.add_le_add_right h (-b)
rwa int.add_right_neg at h
intros
have h := int.add_lt_add_left h (-b)
rwa int.neg_add_cancel_left at h
intros
rw [nat.mul_comm x z, nat.mul_comm y z, nat.mul_comm (x % y) z]
rw [nat.mul_comm x z, nat.mul_comm y z, nat.mul_comm (x % y) z]; apply mul_mod_mul_left
apply mul_mod_mul_left
intros
apply nat.sub_lt _ h‚ÇÄ
apply lt_of_lt_of_le h‚ÇÄ h‚ÇÅ
intros
induction h; [refl, exact le_trans (pred_le _) h_ih]
induction h
refl
exact le_trans (pred_le _) h_ih
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero]
intros
{ ext, refl }
ext
refl
intros
rw submodule.mul_le
intros m hm n hn
rw [submodule.mem_div_iff_forall_mul_mem] at hn
rw mul_comm
exact hn m hm
intros
{ ext, refl }
ext
refl
intros
split
rintro rfl
{ rintro rfl, apply not_lt_of_le _ hlt, apply dvd_zero }
apply not_lt_of_le _ hlt
apply dvd_zero
rcases hlt with ‚ü®‚ü®x, rfl‚ü©, ndvd‚ü©
refine ‚ü®x, _, rfl‚ü©
contrapose! ndvd
rcases ndvd with ‚ü®u, rfl‚ü©
simp
intros
simp only [card_eq_sum_ones, sum_fiberwise_of_maps_to H]
intros
rw [‚Üê prod_sdiff h, prod_eq_one hg, one_mul]
exact prod_congr rfl hfg
intros
split_ifs
exact finprod_eq_prod_of_mul_support_to_finset_subset _ h (finset.subset.refl _)
{ exact finprod_eq_prod_of_mul_support_to_finset_subset _ h (finset.subset.refl _) }
rw [finprod, dif_neg]
{ rw [finprod, dif_neg], rw [mul_support_comp_eq_preimage], exact mt (Œª hf, hf.of_preimage equiv.plift.surjective) h}
rw [mul_support_comp_eq_preimage]
exact mt (Œª hf, hf.of_preimage equiv.plift.surjective) h
intros
rw [‚Üê finprod_mem_inter_mul_diff' _ ht, inter_eq_self_of_subset_right hst]
intros
rw [mono_iff_ker_eq_bot, linear_map.ker_eq_bot]
intros
apply tensor_product.ext_threefold
intros x y z
refl
intros
simp [nth_cont_eq_succ_nth_cont_aux, (continuants_aux_recurrence nth_s_eq nth_conts_aux_eq succ_nth_conts_aux_eq)]
intros
refl
intros
{ rw gcd, split_ifs; simp only [h, zero_mod, gcd_zero_left] }
rw gcd
split_ifs
split_ifs; simp only [h, zero_mod, gcd_zero_left]
simp only [h, zero_mod, gcd_zero_left]
simp only [h, zero_mod, gcd_zero_left]
intros
rw [(mul_sub_left_distrib (1 / a)), (one_div_mul_cancel ha), mul_sub_right_distrib, one_mul, mul_assoc, (mul_one_div_cancel hb), mul_one]
intros
rw [‚Üê function.comp_app (lift R f) (of R) x, of_comp_lift]
intros
have := (h.sub_left (commute.refl y)).geom_sum‚ÇÇ_mul_add n
rw [sub_add_cancel] at this
rw [‚Üê this, add_sub_cancel]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]
intros
rw [f.map_mul, f.map_inv]
intros
{ rcases h with ‚ü®‚ü®a, b, _, hba‚ü©, rfl‚ü©, exact ‚ü®b, hba‚ü© }
rcases h with ‚ü®‚ü®a, b, _, hba‚ü©, rfl‚ü©
exact ‚ü®b, hba‚ü©
intros
ext x
{ ext x, rw [‚Üê mul_one x, ‚Üê smul_eq_mul R, f.map_smul, g.map_smul, h], }
rw [‚Üê mul_one x, ‚Üê smul_eq_mul R, f.map_smul, g.map_smul, h]
intros
ring
intros
induction k with k ih; [refl, rw [pow_succ', int.nat_abs_mul, pow_succ', ih]]
induction k with k ih
refl
rw [pow_succ', int.nat_abs_mul, pow_succ', ih]
intros
rw [sq, int.nat_abs_mul_self', sq]
intros
rw [‚Üêpow_abs, abs_neg, abs_one, one_pow]
intros
by_cases hc : c = 0; [simp [hc], simp [mul_left_inj', hc]]
by_cases hc : c = 0
simp [hc]
simp [mul_left_inj', hc]
intros
tidy
intros
have P : ‚àÄ h : j' = j, C.d i j' ‚â´ eq_to_hom (congr_arg C.X h) = C.d i j
{ rintro rfl, simp }
rintro rfl
simp
apply P
intros
by_cases hij : c.rel i j
by_cases hjk : c.rel j k
{ by_cases hjk : c.rel j k, { exact C.d_comp_d' i j k hij hjk }, { rw [C.shape j k hjk, comp_zero] } }
{ exact C.d_comp_d' i j k hij hjk }
exact C.d_comp_d' i j k hij hjk
{ rw [C.shape j k hjk, comp_zero] }
rw [C.shape j k hjk, comp_zero]
{ rw [C.shape i j hij, zero_comp] }
rw [C.shape i j hij, zero_comp]
intros
{ simp [homology.œÄ, homology.map], }
simp [homology.œÄ, homology.map]
intros
by_cases hij : j = i
simp only [lie_of_of_eq R Œπ L hij x y, hij, dif_pos, not_false_iff, lie_algebra_of_apply]
{ simp only [lie_of_of_eq R Œπ L hij x y, hij, dif_pos, not_false_iff, lie_algebra_of_apply], }
simp only [lie_of_of_ne R Œπ L hij x y, hij, dif_neg, not_false_iff]
{ simp only [lie_of_of_ne R Œπ L hij x y, hij, dif_neg, not_false_iff], }
intros
suffices : ‚àÄ (I J : lie_ideal R L), ‚ÅÖI, J‚ÅÜ ‚â§ ‚ÅÖJ, I‚ÅÜ
exact le_antisymm (this I J) (this J I)
{ exact le_antisymm (this I J) (this J I), }
clear I J
intros I J
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros x ‚ü®y, z, h‚ü©
rw ‚Üê h
rw [‚Üê lie_skew, ‚Üê lie_neg, ‚Üê submodule.coe_neg]
apply lie_coe_mem_lie
intros
rw [is_ideal_morphism_def, f.ideal_range_eq_top_of_surjective h, f.range_eq_top.mpr h, lie_ideal.top_coe_lie_subalgebra]
intros
rw [neg_smul, smul_neg, neg_neg]
intros
rw [of, monoid_hom.coe_mk, ‚Üê finsupp.supported_eq_span_single, finsupp.mem_supported]
intros
{ ext a, exact distrib_mul_action_hom.congr_fun h a, }
ext a
exact distrib_mul_action_hom.congr_fun h a
intros
haveI := classical.dec; exact decidable.ne_iff_lt_iff_le
haveI := classical.dec
exact decidable.ne_iff_lt_iff_le
intros
rw [mul_comm, le_div_iff_of_neg hc]
intros
simpa using inv_lt ha hb
intros
contrapose! h
simpa only [and_comm ((0 : Œ±) < _), lt_sub_iff_add_lt, gt_iff_lt] using exists_add_lt_and_pos_of_lt h
intros
rw [‚Üê mul_lt_mul_iff_right a, inv_mul_self, one_mul]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_le_inv_mul_iff, mul_comm]
exact mul_le_mul' hab hcd
intros
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®decidable.mul_self_le_mul_self h1, nonneg_le_nonneg_of_sq_le_sq h2‚ü©
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®decidable.mul_self_le_mul_self h1, nonneg_le_nonneg_of_sq_le_sq h2‚ü©
intros
rw [bit0, bit0, ‚Üê two_mul, ‚Üê two_mul, mul_lt_mul_left (zero_lt_two : 0 < (2:Œ±))]
intros
rw [‚Üê image_mul_left', image_one, mul_one]
intros
rw nat_degree_multiset_prod'
simp_rw [ne.def, multiset.prod_eq_zero_iff, multiset.mem_map, leading_coeff_eq_zero]
rintro ‚ü®_, h, rfl‚ü©
contradiction
intros
ext
ext; simp; ring_exp
ext; simp
simp
simp
ring_exp
simp
ring_exp
simp
ring_exp
intros
rw [nontrivial_iff, not_iff_comm, is_right_regular_zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
intros
simpa only [sub_eq_add_neg] using h.add_right h'.neg_right
intros
simp
intros
apply topological_space.is_topological_basis_of_open_of_nhds
rintros _ ‚ü®r, rfl‚ü©
{ rintros _ ‚ü®r, rfl‚ü©, exact is_open_basic_open }
exact is_open_basic_open
rintros p U hp ‚ü®s, hs‚ü©
{ rintros p U hp ‚ü®s, hs‚ü©, rw [‚Üê compl_compl U, set.mem_compl_eq, ‚Üê hs, mem_zero_locus, set.not_subset] at hp, obtain ‚ü®f, hfs, hfp‚ü© := hp, refine ‚ü®basic_open f, ‚ü®f, rfl‚ü©, hfp, _‚ü©, rw [‚Üê set.compl_subset_compl, ‚Üê hs, basic_open_eq_zero_locus_compl, compl_compl], exact zero_locus_anti_mono (set.singleton_subset_iff.mpr hfs) }
rw [‚Üê compl_compl U, set.mem_compl_eq, ‚Üê hs, mem_zero_locus, set.not_subset] at hp
obtain ‚ü®f, hfs, hfp‚ü© := hp
refine ‚ü®basic_open f, ‚ü®f, rfl‚ü©, hfp, _‚ü©
rw [‚Üê set.compl_subset_compl, ‚Üê hs, basic_open_eq_zero_locus_compl, compl_compl]
exact zero_locus_anti_mono (set.singleton_subset_iff.mpr hfs)
intros
dsimp [Œ¥]
{ dsimp [Œ¥], simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_Œ¥ H], }
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_Œ¥ H]
intros
by_cases hK : K = 0
simp only [gronwall_bound_K0, hK, zero_mul, exp_zero, add_zero, mul_one]
{ simp only [gronwall_bound_K0, hK, zero_mul, exp_zero, add_zero, mul_one] }
simp only [gronwall_bound_of_K_ne_0 hK, zero_div, zero_mul, add_zero]
{ simp only [gronwall_bound_of_K_ne_0 hK, zero_div, zero_mul, add_zero] }
intros
convert (hf.tendsto_uniformly_on h).comp (Œª y, y - x)
{ simp [(‚àò)] }
simp [(‚àò)]
{ ext z, simp [dist_eq_norm] }
ext z
simp [dist_eq_norm]
intros
have : {composition.ones 1} = (finset.univ : finset (composition 1)) := finset.eq_univ_of_card _ (by simp [composition_card])
simp only [formal_multilinear_series.comp, comp_along_composition_apply, ‚Üê this, finset.sum_singleton]
refine q.congr (by simp) (Œª i hi1 hi2, _)
simp only [apply_composition_ones]
exact p.congr rfl (Œª j hj1 hj2, by congr)
intros
refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr rfl _ _).of_norm_norm
refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr rfl _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
unfold is_o
{ unfold is_o, exact forall_congr (Œª c, forall_congr (Œª hc, e.is_O_with_congr)) }
exact forall_congr (Œª c, forall_congr (Œª hc, e.is_O_with_congr))
intros
rw ‚Üê has_deriv_within_at_univ at *
exact hc.inv hx
intros
simpa only [sub_eq_add_neg] using hf.add_const (-c)
intros
simp only [‚Üê fderiv_within_univ, fderiv_within_add_const unique_diff_within_at_univ]
intros
symmetry
rw [tendsto_iff_norm_tendsto_zero]
refine tendsto_congr (Œª x', _)
have : ‚à•x' - x‚à•‚Åª¬π ‚â• 0
from inv_nonneg.mpr (norm_nonneg _)
simp [norm_smul, real.norm_eq_abs, abs_of_nonneg this]
intros
split
intro hfx
{ intro hfx, by_cases hx : differentiable_at ùïú f x, { exact or.inl ‚ü®hx, hfx‚ü© }, { rw [fderiv_zero_of_not_differentiable_at hx] at hfx, exact or.inr ‚ü®hfx, hx‚ü© } }
by_cases hx : differentiable_at ùïú f x
{ exact or.inl ‚ü®hx, hfx‚ü© }
exact or.inl ‚ü®hx, hfx‚ü©
rw [fderiv_zero_of_not_differentiable_at hx] at hfx
{ rw [fderiv_zero_of_not_differentiable_at hx] at hfx, exact or.inr ‚ü®hfx, hx‚ü© }
exact or.inr ‚ü®hfx, hx‚ü©
rintro (‚ü®hf, hf'‚ü©|‚ü®h‚ÇÄ, hx‚ü©)
{ rintro (‚ü®hf, hf'‚ü©|‚ü®h‚ÇÄ, hx‚ü©), { exact hf' }, { rwa [fderiv_zero_of_not_differentiable_at hx] } }
{ exact hf' }
exact hf'
{ rwa [fderiv_zero_of_not_differentiable_at hx] }
rwa [fderiv_zero_of_not_differentiable_at hx]
intros
refine ((nhds_basis_opens a).exists_iff _).1 _
exact (Œª s t, approximates_linear_on.mono_set)
exact (hf.approximates_deriv_on_nhds $ f'.subsingleton_or_nnnorm_symm_pos.imp id $ Œª hf', nnreal.half_pos $ nnreal.inv_pos.2 $ hf')
intros
have hdf : ‚àÄ x ‚àà Ioo a b, differentiable_at ‚Ñù f x
from Œª x hx, (hdf x hx).differentiable_at (Ioo_mem_nhds hx.1 hx.2)
have hdg : ‚àÄ x ‚àà Ioo a b, differentiable_at ‚Ñù g x
from Œª x hx, classical.by_contradiction (Œª h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_right_on_Ioo hab (Œª x hx, (hdf x hx).has_deriv_at) (Œª x hx, (hdg x hx).has_deriv_at) hg' hfa hga hdiv
intros
rintros s t hst y ‚ü®c, d, hd, hc, hcd‚ü©
exact ‚ü®c, d, mem_of_superset hd $ Œª h hn, hst hn, hc, hcd‚ü©
intros
simp [times_cont_diff_on_univ.symm, continuous_iff_continuous_on_univ, differentiable_on_univ.symm, iterated_fderiv_within_univ, times_cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]
intros
rw ‚Üê times_cont_diff_within_at_univ at *; exact hf.neg
rw ‚Üê times_cont_diff_within_at_univ at *
exact hf.neg
intros
rw times_cont_diff_on_top_iff_deriv_within hs.unique_diff_on
congr' 2
rw ‚Üê iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact deriv_within_of_open hs hx
intros
rw conformal_at_iff_is_conformal_map_fderiv
rw (h.has_fderiv_at.restrict_scalars ‚Ñù).fderiv at ‚ä¢ hf'
apply is_conformal_map_complex_linear
contrapose! hf' with w
simp [w]
intros
rw [open_segment_eq_image', open_segment_eq_image']
refine exists_congr (Œª Œ∏, and_congr iff.rfl _)
simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]
intros
simp_rw le_antisymm_iff
exact (convex_halfspace_le h r).inter (convex_halfspace_ge h r)
intros
rw s.centroid_eq_center_mass hs
apply s.center_mass_id_mem_convex_hull
simp only [inv_nonneg, implies_true_iff, nat.cast_nonneg, finset.centroid_weights_apply]
{ simp only [inv_nonneg, implies_true_iff, nat.cast_nonneg, finset.centroid_weights_apply], }
have hs_card : (s.card : R) ‚â† 0
{ have hs_card : (s.card : R) ‚â† 0, { simp [finset.nonempty_iff_ne_empty.mp hs] }, simp only [hs_card, finset.sum_const, nsmul_eq_mul, mul_inv_cancel, ne.def, not_false_iff, finset.centroid_weights_apply, zero_lt_one] }
simp [finset.nonempty_iff_ne_empty.mp hs]
{ simp [finset.nonempty_iff_ne_empty.mp hs] }
simp only [hs_card, finset.sum_const, nsmul_eq_mul, mul_inv_cancel, ne.def, not_false_iff, finset.centroid_weights_apply, zero_lt_one]
intros
have hxz := hxy.trans hyz
rw ‚Üêsub_pos at hxy hxz hyz
suffices : f y / (y - x) + f y / (z - y) ‚â§ f x / (y - x) + f z / (z - y)
{ ring_nf at this ‚ä¢, linarith }
ring_nf at this ‚ä¢
linarith
set a := (z - y) / (z - x)
set b := (y - x) / (z - x)
have hy : a ‚Ä¢ x + b ‚Ä¢ z = y
field_simp
field_simp
{ field_simp, rw div_eq_iff; [ring, linarith] }
{ field_simp, rw div_eq_iff; [ring, linarith] }
rw div_eq_iff
rw div_eq_iff
rw div_eq_iff; [ring, linarith]
rw div_eq_iff; [ring, linarith]
ring
ring
linarith
linarith
have key
from hf.2 hx hz (show 0 ‚â§ a, by apply div_nonneg; linarith) (show 0 ‚â§ b, by apply div_nonneg; linarith) (show a + b = 1, by { field_simp, rw div_eq_iff; [ring, linarith] })
rw hy at key
replace key := mul_le_mul_of_nonneg_left key hxz.le
field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _] at key ‚ä¢
rw div_le_div_right
{ linarith }
linarith
{ nlinarith }
nlinarith
intros
simp [‚Üê coe_inv_circle_eq_conj z]
intros
simp_rw [submodule.mem_orthogonal, inner_eq_zero_sym]
intros
rw [‚Üêinner_conj_sym, inner_add_left, ring_hom.map_add]
{ rw [‚Üêinner_conj_sym, inner_add_left, ring_hom.map_add], simp only [inner_conj_sym] }
simp only [inner_conj_sym]
intros
{ rw norm_add_mul_self, ring }
rw norm_add_mul_self
ring
intros
have := nnreal.coe_le_coe.2 (nnreal.inner_le_Lp_mul_Lq s (Œª i, ‚ü®_, abs_nonneg (f i)‚ü©) (Œª i, ‚ü®_, abs_nonneg (g i)‚ü©) hpq)
push_cast at this
refine le_trans (sum_le_sum $ Œª i hi, _) this
simp only [‚Üê abs_mul, le_abs_self]
intros
simp [dist_eq_norm]
intros
simpa [dist_eq_norm] using dist_triangle g 0 h
intros
rw [‚Üê neg_sub, e.map_neg]
intros
{ ext, refl }
ext
refl
simpa only [inv_eq_one_div] using real.not_summable_nat_cast_inv
intros
simp only [exp_eq_exp_iff_exp_sub_eq_one, exp_eq_one_iff, sub_eq_iff_eq_add']
rw [‚Üê coe_comp_exp_order_iso, range_comp, exp_order_iso.range_eq, image_univ, subtype.range_coe]
intros
cases hx.lt_or_lt with hx hx
convert (has_strict_deriv_at_log_of_pos (neg_pos.mpr hx)).comp x (has_strict_deriv_at_neg x)
{ convert (has_strict_deriv_at_log_of_pos (neg_pos.mpr hx)).comp x (has_strict_deriv_at_neg x), { ext y, exact (log_neg_eq_log y).symm }, { field_simp [hx.ne] } }
{ ext y, exact (log_neg_eq_log y).symm }
ext y
exact (log_neg_eq_log y).symm
{ field_simp [hx.ne] }
field_simp [hx.ne]
{ exact has_strict_deriv_at_log_of_pos hx }
exact has_strict_deriv_at_log_of_pos hx
intros
field_simp [integral_sin_pow, add_sub_assoc]
intros
by_cases hP : 0 ‚â§ P.leading_coeff
exact tendsto_abs_at_top_at_top.comp (P.tendsto_at_top_of_leading_coeff_nonneg hdeg hP)
{ exact tendsto_abs_at_top_at_top.comp (P.tendsto_at_top_of_leading_coeff_nonneg hdeg hP)}
push_neg at hP
{ push_neg at hP, exact tendsto_abs_at_bot_at_top.comp (P.tendsto_at_bot_of_leading_coeff_nonpos hdeg hP.le)}
exact tendsto_abs_at_bot_at_top.comp (P.tendsto_at_bot_of_leading_coeff_nonpos hdeg hP.le)
intros
by_cases hx : x = 0
rcases le_iff_eq_or_lt.1 h with H|H
{ rcases le_iff_eq_or_lt.1 h with H|H, { simp [hx, H.symm] }, { simp [hx, zero_rpow_of_pos H, nnreal.zero_rpow (ne_of_gt H)] } }
{ simp [hx, H.symm] }
simp [hx, H.symm]
{ simp [hx, zero_rpow_of_pos H, nnreal.zero_rpow (ne_of_gt H)] }
simp [hx, zero_rpow_of_pos H, nnreal.zero_rpow (ne_of_gt H)]
{ exact coe_rpow_of_ne_zero hx _ }
exact coe_rpow_of_ne_zero hx _
intros
by_cases h : x = 0; simp [h, zero_le_one]
{ by_cases h : x = 0; simp [h, zero_le_one] }
by_cases h : x = 0
simp [h, zero_le_one]
simp [h, zero_le_one]
intros
rw [rpow_def_of_pos hx0]
repeat {rw [rpow_def_of_pos hx0]}
rw [rpow_def_of_pos hx0]
rw [rpow_def_of_pos hx0]
rw exp_lt_exp
exact mul_lt_mul_of_neg_left hyz (log_neg hx0 hx1)
intros
simp [cpow_def]; split_ifs; simp [exp_neg]
simp [cpow_def]; split_ifs
simp [cpow_def]
split_ifs
simp [exp_neg]
simp [exp_neg]
simp [exp_neg]
intros
rw [‚Üê not_exists, not_iff_not, cos_eq_zero_iff]
intros
rw [arccos, cos_pi_div_two_sub, sin_arcsin hx‚ÇÅ hx‚ÇÇ]
intros
rw tsum_eq_zero_add (normed_ring.summable_geometric_of_norm_lt_1 x h)
simp only [pow_zero]
refine le_trans (norm_add_le _ _) _
have : ‚à•‚àë' b : ‚Ñï, (Œª n, x ^ (n + 1)) b‚à• ‚â§ (1 - ‚à•x‚à•)‚Åª¬π - 1
refine tsum_of_norm_bounded _ (Œª b, norm_pow_le' _ (nat.succ_pos b))
{ refine tsum_of_norm_bounded _ (Œª b, norm_pow_le' _ (nat.succ_pos b)), convert (has_sum_nat_add_iff' 1).mpr (has_sum_geometric_of_lt_1 (norm_nonneg x) h), simp }
convert (has_sum_nat_add_iff' 1).mpr (has_sum_geometric_of_lt_1 (norm_nonneg x) h)
simp
linarith
intros
suffices : (of_right_adjoint i).unit.app A = h.get_iso.inv ‚â´ (of_right_adjoint i).unit.app (i.obj h.witness) ‚â´ (left_adjoint i ‚ãô i).map h.get_iso.hom
rw this
{ rw this, apply_instance }
apply_instance
rw ‚Üê nat_trans.naturality
simp
intros
rw ‚Üêfrobenius_morphism_mate F h at i
exact @@transfer_nat_trans_self_of_iso _ _ _ _ _ i
intros
simp
intros
subst h
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
ext X b
simp
intros
apply (cancel_mono f).mp
simp [inv_hom_id]
intros
haveI : has_limit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_limit_equivalence_comp e.symm
apply has_limit_of_iso (e.inv_fun_id_assoc F)
intros
{ rw ‚Üê prod.lift_map, simp }
rw ‚Üê prod.lift_map
simp
intros
simp [is_iso.inv_comp_eq]
intros
rw [‚Üêimage.fac f, w, has_zero_morphisms.comp_zero]
intros
apply (cancel_mono ((œÅ_ X).hom ‚äó ùüô Y)).1
simp only [triangle_assoc_comp_right, assoc]
rw [‚Üêid_tensor_comp, iso.inv_hom_id, ‚Üêcomp_tensor_id, iso.inv_hom_id]
intros
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
rintro ‚ü®‚ü©
rintro ‚ü®‚ü©; { dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
dsimp [tensor_hom]
simp
intros
rw covers_iff at h ‚ä¢
simp [h, sieve.pullback_comp]
intros
{ cases f, congr, ext, }
cases f
congr
ext
intros
simp [of_mk_le, of_le_mk, of_le, ‚Üêfunctor.map_comp underlying]
intros
{ rw c.size_up_to_succ h, simp }
rw c.size_up_to_succ h
simp
intros
induction n using nat.strong_induction_on with n hyp
obtain (_|_|n) := n
refl
{ refl }
refl
{ refl }
rw [num_derangements_add_two, card_derangements_fin_add_two, mul_add, hyp _ (nat.lt_add_of_pos_right zero_lt_two), hyp _ (lt_add_one _)]
intros
ext x
simp only [mem_star, mem_supr, mem_pow]
split
{ rintro ‚ü®S, rfl, hS‚ü©, exact ‚ü®_, S, rfl, rfl, hS‚ü© }
rintro ‚ü®S, rfl, hS‚ü©
exact ‚ü®_, S, rfl, rfl, hS‚ü©
{ rintro ‚ü®_, S, rfl, rfl, hS‚ü©, exact ‚ü®S, rfl, hS‚ü© }
rintro ‚ü®_, S, rfl, rfl, hS‚ü©
exact ‚ü®S, rfl, hS‚ü©
intros
convert one_one_reducible.of_equiv _ h; funext; simp
convert one_one_reducible.of_equiv _ h; funext
convert one_one_reducible.of_equiv _ h
funext
simp
intros
induction k generalizing v; simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
induction k generalizing v
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
{ simp only [‚Üê k_ih] }
simp only [‚Üê k_ih]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
split_ifs; [refl, simp only [‚Üê k_ih, bind_assoc]]
{ split_ifs; [refl, simp only [‚Üê k_ih, bind_assoc]] }
split_ifs
refl
simp only [‚Üê k_ih, bind_assoc]
intros
suffices : ‚àÄ i L, (tape.move dir.right)^[i] ((tape.move dir.left)^[i] L) = L
refine (eq.symm _).trans (this n _)
{ refine (eq.symm _).trans (this n _), simp only [tr_tape'_move_left, list_blank.cons_head_tail, list_blank.head_cons, list_blank.tail_cons] }
simp only [tr_tape'_move_left, list_blank.cons_head_tail, list_blank.head_cons, list_blank.tail_cons]
intros
induction i with i IH
refl
{refl}
rw [iterate_succ_apply, iterate_succ_apply', tape.move_left_right, IH]
intros
obtain ‚ü®c‚ÇÅ, h‚ÇÅ, rfl‚ü© := (part.mem_map_iff _).1 H‚ÇÅ
obtain ‚ü®c‚ÇÇ, h‚ÇÇ, rfl‚ü© := (part.mem_map_iff _).1 H‚ÇÇ
obtain ‚ü®_, ‚ü®q, v, S, L', hT‚ü©, h‚ÇÉ‚ü© := tr_eval (tr_respects M) (tr_cfg_init M k L) h‚ÇÇ
cases part.mem_unique h‚ÇÅ h‚ÇÉ
exact ‚ü®S, L', by simp only [tape.mk'_right‚ÇÄ], hT, rfl‚ü©
intros
simp only [tape.mk‚ÇÇ, tape.map_mk', list_blank.map_mk]
intros
cases x
cases x; refl
refl
intros
cases x; refl
cases x
refl
refl
intros
cases b; simp
cases b
simp
simp
intros
introI
cases h : p buffer.nil 0
{ simpa [lt_irrefl] using bounded.of_done h }
simpa [lt_irrefl] using bounded.of_done h
{ exact of_fail h }
exact of_fail h
intros
split
introI
{ introI, constructor, intros cb n n' a h, have : (@parser.decorate_errors Œ± msgs p) cb n = done n' a := by simpa using h, exact of_done this }
constructor
intros cb n n' a h
have : (@parser.decorate_errors Œ± msgs p) cb n = done n' a := by simpa using h
exact of_done this
introI
{ introI, constructor, intros _ _ _ _ h, rw decorate_errors_eq_done at h, exact of_done h }
constructor
intros _ _ _ _ h
rw decorate_errors_eq_done at h
exact of_done h
intros
simp [foldl, foldl_core_eq_done]
rw [sq, I_mul_I]
intros
haveI := classical.dec_eq Œ≥; exact finset.induction_on s (by simp [abv_zero abv]) (Œª a s has ih, by rw [sum_insert has, sum_insert has]; exact le_trans (abv_add abv _ _) (add_le_add_left ih _))
haveI := classical.dec_eq Œ≥
exact finset.induction_on s (by simp [abv_zero abv]) (Œª a s has ih, by rw [sum_insert has, sum_insert has]; exact le_trans (abv_add abv _ _) (add_le_add_left ih _))
intros
apply (@is_R_or_C.ext_iff K _ ((r + s : ‚Ñù) : K) (r + s)).mpr
{ apply (@is_R_or_C.ext_iff K _ ((r + s : ‚Ñù) : K) (r + s)).mpr, simp }
simp
intros
{ rw ‚Üê re_add_im a, simp [im_eq_zero_of_le h] }
rw ‚Üê re_add_im a
simp [im_eq_zero_of_le h]
intros
simp [(‚Ä¢)]
intros
rw [erase_single, if_pos rfl]
intros
ext i
ext i; by_cases h1 : p i; by_cases h2 : f i ‚â† 0; simp at h2; simp [h1, h2]
ext i; by_cases h1 : p i; by_cases h2 : f i ‚â† 0; simp at h2
ext i; by_cases h1 : p i; by_cases h2 : f i ‚â† 0
ext i; by_cases h1 : p i
by_cases h1 : p i
by_cases h2 : f i ‚â† 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
by_cases h2 : f i ‚â† 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
intros
simp [perm.extend_domain, perm_congr_trans]
intros
conv_lhs { rw ‚Üêapply_symm_apply f y, }
rw apply_eq_iff_eq
intros
cases e; cases e'; refl
cases e; cases e'
cases e
cases e'
refl
intros
simp only [‚Üêsucc_above_ne_zero_zero ha, order_embedding.eq_iff_eq]
intros
simp [cons]
intros
simp [pi.le_def, forall_iff_succ_above i]
intros
induction a with a ih
refl
{ refl }
ext
show (a+1) % (n+1) = subtype.val (a+1 : fin (n+1))
rw [val_add, ‚Üê ih, of_nat]
{ rw [val_add, ‚Üê ih, of_nat], exact add_mod _ _ _ }
exact add_mod _ _ _
intros
simp [piecewise, hi]
intros
rw [‚Üê supr_eq_supr_finset, ‚Üê equiv.plift.surjective.supr_comp]
rw [‚Üê supr_eq_supr_finset, ‚Üê equiv.plift.surjective.supr_comp]; refl
refl
intros
apply eq_of_veq
rw ‚Üê multiset.erase_dup_eq_self.2 (pi (insert a s) t).2
refine (Œª s' (h : s' = a ::‚Çò s.1), (_ : erase_dup (multiset.pi s' (Œª a, (t a).1)) = erase_dup ((t a).1.bind $ Œª b, erase_dup $ (multiset.pi s.1 (Œª (a : Œ±), (t a).val)).map $ Œª f a' h', multiset.pi.cons s.1 a b f a' (h ‚ñ∏ h')))) _ (insert_val_of_not_mem ha)
subst s'
rw pi_cons
congr
funext b
rw multiset.erase_dup_eq_self.2
exact multiset.nodup_map (multiset.pi_cons_injective ha) (pi s t).2
intros
transitivity
apply single_multiset_sum
rw [multiset.map_map]
refl
intros
{ ext, simp, }
ext
simp
intros
rw [split_support, mem_image, ne.def, ‚Üê support_eq_empty, ‚Üê ne.def, ‚Üê finset.nonempty_iff_ne_empty, split, comap_domain, finset.nonempty]
simp only [exists_prop, finset.mem_preimage, exists_and_distrib_right, exists_eq_right, mem_support_iff, sigma.exists, ne.def]
intros
intros a h
simp only [mul_apply, mem_support_iff] at h
simp only [mem_support_iff, mem_inter, ne.def]
rw ‚Üênot_or_distrib
intro w
apply h
cases w; { rw w, simp }
cases w
{ rw w, simp }
rw w
{ rw w, simp }
simp
intros
refine fintype.card_of_subtype _ _
simp
intros
obtain ‚ü®c, hcs : c ‚àà s‚ü© := h
have : well_founded (@has_lt.lt {x // x ‚àà s} _) := fintype.well_founded_of_trans_of_irrefl _
obtain ‚ü®‚ü®m, hms : m ‚àà s‚ü©, -, H‚ü© := this.has_min set.univ ‚ü®‚ü®c, hcs‚ü©, trivial‚ü©
exact ‚ü®m, hms, Œª x hx hxm, H ‚ü®x, hx‚ü© trivial hxm‚ü©
intros
rw [fintype.card_pi, finset.prod_const]; refl
rw [fintype.card_pi, finset.prod_const]
refl
intros
rcases int.units_eq_one_or x with (rfl | rfl); simp
rcases int.units_eq_one_or x with (rfl | rfl)
simp
simp
intros
simp
intros
rw [odd_iff_not_even, even_sub, not_iff, not_iff_comm, odd_iff_not_even]
intros
simp only [update_nth_eq_modify_nth, modify_nth_length]
intros
induction l with l_ih l_tl l_ih
{ apply (hl rfl).elim }
apply (hl rfl).elim
cases l_tl
{ cases l_tl, { simp }, { simpa using l_ih } }
{ simp }
simp
{ simpa using l_ih }
simpa using l_ih
intros
rw nth_le_drop
intros
induction l with hd tl hl generalizing b i
symmetry
{ symmetry, simp only [option.bind_eq_none', nth, forall_2_true_iff, not_false_iff, option.map_none', scanl_nil, option.not_mem_none, forall_true_iff] }
simp only [option.bind_eq_none', nth, forall_2_true_iff, not_false_iff, option.map_none', scanl_nil, option.not_mem_none, forall_true_iff]
simp only [nth, scanl_cons, singleton_append]
{ simp only [nth, scanl_cons, singleton_append], cases i, { simp only [option.map_some', nth_zero_scanl, nth, option.some_bind'] }, { simp only [hl, nth] } }
cases i
{ simp only [option.map_some', nth_zero_scanl, nth, option.some_bind'] }
simp only [option.map_some', nth_zero_scanl, nth, option.some_bind']
{ simp only [hl, nth] }
simp only [hl, nth]
intros
{ induction l, simp, simp [l_ih] }
induction l
simp
simp [l_ih]
intros
simp [lookmap, h]
intros
cases p; simp only [nil_append, cons_append, eq_self_iff_true, true_and, false_and]
cases p
simp only [nil_append, cons_append, eq_self_iff_true, true_and, false_and]
simp only [nil_append, cons_append, eq_self_iff_true, true_and, false_and]
intros
{ rw inits_eq_tails l, simp [reverse_involutive.comp_self], }
rw inits_eq_tails l
simp [reverse_involutive.comp_self]
intros
simp only [diff_eq_foldl, foldl_append]
intros
cases as; refl
cases as
refl
refl
intros
by_cases h‚ÇÅ : n < a
{ left, exact h‚ÇÅ }
left
exact h‚ÇÅ
right
{ right, by_cases h‚ÇÇ : n ‚àà Ico a b, { right, exact h‚ÇÇ }, { left, simp only [Ico.mem, not_and, not_lt] at *, exact h‚ÇÇ h‚ÇÅ }}
by_cases h‚ÇÇ : n ‚àà Ico a b
{ right, exact h‚ÇÇ }
right
exact h‚ÇÇ
{ left, simp only [Ico.mem, not_and, not_lt] at *, exact h‚ÇÇ h‚ÇÅ }
left
simp only [Ico.mem, not_and, not_lt] at *
exact h‚ÇÇ h‚ÇÅ
intros
rw [antidiagonal, length_map, length_range]
intros
rw sublist_iff_exists_order_embedding_nth_eq
split
rintro ‚ü®f, hf‚ü©
{ rintro ‚ü®f, hf‚ü©, have h : ‚àÄ {i : ‚Ñï} (h : i < l.length), f i < l'.length, { intros i hi, specialize hf i, rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf, obtain ‚ü®h, -‚ü© := hf, exact h }, refine ‚ü®order_embedding.of_map_le_iff (Œª ix, ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©, { simp }, { intro i, apply option.some_injective, simpa [‚Üênth_le_nth] using hf _ } }
have h : ‚àÄ {i : ‚Ñï} (h : i < l.length), f i < l'.length
intros i hi
{ intros i hi, specialize hf i, rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf, obtain ‚ü®h, -‚ü© := hf, exact h }
specialize hf i
rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf
obtain ‚ü®h, -‚ü© := hf
exact h
refine ‚ü®order_embedding.of_map_le_iff (Œª ix, ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
{ simp }
simp
intro i
{ intro i, apply option.some_injective, simpa [‚Üênth_le_nth] using hf _ }
apply option.some_injective
apply option.some_injective
simpa [‚Üênth_le_nth] using hf _
rintro ‚ü®f, hf‚ü©
{ rintro ‚ü®f, hf‚ü©, refine ‚ü®order_embedding.of_strict_mono (Œª i, if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length) _, _‚ü©, { intros i j h, dsimp only, split_ifs with hi hj hj hi, { simpa using h }, { rw add_comm, exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h) }, { exact absurd (h.trans hj) hi }, { simpa using h } }, { intro i, simp only [order_embedding.coe_of_strict_mono], split_ifs with hi, { rw [nth_le_nth hi, nth_le_nth, ‚Üêhf], simp }, { rw [nth_len_le, nth_len_le], { simp }, { simpa using hi } } } }
refine ‚ü®order_embedding.of_strict_mono (Œª i, if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length) _, _‚ü©
intros i j h
{ intros i j h, dsimp only, split_ifs with hi hj hj hi, { simpa using h }, { rw add_comm, exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h) }, { exact absurd (h.trans hj) hi }, { simpa using h } }
dsimp only
split_ifs with hi hj hj hi
{ simpa using h }
simpa using h
rw add_comm
{ rw add_comm, exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h) }
exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h)
{ exact absurd (h.trans hj) hi }
exact absurd (h.trans hj) hi
{ simpa using h }
simpa using h
intro i
{ intro i, simp only [order_embedding.coe_of_strict_mono], split_ifs with hi, { rw [nth_le_nth hi, nth_le_nth, ‚Üêhf], simp }, { rw [nth_len_le, nth_len_le], { simp }, { simpa using hi } } }
simp only [order_embedding.coe_of_strict_mono]
split_ifs with hi
rw [nth_le_nth hi, nth_le_nth, ‚Üêhf]
{ rw [nth_le_nth hi, nth_le_nth, ‚Üêhf], simp }
simp
rw [nth_len_le, nth_len_le]
{ rw [nth_len_le, nth_len_le], { simp }, { simpa using hi } }
simp
{ simp }
simpa using hi
{ simpa using hi }
intros
induction p with a l r p IH generalizing H
induction p with a l r p IH generalizing H; constructor
constructor
constructor
exact ball.imp_right (Œª x h, H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r
{ exact ball.imp_right (Œª x h, H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r }
exact IH (Œª a b m m', H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m'))
{ exact IH (Œª a b m m', H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m')) }
intros
rw ‚Üê filter_map_eq_filter; apply s.filter_map _
rw ‚Üê filter_map_eq_filter
apply s.filter_map _
intros
refine ‚ü®Œª h x hx, subperm.count_le h x, Œª h, _‚ü©
suffices : l‚ÇÅ <+~ (l‚ÇÇ.diff l‚ÇÅ ++ l‚ÇÅ)
refine this.trans (perm.subperm _)
{ refine this.trans (perm.subperm _), exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h) }
exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h)
convert (subperm_append_right _).mpr nil_subperm using 1
intros
simp only [iota_eq_reverse_range', length_reverse, length_range']
intros
induction n with n hn generalizing l
{ simp }
simp
cases l with hd tl
{ cases l with hd tl, { simp }, { simp [rotate_cons_succ, hn] } }
{ simp }
simp
{ simp [rotate_cons_succ, hn] }
simp [rotate_cons_succ, hn]
intros
simp [rotate']
intros
induction l‚ÇÅ generalizing l‚ÇÇ
simp
case list.nil { simp }
case list.cons : s l‚ÇÅ ih { by_cases h : a = s.1; [simp [h], simp [h, ih]] }
intros
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id', append_nil, cons_append, map_id' (Œª _, rfl)]
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id', append_nil, cons_append, map_id' (Œª _, rfl)]; split; refl
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id', append_nil, cons_append, map_id' (Œª _, rfl)]; split
split
refl
refl
intros
convert (zip_with_map f g id l l')
{ convert (zip_with_map f g id l l'), exact eq.symm (list.map_id _) }
exact eq.symm (list.map_id _)
intros
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l' with hd' tl'
{ cases l' with hd' tl', { simp }, { simp only [add_left_inj, length] at h, have : tl.reverse.length = tl'.reverse.length := by simp [h], simp [hl _ h, zip_with_append _ _ _ _ _ this] } }
{ simp }
simp
simp only [add_left_inj, length] at h
{ simp only [add_left_inj, length] at h, have : tl.reverse.length = tl'.reverse.length := by simp [h], simp [hl _ h, zip_with_append _ _ _ _ _ this] }
have : tl.reverse.length = tl'.reverse.length := by simp [h]
simp [hl _ h, zip_with_append _ _ _ _ _ this]
intros
ext i j; refl
ext i j
refl
intros
ext i' j
rw [transpose_apply, update_row_apply, update_column_apply]
refl
intros
dsimp [algebra_map, algebra.to_ring_hom, matrix.scalar]
split_ifs with h; simp [h, matrix.one_apply_ne]
split_ifs with h
simp [h, matrix.one_apply_ne]
simp [h, matrix.one_apply_ne]
intros
ext i j
rcases i
rcases i; rcases j; refl
rcases i; rcases j
rcases j
refl
refl
rcases j
refl
refl
intros
{ ext, simp, }
ext
simp
intros
{ ext i j, refl }
ext i j
refl
intros
rcases multiset.exists_cons_of_mem h with ‚ü®s', hs'‚ü©
simp [hs', multiset.prod_cons]
intros
subst h
simp at hf
simp [bind_congr hf]
intros
simp [ne.def, count_eq_zero]
intros
rw [card.map_nsmul s n, nat.nsmul_eq_mul]
intros
{ ext, simp only [aeval_X, aeval_tower_X] }
ext
simp only [aeval_X, aeval_tower_X]
intros
{ ext, apply constant_coeff_C }
ext
apply constant_coeff_C
intros
simp [expand, map_bind‚ÇÅ]
intros
{ rw ‚Üê C_0, exact degrees_C 0 }
rw ‚Üê C_0
exact degrees_C 0
intros
conv_lhs { rw [‚Üêmod_add_div a n, ‚Üêmod_add_div' b n, right_distrib, left_distrib, left_distrib, mul_assoc, mul_assoc, ‚Üêleft_distrib n _ _, add_mul_mod_self_left, ‚Üê mul_assoc, add_mul_mod_self_right] }
intros
{ convert bit1_lt_bit0_iff, refl, }
convert bit1_lt_bit0_iff
refl
intros
rw [succ_add, succ_sub_one]
intros
simp [lxor]
intros
cases n
cases n; refl
refl
refl
intros
induction L with d L ih
{ refl, }
refl
{ dsimp [of_digits], push_cast, rw ih, }
dsimp [of_digits]
push_cast
rw ih
intros
simp [dist.def, succ_sub_succ]
intros
classical; exact not_iff_comm.1 part.eq_none_iff'.symm
classical
exact not_iff_comm.1 part.eq_none_iff'.symm
intros
rw [‚Üê succ_pred_eq_of_pos ((zero_lt_two.trans (lt.base 2)).trans_le hi), factorial_succ]
exact lt_mul_of_one_lt_right ((pred n).succ_pos) ((one_lt_two.trans_le (le_pred_of_lt (succ_le_iff.mp hi))).trans_le (self_le_factorial _))
intros
split
split; intro h
intro h
rw [‚Üê not_lt, ‚Üê one_lt_factorial, h]
{ rw [‚Üê not_lt, ‚Üê one_lt_factorial, h], apply lt_irrefl }
apply lt_irrefl
intro h
cases h with h h
refl
cases h
refl
intros
simp [nat.lt_succ_iff_lt_or_eq, supr_or, supr_sup_eq]
intros
rw [nat.modeq, nat.add_mod_left]
intros
rw [even_iff_two_dvd, dvd_iff_mod_eq_zero, nat.div_mod_eq_mod_mul_div, mul_comm]
intros
rw [nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h), pow_sub_mul_pow _ h]
rw factors
intros
refine min_fac_helper_1 e _ h
refine mt _ (ne_of_gt c0)
intro e‚ÇÅ
rw [‚Üê nc, ‚Üê nat.dvd_iff_mod_eq_zero, ‚Üê e‚ÇÅ]
apply nat.min_fac_dvd
intros
simp
intros
linarith
intros
rw balance'; split_ifs; simp [all_node', all_rotate_l, all_rotate_r]
rw balance'; split_ifs
rw balance'
split_ifs
simp [all_node', all_rotate_l, all_rotate_r]
simp [all_node', all_rotate_l, all_rotate_r]
simp [all_node', all_rotate_l, all_rotate_r]
simp [all_node', all_rotate_l, all_rotate_r]
intros
split
split; intro h
intro h
intros a h' b
{ intros a h' b, replace h := h b, simp only [and_imp, exists_prop, bind_eq_bind, mem_bind_iff, exists_imp_distrib] at h, apply h _ h' }
replace h := h b
simp only [and_imp, exists_prop, bind_eq_bind, mem_bind_iff, exists_imp_distrib] at h
apply h _ h'
intro h
intros b h'
{ intros b h', simp only [exists_prop, bind_eq_bind, mem_bind_iff] at h', rcases h' with ‚ü®a,h‚ÇÄ,h‚ÇÅ‚ü©, apply h _ h‚ÇÄ _ h‚ÇÅ }
simp only [exists_prop, bind_eq_bind, mem_bind_iff] at h'
rcases h' with ‚ü®a,h‚ÇÄ,h‚ÇÅ‚ü©
apply h _ h‚ÇÄ _ h‚ÇÅ
intros
cases x
simp! [comp.get,comp.mk]
intros
simp only [isubtree,ichildren_mk,pfunctor.obj.iget,dif_pos,isubtree,M.cases_on_mk']
simp only [isubtree,ichildren_mk,pfunctor.obj.iget,dif_pos,isubtree,M.cases_on_mk']; refl
refl
intros
change ((to_pnat' ((a : ‚Ñï) - (b : ‚Ñï)) : ‚Ñï)) = ite ((a : ‚Ñï) > (b : ‚Ñï)) ((a : ‚Ñï) - (b : ‚Ñï)) 1
split_ifs with h
{ exact to_pnat'_coe (nat.sub_pos_of_lt h) }
exact to_pnat'_coe (nat.sub_pos_of_lt h)
rw [nat.sub_eq_zero_iff_le.mpr (le_of_not_gt h)]
{ rw [nat.sub_eq_zero_iff_le.mpr (le_of_not_gt h)], refl }
refl
intros
dsimp [gcd_a', gcd_x, gcd_w, xgcd_type.w]
{ dsimp [gcd_a', gcd_x, gcd_w, xgcd_type.w], rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_right_comm] }
rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_right_comm]
intros
simp
intros
rw [eq_neg_iff_add_eq_zero, ‚Üêmonomial_add, neg_add_self, monomial_zero_right]
intros
simp [coeff_mul]
intros
simp [mul_sub]
intros
unfold leading_coeff
rw [nat_degree_mul' h, coeff_mul_degree_add_degree]
refl
intros
rw [leading_coeff, nat_degree_X_pow_sub_C, coeff_sub, coeff_X_pow_self, coeff_C, if_neg (pos_iff_ne_zero.mp hn), sub_zero]
intros
induction k with k ih generalizing p
{ simp, }
simp
simp [ih p.derivative, iterate_derivative_neg, derivative_comp, pow_succ]
{ simp [ih p.derivative, iterate_derivative_neg, derivative_comp, pow_succ], }
intros
rw [‚ÜêC_eq_nat_cast, C_mul_comp, C_eq_nat_cast]
intros
rw [comp, p.as_sum_range]; simp [eval‚ÇÇ_finset_sum, eval‚ÇÇ_pow]
rw [comp, p.as_sum_range]
simp [eval‚ÇÇ_finset_sum, eval‚ÇÇ_pow]
intros
rw [integral_normalization_coeff, if_neg hi]
intros
{ rw sub_eq_add_neg, apply monic_add_of_left hp, rwa degree_neg }
rw sub_eq_add_neg
apply monic_add_of_left hp
rwa degree_neg
intros
rw ‚Üê sub_eq_zero
apply zero_of_eval_zero
intro x
rw [eval_sub, sub_eq_zero, ext]
intros
intros b‚ÇÅ b‚ÇÇ h
{ intros b‚ÇÅ b‚ÇÇ h, by simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h }
simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h
simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h
intros
by_cases n = 0; simp [*, mk_nat]
by_cases n = 0
simp [*, mk_nat]
simp [*, mk_nat]
intros
cases q‚ÇÅ; cases q‚ÇÇ; refl
cases q‚ÇÅ; cases q‚ÇÇ
cases q‚ÇÅ
cases q‚ÇÇ
refl
intros
let S := {x : ‚Ñù | const abs x < f}
have lb : ‚àÉ x, x ‚àà S := exists_lt f
have ub' : ‚àÄ x, f < const abs x ‚Üí ‚àÄ y ‚àà S, y ‚â§ x := Œª x h y yS, le_of_lt $ const_lt.1 $ cau_seq.lt_trans yS h
have ub : ‚àÉ x, ‚àÄ y ‚àà S, y ‚â§ x := (exists_gt f).imp ub'
refine ‚ü®Sup S, ((lt_total _ _).resolve_left (Œª h, _)).resolve_right (Œª h, _)‚ü©
rcases h with ‚ü®Œµ, Œµ0, i, ih‚ü©
{ rcases h with ‚ü®Œµ, Œµ0, i, ih‚ü©, refine (cSup_le lb (ub' _ _)).not_lt (sub_lt_self _ (half_pos Œµ0)), refine ‚ü®_, half_pos Œµ0, i, Œª j ij, _‚ü©, rw [sub_apply, const_apply, sub_right_comm, le_sub_iff_add_le, add_halves], exact ih _ ij }
refine (cSup_le lb (ub' _ _)).not_lt (sub_lt_self _ (half_pos Œµ0))
refine ‚ü®_, half_pos Œµ0, i, Œª j ij, _‚ü©
rw [sub_apply, const_apply, sub_right_comm, le_sub_iff_add_le, add_halves]
exact ih _ ij
rcases h with ‚ü®Œµ, Œµ0, i, ih‚ü©
{ rcases h with ‚ü®Œµ, Œµ0, i, ih‚ü©, refine (le_cSup ub _).not_lt ((lt_add_iff_pos_left _).2 (half_pos Œµ0)), refine ‚ü®_, half_pos Œµ0, i, Œª j ij, _‚ü©, rw [sub_apply, const_apply, add_comm, ‚Üê sub_sub, le_sub_iff_add_le, add_halves], exact ih _ ij }
refine (le_cSup ub _).not_lt ((lt_add_iff_pos_left _).2 (half_pos Œµ0))
refine ‚ü®_, half_pos Œµ0, i, Œª j ij, _‚ü©
rw [sub_apply, const_apply, add_comm, ‚Üê sub_sub, le_sub_iff_add_le, add_halves]
exact ih _ ij
intros
apply (summable_geometric_of_lt_1 h1 h2).summable_of_eq_zero_or_self
intro n
cases h : f n
cases h : f n; simp [h]
simp [h]
simp [h]
intros
cases classical.em (lim_zero f); simp *
cases classical.em (lim_zero f)
simp *
simp *
rcases abv_pos_of_not_lim_zero h with ‚ü®K, K0, hK‚ü©
rcases exists_forall_ge_and hK (f.cauchy‚ÇÉ K0) with ‚ü®i, hi‚ü©
refine (le_total 0 (f i)).imp _ _; refine (Œª h, ‚ü®K, K0, i, Œª j ij, _‚ü©); have := (hi _ ij).1; cases hi _ (le_refl _) with h‚ÇÅ h‚ÇÇ
refine (le_total 0 (f i)).imp _ _; refine (Œª h, ‚ü®K, K0, i, Œª j ij, _‚ü©); have := (hi _ ij).1
refine (le_total 0 (f i)).imp _ _; refine (Œª h, ‚ü®K, K0, i, Œª j ij, _‚ü©)
refine (le_total 0 (f i)).imp _ _
refine (Œª h, ‚ü®K, K0, i, Œª j ij, _‚ü©)
have := (hi _ ij).1
cases hi _ (le_refl _) with h‚ÇÅ h‚ÇÇ
rwa abs_of_nonneg at this
{ rwa abs_of_nonneg at this, rw abs_of_nonneg h at h‚ÇÅ, exact (le_add_iff_nonneg_right _).1 (le_trans h‚ÇÅ $ neg_le_sub_iff_le_add'.1 $ le_of_lt (abs_lt.1 $ h‚ÇÇ _ ij).1) }
rw abs_of_nonneg h at h‚ÇÅ
exact (le_add_iff_nonneg_right _).1 (le_trans h‚ÇÅ $ neg_le_sub_iff_le_add'.1 $ le_of_lt (abs_lt.1 $ h‚ÇÇ _ ij).1)
refine (Œª h, ‚ü®K, K0, i, Œª j ij, _‚ü©)
have := (hi _ ij).1
cases hi _ (le_refl _) with h‚ÇÅ h‚ÇÇ
rwa abs_of_nonpos at this
{ rwa abs_of_nonpos at this, rw abs_of_nonpos h at h‚ÇÅ, rw [‚Üê sub_le_sub_iff_right, zero_sub], exact le_trans (le_of_lt (abs_lt.1 $ h‚ÇÇ _ ij).2) h‚ÇÅ }
rw abs_of_nonpos h at h‚ÇÅ
rw [‚Üê sub_le_sub_iff_right, zero_sub]
exact le_trans (le_of_lt (abs_lt.1 $ h‚ÇÇ _ ij).2) h‚ÇÅ
intros
rw [‚Üê real.to_nnreal_one, ‚Üê real.to_nnreal_div' h.nonneg, ‚Üê real.to_nnreal_div' h.symm.nonneg, ‚Üê real.to_nnreal_add h.one_div_nonneg h.symm.one_div_nonneg, h.inv_add_inv_conj]
intros
simp [div_eq_mul_inv]
intros
simp
intros
rw [‚Üê coe_eq_coe, coe_to_nnreal, coe_finset_sum, sum_congr rfl]
{ intros x hx, exact (coe_to_nnreal (hf x hx)).symm }
intros x hx
exact (coe_to_nnreal (hf x hx)).symm
{ exact (sum_lt_top hf).ne }
exact (sum_lt_top hf).ne
intros
rw iff_eq_eq
rw iff_eq_eq; refl
refl
intros
rintros ‚ü®‚ü®N, D, P, C‚ü©, rfl‚ü©
rw [‚Üê cast_pow] at hxr
have c1 : ((D : ‚Ñ§) : ‚Ñù) ‚â† 0
rw [int.cast_ne_zero, int.coe_nat_ne_zero]
{ rw [int.cast_ne_zero, int.coe_nat_ne_zero], exact ne_of_gt P }
exact ne_of_gt P
have c2 : ((D : ‚Ñ§) : ‚Ñù) ^ n ‚â† 0 := pow_ne_zero _ c1
rw [num_denom', cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2, ‚Üê int.cast_pow, ‚Üê int.cast_pow, ‚Üê int.cast_mul, int.cast_inj] at hxr
have hdivn : ‚ÜëD ^ n ‚à£ N ^ n := dvd.intro_left m hxr
rw [‚Üê int.dvd_nat_abs, ‚Üê int.coe_nat_pow, int.coe_nat_dvd, int.nat_abs_pow, nat.pow_dvd_pow_iff hnpos] at hdivn
have hD : D = 1 := by rw [‚Üê nat.gcd_eq_right hdivn, C.gcd_eq_one]
subst D
refine hv ‚ü®N, _‚ü©
rw [num_denom', int.coe_nat_one, mk_eq_div, int.cast_one, div_one, cast_coe_int]
intros
simp [to_nnreal_one, bit1, hr]
intros
ext
{ ext, rw [nnreal.coe_nat_cast, int.cast_nat_abs, real.coe_nnabs] }
rw [nnreal.coe_nat_cast, int.cast_nat_abs, real.coe_nnabs]
intros
ext z
simp only [mem_image, comp]
split
rintros ‚ü®x, xt, y, rxy, syz‚ü©
{ rintros ‚ü®x, xt, y, rxy, syz‚ü©, exact ‚ü®y, ‚ü®x, xt, rxy‚ü©, syz‚ü© }
exact ‚ü®y, ‚ü®x, xt, rxy‚ü©, syz‚ü©
rintros ‚ü®y, ‚ü®x, xt, rxy‚ü©, syz‚ü©
exact ‚ü®x, xt, y, rxy, syz‚ü©
intros
rw [head_eq_destruct, destruct_cons]; refl
rw [head_eq_destruct, destruct_cons]
refl
intros
rw add_comm; symmetry; apply dropn_add
rw add_comm; symmetry
rw add_comm
symmetry
apply dropn_add
intros
split_ifs with hb hb
{ split_ifs with hb hb, exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb] }
exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]
intros
simp
intros
rw [compl_eq_univ_diff, ‚Üê pi_update_of_mem (mem_univ _)]
intros
ext
{ ext, split; rintro ‚ü®a, b, ha, hb, rfl‚ü©; refine ‚ü®b, a, hb, ha, rfl‚ü© }
split
split; rintro ‚ü®a, b, ha, hb, rfl‚ü©; refine ‚ü®b, a, hb, ha, rfl‚ü©
split; rintro ‚ü®a, b, ha, hb, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
refine ‚ü®b, a, hb, ha, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
refine ‚ü®b, a, hb, ha, rfl‚ü©
intros
by_cases p; simp [h, ht]
by_cases p
simp [h, ht]
simp [h, ht]
intros
simp [surjective, surj_on, subset_def]
intros
{ rw ‚Üê image_univ, exact h.surj_on_image (ha.surj_on univ) }
rw ‚Üê image_univ
exact h.surj_on_image (ha.surj_on univ)
intros
{ ext x, simp [‚Üê e.le_iff_le] }
ext x
simp [‚Üê e.le_iff_le]
intros
rw [‚Üê Ico_diff_left, diff_union_self, union_eq_self_of_subset_right (singleton_subset_iff.2 $ left_mem_Ico.2 hab)]
intros
ext1 x
simp_rw [mem_union, mem_Iio, mem_Ico, lt_max_iff]
by_cases hc : c ‚â§ x
{ tauto }
tauto
have hxb : x < b := (lt_of_not_ge hc).trans_le h‚ÇÅ
{ have hxb : x < b := (lt_of_not_ge hc).trans_le h‚ÇÅ, tauto }
tauto
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Iic_of_neg a h
intros
rintro z ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
refine (h‚ÇÅ i‚ÇÄ (mem_univ _)).2.not_lt _
simpa only [function.update_same] using (h‚ÇÇ i‚ÇÄ (mem_univ _)).1
intros
{ ext, simp }
ext
simp
intros
rw [Sup_eq_eqv_gen, Sup_image]
congr' with x y
simp only [supr_apply, supr_Prop_eq, exists_prop]
intros
rw [‚Üêstring.as_string_inv_to_list s, list.to_list_inv_as_string, list.length_as_string]
intros
convert card_image_off_diag (univ : finset Œ±)
rw [fintype.card_of_subtype, ‚Üêfilter_image_quotient_mk_not_is_diag]
rintro x
rw [mem_filter, univ_product_univ, mem_image]
obtain ‚ü®a, ha‚ü© := quotient.exists_rep x
exact and_iff_right ‚ü®a, mem_univ _, ha‚ü©
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
rw [‚Üê nth_zero, nth_of_fn]
intros
apply list.nth_le_repeat
intros
cases n
{ simp }
simp
simp only [coe_coe, fin.coe_add_eq_ite, int.nat_cast_eq_coe_nat, ‚Üê int.coe_nat_add, ‚Üê int.coe_nat_succ, int.coe_nat_le]
split_ifs with h
{ exact int.coe_nat_sub h }
exact int.coe_nat_sub h
{ refl }
refl
intros
rw [mem_ker]; exact one_iff_ker_inv hf _ _
rw [mem_ker]
exact one_iff_ker_inv hf _ _
intros
refl
intros
apply subfield.closure_le.mpr
rw set.union_subset_iff
exact ‚ü®HF, HS‚ü©
intros
suffices : set.range (algebra_map F E) = (‚ä• : intermediate_field F E)
{ rw this, refl }
rw this
refl
change set.range (algebra_map F E) = subfield.closure (set.range (algebra_map F E) ‚à™ ‚àÖ)
{ change set.range (algebra_map F E) = subfield.closure (set.range (algebra_map F E) ‚à™ ‚àÖ), simp [‚Üêset.image_univ, ‚Üêring_hom.map_field_closure] }
simp [‚Üêset.image_univ, ‚Üêring_hom.map_field_closure]
intros
cases n
simp
{simp}
rw ‚Üê zmod.eq_iff_modeq_nat
let x' : units (zmod (n+1)) := zmod.unit_of_coprime _ h
have := zmod.pow_totient x'
apply_fun (coe : units (zmod (n+1)) ‚Üí zmod (n+1)) at this
simpa only [-zmod.pow_totient, nat.succ_eq_add_one, nat.cast_pow, units.coe_one, nat.cast_one, coe_unit_of_coprime, units.coe_pow]
intros
{ rw [set_like.ext_iff, set_like.ext'_iff, set.ext_iff], refl }
rw [set_like.ext_iff, set_like.ext'_iff, set.ext_iff]
refl
intros
induction n with n ih; [refl, rw ‚Üê ih]; symmetry; apply quot.sound; have := r.intro n (0:K); rwa [frobenius_zero K p] at this
induction n with n ih; [refl, rw ‚Üê ih]; symmetry; apply quot.sound; have := r.intro n (0:K)
induction n with n ih; [refl, rw ‚Üê ih]; symmetry; apply quot.sound
induction n with n ih; [refl, rw ‚Üê ih]; symmetry
induction n with n ih; [refl, rw ‚Üê ih]
induction n with n ih
refl
rw ‚Üê ih
symmetry
apply quot.sound
have := r.intro n (0:K)
rwa [frobenius_zero K p] at this
intros
rcases angle_eq_pi_iff.1 h with ‚ü®hx, ‚ü®r, ‚ü®hr, rfl‚ü©‚ü©‚ü©
rw [angle_smul_left_of_neg x z hr, angle_neg_left, add_sub_cancel'_right]
intros
refine (triangle.eq_orthocenter_of_forall_mem_altitude hj‚ÇÇ‚ÇÉ _ _).symm
rw altitude_replace_orthocenter_eq_affine_span hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ h‚ÇÅ h‚ÇÇ h‚ÇÉ
{ rw altitude_replace_orthocenter_eq_affine_span hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ h‚ÇÅ h‚ÇÇ h‚ÇÉ, exact mem_affine_span ‚Ñù (set.mem_insert _ _) }
exact mem_affine_span ‚Ñù (set.mem_insert _ _)
rw altitude_replace_orthocenter_eq_affine_span hi‚ÇÅ‚ÇÉ hi‚ÇÅ‚ÇÇ hi‚ÇÇ‚ÇÉ.symm hj‚ÇÅ‚ÇÉ hj‚ÇÅ‚ÇÇ hj‚ÇÇ‚ÇÉ.symm h‚ÇÅ h‚ÇÉ h‚ÇÇ
{ rw altitude_replace_orthocenter_eq_affine_span hi‚ÇÅ‚ÇÉ hi‚ÇÅ‚ÇÇ hi‚ÇÇ‚ÇÉ.symm hj‚ÇÅ‚ÇÉ hj‚ÇÅ‚ÇÇ hj‚ÇÇ‚ÇÉ.symm h‚ÇÅ h‚ÇÉ h‚ÇÇ, exact mem_affine_span ‚Ñù (set.mem_insert _ _) }
exact mem_affine_span ‚Ñù (set.mem_insert _ _)
intros
assume z hz
simp only with mfld_simps at hz
have : (chart_at H x).mdifferentiable I I := mdifferentiable_chart _ _
have T := (hs.unique_mdiff_on_preimage this) (I.symm z)
simp only [hz.left.left, hz.left.right, hz.right, unique_mdiff_within_at] with mfld_simps at ‚ä¢ T
convert T using 1
rw @preimage_comp _ _ _ _ (chart_at H x).symm
mfld_set_tac
intros
rw ‚Üê mdifferentiable_within_at_univ at h
rw ‚Üê tangent_map_within_univ
exact tangent_map_within_subset (subset_univ _) hs h
intros
rw [‚Üê nhds_within_univ, ‚Üê ext_chart_at_symm_map_nhds_within' I x hy, preimage_univ, univ_inter]
intros
rw [times_cont_mdiff_within_at, times_cont_mdiff_within_at, lift_prop_within_at, lift_prop_within_at, ‚Üê and_assoc]
have cont : (continuous_within_at f s x ‚àß continuous_within_at ((I' ‚àò (chart_at H' (f x))) ‚àò f) (s ‚à© f ‚Åª¬π' (chart_at H' (f x)).to_local_equiv.source) x) ‚Üî continuous_within_at f s x
refine ‚ü®Œª h, h.1, Œª h, ‚ü®h, _‚ü©‚ü©
{ refine ‚ü®Œª h, h.1, Œª h, ‚ü®h, _‚ü©‚ü©, have h‚ÇÅ : continuous_within_at _ univ ((chart_at H' (f x)) (f x)), { exact (model_with_corners.continuous I').continuous_within_at }, have h‚ÇÇ := (chart_at H' (f x)).continuous_to_fun.continuous_within_at (mem_chart_source _ _), convert (h‚ÇÅ.comp' h‚ÇÇ).comp' h, simp }
have h‚ÇÅ : continuous_within_at _ univ ((chart_at H' (f x)) (f x))
{ exact (model_with_corners.continuous I').continuous_within_at }
exact (model_with_corners.continuous I').continuous_within_at
have h‚ÇÇ := (chart_at H' (f x)).continuous_to_fun.continuous_within_at (mem_chart_source _ _)
convert (h‚ÇÅ.comp' h‚ÇÇ).comp' h
simp
simp [cont, times_cont_diff_within_at_prop]
intros
rw [‚Üêlift_apply_mk' f, ‚Üêlift_apply_mk' g]
congr' 1
exact monoid_hom.ext_iff.2 h
intros
{ classical, exact (of_left_inverse i).injective }
classical
exact (of_left_inverse i).injective
intros
rw [smul_smul, mul_right_inv, one_smul]
intros
erw [mul_assoc, is_unit.lift_right_inv_mul, mul_one]
intros
rw ‚Üê order_of_of_add_eq_add_order_of
exact order_of_dvd_card_univ
intros
obtain ‚ü®n, hn‚ü© := cycle_type_prime_order h1
rw [‚ÜêœÉ.sum_cycle_type, hn, multiset.sum_repeat, nsmul_eq_mul, nat.cast_id, mul_lt_mul_right (order_of_pos œÉ), nat.succ_lt_succ_iff, nat.lt_succ_iff, nat.le_zero_iff] at h2
rw [‚Üêcard_cycle_type_eq_one, hn, card_repeat, h2]
intros
obtain ‚ü®a, b, ab, rfl‚ü© := hœÉ
obtain ‚ü®c, d, cd, rfl‚ü© := hœÑ
by_cases ac : a = c
subst ac
{ subst ac, exact swap_mul_swap_same_mem_closure_three_cycles ab cd }
exact swap_mul_swap_same_mem_closure_three_cycles ab cd
have h' : swap a b * swap c d = swap a b * swap a c * (swap c a * swap c d)
{ simp [swap_comm c a, mul_assoc] }
simp [swap_comm c a, mul_assoc]
rw h'
exact mul_mem _ (swap_mul_swap_same_mem_closure_three_cycles ab ac) (swap_mul_swap_same_mem_closure_three_cycles (ne.symm ac) cd)
intros
rw [‚Üêcycle_of_pow_apply_self f, ‚Üêcycle_of_pow_apply_self f, pow_eq_mod_order_of]
intros
rw [cycle_range_of_le h.le, if_pos h]
intros
induction n with n hn
{ simp [nat.mod_eq_of_lt hk] }
simp [nat.mod_eq_of_lt hk]
simp [pow_succ, mul_apply, hn, form_perm_apply_nth_le _ h, nat.succ_eq_add_one, ‚Üênat.add_assoc]
{ simp [pow_succ, mul_apply, hn, form_perm_apply_nth_le _ h, nat.succ_eq_add_one, ‚Üênat.add_assoc] }
intros
unfold sign_aux
conv { to_rhs, rw ‚Üê @finset.prod_const_one (units ‚Ñ§) _ (fin_pairs_lt n) }
exact finset.prod_congr rfl (Œª a ha, if_neg (mem_fin_pairs_lt.1 ha).not_le)
intros
induction l with g l ih
{ exact disjoint_one_right _ }
exact disjoint_one_right _
rw list.prod_cons
{ rw list.prod_cons, exact (h _ (list.mem_cons_self _ _)).mul_right (ih (Œª g hg, h g (list.mem_cons_of_mem _ hg))) }
exact (h _ (list.mem_cons_self _ _)).mul_right (ih (Œª g hg, h g (list.mem_cons_of_mem _ hg)))
intros
intros x hx
rwa [mem_support, ‚Üêeq_on_support_mem_disjoint h hl _ hx, ‚Üêmem_support]
intros
rw is_solvable_def at *
cases h with n hn
use n
calc derived_series G' n = (derived_series G n).map f : eq.symm (map_derived_series_eq hf n) ... = (‚ä• : subgroup G).map f : by rw hn ... = ‚ä• : map_bot f
intros
change a ‚àà set_of is_unit ‚Üî is_unit a
rw set.mem_set_of_eq
intros
symmetry
rw equiv.eq_image_iff_symm_image_eq
exact of_mul_image_powers_eq_multiples_of_mul
intros
rw [‚Üê fintype.card_prod, fintype.card_congr (preimage_mk_equiv_subgroup_times_set _ _)]
intros
rw coe_direction_eq_vsub_set ‚ü®p, hp‚ü©
refine le_antisymm _ _
rintros v ‚ü®p1, p2, hp1, hp2, rfl‚ü©
{ rintros v ‚ü®p1, p2, hp1, hp2, rfl‚ü©, exact ‚ü®p1 -·µ• p2 +·µ• p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, (vadd_vsub _ _)‚ü© }
exact ‚ü®p1 -·µ• p2 +·µ• p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, (vadd_vsub _ _)‚ü©
rintros v ‚ü®p2, hp2, rfl‚ü©
{ rintros v ‚ü®p2, hp2, rfl‚ü©, exact ‚ü®p2, p, hp2, hp, rfl‚ü© }
exact ‚ü®p2, p, hp2, hp, rfl‚ü©
intros
rw [vector_span_eq_span_vsub_set_right k (set.mem_range_self i0), ‚Üêset.range_comp]
intros
{ ext, simp }
ext
simp
intros
rw [ker, comap_cod_restrict, map_bot]; refl
rw [ker, comap_cod_restrict, map_bot]
refl
intros
{ rw is_skew_adjoint_iff_neg_self_adjoint, exact iff.rfl, }
rw is_skew_adjoint_iff_neg_self_adjoint
exact iff.rfl
intros
ext i j
simp only [bilin_form.to_matrix_apply, bilin_form.comp_apply, transpose_apply, matrix.mul_apply, linear_map.to_matrix', linear_equiv.coe_mk, sum_mul]
rw sum_comm
conv_lhs { rw ‚Üê sum_repr_mul_repr_mul b }
rw finsupp.sum_fintype
apply sum_congr rfl
{ apply sum_congr rfl, rintros i' -, rw finsupp.sum_fintype, { apply sum_congr rfl, rintros j' -, simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm] }, { intros, simp only [zero_smul, smul_zero] } }
rintros i' -
rw finsupp.sum_fintype
apply sum_congr rfl
{ apply sum_congr rfl, rintros j' -, simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm] }
rintros j' -
simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm]
{ intros, simp only [zero_smul, smul_zero] }
intros
simp only [zero_smul, smul_zero]
{ intros, simp only [zero_smul, finsupp.sum_zero] }
intros
simp only [zero_smul, finsupp.sum_zero]
intros
simp [reverse]
intros
haveI := classical.dec_eq Œπ
{ haveI := classical.dec_eq Œπ, rw [‚Üê det_to_matrix b, linear_equiv.map_zero, det_zero], assumption }
rw [‚Üê det_to_matrix b, linear_equiv.map_zero, det_zero]
assumption
intros
simp only [le_rank_iff_exists_linear_independent, cardinal.lift_nat_cast, cardinal.lift_eq_nat_iff, cardinal.mk_eq_nat_iff_finset]
split
rintro ‚ü®s, ‚ü®t, rfl, rfl‚ü©, si‚ü©
{ rintro ‚ü®s, ‚ü®t, rfl, rfl‚ü©, si‚ü©, exact ‚ü®t, rfl, si‚ü© }
exact ‚ü®t, rfl, si‚ü©
rintro ‚ü®s, rfl, si‚ü©
{ rintro ‚ü®s, rfl, si‚ü©, exact ‚ü®s, ‚ü®s, rfl, rfl‚ü©, si‚ü© }
exact ‚ü®s, ‚ü®s, rfl, rfl‚ü©, si‚ü©
intros
{ ext, apply to_dual_apply_right }
ext
apply to_dual_apply_right
intros
have : module.rank F (‚ä• : subalgebra F E) = 1 := subalgebra.dim_bot
rw ‚Üê finrank_eq_dim at this
norm_cast at *
simp *
intros
have : map_domain f l = emb_domain ‚ü®f, hf‚ü© l
rw emb_domain_eq_map_domain ‚ü®f, hf‚ü©
{ rw emb_domain_eq_map_domain ‚ü®f, hf‚ü©, refl }
refl
rw this
apply total_emb_domain R ‚ü®f, hf‚ü© l
intros
apply @linear_independent_Union_finite R _ _ _ _ Œπ œÜ (Œª i x, single i (f i x))
assume i
{ assume i, have h_disjoint : disjoint (span R (range (f i))) (ker (lsingle i)), { rw ker_lsingle, exact disjoint_bot_right }, apply (hf i).map h_disjoint }
have h_disjoint : disjoint (span R (range (f i))) (ker (lsingle i))
rw ker_lsingle
{ rw ker_lsingle, exact disjoint_bot_right }
exact disjoint_bot_right
apply (hf i).map h_disjoint
intros i t ht hit
{ intros i t ht hit, refine (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono _ _, { rw span_le, simp only [supr_singleton], rw range_coe, apply range_comp_subset_range }, { refine supr_le_supr (Œª i, supr_le_supr _), intros hi, rw span_le, rw range_coe, apply range_comp_subset_range } }
refine (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono _ _
rw span_le
{ rw span_le, simp only [supr_singleton], rw range_coe, apply range_comp_subset_range }
simp only [supr_singleton]
rw range_coe
apply range_comp_subset_range
refine supr_le_supr (Œª i, supr_le_supr _)
{ refine supr_le_supr (Œª i, supr_le_supr _), intros hi, rw span_le, rw range_coe, apply range_comp_subset_range }
intros hi
rw span_le
rw range_coe
apply range_comp_subset_range
intros
refine ‚ü®Œª h n, Œª f hf, _, Œª h, ‚ü®Œª n m f hf, _‚ü©‚ü©
letI : strong_rank_condition R := h
{ letI : strong_rank_condition R := h, exact nat.not_succ_le_self n (le_of_fin_injective R f hf) }
exact nat.not_succ_le_self n (le_of_fin_injective R f hf)
by_contra H
{ by_contra H, exact h m (f.comp (function.extend_by_zero.linear_map R (fin.cast_le (not_le.1 H)))) (hf.comp (function.extend_injective (rel_embedding.injective _) 0)) }
exact h m (f.comp (function.extend_by_zero.linear_map R (fin.cast_le (not_le.1 H)))) (hf.comp (function.extend_injective (rel_embedding.injective _) 0))
intros
let l : Œπ ‚Üí‚ÇÄ R := finsupp.single i c - finsupp.single j d
have h_total : finsupp.total Œπ M R v l = 0
simp_rw [linear_map.map_sub, finsupp.total_apply]
{ simp_rw [linear_map.map_sub, finsupp.total_apply], simp [h] }
simp [h]
have h_single_eq : finsupp.single i c = finsupp.single j d
rw linear_independent_iff at li
{ rw linear_independent_iff at li, simp [eq_add_of_sub_eq' (li l h_total)] }
simp [eq_add_of_sub_eq' (li l h_total)]
rcases (finsupp.single_eq_single_iff _ _ _ _).mp h_single_eq with ‚ü®this, _‚ü© | ‚ü®hc, _‚ü©
{ exact this }
exact this
{ contradiction }
contradiction
intros
ext k i j
simp only [mat_poly_equiv_coeff_apply, coeff_sub, pi.sub_apply]
by_cases h : i = j
subst h
{ subst h, rw [charmatrix_apply_eq, coeff_sub], simp only [coeff_X, coeff_C], split_ifs; simp, }
rw [charmatrix_apply_eq, coeff_sub]
simp only [coeff_X, coeff_C]
split_ifs; simp
split_ifs
simp
simp
simp
simp
rw [charmatrix_apply_ne _ _ _ h, coeff_X, coeff_neg, coeff_C, coeff_C]
{ rw [charmatrix_apply_ne _ _ _ h, coeff_X, coeff_neg, coeff_C, coeff_C], split_ifs; simp [h], }
split_ifs; simp [h]
split_ifs
simp [h]
simp [h]
simp [h]
simp [h]
intros
simp [det_apply, units.smul_def]
intros
rw [‚Üê(inv_eq_right_inv h), ‚Üê(inv_eq_right_inv g)]
intros
{ ext, simp }
ext
simp
intros
rw [show (@has_mul.mul (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ) _) = linear_map.comp, from rfl, linear_map.to_matrix_alg_equiv_comp v‚ÇÅ f g]
{ rw [show (@has_mul.mul (M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÅ) _) = linear_map.comp, from rfl, linear_map.to_matrix_alg_equiv_comp v‚ÇÅ f g] }
intros
simp [transvection, matrix.mul_add, hb]
intros
rw [associated_apply, map_add_self]
suffices : (‚Öü2) * (2 * Q x) = Q x
convert this
{ convert this, simp only [bit0, add_mul, one_mul], abel }
simp only [bit0, add_mul, one_mul]
abel
simp [‚Üê mul_assoc]
intros
rw [eq_bot_iff, map_le_iff_le_comap, comap_bot, ker_mkq]
rw [eq_bot_iff, map_le_iff_le_comap, comap_bot, ker_mkq]; exact le_refl _
exact le_refl _
intros
rw [smodeq.def, submodule.quotient.eq]
intros
rw [h]
intros
rw [cases_head_iff]; simp [h, eq_comm]
rw [cases_head_iff]
simp [h, eq_comm]
intros
refine lintegral_congr_ae _
filter_upwards [hf.prod_right_ae, hg.prod_right_ae]
intros x h2f h2g
simp [integral_sub h2f h2g]
intros
simp only [condexp_ind_L1, hs, dif_neg, not_false_iff, false_and]
intros
rw ‚Üê lintegral_add' (hf.edist hh) (hg.edist hh)
refine lintegral_mono (Œª a, _)
apply edist_triangle_right
intros
simp_rw [snorm_ess_sup, pi.smul_apply, nnnorm_smul, ennreal.coe_mul, ennreal.ess_sup_const_mul]
intros
rw [mem_Lp_iff_snorm_lt_top, snorm_congr_ae (ae_eq_fun.coe_fn_smul _ _), snorm_const_smul, ennreal.mul_lt_top_iff]
exact or.inl ‚ü®ennreal.coe_lt_top, f.prop‚ü©
intros
convert zero_mem_‚Ñíp
intros
haveI : nonempty s := ‚ü®‚ü®y‚ÇÄ, h‚ÇÄ‚ü©‚ü©
rw [‚Üê @subtype.range_coe _ s, ‚Üê image_univ, ‚Üê (dense_range_dense_seq s).closure_eq] at hx
simp only [approx_on, coe_comp]
refine tendsto_nearest_pt (closure_minimal _ is_closed_closure hx)
simp only [nat.range_cases_on, closure_union, range_comp coe]
exact subset.trans (image_closure_subset_closure_image continuous_subtype_coe) (subset_union_right _ _)
intros
simpa only [‚Üê pi.multiset_prod_apply] using s.measurable_prod' hs
intros
simp [interval_integral, h]
intros
simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)
intros
simp only [‚Üê supr_apply]
exact (monotone_lintegral Œº).le_map_supr
intros
rw [restrict_map hg hs, lintegral_map hf hg]
intros
{ rw ‚Üê singleton_prod_singleton, exact pair_preimage _ _ _ _ }
rw ‚Üê singleton_prod_singleton
exact pair_preimage _ _ _ _
intros
rw [measure.restrict_empty, integral_zero_measure]
intros
rw [Lp.norm_def, Lp.norm_def, ennreal.to_real_le_to_real (Lp.snorm_ne_top _) (Lp.snorm_ne_top _)]
refine (le_of_eq _).trans (snorm_mono_measure _ measure.restrict_le_self)
{ exact s, }
exact s
exact snorm_congr_ae (mem_‚Ñíp.coe_fn_to_Lp _)
intros
simp_rw set_to_L1s
rw ‚Üê simple_func.set_to_simple_func_smul_real T h_add c (simple_func.integrable f)
refine simple_func.set_to_simple_func_congr T h_zero h_add (simple_func.integrable _) _
exact smul_to_simple_func c f
intros
assume s hs
rw [‚Üê bUnion_preimage_singleton]
refine measurable_set.Union (Œª y, measurable_set.Union_Prop $ Œª hy, _)
by_cases hyf : y ‚àà range f
rcases hyf with ‚ü®y, rfl‚ü©
{ rcases hyf with ‚ü®y, rfl‚ü©, apply h }
apply h
simp only [preimage_singleton_eq_empty.2 hyf, measurable_set.empty]
{ simp only [preimage_singleton_eq_empty.2 hyf, measurable_set.empty] }
intros
let eval : (compacts G ‚Üí ‚Ñù) ‚Üí ‚Ñù := Œª f, f K‚ÇÇ - f K‚ÇÅ
have : continuous eval := (continuous_apply K‚ÇÇ).sub (continuous_apply K‚ÇÅ)
rw [‚Üê sub_nonneg]
show chaar K‚ÇÄ ‚àà eval ‚Åª¬π' (Ici (0 : ‚Ñù))
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K‚ÇÄ ‚ü®set.univ, is_open_univ, mem_univ _‚ü©)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©
{ rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©, simp only [mem_preimage, mem_Ici, eval, sub_nonneg], apply prehaar_mono _ h, rw h2U.interior_eq, exact ‚ü®1, h3U‚ü© }
simp only [mem_preimage, mem_Ici, eval, sub_nonneg]
apply prehaar_mono _ h
rw h2U.interior_eq
exact ‚ü®1, h3U‚ü©
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_Ici }
exact is_closed_Ici
intros
rcases eq_or_ne r 0 with rfl|h
simp only [‚Üê closed_ball_diff_ball, diff_empty, closed_ball_zero, ball_zero, measure_singleton]
{ simp only [‚Üê closed_ball_diff_ball, diff_empty, closed_ball_zero, ball_zero, measure_singleton] }
{ exact add_haar_sphere_of_ne_zero Œº x h }
exact add_haar_sphere_of_ne_zero Œº x h
intros
rw [‚Üê finset.sum_attach, finset.attach_eq_univ, ‚Üê tsum_fintype]
exact measure_bUnion s.countable_to_set hd hm
intros
simp_rw [spanning_sets, Union_accumulate, Œº.to_finite_spanning_sets_in.spanning]
intros
split
assume h
{ assume h, exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs) }
exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)
assume h
{ assume h, refine ‚ü®indicator s (h.mk f), h.measurable_mk.indicator hs, _‚ü©, have A : s.indicator f =·µê[Œº.restrict s] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans $ (indicator_ae_eq_restrict hs).symm), have B : s.indicator f =·µê[Œº.restrict s·∂ú] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm, have : s.indicator f =·µê[Œº.restrict s + Œº.restrict s·∂ú] s.indicator (ae_measurable.mk f h) := ae_add_measure_iff.2 ‚ü®A, B‚ü©, simpa only [hs, measure.restrict_add_restrict_compl] using this }
refine ‚ü®indicator s (h.mk f), h.measurable_mk.indicator hs, _‚ü©
have A : s.indicator f =·µê[Œº.restrict s] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans $ (indicator_ae_eq_restrict hs).symm)
have B : s.indicator f =·µê[Œº.restrict s·∂ú] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm
have : s.indicator f =·µê[Œº.restrict s + Œº.restrict s·∂ú] s.indicator (ae_measurable.mk f h) := ae_add_measure_iff.2 ‚ü®A, B‚ü©
simpa only [hs, measure.restrict_add_restrict_compl] using this
intros
rw [restrict_apply measurable_set.univ, set.univ_inter]
intros
rw [h‚ÇÅ, set.inter_assoc, set.union_inter_cancel_left, inter_diff_assoc, union_diff_cancel_left h]
intros
refine le_antisymm (le_of_forall_lt (Œª r hr, _)) (bsupr_le $ Œª K hK, supr_le $ Œª _, Œº.mono hK)
simpa only [lt_supr_iff, exists_prop] using H hU r hr
intros
split
split; intro h
intro h
refine mk (Œª s hmeas hs, h _)
{ refine mk (Œª s hmeas hs, h _), rw [‚Üê hs, ennreal_to_measure_apply hmeas] }
rw [‚Üê hs, ennreal_to_measure_apply hmeas]
intro h
intros s hs
{ intros s hs, by_cases hmeas : measurable_set s, { rw ennreal_to_measure_apply hmeas at hs, exact h hs }, { exact not_measurable v hmeas } }
by_cases hmeas : measurable_set s
rw ennreal_to_measure_apply hmeas at hs
{ rw ennreal_to_measure_apply hmeas at hs, exact h hs }
exact h hs
{ exact not_measurable v hmeas }
exact not_measurable v hmeas
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
ext1 i hi
{ ext1 i hi, have : Œº.to_signed_measure i = ŒΩ.to_signed_measure i, { rw h }, rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at this; { exact measure_ne_top _ _ } }
have : Œº.to_signed_measure i = ŒΩ.to_signed_measure i
{ rw h }
rw h
rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at this
rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at this; { exact measure_ne_top _ _ }
{ exact measure_ne_top _ _ }
{ exact measure_ne_top _ _ }
exact measure_ne_top _ _
{ congr, assumption }
congr
assumption
intros
cases m
rw [mem_divisors, zero_dvd_iff] at h
{ rw [mem_divisors, zero_dvd_iff] at h, rcases h with ‚ü®rfl, h‚ü©, exfalso, apply h rfl }
rcases h with ‚ü®rfl, h‚ü©
exfalso
apply h rfl
apply nat.succ_pos
intros
{ delta fermat_42, rw add_comm, tauto }
delta fermat_42
rw add_comm
tauto
intros
induction n
{ refl, }
refl
{ dsimp, simp only [add_left_inj], exact n_ih, }
dsimp
simp only [add_left_inj]
exact n_ih
intros
by_contra h
rw padic_val_nat_of_not_dvd h at hp
exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)
intros
simp [cast_eq_of_rat]
intros
show _ = ring_hom.id _ z
rw @lift_unique p _ ‚Ñ§_[p] _ _ zmod_cast_comp_to_zmod_pow (ring_hom.id ‚Ñ§_[p])
intro
rw ring_hom.comp_id
intros
by_cases h0 : int.gcd x y = 0
have hx : x = 0
{ have hx : x = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }, have hy : y = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }, have hz : z = 0, { simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }, simp only [hx, hy, hz, int.zero_div], exact zero }
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hy : y = 0
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }
apply nat.eq_zero_of_gcd_eq_zero_right h0
have hz : z = 0
simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h
{ simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }
simp only [hx, hy, hz, int.zero_div]
exact zero
rcases h.gcd_dvd with ‚ü®z0, rfl‚ü©
obtain ‚ü®k, x0, y0, k0, h2, rfl, rfl‚ü© : ‚àÉ (k : ‚Ñï) x0 y0, 0 < k ‚àß int.gcd x0 y0 = 1 ‚àß x = x0 * k ‚àß y = y0 * k := int.exists_gcd_one' (nat.pos_of_ne_zero h0)
have hk : (k : ‚Ñ§) ‚â† 0
norm_cast
{ norm_cast, rwa pos_iff_ne_zero at k0 }
rwa pos_iff_ne_zero at k0
rw [int.gcd_mul_right, h2, int.nat_abs_of_nat, one_mul] at h ‚ä¢
rw [mul_comm x0, mul_comm y0, mul_iff k hk] at h
rwa [int.mul_div_cancel _ hk, int.mul_div_cancel _ hk, int.mul_div_cancel_left _ hk]
intros
simp only [zsqrtd.ext, zsqrtd.conj_re, zsqrtd.conj_im, zsqrtd.one_im, neg_zero, eq_self_iff_true, and_self]
intros
rw [int.is_unit_iff_nat_abs_eq, norm_eq_one_iff]
intros
rw [inf_comm, sdiff_inf_self_right]
intros
{ rw h.upper_bounds_eq, refl }
rw h.upper_bounds_eq
refl
intros
simp only [Inf_eq_infi, compl_infi]
intros
rw [‚Üê Inf_image, ‚Üê Inf_image, ‚Üê image_comp]
intros
cases s.eq_empty_or_nonempty with hs hs
rw hs
{ rw hs, show is_lub ‚àÖ (ite _ _ _), split_ifs, { cases h }, { rw [preimage_empty, cSup_empty], exact is_lub_empty }, { exfalso, apply h_1, use ‚ä•, rintro a ‚ü®‚ü© } }
show is_lub ‚àÖ (ite _ _ _)
split_ifs
{ cases h }
cases h
{ rw [preimage_empty, cSup_empty], exact is_lub_empty }
rw [preimage_empty, cSup_empty]
exact is_lub_empty
{ exfalso, apply h_1, use ‚ä•, rintro a ‚ü®‚ü© }
exfalso
apply h_1
use ‚ä•
rintro a ‚ü®‚ü©
exact is_lub_Sup' hs
intros
nontriviality
rcases nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫ with ‚ü®b, hb‚ü©
rw [‚Üê map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map subtype.coe_injective]
intros
simpa [frequently_at_top] using high_scores hu
intros
simp [‚Üê prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]
intros
simp [filter.prod]
intros
simp [is_bounded, subset_def]
intros
induction n with n ih
{ simp }
simp
dsimp [partial_sups] at ih ‚ä¢
{ dsimp [partial_sups] at ih ‚ä¢, rw [finset.range_succ, finset.sup_insert, sup_comm, ih] }
rw [finset.range_succ, finset.sup_insert, sup_comm, ih]
intros
simp [‚Üêsymm_diff_assoc]
intros
haveI : is_strict_order Œ± (Œª (a b : Œ±), a < b ‚àß a ‚àà s ‚àß b ‚àà s) := { to_is_irrefl := ‚ü®Œª x con, lt_irrefl x con.1‚ü©, to_is_trans := ‚ü®Œª a b c ab bc, ‚ü®lt_trans ab.1 bc.1, ab.2.1, bc.2.2‚ü©‚ü©, }
rw [is_wf, well_founded_on_iff_no_descending_seq]
exact ‚ü®Œª h f, h f.lt_embedding, Œª h f, h (order_embedding.of_strict_mono f (Œª _ _, f.map_rel_iff.2))‚ü©
intros
suffices : multiplicative.of_add m ‚àà submonoid.closure (multiplicative.to_add ‚Åª¬π' S)
{ simpa [‚Üê to_submonoid_closure] }
simpa [‚Üê to_submonoid_closure]
rw [set.image_congr' (show ‚àÄ x, of' R M x = of R M x, from Œª x, of'_eq_of x), ‚Üê monoid_hom.map_mclosure] at h
simpa using of'_mem_span.1 h
intros
ext x
by_cases h : x = a + b
rw [h, mul_single_coeff_add]
{ rw [h, mul_single_coeff_add], simp }
simp
rw [single_coeff_of_ne h, mul_coeff, sum_eq_zero]
{ rw [single_coeff_of_ne h, mul_coeff, sum_eq_zero], rintros ‚ü®y1, y2‚ü© hy, obtain ‚ü®rfl, hy1, hy2‚ü© := mem_add_antidiagonal.1 hy, rw [eq_of_mem_support_single hy1, eq_of_mem_support_single hy2] at h, exact (h rfl).elim }
rintros ‚ü®y1, y2‚ü© hy
obtain ‚ü®rfl, hy1, hy2‚ü© := mem_add_antidiagonal.1 hy
rw [eq_of_mem_support_single hy1, eq_of_mem_support_single hy2] at h
exact (h rfl).elim
intros
rw or_iff_not_imp_right
change _ ‚â† _ ‚Üí _
rw ideal.ne_top_iff_one
intro h1
rw eq_bot_iff
intros r hr
by_cases H : r = 0
simpa
{simpa}
simpa [H, h1] using I.mul_mem_left r‚Åª¬π hr
intros
rw [is_localization.coe_submodule, ideal.span, submodule.map_span]
{ rw [is_localization.coe_submodule, ideal.span, submodule.map_span], refl }
refl
intros
induction k with k hi
{ simp }
simp
rw [pow_succ, content_X_mul, hi]
intros
by_cases hzero : n = 0
simp only [hzero, ring_hom.map_one, splits_zero, pow_zero, sub_self]
{ simp only [hzero, ring_hom.map_one, splits_zero, pow_zero, sub_self] }
rw [splits_iff_card_roots, ‚Üê nth_roots, is_primitive_root.card_nth_roots h, nat_degree_X_pow_sub_C]
intros
simp only [cyclotomic', finset.prod_empty, is_primitive_root.primitive_roots_zero]
intros
haveI := classical.prop_decidable
by_cases hp : p = 0
{ rw [hp, zero_scale_roots] }
rw [hp, zero_scale_roots]
have := scale_roots_ne_zero hp s
refine le_antisymm (finset.sup_mono (support_scale_roots_le p s)) (degree_le_degree _)
rw coeff_scale_roots_nat_degree
intro h
have := leading_coeff_eq_zero.mp h
contradiction
intros
{ classical, split_ifs; simp *, }
classical
split_ifs
split_ifs; simp *
simp *
intros
ext (_ | n)
simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, zero_mul, ring_hom.map_mul]
{ simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, zero_mul, ring_hom.map_mul], }
simp only [coeff_succ_X_mul, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero]
{ simp only [coeff_succ_X_mul, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero], }
intros
ext (_|n)
{ simp }
simp
{ simp [n.succ_ne_zero, pow_succ] }
simp [n.succ_ne_zero, pow_succ]
intros
split
{ intro h, rw [‚Üê pow_one Œ∂, h.pow_eq_one] }
intro h
rw [‚Üê pow_one Œ∂, h.pow_eq_one]
{ rintro rfl, exact one }
rintro rfl
exact one
intros
{ ext, simp [base_change_tmul], }
ext
simp [base_change_tmul]
intros
simp
intros
map_fun_tac
intros
cases x
cases y
simp only at h
simp [function.funext_iff, h]
intros
simp only [witt_structure_rat, eval‚ÇÇ_hom_zero', h, bind‚ÇÅ, map_aeval, constant_coeff_rename, constant_coeff_witt_polynomial, constant_coeff_comp_algebra_map, ring_hom.id_apply, constant_coeff_X_in_terms_of_W]
intros
by_cases h : c = 0
{ by_cases h : c = 0, rw [h, power_zero], rw [zero_power h], apply zero_le }
rw [h, power_zero]
rw [zero_power h]
apply zero_le
intros
rw [quot_mul_comm, quot_mul_one x]
intros
simpa only [add_zero] using add_le_add_left (ordinal.zero_le b) a
intros
rw le_def
dsimp
simp [forall_pempty, exists_pempty]
intros
simp [funs, is_func]
intros
simp [left_distrib, *, sub_eq_add_neg]
intros
simp *
intros
rw [‚Üê h, ‚Üê hm, nat.add_mul_mod_self_right, nat.mod_eq_of_lt h‚ÇÇ]
intros
cases t1
cases t2
simp only [add_assoc, coeffs.val_sub, neg_add_rev, val, sub, add_comm, add_left_comm, sub_eq_add_neg]
intros
simp only [is_open_iff_of_mem' h, is_closed_compl_iff, and.comm]
intros
have H : ‚àÄ n, m (‚®Ü b ‚àà decode‚ÇÇ Œ≥ n, s b) ‚â† 0 ‚Üí (decode‚ÇÇ Œ≥ n).is_some
intros n h
{ intros n h, cases decode‚ÇÇ Œ≥ n with b, { refine (h $ by simp [m0]).elim }, { exact rfl } }
cases decode‚ÇÇ Œ≥ n with b
{ refine (h $ by simp [m0]).elim }
refine (h $ by simp [m0]).elim
{ exact rfl }
exact rfl
symmetry
refine tsum_eq_tsum_of_ne_zero_bij (Œª a, option.get (H a.1 a.2)) _ _ _
rintros ‚ü®m, hm‚ü© ‚ü®n, hn‚ü© e
{ rintros ‚ü®m, hm‚ü© ‚ü®n, hn‚ü© e, have := mem_decode‚ÇÇ.1 (option.get_mem (H n hn)), rwa [‚Üê e, mem_decode‚ÇÇ.1 (option.get_mem (H m hm))] at this }
have := mem_decode‚ÇÇ.1 (option.get_mem (H n hn))
rwa [‚Üê e, mem_decode‚ÇÇ.1 (option.get_mem (H m hm))] at this
intros b h
{ intros b h, refine ‚ü®‚ü®encode b, _‚ü©, _‚ü©, { simp only [mem_support, encodek‚ÇÇ] at h ‚ä¢, convert h, simp [set.ext_iff, encodek‚ÇÇ] }, { exact option.get_of_mem _ (encodek‚ÇÇ _) } }
refine ‚ü®‚ü®encode b, _‚ü©, _‚ü©
simp only [mem_support, encodek‚ÇÇ] at h ‚ä¢
{ simp only [mem_support, encodek‚ÇÇ] at h ‚ä¢, convert h, simp [set.ext_iff, encodek‚ÇÇ] }
convert h
simp [set.ext_iff, encodek‚ÇÇ]
{ exact option.get_of_mem _ (encodek‚ÇÇ _) }
exact option.get_of_mem _ (encodek‚ÇÇ _)
rintros ‚ü®n, h‚ü©
{ rintros ‚ü®n, h‚ü©, dsimp only [subtype.coe_mk], transitivity, swap, rw [show decode‚ÇÇ Œ≥ n = _, from option.get_mem (H n h)], congr, simp [ext_iff, -option.some_get] }
dsimp only [subtype.coe_mk]
transitivity
swap
rw [show decode‚ÇÇ Œ≥ n = _, from option.get_mem (H n h)]
congr
simp [ext_iff, -option.some_get]
intros
induction n with n ih
{ simp [continuous_const] }
simp [continuous_const]
simp [nat.succ_eq_add_one, add_smul]
{ simp [nat.succ_eq_add_one, add_smul], exact ih.add continuous_id }
exact ih.add continuous_id
intros
convert continuous_fst.comp continuous_induced_dom
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
have hn : n = 0
{ have hn : n = 0, { by_contradiction hn, have hn : 1 ‚â§ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn)), by_cases hc' : 0 < c, { have := (tendsto_const_mul_pow_at_top_iff c n).2 ‚ü®hn, hc'‚ü©, exact not_tendsto_nhds_of_tendsto_at_top this d h }, { have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ‚ü®hn, lt_of_le_of_ne (not_lt.1 hc') hc‚ü©, exact not_tendsto_nhds_of_tendsto_at_bot this d h } }, have : (Œª x : Œ±, c * x ^ n) = (Œª x : Œ±, c), by simp [hn], rw [this, tendsto_const_nhds_iff] at h, exact ‚ü®hn, h‚ü© }
by_contradiction hn
{ by_contradiction hn, have hn : 1 ‚â§ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn)), by_cases hc' : 0 < c, { have := (tendsto_const_mul_pow_at_top_iff c n).2 ‚ü®hn, hc'‚ü©, exact not_tendsto_nhds_of_tendsto_at_top this d h }, { have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ‚ü®hn, lt_of_le_of_ne (not_lt.1 hc') hc‚ü©, exact not_tendsto_nhds_of_tendsto_at_bot this d h } }
have hn : 1 ‚â§ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn))
by_cases hc' : 0 < c
have := (tendsto_const_mul_pow_at_top_iff c n).2 ‚ü®hn, hc'‚ü©
{ have := (tendsto_const_mul_pow_at_top_iff c n).2 ‚ü®hn, hc'‚ü©, exact not_tendsto_nhds_of_tendsto_at_top this d h }
exact not_tendsto_nhds_of_tendsto_at_top this d h
have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ‚ü®hn, lt_of_le_of_ne (not_lt.1 hc') hc‚ü©
{ have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ‚ü®hn, lt_of_le_of_ne (not_lt.1 hc') hc‚ü©, exact not_tendsto_nhds_of_tendsto_at_bot this d h }
exact not_tendsto_nhds_of_tendsto_at_bot this d h
have : (Œª x : Œ±, c * x ^ n) = (Œª x : Œ±, c)
simp [hn]
simp [hn]
rw [this, tendsto_const_nhds_iff] at h
exact ‚ü®hn, h‚ü©
obtain ‚ü®hn, hcd‚ü© := h
{ obtain ‚ü®hn, hcd‚ü© := h, simpa [hn, hcd] using tendsto_const_nhds }
simpa [hn, hcd] using tendsto_const_nhds
intros
rw [‚Üê map_coe_Ioo_at_top h, tendsto_map'_iff]
intros
simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf ‚ä¢
intros x hx
filter_upwards [hf x hx, hg]
exact Œª x, lt_of_lt_of_le
intros
rw [inter_comm, ‚Üê subset_compl_iff_disjoint]
exact subset.trans frontier_subset_closure (closure_minimal (Œª _, disjoint_left.1 hd) (is_closed_compl_iff.2 ht))
intros
let F' : J ‚•§ Top := F ‚ãô Top.discrete
haveI : Œ† (j : J), fintype (F'.obj j) := hf
haveI : Œ† (j : J), nonempty (F'.obj j) := hne
obtain ‚ü®‚ü®u, hu‚ü©‚ü© := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system F'
exact ‚ü®u, Œª _ _ f, hu f‚ü©
intros
split
intros h u v hu hv hss huv
{ intros h u v hu hv hss huv, apply is_preconnected_iff_subset_of_disjoint_closed.1 h u v hu hv hss, rw huv, exact inter_empty s }
apply is_preconnected_iff_subset_of_disjoint_closed.1 h u v hu hv hss
rw huv
exact inter_empty s
intro H
rw is_preconnected_iff_subset_of_disjoint_closed
intros u v hu hv hss huv
have H1 := H (u ‚à© s) (v ‚à© s)
rw [subset_inter_iff, subset_inter_iff] at H1
simp only [subset.refl, and_true] at H1
apply H1 (is_closed.inter hu hs) (is_closed.inter hv hs)
rw ‚Üêinter_distrib_right
{ rw ‚Üêinter_distrib_right, apply subset_inter_iff.2, exact ‚ü®hss, subset.refl s‚ü© }
apply subset_inter_iff.2
exact ‚ü®hss, subset.refl s‚ü©
rw [inter_comm v s, inter_assoc, ‚Üêinter_assoc s, inter_self s, inter_comm, inter_assoc, inter_comm v u, huv]
{ rw [inter_comm v s, inter_assoc, ‚Üêinter_assoc s, inter_self s, inter_comm, inter_assoc, inter_comm v u, huv] }
intros
set fxg := (Œª p : Œ± √ó Œ≥, (f p.1, g p.2))
have key1 : f ‚àò (prod.fst : Œ± √ó Œ≥ ‚Üí Œ±) = (prod.fst : Œ≤ √ó Œ¥ ‚Üí Œ≤) ‚àò fxg
from rfl
have key2 : g ‚àò (prod.snd : Œ± √ó Œ≥ ‚Üí Œ≥) = (prod.snd : Œ≤ √ó Œ¥ ‚Üí Œ¥) ‚àò fxg
from rfl
unfold prod.topological_space
conv_lhs { rw [induced_compose, induced_compose, key1, key2], congr, rw ‚Üê induced_compose, skip, rw ‚Üê induced_compose, }
rw induced_inf
intros
rw [pi_def]; exact (is_open_bInter hi $ assume a ha, (hs _ ha).preimage (continuous_apply _))
rw [pi_def]
exact (is_open_bInter hi $ assume a ha, (hs _ ha).preimage (continuous_apply _))
intros
have w := mem_closure_iff_frequently.mp (continuous_map_mem_polynomial_functions_closure _ _ f)
rw metric.nhds_basis_ball.frequently_iff at w
obtain ‚ü®-, H, ‚ü®m, ‚ü®-, rfl‚ü©‚ü©‚ü© := w Œµ pos
rw [metric.mem_ball, dist_eq_norm] at H
exact ‚ü®m, H‚ü©
intros
simp [ne_bot_iff, nhds_within_pi_eq_bot]
intros
rw continuous_iff_continuous_on_univ at h
exact h.mono (subset_univ _)
intros
tauto
intros
rw [‚Üê e.coe_fst ex, prod.mk.eta, ‚Üê e.coe_coe, e.to_local_equiv.left_inv ex]
intros
lift d to (‚Ñï ‚Üí nnreal) using (Œª i, ennreal.ne_top_of_tsum_ne_top hd i)
rw ennreal.tsum_coe_ne_top_iff_summable at hd
exact cauchy_seq_of_edist_le_of_summable d hf hd
intros
apply tendsto.mul hma _ (ennreal.tendsto_inv_iff.2 hmb) _; simp [ha, hb]
apply tendsto.mul hma _ (ennreal.tendsto_inv_iff.2 hmb) _
{ apply tendsto.mul hma _ (ennreal.tendsto_inv_iff.2 hmb) _; simp [ha, hb] }
simp [ha, hb]
simp [ha, hb]
intros
rw nnreal.summable_coe
exact tsum_coe_ne_top_iff_summable
intros
ext
{ ext, refl }
refl
intros
rw [tendsto, tendsto, hg.induced, nhds_induced, ‚Üê map_le_iff_le_comap, filter.map_map]
intros
rw [inter_eq_Inter]
apply dense_Inter_of_GŒ¥; simp [bool.forall_bool, *]
apply dense_Inter_of_GŒ¥
simp [bool.forall_bool, *]
simp [bool.forall_bool, *]
intros
simpa only [dist_edist] using congr_arg ennreal.to_real (edist_pi_const a b)
intros
rw [edist_dist, ennreal.to_real_of_real (dist_nonneg)]
intros
simp [continuous_on, continuous_within_at_iff]
intros
have : separated_space (completion Œ±) := by apply_instance
refine separated_def.1 this x y (Œªs hs, _)
rcases (completion.mem_uniformity_dist s).1 hs with ‚ü®Œµ, Œµpos, hŒµ‚ü©
rw ‚Üê h at Œµpos
exact hŒµ Œµpos
intros
rw [union_eq_Union, dimH_Union, supr_bool_eq, cond, cond, ennreal.sup_eq_max]
intros
simp only [Hausdorff_edist_def, supr_image, inf_edist_image h]
intros
have r0 : 0 < r := lt_of_le_of_lt (Hausdorff_dist_nonneg) H
have : Hausdorff_edist s t < ennreal.of_real r
rwa [Hausdorff_dist, ‚Üê ennreal.to_real_of_real (le_of_lt r0), ennreal.to_real_lt_to_real fin (ennreal.of_real_ne_top)] at H
rwa [Hausdorff_dist, ‚Üê ennreal.to_real_of_real (le_of_lt r0), ennreal.to_real_lt_to_real fin (ennreal.of_real_ne_top)] at H
rcases exists_edist_lt_of_Hausdorff_edist_lt h this with ‚ü®y, hy, yr‚ü©
rw [edist_dist, ennreal.of_real_lt_of_real_iff r0] at yr
exact ‚ü®y, hy, yr‚ü©
intros
rw continuous_def
intros s hs
change continuous' (s ‚àò f)
cases hs with hs hs'
cases hf with hf hf'
apply continuous.of_bundled
apply continuous_comp _ _ hf' hs'
intros
{ ext s, rw [mem_nhds_induced, mem_comap] }
ext s
rw [mem_nhds_induced, mem_comap]
intros
simp
intros
split
intro h
{ intro h, constructor, rintros x - y -, contrapose!, intros hyp, suffices : x ‚àà connected_component y, by simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff], rw [connected_component_eq_Inter_clopen, mem_Inter], rintro ‚ü®w : set Œ±, hw : is_clopen w, hy : y ‚àà w‚ü©, by_contra hx, simpa using hyp w·∂ú w (is_open_compl_iff.mpr hw.2) hw.1 hx hy }
constructor
rintros x - y -
contrapose!
intros hyp
suffices : x ‚àà connected_component y
simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff]
simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff]
rw [connected_component_eq_Inter_clopen, mem_Inter]
rintro ‚ü®w : set Œ±, hw : is_clopen w, hy : y ‚àà w‚ü©
by_contra hx
simpa using hyp w·∂ú w (is_open_compl_iff.mpr hw.2) hw.1 hx hy
apply totally_separated_space.totally_disconnected_space
intros
simpa only [hne] using hf.finite_nonempty_of_compact
intros
rw [continuous_within_at, tendsto_nhds_left]
intros
rw uniform_space.mem_nhds_iff
exact ‚ü®V, V_in, subset.refl _‚ü©
intros
rw [complete_space_iff_is_complete_range he.to_uniform_inducing, e.range_eq_univ, complete_space_iff_is_complete_univ]
intros
induction n with n ihn generalizing c
simp only [approx, right_U, right_le_midpoint]
{ simp only [approx, right_U, right_le_midpoint], exact (approx_mem_Icc_right_left c 0 x).2 }
exact (approx_mem_Icc_right_left c 0 x).2
rw [approx, approx]
{ rw [approx, approx], exact midpoint_le_midpoint (ihn _) (ihn _) }
exact midpoint_le_midpoint (ihn _) (ihn _)
intros
unfold tails; rw [corec_eq]; refl
unfold tails; rw [corec_eq]
unfold tails
rw [corec_eq]
refl
intros
simp [read', h]
intros
cases b; simp
cases b
simp
simp
intros
unfold sub_nat_nat
rw h
unfold sub_nat_nat._match_1
intros
by_cases h : x % 2 = 1
{ simp! [*] }
simp! [*]
cases mod_two_eq_zero_or_one x; simp! [*, nat.zero_ne_one]
cases mod_two_eq_zero_or_one x
{ cases mod_two_eq_zero_or_one x; simp! [*, nat.zero_ne_one] }
simp! [*, nat.zero_ne_one]
simp! [*, nat.zero_ne_one]
intros
rw [nat.mul_comm, nat.mul_div_cancel' H]
intros
rw [nat.sub_sub, nat.sub_sub, add_succ, succ_sub_succ]
intros
rwa [‚Üêsub_eq_zero, vsub_sub_vsub_cancel_right, vsub_eq_zero_iff_eq] at h
intros
simp only [one_eq_range, linear_map.mem_range, algebra.linear_map_apply]
intros
ext
ext; simp
simp
intros
rw forall_associated
split
split; intros h a; have ha := h a; rw irreducible_mk at *; rw prime_mk at *; exact ha
split; intros h a; have ha := h a; rw irreducible_mk at *; rw prime_mk at *
split; intros h a; have ha := h a; rw irreducible_mk at *
split; intros h a; have ha := h a
split; intros h a
intros h a
have ha := h a
rw irreducible_mk at *
rw prime_mk at *
exact ha
intros h a
have ha := h a
rw irreducible_mk at *
rw prime_mk at *
exact ha
intros
simpa only [sub_eq_add_neg] using sum_add_distrib.trans (congr_arg _ sum_neg_distrib)
intros
{ convert prod_multiset_map_count s id, rw map_id }
convert prod_multiset_map_count s id
rw map_id
intros
{ classical, rw [finprod_def, dif_neg hf] }
classical
rw [finprod_def, dif_neg hf]
intros
{ rw ‚Üêcocone_naturality F f, refl }
rw ‚Üêcocone_naturality F f
refl
intros
apply (cancel_epi (Œ±_ X Y Z).hom).1
apply tensor_product.ext_threefold
intros x y z
refl
intros
rw [eq_comm, ‚Üêsub_eq_zero, ‚Üêint.cast_sub, char_p.int_cast_eq_zero_iff R p, int.modeq_iff_dvd]
intros
rw [nth_cont_eq_succ_nth_cont_aux] at nth_conts_eq succ_nth_conts_eq
exact (continuants_recurrence_aux succ_nth_s_eq nth_conts_eq succ_nth_conts_eq)
intros
cases s_nth_eq : (g.s.nth n); simp [partial_numerators, s_nth_eq]
cases s_nth_eq : (g.s.nth n)
simp [partial_numerators, s_nth_eq]
simp [partial_numerators, s_nth_eq]
intros
rw gcd
{ rw gcd, split_ifs; [simp only [h, mod_zero, gcd_zero_right], refl]}
split_ifs
split_ifs; [simp only [h, mod_zero, gcd_zero_right], refl]
simp only [h, mod_zero, gcd_zero_right]
refl
intros
rw [‚Üê lift_symm_apply, equiv.apply_symm_apply]
intros
simp [mul_assoc]
intros
rw [sub_eq_add_neg, neg_neg]
intros
simp [is_unit_iff_exists_inv, mul_comm]
intros
induction n with n ih
{ rw [pow_zero, pow_zero, one_inv] }
rw [pow_zero, pow_zero, one_inv]
{ rw [pow_succ', pow_succ, ih, mul_inv_rev] }
rw [pow_succ', pow_succ, ih, mul_inv_rev]
intros
{ rw [‚Üê int.nat_abs_sq a, sq], norm_cast, apply nat.le_mul_self }
rw [‚Üê int.nat_abs_sq a, sq]
norm_cast
apply nat.le_mul_self
intros
{ rw pow_bit0, exact mul_self_nonneg _ }
rw pow_bit0
exact mul_self_nonneg _
intros
by_cases ha : a = 0; [simp [ha], simp [mul_right_inj', ha]]
by_cases ha : a = 0
simp [ha]
simp [mul_right_inj', ha]
intros
rw [one_div_mul_one_div_rev, mul_comm b]
intros
tidy
intros
refine ‚ü®_, by { introI, apply_instance }‚ü©
introI
have : exact ((f ‚â´ i.hom) ‚â´ i.inv) (i.hom ‚â´ i.inv ‚â´ g) := infer_instance
simpa using this
intros
have P : ‚àÄ h : i = i', eq_to_hom (congr_arg C.X h) ‚â´ C.d i' j = C.d i j
{ rintro rfl, simp }
rintro rfl
simp
apply P
intros
dsimp [prev_d]
simp only [chain_complex.prev]
refl
intros
{ ext, simp, }
ext
simp
intros
rw [sup_eq_mul_pos_div, inf_comm, inf_eq_div_pos_div, div_eq_mul_inv]
nth_rewrite 1 div_eq_mul_inv
rw [mul_inv_rev, inv_inv, mul_comm, ‚Üê mul_assoc, inv_mul_cancel_right, pos_eq_neg_inv (a / b)]
nth_rewrite 1 div_eq_mul_inv
rw [mul_inv_rev, ‚Üê div_eq_mul_inv, inv_inv, ‚Üê pos_mul_neg]
intros
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ‚ü®x, n, hn‚ü©
rw ‚Üê hn
exact N.lie_mem n.property
intros
split
split; intros h
intros h
{ exact le_Sup h, }
exact le_Sup h
intros h
{ apply le_solvable_ideal_solvable h, apply_instance, }
apply le_solvable_ideal_solvable h
apply_instance
intros
{ rw ‚Üê le_bot_iff, exact lie_ideal.map_le_iff_le_comap }
rw ‚Üê le_bot_iff
exact lie_ideal.map_le_iff_le_comap
intros
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule]
exact infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M
intros
rw [units.smul_def, units.coe_neg, neg_smul, units.smul_def]
intros
rw [of', ‚Üê finsupp.supported_eq_span_single, finsupp.mem_supported]
intros
{ ext a, exact mul_hom.congr_fun h a, }
ext a
exact mul_hom.congr_fun h a
intros
by_cases xy : x ‚â§ y; by_cases yx : y ‚â§ x; simp [cmp_le, *, ordering.swap]
by_cases xy : x ‚â§ y; by_cases yx : y ‚â§ x
by_cases xy : x ‚â§ y
by_cases yx : y ‚â§ x
simp [cmp_le, *, ordering.swap]
simp [cmp_le, *, ordering.swap]
by_cases yx : y ‚â§ x
simp [cmp_le, *, ordering.swap]
simp [cmp_le, *, ordering.swap]
cases not_or xy yx (total_of _ _ _)
intros
rw [mul_comm, div_lt_iff_of_neg hc]
intros
simpa using le_inv ha hb
intros
simp only [‚Üê not_lt, inv_pos]
intros
simpa only [div_eq_mul_inv] using mul_lt_mul_iff_right _
intros
rw [mul_comm b, mul_comm c, ha.mul_le_mul_iff_left]
intros
haveI := @linear_order.decidable_le Œ± _; exact ((@decidable.strict_mono_on_mul_self Œ± _ _).lt_iff_lt h1 h2).symm
haveI := @linear_order.decidable_le Œ± _
exact ((@decidable.strict_mono_on_mul_self Œ± _ _).lt_iff_lt h1 h2).symm
intros
{ rw [add_comm], apply lt_add_one }
rw [add_comm]
apply lt_add_one
intros
rw [bit1, le_add_iff_nonneg_left, bit0, ‚Üê two_mul, zero_le_mul_left (zero_lt_two : 0 < (2:Œ±))]
intros
rw [‚Üê image_mul_right', image_one, one_mul]
intros
simp only [‚Üê image_smul, image_eta, zero_smul, h.image_const, singleton_zero]
intros
{ rw a.commute_self_conj.eq, exact a.conj_mul_eq_coe }
rw a.commute_self_conj.eq
exact a.conj_mul_eq_coe
intros
rintro rfl
rcases exists_pair_ne R with ‚ü®x, y, xy‚ü©
refine xy (la _)
rw [zero_mul, zero_mul]
intros
simpa only [sub_eq_add_neg] using ha.add_left hb.neg_left
intros
simp
intros
rw [sub_eq_add_neg, add_right_inj, neg_eq]
intros
{ cases x, exact stalk_to_fiber_ring_hom_germ' R U _ _ _ }
cases x
exact stalk_to_fiber_ring_hom_germ' R U _ _ _
intros
dsimp [Œ¥]
{ dsimp [Œ¥], simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_Œ¥_self] }
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_Œ¥_self]
intros
simp only [gronwall_bound_Œµ0, zero_mul]
intros
have A : continuous_on (Œª (y : E), y - x) (emetric.ball (x : E) r) := (continuous_id.sub continuous_const).continuous_on
convert (hf.tendsto_locally_uniformly_on).comp (Œª (y : E), y - x) _ A
{ ext z, simp }
ext z
simp
assume z
{ assume z, simp [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] }
simp [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub]
intros
ext v
simp only [formal_multilinear_series.comp, comp_along_composition, continuous_multilinear_map.comp_along_composition_apply, continuous_multilinear_map.sum_apply]
apply finset.sum_congr rfl (Œª c hc, _)
rw remove_zero_of_pos _ (c.length_pos_of_pos hn)
intros
refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm
refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
apply has_deriv_within_at.deriv_within _ hxs
exact has_deriv_within_at.scomp x (hg.has_deriv_within_at) (hh.has_deriv_within_at) hs
intros
convert hc.mul ((has_deriv_at_inv hx).comp_has_deriv_within_at x hd)
{ simp only [div_eq_mul_inv] }
simp only [div_eq_mul_inv]
{ field_simp, ring }
field_simp
ring
intros
simp only [has_deriv_within_at, nhds_within, diff_eq, inf_assoc.symm, inf_principal.symm]
exact has_deriv_at_filter_iff_tendsto_slope
intros
simp only [deriv_within, fderiv_within_sub_const hxs]
intros
simp [sub_eq_add_neg]
intros
apply hf.lim v
rw tendsto_at_top_at_top
exact Œª b, ‚ü®b, Œª a ha, le_trans ha (le_abs_self _)‚ü©
intros
refine lhopital_zero_right_on_Ioo hab hdf hg' _ _ hdiv
rw [‚Üê hfa, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab]
{ rw [‚Üê hfa, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab], exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto }
exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
rw [‚Üê hga, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab]
{ rw [‚Üê hga, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab], exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto }
exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
intros
simp [times_cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm, - fderiv_within_univ]
rw times_cont_diff_on_top_iff_fderiv_within unique_diff_on_univ
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
split
rintro ‚ü®a, b, ha, hb, hab, hx‚ü©
{ rintro ‚ü®a, b, ha, hb, hab, hx‚ü©, refine smul_right_injective _ hb.ne' ((add_right_inj (a ‚Ä¢ x)).1 _), rw [hx, ‚Üêadd_smul, hab, one_smul] }
refine smul_right_injective _ hb.ne' ((add_right_inj (a ‚Ä¢ x)).1 _)
rw [hx, ‚Üêadd_smul, hab, one_smul]
rintro rfl
{ rintro rfl, rw open_segment_same, exact mem_singleton _ }
rw open_segment_same
exact mem_singleton _
intros
have h := (hs.smul c).translate z
rwa [‚Üêimage_smul, image_image] at h
intros
refine subset.antisymm (convex_hull_min _ _) _
intros x hx
{ intros x hx, use [punit, {punit.star}, Œª _, 1, Œª _, x, Œª _ _, zero_le_one, finset.sum_singleton, Œª _ _, hx], simp only [finset.center_mass, finset.sum_singleton, inv_one, one_smul] }
use [punit, {punit.star}, Œª _, 1, Œª _, x, Œª _ _, zero_le_one, finset.sum_singleton, Œª _ _, hx]
simp only [finset.center_mass, finset.sum_singleton, inv_one, one_smul]
rintros x y ‚ü®Œπ, sx, wx, zx, hwx‚ÇÄ, hwx‚ÇÅ, hzx, rfl‚ü© ‚ü®Œπ', sy, wy, zy, hwy‚ÇÄ, hwy‚ÇÅ, hzy, rfl‚ü© a b ha hb hab
{ rintros x y ‚ü®Œπ, sx, wx, zx, hwx‚ÇÄ, hwx‚ÇÅ, hzx, rfl‚ü© ‚ü®Œπ', sy, wy, zy, hwy‚ÇÄ, hwy‚ÇÅ, hzy, rfl‚ü© a b ha hb hab, rw [finset.center_mass_segment' _ _ _ _ _ _ hwx‚ÇÅ hwy‚ÇÅ _ _ hab], refine ‚ü®_, _, _, _, _, _, _, rfl‚ü©, { rintros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; simp only [sum.elim_inl, sum.elim_inr]; apply_rules [mul_nonneg, hwx‚ÇÄ, hwy‚ÇÄ] }, { simp [finset.sum_sum_elim, finset.mul_sum.symm, *] }, { intros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; apply_rules [hzx, hzy] } }
rw [finset.center_mass_segment' _ _ _ _ _ _ hwx‚ÇÅ hwy‚ÇÅ _ _ hab]
refine ‚ü®_, _, _, _, _, _, _, rfl‚ü©
rintros i hi
{ rintros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; simp only [sum.elim_inl, sum.elim_inr]; apply_rules [mul_nonneg, hwx‚ÇÄ, hwy‚ÇÄ] }
rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi
rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; simp only [sum.elim_inl, sum.elim_inr]; apply_rules [mul_nonneg, hwx‚ÇÄ, hwy‚ÇÄ]
rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; simp only [sum.elim_inl, sum.elim_inr]
rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©
simp only [sum.elim_inl, sum.elim_inr]
apply_rules [mul_nonneg, hwx‚ÇÄ, hwy‚ÇÄ]
simp only [sum.elim_inl, sum.elim_inr]
apply_rules [mul_nonneg, hwx‚ÇÄ, hwy‚ÇÄ]
{ simp [finset.sum_sum_elim, finset.mul_sum.symm, *] }
simp [finset.sum_sum_elim, finset.mul_sum.symm, *]
intros i hi
{ intros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; apply_rules [hzx, hzy] }
rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi
rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©; apply_rules [hzx, hzy]
rcases hi with ‚ü®j, hj, rfl‚ü©|‚ü®j, hj, rfl‚ü©
apply_rules [hzx, hzy]
apply_rules [hzx, hzy]
rintros _ ‚ü®Œπ, t, w, z, hw‚ÇÄ, hw‚ÇÅ, hz, rfl‚ü©
{ rintros _ ‚ü®Œπ, t, w, z, hw‚ÇÄ, hw‚ÇÅ, hz, rfl‚ü©, exact t.center_mass_mem_convex_hull hw‚ÇÄ (hw‚ÇÅ.symm ‚ñ∏ zero_lt_one) hz }
exact t.center_mass_mem_convex_hull hw‚ÇÄ (hw‚ÇÅ.symm ‚ñ∏ zero_lt_one) hz
intros
rcases riesz_extension.exists_top s f nonneg dense with ‚ü®‚ü®g_dom, g‚ü©, ‚ü®hpg, hfg‚ü©, htop, hgs‚ü©
clear hpg
refine ‚ü®g ‚àò‚Çó ‚Üë(linear_equiv.of_top _ htop).symm, _, _‚ü©
refine ‚ü®g ‚àò‚Çó ‚Üë(linear_equiv.of_top _ htop).symm, _, _‚ü©; simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]
simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]
{ exact Œª x, (hfg (submodule.coe_mk _ _).symm).symm }
exact Œª x, (hfg (submodule.coe_mk _ _).symm).symm
simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]
{ exact Œª x hx, hgs ‚ü®x, _‚ü© hx }
exact Œª x hx, hgs ‚ü®x, _‚ü© hx
intros
rw [‚Üêneg_le_neg_iff, ‚Üêneg_sub_neg (f x), ‚Üêneg_sub_neg (f y)]
simp_rw [‚Üêpi.neg_apply, ‚Üêneg_div, neg_sub]
exact convex_on.slope_mono_adjacent hf.neg hx hz hxy hyz
intros
rw [inner_eq_zero_sym]; exact submodule.inner_right_of_mem_orthogonal hu hv
rw [inner_eq_zero_sym]
exact submodule.inner_right_of_mem_orthogonal hu hv
intros
rw [‚Üêinner_conj_sym, conj_re]
intros
have h‚ÇÅ : ‚ü™y, x‚ü´_‚Ñù = ‚ü™x, y‚ü´_‚Ñù := by rw [‚Üêinner_conj_sym]; refl
have h‚ÇÇ := @inner_mul_inner_self_le ‚Ñù F _ _ x y
dsimp at h‚ÇÇ
have h‚ÇÉ := abs_mul_abs_self ‚ü™x, y‚ü´_‚Ñù
rw [h‚ÇÅ] at h‚ÇÇ
simpa [h‚ÇÉ] using h‚ÇÇ
intros
{ rw [norm_sub_mul_self], ring }
rw [norm_sub_mul_self]
ring
intros
rw [‚Üê complex.isometry_euclidean_symm_apply (complex.isometry_euclidean z), complex.isometry_euclidean.symm_apply_apply z]
intros
have := nnreal.coe_le_coe.2 (nnreal.Lp_add_le s (Œª i, ‚ü®_, abs_nonneg (f i)‚ü©) (Œª i, ‚ü®_, abs_nonneg (g i)‚ü©) hp)
push_cast at this
refine le_trans (rpow_le_rpow _ (sum_le_sum $ Œª i hi, _) _) this
refine le_trans (rpow_le_rpow _ (sum_le_sum $ Œª i hi, _) _) this; simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
intros
rw [dist_comm, dist_center_homothety]
intros
choose C hC fsymm h using exists_preimage_norm_le _ (linear_map.range_eq_top.mp hsurj)
use { to_fun := fsymm, nnnorm := ‚ü®C, hC.lt.le‚ü©, bound' := Œª y, (h y).2, right_inv' := Œª y, (h y).1 }
exact hC
intros
rcases exists_one_lt_norm Œ± with ‚ü®y, hy‚ü©
refine ‚ü®y‚Åª¬π, _, _‚ü©
simp only [inv_eq_zero, ne.def, norm_pos_iff]
{ simp only [inv_eq_zero, ne.def, norm_pos_iff], rintro rfl, rw norm_zero at hy, exact lt_asymm zero_lt_one hy }
rintro rfl
rw norm_zero at hy
exact lt_asymm zero_lt_one hy
{ simp [inv_lt_one hy] }
simp [inv_lt_one hy]
intros
simp only [dist_eq_norm, (norm_smul _ _).symm, smul_sub]
intros
replace h := mem_cofinite.1 h
refine h.summable_compl_iff.mp _
refine summable_of_norm_bounded _ (h.summable_compl_iff.mpr hg) _
rintros ‚ü®a, h'‚ü©
simpa using h'
intros
simp only [norm_def, coe_restrict_scalars]
intros
refine le_antisymm (op_norm_le_bound _ (le_refl _) (Œª x, _)) (norm_nonneg _)
have hker : x ‚àà (S.normed_mk).ker.topological_closure
rw [S.ker_normed_mk]
{ rw [S.ker_normed_mk], exact set.mem_of_eq_of_mem h trivial }
exact set.mem_of_eq_of_mem h trivial
rw [ker_normed_mk] at hker
simp only [(quotient_norm_eq_zero_iff S x).mpr hker, normed_mk.apply, zero_mul]
rw ‚Üê not_summable_iff_tendsto_nat_at_top_of_nonneg
exact_mod_cast mt (summable_nat_add_iff 1).1 real.not_summable_one_div_nat_cast
{ exact_mod_cast mt (summable_nat_add_iff 1).1 real.not_summable_one_div_nat_cast }
exact Œª i, div_nonneg zero_le_one i.cast_add_one_pos.le
{ exact Œª i, div_nonneg zero_le_one i.cast_add_one_pos.le }
intros
have H := real.cosh_sq_sub_sinh_sq x
have G : cosh x ^ 2 - sinh x ^ 2 + sinh x ^ 2 = 1 + sinh x ^ 2 := by rw H
rw sub_add_cancel at G
rw [‚ÜêG, sqrt_sq]
exact le_of_lt (cosh_pos x)
intros
refine ‚ü®Œª hs, _, Œª hs, _‚ü©
refine ((hs.image exp).insert 0).mono _
{ refine ((hs.image exp).insert 0).mono _, rw [image_preimage_eq_inter_range, range_exp, ‚Üê diff_eq, ‚Üê union_singleton, diff_union_self], exact subset_union_left _ _ }
rw [image_preimage_eq_inter_range, range_exp, ‚Üê diff_eq, ‚Üê union_singleton, diff_union_self]
exact subset_union_left _ _
rw ‚Üê bUnion_preimage_singleton
{ rw ‚Üê bUnion_preimage_singleton, refine hs.bUnion (Œª z hz, _), rcases em (‚àÉ w, exp w = z) with ‚ü®w, rfl‚ü©|hne, { simp only [preimage, mem_singleton_iff, exp_eq_exp_iff_exists_int, set_of_exists], exact countable_Union (Œª m, countable_singleton _) }, { push_neg at hne, simp [preimage, hne] } }
refine hs.bUnion (Œª z hz, _)
rcases em (‚àÉ w, exp w = z) with ‚ü®w, rfl‚ü©|hne
simp only [preimage, mem_singleton_iff, exp_eq_exp_iff_exists_int, set_of_exists]
{ simp only [preimage, mem_singleton_iff, exp_eq_exp_iff_exists_int, set_of_exists], exact countable_Union (Œª m, countable_singleton _) }
exact countable_Union (Œª m, countable_singleton _)
{ push_neg at hne, simp [preimage, hne] }
push_neg at hne
simp [preimage, hne]
rw [‚Üê coe_comp_exp_order_iso, ‚Üê filter.map_map, order_iso.map_at_top, map_coe_Ioi_at_top]
intros
induction n with k ih
norm_num
{ norm_num }
rw [prod_range_succ_comm, mul_left_comm, ‚Üê ih, mul_succ, integral_sin_pow]
norm_cast
simp [-cast_add] with field_simps
intros
by_cases h : x = 0; simp [h, zero_le_one]
{ by_cases h : x = 0; simp [h, zero_le_one] }
by_cases h : x = 0
simp [h, zero_le_one]
simp [h, zero_le_one]
intros
rw [rpow_def_of_pos hx0]
repeat {rw [rpow_def_of_pos hx0]}
rw [rpow_def_of_pos hx0]
rw [rpow_def_of_pos hx0]
rw exp_le_exp
exact mul_le_mul_of_nonpos_left hyz (log_nonpos (le_of_lt hx0) hx1)
intros
rw [‚Üê cos_sub_pi_div_two, ‚Üê cos_sub_pi_div_two, ‚Üê cos_neg (x - _), ‚Üê cos_neg (y - _)]
rw [‚Üê cos_sub_pi_div_two, ‚Üê cos_sub_pi_div_two, ‚Üê cos_neg (x - _), ‚Üê cos_neg (y - _)]; apply cos_lt_cos_of_nonneg_of_le_pi; linarith
rw [‚Üê cos_sub_pi_div_two, ‚Üê cos_sub_pi_div_two, ‚Üê cos_neg (x - _), ‚Üê cos_neg (y - _)]; apply cos_lt_cos_of_nonneg_of_le_pi
apply cos_lt_cos_of_nonneg_of_le_pi
linarith
linarith
linarith
intros
exact_mod_cast @complex.cos_eq_cos_iff x y
intros
rw [arccos, ‚Üê sin_pi_div_two_sub, arcsin_sin]; simp [sub_eq_add_neg]; linarith
rw [arccos, ‚Üê sin_pi_div_two_sub, arcsin_sin]; simp [sub_eq_add_neg]
rw [arccos, ‚Üê sin_pi_div_two_sub, arcsin_sin]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
linarith
simp [sub_eq_add_neg]
linarith
intros
simpa only [category.assoc] using (iso.comp_inv_eq p).mpr ((arrow.w_mk_right sq).symm)
intros
rw [conj_apply, iso.refl_inv, iso.refl_hom, category.id_comp, category.comp_id]
intros
{ cases f, cases f, cases f, refl }
cases f
cases f
cases f
refl
intros
subst h; simp
subst h
simp
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
rw [‚Üêcancel_epi (limit_uncurry_iso_limit_comp_lim F).hom]
simp
intros
rw [h.hom_desc f, h.hom_desc f']; congr; exact funext w
rw [h.hom_desc f, h.hom_desc f']; congr
rw [h.hom_desc f, h.hom_desc f']
congr
exact funext w
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
simp [is_iso.inv_comp_eq]
intros
ext
simp only [map_pair_left, is_colimit.Œπ_map, is_limit.map_œÄ, biprod.inl_fst_assoc, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_left, ‚Üêbinary_biproduct.bicone_fst, ‚Üêbinary_bicone.to_cocone_Œπ_app_left, ‚Üêbinary_biproduct.bicone_inl]
{ simp only [map_pair_left, is_colimit.Œπ_map, is_limit.map_œÄ, biprod.inl_fst_assoc, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_left, ‚Üêbinary_biproduct.bicone_fst, ‚Üêbinary_bicone.to_cocone_Œπ_app_left, ‚Üêbinary_biproduct.bicone_inl], simp }
simp
simp only [map_pair_left, is_colimit.Œπ_map, is_limit.map_œÄ, zero_comp, biprod.inl_snd_assoc, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_right, ‚Üêbinary_biproduct.bicone_snd, ‚Üêbinary_bicone.to_cocone_Œπ_app_left, ‚Üêbinary_biproduct.bicone_inl]
{ simp only [map_pair_left, is_colimit.Œπ_map, is_limit.map_œÄ, zero_comp, biprod.inl_snd_assoc, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_right, ‚Üêbinary_biproduct.bicone_snd, ‚Üêbinary_bicone.to_cocone_Œπ_app_left, ‚Üêbinary_biproduct.bicone_inl], simp }
simp
simp only [map_pair_right, biprod.inr_fst_assoc, is_colimit.Œπ_map, is_limit.map_œÄ, zero_comp, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_left, ‚Üêbinary_biproduct.bicone_fst, ‚Üêbinary_bicone.to_cocone_Œπ_app_right, ‚Üêbinary_biproduct.bicone_inr]
{ simp only [map_pair_right, biprod.inr_fst_assoc, is_colimit.Œπ_map, is_limit.map_œÄ, zero_comp, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_left, ‚Üêbinary_biproduct.bicone_fst, ‚Üêbinary_bicone.to_cocone_Œπ_app_right, ‚Üêbinary_biproduct.bicone_inr], simp }
simp
simp only [map_pair_right, is_colimit.Œπ_map, is_limit.map_œÄ, biprod.inr_snd_assoc, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_right, ‚Üêbinary_biproduct.bicone_snd, ‚Üêbinary_bicone.to_cocone_Œπ_app_right, ‚Üêbinary_biproduct.bicone_inr]
{ simp only [map_pair_right, is_colimit.Œπ_map, is_limit.map_œÄ, biprod.inr_snd_assoc, category.assoc, ‚Üêbinary_bicone.to_cone_œÄ_app_right, ‚Üêbinary_biproduct.bicone_snd, ‚Üêbinary_bicone.to_cocone_Œπ_app_right, ‚Üêbinary_biproduct.bicone_inr], simp }
simp
intros
{ ext; simp [‚Üê G.map_comp] }
ext
ext; simp [‚Üê G.map_comp]
simp [‚Üê G.map_comp]
simp [‚Üê G.map_comp]
intros
rw [‚Üêtensor_left_iff, ‚Üêcancel_epi (Œ±_ (ùüô_ C) (ùüô_ _) (ùüô_ _)).hom, ‚Üêcancel_mono (œÅ_ (ùüô_ C)).hom, triangle, ‚Üêright_unitor_tensor, right_unitor_naturality]
intros
dsimp [tensor_hom]
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
rintro ‚ü®‚ü©
{ simp, }
simp
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
{ apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit, rintro ‚ü®‚ü©, { simp, }, apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit, rintro ‚ü®‚ü©, { simp, }, { simp, }, }
rintro ‚ü®‚ü©
{ simp, }
simp
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
rintro ‚ü®‚ü©
{ simp, }
simp
{ simp, }
simp
intros
simp only [cancel_epi]
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp underlying]
intros
{ dsimp [factor_thru_kernel_subobject], simp, }
dsimp [factor_thru_kernel_subobject]
simp
intros
simp [kernel_subobject_iso]
intros
simp [boundary, fin.ext_iff]
intros
have : l'.length ‚àà (l.split_wrt_composition c).map list.length := list.mem_map_of_mem list.length h
rw map_length_split_wrt_composition at this
exact c.blocks_pos this
intros
rw ‚Üêcard_derangements_invariant (card_fin _)
exact card_derangements_fin_eq_num_derangements
intros
induction n with m hm m hm; unfold encode_pos_num decode_pos_num
induction n with m hm m hm
unfold encode_pos_num decode_pos_num
{ refl }
refl
unfold encode_pos_num decode_pos_num
rw hm
{ rw hm, exact if_neg (encode_pos_num_nonempty m) }
exact if_neg (encode_pos_num_nonempty m)
unfold encode_pos_num decode_pos_num
{ exact congr_arg pos_num.bit0 hm }
exact congr_arg pos_num.bit0 hm
intros
simp only [star_eq_supr_pow, mul_supr, supr_mul, ‚Üê pow_succ, ‚Üê pow_succ']
intros
induction x; simp [rmatch, match_epsilon, deriv, *]
induction x
simp [rmatch, match_epsilon, deriv, *]
simp [rmatch, match_epsilon, deriv, *]
intros
induction k generalizing v; simp only [cont.then, step_ret, cfg.then, *]
induction k generalizing v
simp only [cont.then, step_ret, cfg.then, *]
simp only [cont.then, step_ret, cfg.then, *]
{ rw ‚Üê step_normal_then, refl }
rw ‚Üê step_normal_then
refl
simp only [cont.then, step_ret, cfg.then, *]
simp only [cont.then, step_ret, cfg.then, *]
{ rw ‚Üê step_normal_then }
rw ‚Üê step_normal_then
simp only [cont.then, step_ret, cfg.then, *]
{ split_ifs, {rw ‚Üê k_ih}, {rw ‚Üê step_normal_then, refl} }
split_ifs
rw ‚Üê k_ih
{rw ‚Üê k_ih}
rw ‚Üê step_normal_then
{rw ‚Üê step_normal_then, refl}
refl
intros
simp only [(>=>)] with functor_norm
intros
rw ‚Üê comp_bitraverse; simp [tfst,map_comp_pure,has_pure.pure]
rw ‚Üê comp_bitraverse
simp [tfst,map_comp_pure,has_pure.pure]
intros
cases x with x; simp! [*] with functor_norm
cases x with x
simp! [*] with functor_norm
simp! [*] with functor_norm
intros
congr
congr; assumption
assumption
assumption
intros
cases hp : p cb n; simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
cases hp : p cb n
simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
intros
simp [foldl, foldl_core_succ_eq_fail]
intros
have : ch c [c].to_buffer 0 = done 1 ()
have : 0 < [c].to_buffer.size := dec_trivial
{ have : 0 < [c].to_buffer.size := dec_trivial, simp [ch_eq_done, this] }
simp [ch_eq_done, this]
exact not_of_ne this zero_ne_one
intros
rw [‚Üê of_real_tanh_of_real_re, of_real_im]
intros
refine @eq.rec_on (‚Ñï ‚Üí Œ±) _ (is_cau_seq abs) _ _ (-‚ü®_, @is_cau_of_decreasing_bounded _ _ _ (Œª n, -f n) a m (by simpa) (by simpa)‚ü© : cau_seq Œ± abs).2
ext
exact neg_neg _
intros
simp [bit0]
intros
have h‚ÇÇ : ‚à•z‚à• = real.sqrt (‚à•z‚à•^2) := (real.sqrt_sq (norm_nonneg z)).symm
rw [h‚ÇÇ]
exact congr_arg real.sqrt (norm_sq_eq_def' z)
intros
simp [(‚Ä¢)]
intros
rw [erase_single, if_neg h]
intros
ext i
ext i; by_cases h : p i; simp [h]
ext i; by_cases h : p i
by_cases h : p i
simp [h]
simp [h]
intros
substs h h2
{ substs h h2, refl }
refl
intros
dsimp [fin_rotate]
simp [h, add_comm]
intros
rw [e.trans_source', e.symm_image_target_inter_eq]
intros
{ ext, simp only [succ_above_below, cast_succ_lt_last] }
ext
simp only [succ_above_below, cast_succ_lt_last]
intros
simp [cons]
intros
simp [pi.le_def, forall_iff_succ_above i]
intros
rw ‚Üêof_nat_eq_coe
exact nat.mod_eq_of_lt h
intros
simp [piecewise, hi]
intros
change (s.1.map f).erase_dup.card = s.1.card at H
have : (s.1.map f).erase_dup = s.1.map f
apply multiset.eq_of_le_of_card_le
{ apply multiset.eq_of_le_of_card_le, { apply multiset.erase_dup_le }, rw H, simp only [multiset.card_map] }
{ apply multiset.erase_dup_le }
apply multiset.erase_dup_le
rw H
simp only [multiset.card_map]
rw multiset.erase_dup_eq_self at this
apply inj_on_of_nodup_map this
intros
{ rw bUnion_singleton, exact image_id }
rw bUnion_singleton
exact image_id
intros
subst s
refine eq_of_forall_ge_iff (Œª c, _)
simp only [sup'_le_iff, h‚ÇÇ] { contextual := tt }
intros
classical
convert fintype.card_le_of_embedding (subtype_or_left_embedding p q)
rw fintype.card_sum
intros
rw fintype.of_equiv_card; simp
rw fintype.of_equiv_card
simp
intros
rcases int.units_eq_one_or x with (rfl | rfl); simp
rcases int.units_eq_one_or x with (rfl | rfl)
simp
simp
intros
unfold sub_nat_nat
cases e : n - m
{ simp [sub_nat_nat, e, nat.le_of_sub_eq_zero e] }
simp [sub_nat_nat, e, nat.le_of_sub_eq_zero e]
rw [sub_nat_nat, cast_neg_succ_of_nat, ‚Üê nat.cast_succ, ‚Üê e, nat.cast_sub $ _root_.le_of_lt $ nat.lt_of_sub_eq_succ e, neg_sub]
{ rw [sub_nat_nat, cast_neg_succ_of_nat, ‚Üê nat.cast_succ, ‚Üê e, nat.cast_sub $ _root_.le_of_lt $ nat.lt_of_sub_eq_succ e, neg_sub] }
intros
rw_mod_cast [even_iff, nat.even_iff]
intros
cases l
cases l; refl
refl
refl
intros
simp only [nth_modify_nth, if_pos]
intros
cases l; refl
cases l
refl
refl
intros
induction i with i hi generalizing b l
cases l
{ cases l, { simp only [length, zero_add, scanl_nil] at h, exact absurd h (lt_irrefl 1) }, { simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le] } }
simp only [length, zero_add, scanl_nil] at h
{ simp only [length, zero_add, scanl_nil] at h, exact absurd h (lt_irrefl 1) }
exact absurd h (lt_irrefl 1)
{ simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le] }
simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le]
cases l
{ cases l, { simp only [length, add_lt_iff_neg_right, scanl_nil] at h, exact absurd h (not_lt_of_lt nat.succ_pos') }, { simp_rw scanl_cons, rw nth_le_append_right _, { simpa only [hi, length, succ_add_sub_one] }, { simp only [length, nat.zero_le, le_add_iff_nonneg_left] } } }
simp only [length, add_lt_iff_neg_right, scanl_nil] at h
{ simp only [length, add_lt_iff_neg_right, scanl_nil] at h, exact absurd h (not_lt_of_lt nat.succ_pos') }
exact absurd h (not_lt_of_lt nat.succ_pos')
simp_rw scanl_cons
{ simp_rw scanl_cons, rw nth_le_append_right _, { simpa only [hi, length, succ_add_sub_one] }, { simp only [length, nat.zero_le, le_add_iff_nonneg_left] } }
rw nth_le_append_right _
{ simpa only [hi, length, succ_add_sub_one] }
simpa only [hi, length, succ_add_sub_one]
{ simp only [length, nat.zero_le, le_add_iff_nonneg_left] }
simp only [length, nat.zero_le, le_add_iff_nonneg_left]
intros
simp [prod_inv_reverse]
intros
induction L generalizing i
simp
{ simp }
cases i
simp
{ simp }
simp [take_append, L_ih]
intros
simp [lookmap, h]
intros
{ rw tails_eq_inits l, simp [reverse_involutive.comp_self], }
rw tails_eq_inits l
simp [reverse_involutive.comp_self]
intros
simp [erasep_cons, h]
intros
simp only [diff_eq_foldl, foldl_map, map_foldl_erase finj]
intros
cases bs; refl
cases bs
refl
refl
intros
cases l; refl
cases l
refl
refl
intros
simp only [chain_cons, chain.nil, and_true]
intros
induction xs with y ys IH
{ cases x_mem }
cases x_mem
cases ys with z zs
{ simp at x_mem x_ne, contradiction }
simp at x_mem x_ne
contradiction
by_cases h : x = y
rw [h, next_or_self_cons_cons, next_or_self_cons_cons]
{ rw [h, next_or_self_cons_cons, next_or_self_cons_cons] }
rw [next_or, next_or, IH]; simpa [h] using x_mem
rw [next_or, next_or, IH]
{ rw [next_or, next_or, IH]; simpa [h] using x_mem }
simpa [h] using x_mem
simpa [h] using x_mem
intros
rw [Ico, nat.sub_zero, range_eq_range']
intros
simp only [antidiagonal, range_succ_eq_map, map_cons, true_and, nat.add_succ_sub_one, add_zero, id.def, eq_self_iff_true, nat.sub_zero, map_map, prod.map_mk]
apply congr (congr rfl _) rfl
ext
ext; simp
simp
simp
intros
classical
rw [duplicate_iff_two_le_count, le_count_iff_repeat_sublist, sublist_iff_exists_fin_order_embedding_nth_le_eq]
split
rintro ‚ü®f, hf‚ü©
{ rintro ‚ü®f, hf‚ü©, refine ‚ü®f ‚ü®0, by simp‚ü©, fin.is_lt _, f ‚ü®1, by simp‚ü©, fin.is_lt _, by simp, _, _‚ü©, { simpa using hf ‚ü®0, by simp‚ü© }, { simpa using hf ‚ü®1, by simp‚ü© } }
refine ‚ü®f ‚ü®0, by simp‚ü©, fin.is_lt _, f ‚ü®1, by simp‚ü©, fin.is_lt _, by simp, _, _‚ü©
{ simpa using hf ‚ü®0, by simp‚ü© }
simpa using hf ‚ü®0, by simp‚ü©
{ simpa using hf ‚ü®1, by simp‚ü© }
simpa using hf ‚ü®1, by simp‚ü©
rintro ‚ü®n, hn, m, hm, hnm, h, h'‚ü©
{ rintro ‚ü®n, hn, m, hm, hnm, h, h'‚ü©, refine ‚ü®order_embedding.of_strict_mono (Œª i, if (i : ‚Ñï) = 0 then ‚ü®n, hn‚ü© else ‚ü®m, hm‚ü©) _, _‚ü©, { rintros ‚ü®‚ü®_|i‚ü©, hi‚ü© ‚ü®‚ü®_|j‚ü©, hj‚ü©, { simp }, { simp [hnm] }, { simp }, { simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj, simp [hi, hj] } }, { rintros ‚ü®‚ü®_|i‚ü©, hi‚ü©, { simpa using h }, { simpa using h' } } }
refine ‚ü®order_embedding.of_strict_mono (Œª i, if (i : ‚Ñï) = 0 then ‚ü®n, hn‚ü© else ‚ü®m, hm‚ü©) _, _‚ü©
rintros ‚ü®‚ü®_|i‚ü©, hi‚ü© ‚ü®‚ü®_|j‚ü©, hj‚ü©
{ rintros ‚ü®‚ü®_|i‚ü©, hi‚ü© ‚ü®‚ü®_|j‚ü©, hj‚ü©, { simp }, { simp [hnm] }, { simp }, { simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj, simp [hi, hj] } }
{ simp }
simp
{ simp [hnm] }
simp [hnm]
{ simp }
simp
simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj
{ simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj, simp [hi, hj] }
simp [hi, hj]
rintros ‚ü®‚ü®_|i‚ü©, hi‚ü©
{ rintros ‚ü®‚ü®_|i‚ü©, hi‚ü©, { simpa using h }, { simpa using h' } }
{ simpa using h }
simpa using h
{ simpa using h' }
simpa using h'
intros
induction l; [exact pairwise.nil, simp only [*, pairwise_cons, forall_2_true_iff, and_true]]
induction l
exact pairwise.nil
simp only [*, pairwise_cons, forall_2_true_iff, and_true]
intros
rw subperm_ext_iff at h ‚ä¢
intros y hy
by_cases hy' : y = x
subst x
{ subst x, simpa using nat.succ_le_of_lt hx }
simpa using nat.succ_le_of_lt hx
rw count_cons_of_ne hy'
{ rw count_cons_of_ne hy', refine h y _, simpa [hy'] using hy }
refine h y _
simpa [hy'] using hy
intros
simp only [iota_eq_reverse_range', pairwise_reverse, pairwise_lt_range']
intros
rw [eq_comm, rotate_eq_nil_iff, eq_comm]
intros
rw [sublists_append, sublists_singleton, bind_eq_bind, cons_bind, cons_bind, nil_bind, map_eq_map, map_eq_map, map_id' (append_nil), append_nil]
intros
convert (list.zip_with_map f id g l l')
{ convert (list.zip_with_map f id g l l'), exact eq.symm (list.map_id _) }
exact eq.symm (list.map_id _)
intros
cases l; refl
cases l
refl
refl
intros
{ ext, refl }
ext
refl
intros
ext i' j
rw [transpose_apply, update_row_apply, update_column_apply]
refl
intros
rw [algebra_map_eq_diagonal, algebra_map_eq_diagonal, diagonal_map hf]
congr' 1 with x
simp only [hf‚ÇÇ, pi.algebra_map_apply]
intros
ext i j
rcases i
rcases i; rcases j; simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
rcases i; rcases j
rcases j
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
rcases j
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
intros
{ ext, simp [h], }
ext
simp [h]
intros
{ ext i j, refine fin.cases _ _ i, { refl }, simp [mul_val_succ] }
ext i j
refine fin.cases _ _ i
refl
{ refl }
simp [mul_val_succ]
intros
{ rcases s with ‚ü®l‚ü©, simp }
rcases s with ‚ü®l‚ü©
simp
intros
revert s u
refine multiset.induction_on t _ (Œª a t IH, _)
refine multiset.induction_on t _ (Œª a t IH, _); intros
intros
{ simp [h‚ÇÅ] }
simp [h‚ÇÅ]
intros
by_cases a ‚àà u
rw [cons_inter_of_pos _ h, ‚Üê erase_le_iff_le_cons]
{ rw [cons_inter_of_pos _ h, ‚Üê erase_le_iff_le_cons], exact IH (erase_le_iff_le_cons.2 h‚ÇÅ) (erase_le_erase _ h‚ÇÇ) }
exact IH (erase_le_iff_le_cons.2 h‚ÇÅ) (erase_le_erase _ h‚ÇÇ)
rw cons_inter_of_neg _ h
{ rw cons_inter_of_neg _ h, exact IH ((le_cons_of_not_mem $ mt (mem_of_le h‚ÇÇ) h).1 h‚ÇÅ) h‚ÇÇ }
exact IH ((le_cons_of_not_mem $ mt (mem_of_le h‚ÇÇ) h).1 h‚ÇÅ) h‚ÇÇ
intros
simp only [singleton_eq_cons, card_zero, eq_self_iff_true, zero_add, card_cons]
intros
simp [C_apply, monomial]
intros
simp [expand, bind‚ÇÅ_rename, rename_bind‚ÇÅ]
intros
simp
intros
rw nat.mod_two_of_bodd
{ rw nat.mod_two_of_bodd, simp }
simp
intros
simp [H]
intros
rw [subsingleton.elim mn (le_trans (le_succ m) smn), decreasing_induction_trans, decreasing_induction_succ']
{ rw [subsingleton.elim mn (le_trans (le_succ m) smn), decreasing_induction_trans, decreasing_induction_succ'] }
intros
simp [land]
intros
induction L with d L ih
{ refl, }
refl
{ dsimp [of_digits], push_cast, rw ih, }
dsimp [of_digits]
push_cast
rw ih
intros
split
{ rintro rfl n, exact coe_lt_top _ }
rintro rfl n
exact coe_lt_top _
contrapose!
{ contrapose!, rw ne_top_iff, rintro ‚ü®n, rfl‚ü©, exact ‚ü®n, irrefl _‚ü© }
rw ne_top_iff
rintro ‚ü®n, rfl‚ü©
exact ‚ü®n, irrefl _‚ü©
intros
rw [‚Üêpochhammer_nat_eq_asc_factorial, pochhammer_eval_cast, nat.cast_add, nat.cast_one]
intros
{ rw ‚Üê sup_supr_nat_succ, simp }
rw ‚Üê sup_supr_nat_succ
simp
intros
rw [nat.modeq, nat.add_mod_right]
intros
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
rw factors
intros
rw ‚Üê nat.dvd_iff_mod_eq_zero at hd; exact le_antisymm (nat.min_fac_le_of_dvd (nat.bit1_lt h.1) hd) h.2
rw ‚Üê nat.dvd_iff_mod_eq_zero at hd
exact le_antisymm (nat.min_fac_le_of_dvd (nat.bit1_lt h.1) hd) h.2
intros
cases m; cases n; refl
cases m; cases n
cases m
cases n
refl
refl
cases n
refl
refl
intros
linarith
intros
dsimp [restrict, mem_eq]
split
{ rintro ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©, exact ‚ü®h‚ÇÄ, ‚ü®_, h‚ÇÅ‚ü©‚ü© }
rintro ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©
exact ‚ü®h‚ÇÄ, ‚ü®_, h‚ÇÅ‚ü©‚ü©
rintro ‚ü®h‚ÇÄ, h‚ÇÅ, h‚ÇÇ‚ü©
exact ‚ü®h‚ÇÄ, h‚ÇÇ‚ü©
intros
cases x
dsimp [comp.get,comp.mk]
ext : 2; intros
ext : 2
intros
refl
intros
refl
intros
congr
ext1
ext1; intros; refl
ext1; intros
intros
refl
intros
refl
ext : 2
congr
rcases x_1 with ‚ü®a,b,c‚ü©
rcases x_1 with ‚ü®a,b,c‚ü©; refl
refl
intros
refl
intros
apply prime_multiset.coe_nat_injective
rw [v.prod.coe_nat_factor_multiset, prime_multiset.coe_prod]
rcases v with ‚ü®l‚ü©
unfold_coes
dsimp [prime_multiset.to_nat_multiset]
rw [multiset.coe_prod]
let l' := l.map (coe : nat.primes ‚Üí ‚Ñï)
have : ‚àÄ (p : ‚Ñï), p ‚àà l' ‚Üí p.prime := Œª p hp, by {rcases list.mem_map.mp hp with ‚ü®‚ü®p', hp'‚ü©, ‚ü®h_mem, h_eq‚ü©‚ü©, exact h_eq ‚ñ∏ hp'}
exact multiset.coe_eq_coe.mpr (@nat.factors_unique _ l' rfl this).symm
intros
rw mul_comm
apply coprime.factor_eq_gcd_left cop am bn
intros
dsimp [gcd_b', gcd_y, gcd_z, xgcd_type.z]
{ dsimp [gcd_b', gcd_y, gcd_z, xgcd_type.z], rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_assoc] }
rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_assoc]
intros
{ convert coeff_monomial using 2, simp [eq_comm], }
convert coeff_monomial using 2
simp [eq_comm]
intros
by_cases hp : p = 0
{ rw [hp, nat_degree_zero, nat_trailing_degree_zero] }
rw [hp, nat_degree_zero, nat_trailing_degree_zero]
exact le_nat_degree_of_ne_zero (mt trailing_coeff_eq_zero.mp hp)
{ exact le_nat_degree_of_ne_zero (mt trailing_coeff_eq_zero.mp hp) }
intros
rw [‚Üê mod_by_monic_X_sub_C_eq_C_eval, C_0, sub_zero]
intros
rcases p
rcases q
simp only [coeff] at hf
simp only [mul_to_finsupp, eval‚ÇÇ_to_finsupp_eq_lift_nc]
exact lift_nc_mul _ _ p q (Œª k n hn, (hf k).pow_right n)
intros
simp only [bit0, add_comp]
intros
rw [‚Üê C_1, eval‚ÇÇ_C, f.map_one]
intros
by_cases hf : f = 0
simp [hf]
{ simp [hf] }
ext i
refine ‚ü®Œª h, integral_normalization_support h, _‚ü©
simp only [integral_normalization_coeff, mem_support_iff]
intro hfi
split_ifs with hi; simp [hfi, hi, pow_ne_zero _ (leading_coeff_ne_zero.mpr hf)]
split_ifs with hi
simp [hfi, hi, pow_ne_zero _ (leading_coeff_ne_zero.mpr hf)]
simp [hfi, hi, pow_ne_zero _ (leading_coeff_ne_zero.mpr hf)]
intros
{ ext, simp only [coeff_add, coeff_reflect], }
ext
simp only [coeff_add, coeff_reflect]
intros
rw [root_set_def, polynomial.map_zero, roots_zero, to_finset_zero, finset.coe_empty]
intros
rw [‚Üê @mk.eta _ _ p, ‚Üê @mk.eta _ _ q, mk.inj_iff]
intros
ext x
apply fix.ind_rec
intros x hyp'
rw [hyp, ‚Üêhyp', fix.rec_eq]
intros
cases n; simp [mk]
cases n
simp [mk]
simp [mk]
intros
cases q‚ÇÅ; cases q‚ÇÇ; refl
cases q‚ÇÅ; cases q‚ÇÇ
cases q‚ÇÅ
cases q‚ÇÇ
refl
intros
have := rat.nonneg_total (b - a); rwa neg_sub at this
have := rat.nonneg_total (b - a)
rwa neg_sub at this
intros
rw [cantor_function, tsum_eq_zero_add (summable_cantor_function f h1 h2)]
rw [cantor_function_aux_succ, tsum_mul_left, cantor_function_aux, pow_zero]
refl
intros
rw [‚Üê ennreal.of_real_one, ‚Üê ennreal.of_real_div_of_pos h.pos, ‚Üê ennreal.of_real_div_of_pos h.symm.pos, ‚Üê ennreal.of_real_add h.one_div_nonneg h.symm.one_div_nonneg, h.inv_add_inv_conj]
intros
simp [pos_iff_ne_zero, not_or_distrib]
intros
{ rw [ennreal.to_real, to_nnreal_sum hf, nnreal.coe_sum], refl }
rw [ennreal.to_real, to_nnreal_sum hf, nnreal.coe_sum]
refl
rw [fib_rec.geom_sol_iff_root_char_poly, fib_rec_char_poly_eq]
simp [sub_eq_zero]
intros
rcases nat.eq_zero_or_pos n with rfl | hnpos
rw [eq_comm, pow_zero, ‚Üê int.cast_one, int.cast_inj] at hxr
{ rw [eq_comm, pow_zero, ‚Üê int.cast_one, int.cast_inj] at hxr, simpa [hxr, multiplicity.one_right (mt is_unit_iff_dvd_one.1 (mt int.coe_nat_dvd.1 hp.1.not_dvd_one)), nat.zero_mod] using hv }
simpa [hxr, multiplicity.one_right (mt is_unit_iff_dvd_one.1 (mt int.coe_nat_dvd.1 hp.1.not_dvd_one)), nat.zero_mod] using hv
refine irrational_nrt_of_notint_nrt _ _ hxr _ hnpos
rintro ‚ü®y, rfl‚ü©
rw [‚Üê int.cast_pow, int.cast_inj] at hxr
subst m
have : y ‚â† 0
rintro rfl
{ rintro rfl, rw zero_pow hnpos at hm, exact hm rfl }
rw zero_pow hnpos at hm
exact hm rfl
erw [multiplicity.pow' (nat.prime_iff_prime_int.1 hp.1) (finite_int_iff.2 ‚ü®hp.1.ne_one, this‚ü©), nat.mul_mod_right] at hv
exact hv rfl
intros
refine lt_of_lt_of_le (pi_lt_sqrt_two_add_series n) _
rw [‚Üê le_sub_iff_add_le, ‚Üê le_div_iff', sqrt_le_left, sub_le]
{ rwa [nat.cast_zero, zero_div] at h }
rwa [nat.cast_zero, zero_div] at h
exact div_nonneg (sub_nonneg.2 h‚ÇÇ) (pow_nonneg (le_of_lt zero_lt_two) _)
{ exact div_nonneg (sub_nonneg.2 h‚ÇÇ) (pow_nonneg (le_of_lt zero_lt_two) _) }
{ exact pow_pos zero_lt_two _ }
exact pow_pos zero_lt_two _
intros
rw [sq, mul_self_sqrt h]
intros
ext y
{ ext y, simp [mem_image, codom] }
simp [mem_image, codom]
intros
cases s with f al; apply subtype.eq; dsimp [tail, cons]; rw [stream.tail_cons]
cases s with f al; apply subtype.eq; dsimp [tail, cons]
cases s with f al; apply subtype.eq
cases s with f al
apply subtype.eq
dsimp [tail, cons]
rw [stream.tail_cons]
intros
dsimp [nth]; rw [dropn_of_seq, head_of_seq, seq.head_dropn]
dsimp [nth]
rw [dropn_of_seq, head_of_seq, seq.head_dropn]
intros
simpa only [exists_prop] using exists_range_iff
intros
rw [univ_pi_update i (Œª j, (univ : set (Œ± j))) s (Œª j t, t), pi_univ, inter_univ, preimage]
intros
simp [nonempty_def.mp h, ext_iff]
intros
rw union_eq_Union; exact countable_Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)
rw union_eq_Union
exact countable_Union (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)
intros
ext x
refine ‚ü®Œª hx, Union_Inter_subset hx, Œª hx, _‚ü©
simp only [mem_Inter, mem_Union, mem_Inter] at hx ‚ä¢
choose j hj using hx
obtain ‚ü®j‚ÇÄ‚ü© := show nonempty Œπ', by apply_instance
refine ‚ü®finset.univ.fold max j‚ÇÄ j, Œª i, hs i _ (hj i)‚ü©
rw [finset.fold_op_rel_iff_or (@le_max_iff _ _)]
exact or.inr ‚ü®i, finset.mem_univ i, le_rfl‚ü©
intros
apply subset.antisymm
rintro _ ‚ü®x, ‚ü®h‚ÇÅ, h‚ü©, rfl‚ü©
{ rintro _ ‚ü®x, ‚ü®h‚ÇÅ, h‚ü©, rfl‚ü©, exact ‚ü®by rwa [mem_preimage, hf h], mem_image_of_mem _ h‚ü© }
exact ‚ü®by rwa [mem_preimage, hf h], mem_image_of_mem _ h‚ü©
rintro _ ‚ü®h‚ÇÅ, ‚ü®x, h, rfl‚ü©‚ü©
{ rintro _ ‚ü®h‚ÇÅ, ‚ü®x, h, rfl‚ü©‚ü©, exact mem_image_of_mem _ ‚ü®by rwa ‚Üê hf h, h‚ü© }
exact mem_image_of_mem _ ‚ü®by rwa ‚Üê hf h, h‚ü©
intros
rintros _ ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü© H
simp only [‚Üê h.eq] at H
exact congr_arg f (ha hx hy $ hf (mem_image_of_mem fa hx) (mem_image_of_mem fa hy) H)
intros
{ ext x, simp [‚Üê e.le_iff_le] }
ext x
simp [‚Üê e.le_iff_le]
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ici_of_neg a h
intros
simp [proj_Icc, hx, hx.trans h]
intros
simpa only [mul_comm] using image_mul_const_interval a b c
intros
simp [set.eq_empty_iff_forall_not_mem]
intros
rw [‚Üêfintype.card_congr (@equiv.sum_compl _ is_diag (sym2.is_diag.decidable_pred Œ±)), fintype.card_sum, card_subtype_diag, card_subtype_not_diag, nat.choose_two_right, add_comm, ‚Üênat.triangle_succ, nat.succ_sub_one, mul_comm]
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
simp [nth_zero]
intros
simp [nth_eq_nth_le]
intros
casesI n
{ exact int.cast_one }
exact int.cast_one
show ((1 % (n+1) : ‚Ñï) : R) = 1
cases n
rw [nat.dvd_one] at h
{ rw [nat.dvd_one] at h, substI m, apply subsingleton.elim }
substI m
apply subsingleton.elim
rw nat.mod_eq_of_lt
{ exact nat.cast_one }
exact nat.cast_one
exact nat.lt_of_sub_eq_succ rfl
intros
rw [mem_ker]; exact one_iff_ker_inv' hf _ _
rw [mem_ker]
exact one_iff_ker_inv' hf _ _
intros
let b := is_noetherian.finset_basis K V
rw [module.card_fintype b, ‚Üê finite_dimensional.finrank_eq_card_basis b]
intros
subst H; induction m with m ih; [simp only [zero_add, iterate_zero_apply], rw [ih, nat.succ_add, iterate_succ']]; apply quot.sound; apply r.intro
subst H; induction m with m ih; [simp only [zero_add, iterate_zero_apply], rw [ih, nat.succ_add, iterate_succ']]; apply quot.sound
subst H; induction m with m ih; [simp only [zero_add, iterate_zero_apply], rw [ih, nat.succ_add, iterate_succ']]
subst H; induction m with m ih
subst H
induction m with m ih
simp only [zero_add, iterate_zero_apply]
rw [ih, nat.succ_add, iterate_succ']
apply quot.sound
apply r.intro
intros
refine alg_equiv.ext (Œª x, (alg_hom.mem_equalizer œÉ.to_alg_hom œÑ.to_alg_hom x).mp ((set_like.ext_iff.mp _ x).mpr algebra.mem_top))
rwa [eq_top_iff, ‚Üêsplitting_field.adjoin_roots, algebra.adjoin_le_iff]
intros
rw [‚Üêmem_coe, ‚Üêset.singleton_subset_iff, ‚Üêinter_eq_singleton_orthogonal_projection_fn]
exact set.inter_subset_left _ _
intros
rw cospherical_iff_exists_mem_of_finite_dimensional h at hc
rcases hc with ‚ü®c, hc, r, hcr‚ü©
use r
intros sx hsxps
have hsx : affine_span ‚Ñù (set.range sx.points) = s
refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _
{ refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _, simp [hd] }
simp [hd]
have hc : c ‚àà affine_span ‚Ñù (set.range sx.points) := hsx.symm ‚ñ∏ hc
exact (sx.eq_circumradius_of_dist_eq hc (Œª i, hcr (sx.points i) (hsxps (set.mem_range_self i)))).symm
intros
ext f
{ ext f, rw [‚Üêleft_invariant, apply_hfdifferential, apply_hfdifferential, L_mul, fdifferential_comp, apply_fdifferential, linear_map.comp_apply, apply_fdifferential, ‚Üêapply_hfdifferential, left_invariant] }
rw [‚Üêleft_invariant, apply_hfdifferential, apply_hfdifferential, L_mul, fdifferential_comp, apply_fdifferential, linear_map.comp_apply, apply_fdifferential, ‚Üêapply_hfdifferential, left_invariant]
intros
simp only [atlas, mem_Union, mem_singleton_iff]
intros
have : unique_mdiff_on I (s ‚à© f ‚Åª¬π' (ext_chart_at I' y).source)
assume z hz
{ assume z hz, apply (hs z hz.1).inter', apply (hf z hz.1).preimage_mem_nhds_within, exact is_open.mem_nhds (ext_chart_at_open_source I' y) hz.2 }
apply (hs z hz.1).inter'
apply (hf z hz.1).preimage_mem_nhds_within
exact is_open.mem_nhds (ext_chart_at_open_source I' y) hz.2
exact this.unique_diff_on_target_inter _
intros
rwa [‚Üê ext_chart_at_symm_map_nhds_within' I x h, mem_map] at ht
intros
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
refine ‚ü®(ext_chart_at_continuous_at _ _).continuous_within_at, _‚ü©
refine times_cont_diff_within_at_id.congr _ _
refine times_cont_diff_within_at_id.congr _ _; simp only with mfld_simps { contextual := tt }
simp only with mfld_simps { contextual := tt }
simp only with mfld_simps { contextual := tt }
intros
rw [inv_eq_iff_mul_eq_one, smul_mul_smul, mul_right_inv, mul_right_inv, one_smul]
intros
rw [mul_comm, lift_mul_right]
intros
apply minimal_period_eq_prime_pow; rwa is_periodic_pt_add_iff_nsmul_eq_zero
apply minimal_period_eq_prime_pow
rwa is_periodic_pt_add_iff_nsmul_eq_zero
rwa is_periodic_pt_add_iff_nsmul_eq_zero
intros
rw mem_cycle_factors_finset_iff at hf
rw [cycle_type_def, cycle_type_def, hf.left.cycle_factors_finset_eq_singleton]
refine map_le_map _
simpa [‚Üêfinset.mem_def, mem_cycle_factors_finset_iff] using hf
intros
have hl : l.nodup := nodup_of_pairwise_disjoint_cycles h1 h2
rw cycle_type_eq' l.to_finset
{ simp [list.erase_dup_eq_self.mpr hl] }
simp [list.erase_dup_eq_self.mpr hl]
{ simpa using h1 }
simpa using h1
{ simpa [hl] using h0 }
simpa [hl] using h0
simpa [list.erase_dup_eq_self.mpr hl] using list.forall_of_pairwise disjoint.symmetric h2
{ simpa [list.erase_dup_eq_self.mpr hl] using list.forall_of_pairwise disjoint.symmetric h2 }
intros
split_ifs with h‚ÇÅ h‚ÇÇ
{ exact cycle_range_of_lt h‚ÇÅ }
exact cycle_range_of_lt h‚ÇÅ
{ exact cycle_range_of_eq h‚ÇÇ }
exact cycle_range_of_eq h‚ÇÇ
exact cycle_range_of_gt (lt_of_le_of_ne (le_of_not_gt h‚ÇÅ) (ne.symm h‚ÇÇ))
{ exact cycle_range_of_gt (lt_of_le_of_ne (le_of_not_gt h‚ÇÅ) (ne.symm h‚ÇÇ)) }
intros
convert form_perm_pow_apply_nth_le _ h n 0 _; simp
{ convert form_perm_pow_apply_nth_le _ h n 0 _; simp }
convert form_perm_pow_apply_nth_le _ h n 0 _
simp
simp
intros
ext b
simp only [exists_prop, function.embedding.coe_fn_mk, to_embedding_apply, mem_map, ne.def, function.embedding.trans_apply, mem_support]
by_cases pb : p b
rw [extend_domain_apply_subtype _ _ pb]
{ rw [extend_domain_apply_subtype _ _ pb], split, { rintro h, refine ‚ü®f.symm ‚ü®b, pb‚ü©, _, by simp‚ü©, contrapose! h, simp [h] }, { rintro ‚ü®a, ha, hb‚ü©, contrapose! ha, obtain rfl : a = f.symm ‚ü®b, pb‚ü©, { rw eq_symm_apply, exact subtype.coe_injective hb }, rw eq_symm_apply, exact subtype.coe_injective ha } }
split
rintro h
{ rintro h, refine ‚ü®f.symm ‚ü®b, pb‚ü©, _, by simp‚ü©, contrapose! h, simp [h] }
refine ‚ü®f.symm ‚ü®b, pb‚ü©, _, by simp‚ü©
contrapose! h
simp [h]
rintro ‚ü®a, ha, hb‚ü©
{ rintro ‚ü®a, ha, hb‚ü©, contrapose! ha, obtain rfl : a = f.symm ‚ü®b, pb‚ü©, { rw eq_symm_apply, exact subtype.coe_injective hb }, rw eq_symm_apply, exact subtype.coe_injective ha }
contrapose! ha
obtain rfl : a = f.symm ‚ü®b, pb‚ü©
rw eq_symm_apply
{ rw eq_symm_apply, exact subtype.coe_injective hb }
exact subtype.coe_injective hb
rw eq_symm_apply
exact subtype.coe_injective ha
rw [extend_domain_apply_not_subtype _ _ pb]
{ rw [extend_domain_apply_not_subtype _ _ pb], simp only [not_exists, false_iff, not_and, eq_self_iff_true, not_true], rintros a ha rfl, exact pb (subtype.prop _) }
simp only [not_exists, false_iff, not_and, eq_self_iff_true, not_true]
rintros a ha rfl
exact pb (subtype.prop _)
intros
tactic.unfreeze_local_instances
obtain ‚ü®n, hn‚ü© := hG''
suffices : ‚àÄ k : ‚Ñï, derived_series G (n + k) ‚â§ (derived_series G' k).map f
obtain ‚ü®m, hm‚ü© := hG'
{ obtain ‚ü®m, hm‚ü© := hG', use n + m, specialize this m, rwa [hm, map_bot, le_bot_iff] at this }
use n + m
specialize this m
rwa [hm, map_bot, le_bot_iff] at this
intro k
induction k with k hk
rw [add_zero, derived_series_zero, ‚Üêmonoid_hom.range_eq_map]
{ rw [add_zero, derived_series_zero, ‚Üêmonoid_hom.range_eq_map], refine le_trans _ hfg, rw [‚Üêmap_eq_bot_iff, eq_bot_iff, ‚Üêhn], exact map_derived_series_le_derived_series g n }
refine le_trans _ hfg
rw [‚Üêmap_eq_bot_iff, eq_bot_iff, ‚Üêhn]
exact map_derived_series_le_derived_series g n
rw [nat.add_succ, derived_series_succ, derived_series_succ]
{ rw [nat.add_succ, derived_series_succ, derived_series_succ], exact commutator_le_map_commutator hk hk }
exact commutator_le_map_commutator hk hk
intros
classical
by_cases h : ‚àÄ x ‚àà H, x = (1 : G)
left
{ left, exact H.eq_bot_iff_forall.mpr h }
exact H.eq_bot_iff_forall.mpr h
right
{ right, push_neg at h, simpa [nontrivial_iff_exists_ne_one] using h }
push_neg at h
simpa [nontrivial_iff_exists_ne_one] using h
intros
lift l to list S using hl
{ lift l to list S using hl, rw ‚Üê coe_list_prod, exact l.prod.coe_prop }
rw ‚Üê coe_list_prod
exact l.prod.coe_prop
intros
split
split; intros hf x y hxy
intros hf x y hxy
rw [‚Üê @vsub_eq_zero_iff_eq V1, ‚Üê @submodule.mem_bot k V1, ‚Üê linear_map.ker_eq_bot.mpr hf, linear_map.mem_ker, affine_map.linear_map_vsub, hxy, vsub_self]
{ rw [‚Üê @vsub_eq_zero_iff_eq V1, ‚Üê @submodule.mem_bot k V1, ‚Üê linear_map.ker_eq_bot.mpr hf, linear_map.mem_ker, affine_map.linear_map_vsub, hxy, vsub_self], }
intros hf x y hxy
obtain ‚ü®p‚ü© := (by apply_instance : nonempty P1)
{ obtain ‚ü®p‚ü© := (by apply_instance : nonempty P1), have hxy' : (f.linear x) +·µ• f p = (f.linear y) +·µ• f p, { rw hxy, }, rw [‚Üê f.map_vadd, ‚Üê f.map_vadd] at hxy', exact (vadd_right_cancel_iff _).mp (hf hxy'), }
have hxy' : (f.linear x) +·µ• f p = (f.linear y) +·µ• f p
rw hxy
{ rw hxy, }
rw [‚Üê f.map_vadd, ‚Üê f.map_vadd] at hxy'
exact (vadd_right_cancel_iff _).mp (hf hxy')
intros
ext v
rw [set_like.mem_coe, ‚Üêsubmodule.neg_mem_iff, ‚Üêset_like.mem_coe, coe_direction_eq_vsub_set_right hp, set.mem_image_iff_bex, set.mem_image_iff_bex]
conv_lhs { congr, funext, rw [‚Üêneg_vsub_eq_vsub_rev, neg_inj] }
intros
by_contradiction hne
change (affine_span k (p '' s1) : set P) ‚à© affine_span k (p '' s2) ‚â† ‚àÖ at hne
rw set.ne_empty_iff_nonempty at hne
rcases hne with ‚ü®p0, hp0s1, hp0s2‚ü©
cases ha.exists_mem_inter_of_exists_mem_inter_affine_span hp0s1 hp0s2 with i hi
exact set.not_mem_empty i (hd ‚ñ∏ hi)
intros
simp only [dom_coprod', tensor_product.lift.tmul, linear_map.mk‚ÇÇ_apply]
intros
rw [span_le, singleton_subset_iff, set_like.mem_coe]
intros
simpa only [range_eq_map] using map_cod_restrict _ _ _ _
intros
rw bilin_form.is_adjoint_pair_iff_comp_left_eq_comp_right
have h : ‚àÄ (B B' : bilin_form R‚ÇÉ (n ‚Üí R‚ÇÉ)), B = B' ‚Üî (bilin_form.to_matrix' B) = (bilin_form.to_matrix' B')
intros B B'
{ intros B B', split; intros h, { rw h }, { exact bilin_form.to_matrix'.injective h } }
split; intros h
split
intros h
{ rw h }
rw h
intros h
{ exact bilin_form.to_matrix'.injective h }
exact bilin_form.to_matrix'.injective h
rw [h, bilin_form.to_matrix'_comp_left, bilin_form.to_matrix'_comp_right, linear_map.to_matrix'_to_lin', linear_map.to_matrix'_to_lin', bilin_form.to_matrix'_to_bilin', bilin_form.to_matrix'_to_bilin']
refl
intros
simp only [comp_left, bilin_form.to_matrix_comp b b, to_matrix_id, matrix.mul_one]
intros
simp [reverse]
intros
let b := basis.of_vector_space K V
split
intro hd
{ intro hd, rw [‚Üê b.mk_eq_dim'', cardinal.le_one_iff_subsingleton, subsingleton_coe] at hd, rcases eq_empty_or_nonempty (of_vector_space_index K V) with hb | ‚ü®‚ü®v‚ÇÄ, hv‚ÇÄ‚ü©‚ü©, { use 0, have h' : ‚àÄ v : V, v = 0, { simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm }, intro v, simp [h' v] }, { use v‚ÇÄ, have h' : (K ‚àô v‚ÇÄ) = ‚ä§, { simpa [hd.eq_singleton_of_mem hv‚ÇÄ] using b.span_eq }, intro v, have hv : v ‚àà (‚ä§ : submodule K V) := mem_top, rwa [‚Üêh', mem_span_singleton] at hv } }
rw [‚Üê b.mk_eq_dim'', cardinal.le_one_iff_subsingleton, subsingleton_coe] at hd
rcases eq_empty_or_nonempty (of_vector_space_index K V) with hb | ‚ü®‚ü®v‚ÇÄ, hv‚ÇÄ‚ü©‚ü©
use 0
{ use 0, have h' : ‚àÄ v : V, v = 0, { simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm }, intro v, simp [h' v] }
have h' : ‚àÄ v : V, v = 0
simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm
{ simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm }
intro v
simp [h' v]
use v‚ÇÄ
{ use v‚ÇÄ, have h' : (K ‚àô v‚ÇÄ) = ‚ä§, { simpa [hd.eq_singleton_of_mem hv‚ÇÄ] using b.span_eq }, intro v, have hv : v ‚àà (‚ä§ : submodule K V) := mem_top, rwa [‚Üêh', mem_span_singleton] at hv }
have h' : (K ‚àô v‚ÇÄ) = ‚ä§
simpa [hd.eq_singleton_of_mem hv‚ÇÄ] using b.span_eq
{ simpa [hd.eq_singleton_of_mem hv‚ÇÄ] using b.span_eq }
intro v
have hv : v ‚àà (‚ä§ : submodule K V) := mem_top
rwa [‚Üêh', mem_span_singleton] at hv
rintros ‚ü®v‚ÇÄ, hv‚ÇÄ‚ü©
{ rintros ‚ü®v‚ÇÄ, hv‚ÇÄ‚ü©, have h : (K ‚àô v‚ÇÄ) = ‚ä§, { ext, simp [mem_span_singleton, hv‚ÇÄ] }, rw [‚Üêdim_top, ‚Üêh], convert dim_span_le _, simp }
have h : (K ‚àô v‚ÇÄ) = ‚ä§
{ ext, simp [mem_span_singleton, hv‚ÇÄ] }
ext
simp [mem_span_singleton, hv‚ÇÄ]
rw [‚Üêdim_top, ‚Üêh]
convert dim_span_le _
simp
intros
simpa using v.mk_eq_dim
intros
rw [b.equiv_fun_apply, to_dual_eq_repr]
intros
{ ext, refl }
ext
refl
intros
{ rw h, exact subalgebra.finrank_bot }
rw h
exact subalgebra.finrank_bot
intros
rw [equiv_map_domain_eq_map_domain, total_map_domain _ _ f.injective]
intros
refine ‚ü®Œª H g, by simpa using linear_independent_iff'.1 H finset.univ g, Œª H, linear_independent_iff''.2 $ Œª s g hg hs i, H _ _ _‚ü©
rw ‚Üê hs
refine (finset.sum_subset (finset.subset_univ _) (Œª i _ hi, _)).symm
rw [hg i hi, zero_smul]
intros
simp only [disjoint_def, finsupp.mem_span_image_iff_total]
rintros _ ‚ü®l‚ÇÅ, hl‚ÇÅ, rfl‚ü© ‚ü®l‚ÇÇ, hl‚ÇÇ, H‚ü©
rw [hv.injective_total.eq_iff] at H
subst l‚ÇÇ
have : l‚ÇÅ = 0 := finsupp.disjoint_supported_supported hs (submodule.mem_inf.2 ‚ü®hl‚ÇÅ, hl‚ÇÇ‚ü©)
simp [this]
intros
ext i j x
by_cases h : i = j
simp [h]
all_goals { simp [h] }
simp [h]
intros
rw [det_mul, det_mul, mul_comm]
intros
rw adjugate_def
{ rw adjugate_def, simp only, rw [cramer_apply, update_column_transpose, det_transpose], }
simp only
rw [cramer_apply, update_column_transpose, det_transpose]
intros
rw [‚Üê(inv_eq_right_inv h), ‚Üê(inv_eq_left_inv g)]
intros
rw [matrix.to_lin'_mul, linear_map.comp_apply]
intros
convert matrix.to_lin_mul v‚ÇÅ v‚ÇÅ v‚ÇÅ A B
intros
rw [‚Üê update_row_eq_transvection i j, det_update_row_add_smul_self _ h, det_one]
intros
ext m
have : m = (Œªi, m i ‚Ä¢ 1)
ext j
ext j
{ ext j, simp }
{ ext j, simp }
simp
simp
conv_rhs { rw [this, f.map_smul_univ] }
refl
intros
dsimp only [ker]
rw [‚Üêprod_map_comap_prod, submodule.prod_bot]
intros
simp [comap_map_eq, sup_comm]
intros
rw [smodeq.def, submodule.quotient.eq, mem_bot, sub_eq_zero]
intros
let s : subalgebra R (tensor_algebra R M) := { carrier := C, mul_mem' := h_mul, add_mem' := h_add, algebra_map_mem' := h_grade0, }
let of : M ‚Üí‚Çó[R] s := (Œπ R).cod_restrict s.to_submodule h_grade1
have of_id : alg_hom.id R (tensor_algebra R M) = s.val.comp (lift R of)
ext
{ ext, simp [of], }
simp [of]
convert subtype.prop (lift R of a)
exact alg_hom.congr_fun of_id a
intros
{ subst hx, subst hy }
subst hx
subst hy
intros
rw iterate_add
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
cases h with c _ hac hcb
{ cases h with c _ hac hcb, { exact or.inl rfl }, { exact or.inr (trans_gen.tail' hac hcb) } }
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr (trans_gen.tail' hac hcb) }
exact or.inr (trans_gen.tail' hac hcb)
{ rcases h with rfl | h, {refl}, {exact h.to_refl} }
rcases h with rfl | h
refl
{refl}
exact h.to_refl
{exact h.to_refl}
intros
{ rw ‚Üê pi_univ_Iic, exact pi_Iio_ae_eq_pi_Iic }
rw ‚Üê pi_univ_Iic
exact pi_Iio_ae_eq_pi_Iic
intros
induction n with m hm
refine ‚ü®_, _‚ü©
{ refine ‚ü®_, _‚ü©, { simp [(hf 0).1] }, { intros A hA, simp [(hf 0).2 A hA] } }
{ simp [(hf 0).1] }
simp [(hf 0).1]
{ intros A hA, simp [(hf 0).2 A hA] }
intros A hA
simp [(hf 0).2 A hA]
have : (Œª (a : Œ±), ‚®Ü (k : ‚Ñï) (hk : k ‚â§ m + 1), f k a) = (Œª a, f m.succ a ‚äî ‚®Ü (k : ‚Ñï) (hk : k ‚â§ m), f k a)
{ have : (Œª (a : Œ±), ‚®Ü (k : ‚Ñï) (hk : k ‚â§ m + 1), f k a) = (Œª a, f m.succ a ‚äî ‚®Ü (k : ‚Ñï) (hk : k ‚â§ m), f k a), { exact funext (Œª _, supr_succ_eq_sup _ _ _) }, refine ‚ü®measurable_supr (Œª n, measurable.supr_Prop _ (hf n).1), Œª A hA, _‚ü©, rw this, exact (sup_mem_measurable_le (hf m.succ) hm).2 A hA }
{ exact funext (Œª _, supr_succ_eq_sup _ _ _) }
exact funext (Œª _, supr_succ_eq_sup _ _ _)
refine ‚ü®measurable_supr (Œª n, measurable.supr_Prop _ (hf n).1), Œª A hA, _‚ü©
rw this
exact (sup_mem_measurable_le (hf m.succ) hm).2 A hA
intros
simp_rw sub_eq_add_neg
exact (condexp_add hf hg.neg).trans (eventually_eq.rfl.add (condexp_neg g))
intros
rw indicator_const_Lp_eq_to_span_singleton_comp_Lp hs hŒºs x
have h_comp := condexp_L2_comp_continuous_linear_map ‚Ñù ùïú hm (to_span_singleton ‚Ñù x) (indicator_const_Lp 2 hs hŒºs (1 : ‚Ñù))
refine h_comp.trans _
exact (to_span_singleton ‚Ñù x).coe_fn_comp_Lp _
intros
apply Lp.norm_le_of_ae_bound (norm_nonneg f)
refine (f.to_continuous_map.coe_fn_to_ae_eq_fun Œº).mono _
{ refine (f.to_continuous_map.coe_fn_to_ae_eq_fun Œº).mono _, intros x hx, convert f.norm_coe_le_norm x }
intros x hx
convert f.norm_coe_le_norm x
{ apply_instance }
apply_instance
intros
dsimp only [approx_on, coe_comp, (‚àò)]
exact edist_nearest_pt_le _ _ ((nearest_pt_ind_le _ _ _).trans h)
intros
rw ‚Üê mem_‚Ñíp_one_iff_integrable
{ rw ‚Üê mem_‚Ñíp_one_iff_integrable, exact (Lp.simple_func.mem_‚Ñíp f) }
exact (Lp.simple_func.mem_‚Ñíp f)
intros
simpa only [‚Üê pi.multiset_prod_apply] using s.ae_measurable_prod' hs
intros
haveI : is_finite_measure (Œº.restrict s) := ‚ü®by rwa [measure.restrict_apply_univ]‚ü©
haveI : is_finite_measure (Œº.restrict s) := ‚ü®by rwa [measure.restrict_apply_univ]‚ü©; exact has_finite_integral_of_bounded hf
exact has_finite_integral_of_bounded hf
intros
simp only [interval_integral, neg_sub]
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
convert (monotone_lintegral Œº).le_map_supr2 f
{ convert (monotone_lintegral Œº).le_map_supr2 f, ext1 a, simp only [supr_apply] }
ext1 a
simp only [supr_apply]
intros
ext
ext; simp
simp
intros
simp only [lintegral, ‚Üê H]
apply lintegral_eq_of_subset
simp only [H]
intros
exact mem_range_of_measure_ne_zero ‚Äπ_‚Ä∫
intros
rw [measure.restrict_univ]
intros
simp_rw set_to_L1s
rw ‚Üê simple_func.set_to_simple_func_smul T h_add h_smul c (simple_func.integrable f)
refine simple_func.set_to_simple_func_congr T h_zero h_add (simple_func.integrable _) _
exact smul_to_simple_func c f
intros
refine measurable_find_greatest' (Œª k hk, _)
simp only [nat.find_greatest_eq_iff, set_of_and, set_of_forall, ‚Üê compl_set_of]
repeat { apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros } }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
intros
let eval : (compacts G ‚Üí ‚Ñù) ‚Üí ‚Ñù := Œª f, f K‚ÇÅ + f K‚ÇÇ - f (K‚ÇÅ ‚äî K‚ÇÇ)
have : continuous eval := ((@continuous_add ‚Ñù _ _ _).comp ((continuous_apply K‚ÇÅ).prod_mk (continuous_apply K‚ÇÇ))).sub (continuous_apply (K‚ÇÅ ‚äî K‚ÇÇ))
rw [‚Üê sub_nonneg]
show chaar K‚ÇÄ ‚àà eval ‚Åª¬π' (Ici (0 : ‚Ñù))
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K‚ÇÄ ‚ü®set.univ, is_open_univ, mem_univ _‚ü©)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©
{ rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©, simp only [mem_preimage, mem_Ici, eval, sub_nonneg], apply prehaar_sup_le, rw h2U.interior_eq, exact ‚ü®1, h3U‚ü© }
simp only [mem_preimage, mem_Ici, eval, sub_nonneg]
apply prehaar_sup_le
rw h2U.interior_eq
exact ‚ü®1, h3U‚ü©
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_Ici }
exact is_closed_Ici
intros
simp only [ae_iff, ‚Üê compl_set_of, restrict_apply_eq_zero' hs]
congr' with x
simp [and_comm]
intros
convert set.ext_iff.1 (preimage_spanning_sets_index_singleton Œº n) x
intros
{ unfold trim, congr, funext s hs, exact H hs }
unfold trim
congr
funext s hs
exact H hs
intros
cases eq_or_ne (Œº U) 0 with h‚ÇÄ h‚ÇÄ
refine ‚ü®‚àÖ, empty_subset _, h0, _‚ü©
{ refine ‚ü®‚àÖ, empty_subset _, h0, _‚ü©, rwa [measure_empty, h‚ÇÄ, zero_add, pos_iff_ne_zero] }
rwa [measure_empty, h‚ÇÄ, zero_add, pos_iff_ne_zero]
rcases H hU _ (ennreal.sub_lt_self hŒºU h‚ÇÄ hŒµ) with ‚ü®K, hKU, hKc, hrK‚ü©
{ rcases H hU _ (ennreal.sub_lt_self hŒºU h‚ÇÄ hŒµ) with ‚ü®K, hKU, hKc, hrK‚ü©, exact ‚ü®K, hKU, hKc, ennreal.lt_add_of_sub_lt (or.inl hŒºU) hrK‚ü© }
exact ‚ü®K, hKU, hKc, ennreal.lt_add_of_sub_lt (or.inl hŒºU) hrK‚ü©
intros
{ ext i hi, simp }
ext i hi
simp
intros
by_cases hi‚ÇÅ : measurable_set i
exact (restrict_le_restrict_iff _ _ hi‚ÇÅ).1 hi‚ÇÇ hi‚ÇÅ set.subset.rfl
{ exact (restrict_le_restrict_iff _ _ hi‚ÇÅ).1 hi‚ÇÇ hi‚ÇÅ set.subset.rfl }
{ rw v.not_measurable hi‚ÇÅ }
rw v.not_measurable hi‚ÇÅ
intros
ext n
simp only [mul_apply, smul_apply, sum_smul, mul_smul, smul_sum, finset.sum_sigma']
apply finset.sum_bij
swap 5
{ rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H, exact ‚ü®(k, l*j), (l, j)‚ü© }
rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H
exact ‚ü®(k, l*j), (l, j)‚ü©
rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H
{ rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H, simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ‚ä¢, rcases H with ‚ü®‚ü®rfl, n0‚ü©, rfl, i0‚ü©, refine ‚ü®‚ü®(mul_assoc _ _ _).symm, n0‚ü©, rfl, _‚ü©, rw mul_ne_zero_iff at *, exact ‚ü®i0.2, n0.2‚ü©, }
simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ‚ä¢
rcases H with ‚ü®‚ü®rfl, n0‚ü©, rfl, i0‚ü©
refine ‚ü®‚ü®(mul_assoc _ _ _).symm, n0‚ü©, rfl, _‚ü©
rw mul_ne_zero_iff at *
exact ‚ü®i0.2, n0.2‚ü©
{ rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H, simp only [mul_assoc] }
rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H
simp only [mul_assoc]
rintros ‚ü®‚ü®a,b‚ü©, ‚ü®c,d‚ü©‚ü© ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H‚ÇÅ H‚ÇÇ
{ rintros ‚ü®‚ü®a,b‚ü©, ‚ü®c,d‚ü©‚ü© ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H‚ÇÅ H‚ÇÇ, simp only [finset.mem_sigma, mem_divisors_antidiagonal, and_imp, prod.mk.inj_iff, add_comm, heq_iff_eq] at H‚ÇÅ H‚ÇÇ ‚ä¢, rintros rfl h2 rfl rfl, exact ‚ü®‚ü®eq.trans H‚ÇÅ.2.1.symm H‚ÇÇ.2.1, rfl‚ü©, rfl, rfl‚ü© }
simp only [finset.mem_sigma, mem_divisors_antidiagonal, and_imp, prod.mk.inj_iff, add_comm, heq_iff_eq] at H‚ÇÅ H‚ÇÇ ‚ä¢
rintros rfl h2 rfl rfl
exact ‚ü®‚ü®eq.trans H‚ÇÅ.2.1.symm H‚ÇÇ.2.1, rfl‚ü©, rfl, rfl‚ü©
rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H
{ rintros ‚ü®‚ü®i,j‚ü©, ‚ü®k,l‚ü©‚ü© H, refine ‚ü®‚ü®(i*k, l), (i, k)‚ü©, _, _‚ü©, { simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ‚ä¢, rcases H with ‚ü®‚ü®rfl, n0‚ü©, rfl, j0‚ü©, refine ‚ü®‚ü®mul_assoc _ _ _, n0‚ü©, rfl, _‚ü©, rw mul_ne_zero_iff at *, exact ‚ü®n0.1, j0.1‚ü© }, { simp only [true_and, mem_divisors_antidiagonal, and_true, prod.mk.inj_iff, eq_self_iff_true, ne.def, mem_sigma, heq_iff_eq] at H ‚ä¢, rw H.2.1 } }
refine ‚ü®‚ü®(i*k, l), (i, k)‚ü©, _, _‚ü©
simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ‚ä¢
{ simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ‚ä¢, rcases H with ‚ü®‚ü®rfl, n0‚ü©, rfl, j0‚ü©, refine ‚ü®‚ü®mul_assoc _ _ _, n0‚ü©, rfl, _‚ü©, rw mul_ne_zero_iff at *, exact ‚ü®n0.1, j0.1‚ü© }
rcases H with ‚ü®‚ü®rfl, n0‚ü©, rfl, j0‚ü©
refine ‚ü®‚ü®mul_assoc _ _ _, n0‚ü©, rfl, _‚ü©
rw mul_ne_zero_iff at *
exact ‚ü®n0.1, j0.1‚ü©
simp only [true_and, mem_divisors_antidiagonal, and_true, prod.mk.inj_iff, eq_self_iff_true, ne.def, mem_sigma, heq_iff_eq] at H ‚ä¢
{ simp only [true_and, mem_divisors_antidiagonal, and_true, prod.mk.inj_iff, eq_self_iff_true, ne.def, mem_sigma, heq_iff_eq] at H ‚ä¢, rw H.2.1 }
rw H.2.1
intros
revert h0
apply s.induction_on
simp
simp
intros a t h h0
rw [multiset.prod_cons, mul_ne_zero_iff] at h0
simp [h0, card_factors_mul, h]
intros
rw [mem_proper_divisors, and_iff_right (one_dvd _)]
intros
intro h
obtain ‚ü®a0, b0, c0, ‚ü®hf, h2, hp‚ü©‚ü© := fermat_42.exists_pos_odd_minimal (and.intro ha (and.intro hb h))
apply fermat_42.not_minimal hf h2 hp
intros
induction n
{ refl, }
refl
{ dsimp, simp only [add_zero], exact n_ih, }
dsimp
simp only [add_zero]
exact n_ih
intros
simp [norm_def]
intros
apply le_antisymm
intros x hx
{ intros x hx, rw ideal.mem_span_singleton, simp only [local_ring.mem_maximal_ideal, mem_nonunits] at hx, rwa ‚Üê norm_lt_one_iff_dvd, }
rw ideal.mem_span_singleton
simp only [local_ring.mem_maximal_ideal, mem_nonunits] at hx
rwa ‚Üê norm_lt_one_iff_dvd
rw [ideal.span_le, set.singleton_subset_iff]
{ rw [ideal.span_le, set.singleton_subset_iff], exact p_nonnunit }
exact p_nonnunit
intros
cases nat.eq_zero_or_pos n with hn hn
{ rw hn, exact dvd_zero (p ^ padic_val_nat p 0) }
rw hn
exact dvd_zero (p ^ padic_val_nat p 0)
rw multiplicity.pow_dvd_iff_le_multiplicity
{ rw multiplicity.pow_dvd_iff_le_multiplicity, apply le_of_eq, rw padic_val_nat_def (ne_of_gt hn), { apply enat.coe_get }, { apply_instance } }
apply le_of_eq
rw padic_val_nat_def (ne_of_gt hn)
{ apply enat.coe_get }
apply enat.coe_get
{ apply_instance }
apply_instance
intros
simp [cast_eq_of_rat]
intros
obtain ‚ü®m, n, H‚ü© := hp
use [1, m, n]
rcases H with ‚ü®‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, co, pp‚ü©
rcases H with ‚ü®‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, co, pp‚ü©; { apply and.intro _ co, rw one_mul, rw one_mul, tauto }
{ apply and.intro _ co, rw one_mul, rw one_mul, tauto }
{ apply and.intro _ co, rw one_mul, rw one_mul, tauto }
apply and.intro _ co
rw one_mul
rw one_mul
tauto
intros
simp only [ext, true_and, conj_re, eq_self_iff_true, neg_neg, conj_im]
intros
simp [bit1]
intros
{ rw h.lower_bounds_eq, refl }
rw h.lower_bounds_eq
refl
intros
simp only [Sup_eq_supr, compl_supr]
intros
finish
intros
rw [‚Üê map_coe_Ici_at_top a, comap_map subtype.coe_injective]
intros
simp [‚Üê prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]
intros
refine mt (Œª h, hq.mp $ h.mono _) hp
exact Œª x hpq hq hp, hpq ‚ü®hp, hq‚ü©
intros
simp only [eventually_eq, eventually_le, le_antisymm_iff, eventually_and]
intros
simpa only [filter.eventually, set_of_forall] using Inter_mem
intros
rw rtendsto_def
change (‚àÄ (s : set Œ≤), s ‚àà l‚ÇÇ.sets ‚Üí r.core s ‚àà l‚ÇÅ) ‚Üî l‚ÇÅ ‚â§ rcomap r l‚ÇÇ
simp [filter.le_def, rcomap, rel.mem_image]
split
{ exact Œª h s t tl‚ÇÇ, mem_of_superset (h t tl‚ÇÇ) }
exact Œª h s t tl‚ÇÇ, mem_of_superset (h t tl‚ÇÇ)
{ exact Œª h t tl‚ÇÇ, h _ t tl‚ÇÇ set.subset.rfl }
exact Œª h t tl‚ÇÇ, h _ t tl‚ÇÇ set.subset.rfl
intros
{ rw ‚Üê h, simp }
rw ‚Üê h
simp
intros
ext
ext; refl
refl
intros
induction m with m ih
{ exact h 0 n hmn.ne, }
exact h 0 n hmn.ne
rw [partial_sups_succ, disjoint_sup_left]
{ rw [partial_sups_succ, disjoint_sup_left], exact ‚ü®ih (nat.lt_of_succ_lt hmn), h (m + 1) n hmn.ne‚ü© }
exact ‚ü®ih (nat.lt_of_succ_lt hmn), h (m + 1) n hmn.ne‚ü©
intros
rw [symm_diff_comm, ‚Üêsymm_diff_assoc, symm_diff_self, bot_symm_diff]
intros
rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]
congr' 1 with z
simp [submonoid.closure_union, submonoid.mem_sup, set.mem_mul]
intros
{ rw mul_comm, exact h.add_mul_left_left z }
rw mul_comm
exact h.add_mul_left_left z
intros
refine Œª f, induction_on f (Œª m, _) _ _
have : m ‚àà closure S := hS.symm ‚ñ∏ mem_top _
{ have : m ‚àà closure S := hS.symm ‚ñ∏ mem_top _, refine closure_induction this (Œª m hm, _) _ _, { exact ‚ü®mv_polynomial.X ‚ü®m, hm‚ü©, mv_polynomial.aeval_X _ _‚ü© }, { exact ‚ü®1, alg_hom.map_one _‚ü© }, { rintro m‚ÇÅ m‚ÇÇ ‚ü®P‚ÇÅ, hP‚ÇÅ‚ü© ‚ü®P‚ÇÇ, hP‚ÇÇ‚ü©, exact ‚ü®P‚ÇÅ * P‚ÇÇ, by rw [alg_hom.map_mul, hP‚ÇÅ, hP‚ÇÇ, of_apply, of_apply, of_apply, single_mul_single, one_mul]; refl‚ü© } }
refine closure_induction this (Œª m hm, _) _ _
{ exact ‚ü®mv_polynomial.X ‚ü®m, hm‚ü©, mv_polynomial.aeval_X _ _‚ü© }
exact ‚ü®mv_polynomial.X ‚ü®m, hm‚ü©, mv_polynomial.aeval_X _ _‚ü©
{ exact ‚ü®1, alg_hom.map_one _‚ü© }
exact ‚ü®1, alg_hom.map_one _‚ü©
rintro m‚ÇÅ m‚ÇÇ ‚ü®P‚ÇÅ, hP‚ÇÅ‚ü© ‚ü®P‚ÇÇ, hP‚ÇÇ‚ü©
{ rintro m‚ÇÅ m‚ÇÇ ‚ü®P‚ÇÅ, hP‚ÇÅ‚ü© ‚ü®P‚ÇÇ, hP‚ÇÇ‚ü©, exact ‚ü®P‚ÇÅ * P‚ÇÇ, by rw [alg_hom.map_mul, hP‚ÇÅ, hP‚ÇÇ, of_apply, of_apply, of_apply, single_mul_single, one_mul]; refl‚ü© }
exact ‚ü®P‚ÇÅ * P‚ÇÇ, by rw [alg_hom.map_mul, hP‚ÇÅ, hP‚ÇÇ, of_apply, of_apply, of_apply, single_mul_single, one_mul]; refl‚ü©
rintro f g ‚ü®P, rfl‚ü© ‚ü®Q, rfl‚ü©
{ rintro f g ‚ü®P, rfl‚ü© ‚ü®Q, rfl‚ü©, exact ‚ü®P + Q, alg_hom.map_add _ _ _‚ü© }
exact ‚ü®P + Q, alg_hom.map_add _ _ _‚ü©
rintro r f ‚ü®P, rfl‚ü©
{ rintro r f ‚ü®P, rfl‚ü©, exact ‚ü®r ‚Ä¢ P, alg_hom.map_smul _ _ _‚ü© }
exact ‚ü®r ‚Ä¢ P, alg_hom.map_smul _ _ _‚ü©
intros
obtain ‚ü®d, J, h_nzd, rfl‚ü© := exists_eq_span_singleton_mul I
apply is_noetherian_span_singleton_inv_to_map_mul
apply is_noetherian_coe_to_fractional_ideal
intros
rw [‚Üêcanonical_equiv_symm, ring_equiv.symm_apply_apply]
intros
refine or_iff_not_imp_left.2 (Œª ne_top, ‚ü®‚ü®Œª h, ne_top h, Œª J hJ, _‚ü©‚ü©)
refine (rel_iso_of_surjective f hf).injective (subtype.ext_iff.2 (eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm))
{ refine (rel_iso_of_surjective f hf).injective (subtype.ext_iff.2 (eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm)), { exact (map_le_iff_le_comap).1 (le_of_lt hJ) }, { exact Œª h, hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm)) } }
{ exact (map_le_iff_le_comap).1 (le_of_lt hJ) }
exact (map_le_iff_le_comap).1 (le_of_lt hJ)
exact Œª h, hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm))
{ exact Œª h, hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm)) }
intros
refine (quotient_map I f H).injective_iff.2 (Œª a ha, _)
obtain ‚ü®r, rfl‚ü© := quotient.mk_surjective a
rw [quotient_map_mk, quotient.eq_zero_iff_mem] at ha
exact (quotient.eq_zero_iff_mem).mpr (h ha)
intros
rw int.associated_iff_nat_abs
exact int.nat_abs_eq_nat_abs_iff
intros
rw [coe_submodule_span, set.image_singleton]
intros
{ ext n, simp [coeff_map] }
ext n
simp [coeff_map]
intros
{ rw [‚Üê mul_one X, content_X_mul, content_one] }
rw [‚Üê mul_one X, content_X_mul, content_one]
intros
rw [cyclotomic']
have prim_root_two : primitive_roots 2 R = {(-1 : R)}
apply finset.eq_singleton_iff_unique_mem.2
{ apply finset.eq_singleton_iff_unique_mem.2, split, { simp only [is_primitive_root.neg_one p hp, nat.succ_pos', mem_primitive_roots] }, { intros x hx, rw [mem_primitive_roots zero_lt_two] at hx, exact is_primitive_root.eq_neg_one_of_two_right hx } }
split
simp only [is_primitive_root.neg_one p hp, nat.succ_pos', mem_primitive_roots]
{ simp only [is_primitive_root.neg_one p hp, nat.succ_pos', mem_primitive_roots] }
intros x hx
{ intros x hx, rw [mem_primitive_roots zero_lt_two] at hx, exact is_primitive_root.eq_neg_one_of_two_right hx }
rw [mem_primitive_roots zero_lt_two] at hx
exact is_primitive_root.eq_neg_one_of_two_right hx
simp only [prim_root_two, finset.prod_singleton, ring_hom.map_neg, ring_hom.map_one, sub_neg_eq_add]
intros
ext
rw [finsupp.mem_supported, set.subset_def]
simp only [finsupp.mem_support_iff, finset.mem_coe]
refl
intros
simp only [nat_degree, degree_scale_roots]
intros
split_ifs with h
{ rw [h, order_eq_top, linear_map.map_zero] }
rw [h, order_eq_top, linear_map.map_zero]
rw [order_eq]
{ rw [order_eq], split; intros i hi, { rw [enat.coe_inj] at hi, rwa [hi, coeff_monomial_same] }, { rw [enat.coe_lt_coe] at hi, rw [coeff_monomial, if_neg], exact ne_of_lt hi } }
split
split; intros i hi
intros i hi
{ rw [enat.coe_inj] at hi, rwa [hi, coeff_monomial_same] }
rw [enat.coe_inj] at hi
rwa [hi, coeff_monomial_same]
intros i hi
rw [enat.coe_lt_coe] at hi
{ rw [enat.coe_lt_coe] at hi, rw [coeff_monomial, if_neg], exact ne_of_lt hi }
rw [coeff_monomial, if_neg]
exact ne_of_lt hi
intros
simp [mul_sub, sub_sub_cancel]
intros
use (X ^ n - 1)
split
{ exact (monic_X_pow_sub_C 1 (ne_of_lt hpos).symm) }
exact (monic_X_pow_sub_C 1 (ne_of_lt hpos).symm)
simp only [((is_primitive_root.iff_def Œº n).mp h).left, eval‚ÇÇ_one, eval‚ÇÇ_X_pow, eval‚ÇÇ_sub, sub_self]
{ simp only [((is_primitive_root.iff_def Œº n).mp h).left, eval‚ÇÇ_one, eval‚ÇÇ_X_pow, eval‚ÇÇ_sub, sub_self] }
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
apply eq_of_prod_eq_prod
rw associates.factors_prod
exact multiset.prod_zero
intros
rw sub_eq_add_neg
exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)
intros
map_fun_tac
intros
have inj : function.injective (int.cast_ring_hom ‚Ñö)
{ intros m n, exact int.cast_inj.mp, }
intros m n
exact int.cast_inj.mp
apply inj
rw [‚Üê constant_coeff_map, map_witt_structure_int, constant_coeff_witt_structure_rat_zero, constant_coeff_map]
rw ordinal.univ_id; exact quotient.sound ‚ü®aleph_idx.rel_iso‚ü©
rw ordinal.univ_id
exact quotient.sound ‚ü®aleph_idx.rel_iso‚ü©
intros
rw [add_comm a b, add_comm c b] at h
{ rw [add_comm a b, add_comm c b] at h, exact cardinal.eq_of_add_eq_add_left h hb }
exact cardinal.eq_of_add_eq_add_left h hb
intros
simp [mem_def, or_and_distrib_right, exists_or_distrib]
intros
rw [‚Üê not_le, ‚Üê not_le, ord_le]
intros
refine eq.trans _ (by rw [‚Üêquotient.out_eq o])
{ refine eq.trans _ (by rw [‚Üêquotient.out_eq o]), cases quotient.out o, refl }
cases quotient.out o
refl
intros
rw [‚Üê cardinal.ord_nat, ‚Üê cardinal.ord_nat, cardinal.ord_le_ord, cardinal.nat_cast_le]
intros
rw lt_def
dsimp
simp [forall_pempty, exists_pempty]
intros
simp *
intros
rw [‚Üê h, ‚Üê hm, int.add_mul_mod_self, int.mod_eq_of_lt h‚ÇÅ h‚ÇÇ]
intros
cases t1
cases t2
simp only [coeffs.val_add, add, val, add_comm, add_left_comm]
intros
cc
intros
simp [is_open_def, h]
intros
{ rw ‚Üênat.cofinite_eq_at_top, exact hf.tendsto_cofinite_zero }
rw ‚Üênat.cofinite_eq_at_top
exact hf.tendsto_cofinite_zero
intros
rw [‚Üê supr_decode‚ÇÇ, ‚Üê tsum_supr_decode‚ÇÇ _ m0 s]
{ rw [‚Üê supr_decode‚ÇÇ, ‚Üê tsum_supr_decode‚ÇÇ _ m0 s], exact m_supr _ }
exact m_supr _
intros
simp [tsum, h]
intros
rcases hs with ‚ü®a', ha'‚ü©
intro h
rcases (ha.1 ha').eq_or_lt with (rfl|ha'a)
{ exact h.self_of_nhds_within le_rfl ha' }
exact h.self_of_nhds_within le_rfl ha'
rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with ‚ü®b, hba, hb‚ü©
{ rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with ‚ü®b, hba, hb‚ü©, rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©, exact hb hb' hb's }
rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©
exact hb hb' hb's
intros
rw [‚Üê map_coe_Ioo_at_bot h, tendsto_map'_iff]
intros
{ rw [‚Üê is_open_compl_iff, compl_empty], exact is_open_univ }
rw [‚Üê is_open_compl_iff, compl_empty]
exact is_open_univ
intros
{ rw [‚Üêfrontier_compl, ‚Üêclosure_compl], refl }
rw [‚Üêfrontier_compl, ‚Üêclosure_compl]
refl
intros
simp_rw [is_closed_iff_cluster_pt, cluster_pt, inf_principal_ne_bot_iff]
intros
rw [pi_def]; exact (is_closed_Inter $ Œª a, is_closed_Inter $ Œª ha, (hs _ ha).preimage (continuous_apply _))
rw [pi_def]
exact (is_closed_Inter $ Œª a, is_closed_Inter $ Œª ha, (hs _ ha).preimage (continuous_apply _))
intros
let f' : C(set.Icc a b, ‚Ñù) := ‚ü®Œª x, f x, continuous_on_iff_continuous_restrict.mp c‚ü©
obtain ‚ü®p, b‚ü© := exists_polynomial_near_continuous_map a b f' Œµ pos
use p
rw norm_lt_iff _ pos at b
intros x m
exact b ‚ü®x, m‚ü©
intros
apply tendsto.piecewise; rwa ‚Üê nhds_within_inter'
apply tendsto.piecewise
rwa ‚Üê nhds_within_inter'
rwa ‚Üê nhds_within_inter'
intros
rw continuous_iff_continuous_on_univ at *
exact hg.comp hf (Œª x _, hs x)
intros
ext ‚ü®‚ü©
{ ext ‚ü®‚ü©, refl }
refl
intros
refine inter_eq_right_iff_subset.mpr (Œª x hx, _)
simp only [mem_preimage, local_equiv.inv_fun_as_coe, e.proj_symm_apply hx]
exact e.mem_target.mp hx
intros
refine le_antisymm (diam_le $ Œª x hx y hy, _) (diam_mono subset_closure)
have : edist x y ‚àà closure (Iic (diam s))
from map_mem_closure2 (@continuous_edist Œ± _) hx hy (Œª _ _, edist_le_diam_of_mem)
rwa closure_Iic at this
intros
apply tendsto.const_mul (ennreal.tendsto_inv_iff.2 hm)
{ apply tendsto.const_mul (ennreal.tendsto_inv_iff.2 hm), simp [hb] }
simp [hb]
intros
rw [‚Üê @not_not (‚àë' a, ‚Üë(f a) = ‚ä§)]
exact not_congr tsum_coe_ne_top_iff_summable_coe
intros
rw [nhds_top', mem_infi_of_directed]
{ refl }
refl
exact Œª x y, ‚ü®max x y, by simp [le_refl], by simp [le_refl]‚ü©
intros
rw [of_set_trans, restr_source_inter]
intros
ext
{ ext, refl }
refl
intros
simp [continuous_iff_continuous_at, continuous_at, inducing.tendsto_nhds_iff hg]
intros
rcases h with ‚ü®x, ‚ü®xs, xt‚ü©‚ü©
simpa using diam_union xs xt
intros
rw dist_comm
rw dist_comm; refl
refl
intros
ext s
rw mem_infi_of_directed
{ simp [completion.mem_uniformity_dist, subset_def] }
simp [completion.mem_uniformity_dist, subset_def]
rintro ‚ü®r, hr‚ü© ‚ü®p, hp‚ü©
{ rintro ‚ü®r, hr‚ü© ‚ü®p, hp‚ü©, use ‚ü®min r p, lt_min hr hp‚ü©, simp [lt_min_iff, (‚â•)] {contextual := tt} }
use ‚ü®min r p, lt_min hr hp‚ü©
simp [lt_min_iff, (‚â•)] {contextual := tt}
intros
rcases subset_countable_closure_of_compact hs with ‚ü®t, hts, htc, hsub‚ü©
exact ‚ü®t, hts, htc, subset.antisymm hsub (closure_minimal hts hs.is_closed)‚ü©
intros
rcases hs with ‚ü®x, xs‚ü©
rcases ht with ‚ü®y, yt‚ü©
refine Hausdorff_edist_le_of_mem_edist _ _
intros z hz
{ intros z hz, exact ‚ü®y, yt, edist_le_diam_of_mem (subset_union_left _ _ hz) (subset_union_right _ _ yt)‚ü© }
exact ‚ü®y, yt, edist_le_diam_of_mem (subset_union_left _ _ hz) (subset_union_right _ _ yt)‚ü©
intros z hz
{ intros z hz, exact ‚ü®x, xs, edist_le_diam_of_mem (subset_union_right _ _ hz) (subset_union_left _ _ xs)‚ü© }
exact ‚ü®x, xs, edist_le_diam_of_mem (subset_union_right _ _ hz) (subset_union_left _ _ xs)‚ü©
intros
rw Hausdorff_dist_comm at H
rw Hausdorff_edist_comm at fin
simpa [dist_comm] using exists_dist_lt_of_Hausdorff_dist_lt h H fin
intros
simp [path_connected_space_iff_univ, is_path_connected_iff_eq]
intros
refine ‚ü®is_open.inter h.1 ha, _‚ü©
have : is_closed (Z ‚à© b·∂ú) := is_closed.inter h.2 (is_closed_compl_iff.2 hb)
convert this using 1
apply subset.antisymm
exact inter_subset_inter_right Z (subset_compl_iff_disjoint.2 hab)
{ exact inter_subset_inter_right Z (subset_compl_iff_disjoint.2 hab) }
rintros x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
{ rintros x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©, exact ‚ü®hx‚ÇÅ, by simpa [not_mem_of_mem_compl hx‚ÇÇ] using cover hx‚ÇÅ‚ü© }
exact ‚ü®hx‚ÇÅ, by simpa [not_mem_of_mem_compl hx‚ÇÇ] using cover hx‚ÇÅ‚ü©
intros
rw [uniform_continuous‚ÇÇ_def, abstract_completion.extend‚ÇÇ, uncurry_curry]
apply uniform_continuous_extend
intros
simp [continuous_on, continuous_within_at_iff'_right]
intros
split
intros e s hs
{ intros e s hs, rcases Cauchy.mem_uniformity'.1 hs with ‚ü®t, tu, ts‚ü©, apply ts, rcases comp_mem_uniformity_sets tu with ‚ü®d, du, dt‚ü©, refine mem_prod_iff.2 ‚ü®_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), Œª x h, _‚ü©, cases x with a b, cases h with h‚ÇÅ h‚ÇÇ, rw ‚Üê e at h‚ÇÇ, exact dt ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© }
rcases Cauchy.mem_uniformity'.1 hs with ‚ü®t, tu, ts‚ü©
apply ts
rcases comp_mem_uniformity_sets tu with ‚ü®d, du, dt‚ü©
refine mem_prod_iff.2 ‚ü®_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), Œª x h, _‚ü©
cases x with a b
cases h with h‚ÇÅ h‚ÇÇ
rw ‚Üê e at h‚ÇÇ
exact dt ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü©
intros H
{ intros H, refine separated_def.1 (by apply_instance) _ _ (Œª t tu, _), rcases mem_uniformity_is_closed tu with ‚ü®d, du, dc, dt‚ü©, refine H {p | (Lim p.1.1, Lim p.2.1) ‚àà t} (Cauchy.mem_uniformity'.2 ‚ü®d, du, Œª f g h, _‚ü©), rcases mem_prod_iff.1 h with ‚ü®x, xf, y, yg, h‚ü©, have limc : ‚àÄ (f : Cauchy Œ±) (x ‚àà f.1), Lim f.1 ‚àà closure x, { intros f x xf, rw closure_eq_cluster_pts, exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf)) }, have := dc.closure_subset_iff.2 h, rw closure_prod_eq at this, refine dt (this ‚ü®_, _‚ü©); dsimp; apply limc; assumption }
refine separated_def.1 (by apply_instance) _ _ (Œª t tu, _)
rcases mem_uniformity_is_closed tu with ‚ü®d, du, dc, dt‚ü©
refine H {p | (Lim p.1.1, Lim p.2.1) ‚àà t} (Cauchy.mem_uniformity'.2 ‚ü®d, du, Œª f g h, _‚ü©)
rcases mem_prod_iff.1 h with ‚ü®x, xf, y, yg, h‚ü©
have limc : ‚àÄ (f : Cauchy Œ±) (x ‚àà f.1), Lim f.1 ‚àà closure x
intros f x xf
{ intros f x xf, rw closure_eq_cluster_pts, exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf)) }
rw closure_eq_cluster_pts
exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf))
have := dc.closure_subset_iff.2 h
rw closure_prod_eq at this
refine dt (this ‚ü®_, _‚ü©); dsimp; apply limc; assumption
refine dt (this ‚ü®_, _‚ü©); dsimp; apply limc
refine dt (this ‚ü®_, _‚ü©); dsimp
refine dt (this ‚ü®_, _‚ü©)
dsimp
apply limc
assumption
dsimp
apply limc
assumption
intros
rw [uniform_continuous, uniformity_prod_eq_prod, uniformity_quotient, uniformity_quotient, filter.prod_map_map_eq, filter.tendsto_map'_iff, filter.tendsto_map'_iff]
rwa [uniform_continuous, uniformity_prod_eq_prod, filter.tendsto_map'_iff] at hf
intros
simp only [CU.lim, approx_of_mem_C, h, csupr_const]
intros
simp [write', h]
intros
cases b; simp
cases b
simp
simp
intros
unfold sub_nat_nat
rw h
unfold sub_nat_nat._match_1
intros
rw [‚Üê int.add_zero (-a), ‚Üêh, ‚Üêint.add_assoc, int.add_left_neg, int.zero_add]
intros
have h := int.add_le_add_right h (-b)
rwa int.add_right_neg at h
intros
have h := int.add_lt_add_right h (-b)
rwa [int.add_comm b c, int.add_neg_cancel_right] at h
intros
unfold bitwise; rw [binary_rec_zero]
unfold bitwise
rw [binary_rec_zero]
intros
induction k with k
{ rw [nat.mul_zero, nat.sub_zero] }
rw [nat.mul_zero, nat.sub_zero]
have h‚ÇÇ : n * k ‚â§ x
{ have h‚ÇÇ : n * k ‚â§ x, { rw [mul_succ] at h‚ÇÅ, apply nat.le_trans _ h‚ÇÅ, apply nat.le_add_right _ n }, have h‚ÇÑ : x - n * k ‚â• n, { apply @nat.le_of_add_le_add_right (n*k), rw [nat.sub_add_cancel h‚ÇÇ], simp [mul_succ, nat.add_comm] at h‚ÇÅ, simp [h‚ÇÅ] }, rw [mul_succ, ‚Üê nat.sub_sub, ‚Üê mod_eq_sub_mod h‚ÇÑ, k_ih h‚ÇÇ] }
rw [mul_succ] at h‚ÇÅ
{ rw [mul_succ] at h‚ÇÅ, apply nat.le_trans _ h‚ÇÅ, apply nat.le_add_right _ n }
apply nat.le_trans _ h‚ÇÅ
apply nat.le_add_right _ n
have h‚ÇÑ : x - n * k ‚â• n
apply @nat.le_of_add_le_add_right (n*k)
{ apply @nat.le_of_add_le_add_right (n*k), rw [nat.sub_add_cancel h‚ÇÇ], simp [mul_succ, nat.add_comm] at h‚ÇÅ, simp [h‚ÇÅ] }
rw [nat.sub_add_cancel h‚ÇÇ]
simp [mul_succ, nat.add_comm] at h‚ÇÅ
simp [h‚ÇÅ]
rw [mul_succ, ‚Üê nat.sub_sub, ‚Üê mod_eq_sub_mod h‚ÇÑ, k_ih h‚ÇÇ]
intros
rw [nat.sub_sub, nat.sub_sub, nat.add_comm]
intros
refine vadd_left_cancel (p -·µ• p2) _
rw [vsub_vadd, ‚Üê h, vsub_vadd]
intros
simp [bit0, add_smul]
intros
split
split; intros h
intros h
rw [‚Üê mul_one a, ‚Üê lmul_left_apply a 1, h, linear_map.zero_apply]
{ rw [‚Üê mul_one a, ‚Üê lmul_left_apply a 1, h, linear_map.zero_apply], }
intros h
{ rw h, exact lmul_left_zero_eq_zero, }
rw h
exact lmul_left_zero_eq_zero
intros
induction n with n ih
simp [h]
{ simp [h] }
convert h.mul_mul ih; rw pow_succ
convert h.mul_mul ih
rw pow_succ
rw pow_succ
intros
haveI := classical.dec_eq Œ±
{ haveI := classical.dec_eq Œ±, rw [‚Üêprod_erase_mul _ _ ha, h, mul_zero] }
rw [‚Üêprod_erase_mul _ _ ha, h, mul_zero]
intros
{ classical, rw [finprod_def, dif_pos hf] }
classical
rw [finprod_def, dif_pos hf]
intros
rw prod_nat_cast
cases le_or_lt k n with hkn hnk
exact prod_congr rfl (Œª i hi, (nat.cast_sub $ (mem_range.1 hi).le.trans hkn).symm)
{ exact prod_congr rfl (Œª i hi, (nat.cast_sub $ (mem_range.1 hi).le.trans hkn).symm) }
rw ‚Üê mem_range at hnk
{ rw ‚Üê mem_range at hnk, rw [prod_eq_zero hnk, prod_eq_zero hnk]; simp }
rw [prod_eq_zero hnk, prod_eq_zero hnk]; simp
rw [prod_eq_zero hnk, prod_eq_zero hnk]
simp
simp
intros
{ rw ‚Üêcocone_naturality F f, refl }
rw ‚Üêcocone_naturality F f
refl
intros
rw [epi_iff_range_eq_top, linear_map.range_eq_top]
intros
obtain ‚ü®ppredConts, nth_conts_eq, ‚ü®rfl‚ü©‚ü© : ‚àÉ conts, g.continuants n = conts ‚àß conts.a = ppredA
from exists_conts_a_of_num nth_num_eq
obtain ‚ü®predConts, succ_nth_conts_eq, ‚ü®rfl‚ü©‚ü© : ‚àÉ conts, g.continuants (n + 1) = conts ‚àß conts.a = predA
from exists_conts_a_of_num succ_nth_num_eq
rw [num_eq_conts_a, (continuants_recurrence succ_nth_s_eq nth_conts_eq succ_nth_conts_eq)]
intros
rw [terminated_at_iff_s_none, part_num_none_iff_s_none]
intros
rw [_root_.mul_comm, direct_limit.mul_inv_cancel G f hp]
intros
simp
intros
apply iff.trans multiset.dvd_gcd
simp only [multiset.mem_map, and_imp, exists_imp_distrib]
exact ‚ü®Œª k b hb, k _ _ hb rfl, Œª k a' b hb h, h ‚ñ∏ k _ hb‚ü©
intros
rw [‚Üê mul_assoc, mul_right_inv, one_mul]
intros
{ dsimp [bit1], rw [add_mul, bit0_mul, one_mul], }
dsimp [bit1]
rw [add_mul, bit0_mul, one_mul]
intros
simpa only [sq] using abs_mul_abs_self x
intros
rw [mul_comm, div_mul_left ha]
intros
rw ‚Üêd_comp_eq_to_hom C r r'
apply kernel_subobject_comp_mono
intros
dsimp [mk_hom, mk_hom_aux]
induction n; congr
induction n
congr
congr
intros
dsimp [d_next]
simp only [chain_complex.next_nat_succ]
refl
intros
rw [‚Üê inf_mul_sup a b, ‚Üê sup_div_inf_eq_abs_div, div_eq_mul_inv, ‚Üê mul_assoc, mul_comm, mul_assoc, ‚Üê pow_two, inv_mul_cancel_left]
intros
{ rw lie_comm, exact lie_le_right I J, }
rw lie_comm
exact lie_le_right I J
intros
simp only [of_le, hom_of_le_apply, lie_hom.mem_range]
split
{ rintros ‚ü®y, rfl‚ü©, exact y.property, }
rintros ‚ü®y, rfl‚ü©
exact y.property
{ intros h, use ‚ü®(x : L), h‚ü©, simp, }
intros h
use ‚ü®(x : L), h‚ü©
simp
intros
let J : lie_ideal R L' := { lie_mem := Œª x y hy, begin have hy' : ‚àÉ (x : L), x ‚àà I ‚àß f x = y, { simpa [hy], }, obtain ‚ü®z‚ÇÇ, hz‚ÇÇ, rfl‚ü© := hy', obtain ‚ü®z‚ÇÅ, rfl‚ü© := h x, simp only [lie_hom.coe_to_linear_map, set_like.mem_coe, set.mem_image, lie_submodule.mem_coe_submodule, submodule.mem_carrier, submodule.map_coe], use ‚ÅÖz‚ÇÅ, z‚ÇÇ‚ÅÜ, exact ‚ü®I.lie_mem hz‚ÇÇ, f.map_lie z‚ÇÅ z‚ÇÇ‚ü©, end, ..(I : submodule R L).map (f : L ‚Üí‚Çó[R] L'), }
erw lie_submodule.coe_lie_span_submodule_eq_iff
use J
apply lie_submodule.coe_to_submodule_mk
intros
ext m
simp only [weight_space, lie_submodule.coe_to_submodule_mk, lie_subalgebra.coe_bracket_of_module, function.comp_app, mem_pre_weight_space]
split
split; intros h x
intros h x
obtain ‚ü®k, hk‚ü© := h ‚ü®x, set.mem_univ x‚ü©
{ obtain ‚ü®k, hk‚ü© := h ‚ü®x, set.mem_univ x‚ü©, use k, exact hk, }
use k
exact hk
intros h x
{ obtain ‚ü®k, hk‚ü© := h x, use k, exact hk, }
obtain ‚ü®k, hk‚ü© := h x
use k
exact hk
intros
simp
intros
{ ext, refl, }
ext
refl
intros
by_cases xy : x ‚â§ y; by_cases yx : y ‚â§ x; simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
by_cases xy : x ‚â§ y; by_cases yx : y ‚â§ x
by_cases xy : x ‚â§ y
by_cases yx : y ‚â§ x
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
by_cases yx : y ‚â§ x
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
cases not_or xy yx (total_of _ _ _)
intros
rw [mul_comm, lt_div_iff_of_neg hc]
intros
simpa using lt_inv ha hb
intros
simpa only [div_eq_mul_inv] using hf.mul_const (inv_nonneg.2 hc)
intros
rw [‚Üê mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
haveI := @linear_order.decidable_le Œ± _; exact (@decidable.strict_mono_on_mul_self Œ± _ _).inj_on.eq_iff h1 h2
haveI := @linear_order.decidable_le Œ± _
exact (@decidable.strict_mono_on_mul_self Œ± _ _).inj_on.eq_iff h1 h2
intros
nontriviality
exact bit1_pos h.le
intros
rw [bit1, lt_add_iff_pos_left, bit0, ‚Üê two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2:Œ±))]
intros
rcases nat.even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©
rcases nat.even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©; have hk : (k : Œ±) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ‚Üê mul_assoc]
have hk : (k : Œ±) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ‚Üê mul_assoc]
{ simpa [hk, hi] using (h.nat_even_mul_periodic k).eq }
simpa [hk, hi] using (h.nat_even_mul_periodic k).eq
have hk : (k : Œ±) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ‚Üê mul_assoc]
simpa [add_mul, hk, hi] using (h.nat_odd_mul_antiperiodic k).eq
{ simpa [add_mul, hk, hi] using (h.nat_odd_mul_antiperiodic k).eq }
intros
simp
intros
simpa using degree_multiset_prod (s.1.map f)
intros
rintro rfl
rcases exists_pair_ne R with ‚ü®x, y, xy‚ü©
refine xy (ra (_ : x * 0 = y * 0))
rw [mul_zero, mul_zero]
intros
unfold bit0
intros
simp [div_eq_mul_inv]
intros
erw [‚Üê to_open_germ S ‚ä§ ‚ü®p, trivial‚ü©, ‚Üê to_open_germ R ‚ä§ ‚ü®prime_spectrum.comap f p, trivial‚ü©, category.assoc, PresheafedSpace.stalk_map_germ (Spec.SheafedSpace_map f) ‚ä§ ‚ü®p, trivial‚ü©, Spec.SheafedSpace_map_c_app, to_open_comp_comap_assoc]
refl
intros
erw [to_stalk, category.assoc, germ_comp_stalk_to_fiber_ring_hom]
{ erw [to_stalk, category.assoc, germ_comp_stalk_to_fiber_ring_hom], refl }
refl
intros
{ ext : 2, dsimp, apply subsingleton.elim }
ext : 2
dsimp
apply subsingleton.elim
intros
dsimp [Œ¥, œÉ]
{ dsimp [Œ¥, œÉ], simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_œÉ_of_le H] }
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_œÉ_of_le H]
intros
by_cases hK : K = 0
simp only [gronwall_bound_K0, hK]
{ simp only [gronwall_bound_K0, hK], exact continuous_const.add (continuous_id.mul continuous_const) }
exact continuous_const.add (continuous_id.mul continuous_const)
simp only [gronwall_bound_of_K_ne_0 hK]
{ simp only [gronwall_bound_of_K_ne_0 hK], exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const) }
exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const)
intros
{ ext n, simp [formal_multilinear_series.comp] }
ext n
simp [formal_multilinear_series.comp]
intros
refine ((h‚ÇÅ.norm_norm.mul_is_o h‚ÇÇ.norm_norm).congr _ _).of_norm_norm
refine ((h‚ÇÅ.norm_norm.mul_is_o h‚ÇÇ.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
unfold is_O
{ unfold is_O, exact exists_congr (Œª c, is_O_with_congr rfl hf hg) }
exact exists_congr (Œª c, is_O_with_congr rfl hf hg)
intros
simp only [is_O_with, exists_prop, true_and, norm_zero, mul_zero, norm_le_zero_iff]
intros
apply has_deriv_at.deriv
exact has_deriv_at.scomp x hg.has_deriv_at hh.has_deriv_at
intros
rw ‚Üê has_deriv_within_at_univ at *
exact hc.div hd hx
intros
convert ‚Üê has_deriv_within_at_iff_tendsto_slope
exact diff_singleton_eq_self hs
intros
simp only [deriv, fderiv_sub_const]
intros
simp only [sub_eq_add_neg, fderiv_within_const_add, fderiv_within_neg, hxs]
intros
rintros v ‚ü®c, d, dtop, clim, cdlim‚ü©
refine ‚ü®c, (Œªn, f (x + d n) - f x), mem_of_superset dtop _, clim, h.lim at_top dtop clim cdlim‚ü©
simp [-mem_image, mem_image_of_mem] {contextual := tt}
intros
refine is_o_congr ((h.prod_mk_nhds h).mono _) (eventually_of_forall $ Œª _, rfl)
rintros p ‚ü®hp‚ÇÅ, hp‚ÇÇ‚ü©
simp only [*]
intros
have := hf.local_inverse_apply_image hf' hn
apply (hf.to_local_homeomorph f hf' hn).times_cont_diff_at_symm (image_mem_to_local_homeomorph_target hf hf' hn)
{ convert hf' }
convert hf'
{ convert hf }
convert hf
intros
have hdf : ‚àÄ x ‚àà Ioo a b, differentiable_at ‚Ñù f x
from Œª x hx, (hdf x hx).differentiable_at (Ioo_mem_nhds hx.1 hx.2)
have hdg : ‚àÄ x ‚àà Ioo a b, differentiable_at ‚Ñù g x
from Œª x hx, classical.by_contradiction (Œª h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_left_on_Ioo hab (Œª x hx, (hdf x hx).has_deriv_at) (Œª x hx, (hdg x hx).has_deriv_at) hg' hfb hgb hdiv
intros
refine univ_subset_iff.1 (Œªy hy, _)
rcases exists_one_lt_norm ùïú with ‚ü®w, hw‚ü©
refine ‚ü®Œªn, w^n, Œªn, (w^n)‚Åª¬π ‚Ä¢ y, univ_mem' (Œªn, mem_univ _), _, _‚ü©
simp only [norm_pow]
{ simp only [norm_pow], exact tendsto_pow_at_top_at_top_of_one_lt hw }
exact tendsto_pow_at_top_at_top_of_one_lt hw
convert tendsto_const_nhds
{ convert tendsto_const_nhds, ext n, have : w ^ n * (w ^ n)‚Åª¬π = 1, { apply mul_inv_cancel, apply pow_ne_zero, simpa [norm_eq_zero] using (ne_of_lt (lt_trans zero_lt_one hw)).symm }, rw [smul_smul, this, one_smul] }
ext n
have : w ^ n * (w ^ n)‚Åª¬π = 1
apply mul_inv_cancel
{ apply mul_inv_cancel, apply pow_ne_zero, simpa [norm_eq_zero] using (ne_of_lt (lt_trans zero_lt_one hw)).symm }
apply pow_ne_zero
simpa [norm_eq_zero] using (ne_of_lt (lt_trans zero_lt_one hw)).symm
rw [smul_smul, this, one_smul]
intros
have A : continuous (Œªq : (E ‚ÜíL[ùïú] F) √ó E, q.1 q.2) := is_bounded_bilinear_map_apply.continuous
have B : continuous (Œªp : E √ó E, (fderiv ùïú f p.1, p.2))
apply continuous.prod_mk _ continuous_snd
{ apply continuous.prod_mk _ continuous_snd, exact continuous.comp (h.continuous_fderiv hn) continuous_fst }
exact continuous.comp (h.continuous_fderiv hn) continuous_fst
exact A.comp B
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
simp only [‚Üê times_cont_diff_on_univ, times_cont_diff_on_succ_iff_deriv_of_open, is_open_univ, differentiable_on_univ]
intros
have A : has_strict_fderiv_at (coe : ‚Ñù ‚Üí ‚ÑÇ) of_real_clm z := of_real_clm.has_strict_fderiv_at
have B : has_strict_fderiv_at e ((continuous_linear_map.smul_right 1 e' : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).restrict_scalars ‚Ñù) (of_real_clm z) := h.has_strict_fderiv_at.restrict_scalars ‚Ñù
have C : has_strict_fderiv_at re re_clm (e (of_real_clm z)) := re_clm.has_strict_fderiv_at
simpa using (C.comp z (B.comp z A)).has_strict_deriv_at
intros
rw [open_segment_symm, left_mem_open_segment_iff, eq_comm]
intros
have h : x + t ‚Ä¢ y = (1 - t) ‚Ä¢ x + t ‚Ä¢ (x + y)
rw [smul_add, ‚Üêadd_assoc, ‚Üêadd_smul, sub_add_cancel, one_smul]
{ rw [smul_add, ‚Üêadd_assoc, ‚Üêadd_smul, sub_add_cancel, one_smul] }
rw h
exact hs hx hy (sub_nonneg_of_le ht.2) ht.1 (sub_add_cancel _ _)
intros
rw [‚Üêinner_conj_sym, conj_im]
intros
{ rw [norm_add_mul_self, norm_sub_mul_self], ring }
rw [norm_add_mul_self, norm_sub_mul_self]
ring
intros
conv_rhs { rw ‚Üê complex.isometry_euclidean_proj_eq_self z }
{ conv_rhs { rw ‚Üê complex.isometry_euclidean_proj_eq_self z }, simp }
simp
intros
ext
{ ext, convert eq_orthogonal_projection_of_mem_orthogonal _ _; simp [hv] }
convert eq_orthogonal_projection_of_mem_orthogonal _ _
convert eq_orthogonal_projection_of_mem_orthogonal _ _; simp [hv]
simp [hv]
simp [hv]
intros
rw [homothety_eq_line_map, ‚Üê line_map_apply_one_sub, ‚Üê homothety_eq_line_map, dist_homothety_center, dist_comm]
intros
rw nonlinear_right_inverse_of_surjective
exact classical.some_spec (exists_nonlinear_right_inverse_of_surjective f hsurj)
intros
simp [dist_eq_norm]
intros
rw [norm_smul, real.norm_eq_abs, abs_of_nonneg ht]
intros
haveI : is_symm E (Œª (x y : E), 1 ‚â§ ‚à•x - y‚à•)
constructor
{ constructor, assume x y hxy, rw ‚Üê norm_neg, simpa }
assume x y hxy
rw ‚Üê norm_neg
simpa
apply exists_seq_of_forall_finset_exists' (Œª (x : E), ‚à•x‚à• ‚â§ R) (Œª (x : E) (y : E), 1 ‚â§ ‚à•x - y‚à•)
assume s hs
exact exists_norm_le_le_norm_sub_of_finset hc hR h s
intros
ext m x
simp only [tail_cons, continuous_linear_map.uncurry_left_apply, continuous_multilinear_map.curry_left_apply]
rw cons_zero
intros
cases f; cases g; congr'; exact funext H
cases f; cases g; congr'
cases f; cases g
cases f
cases g
congr'
intros
simp only [norm_def, neg_apply, norm_neg]
intros
have := bernstein_polynomial.sum ‚Ñù n
apply_fun (Œª p, polynomial.aeval (x : ‚Ñù) p) at this
simp [alg_hom.map_sum, finset.sum_range] at this
exact this
rw [‚Üê map_exp_at_top, comap_map exp_injective, map_exp_at_top]
intros
suffices : times_cont_diff_on ‚Ñù ‚ä§ log {0}·∂ú
from this.of_le le_top
refine (times_cont_diff_on_top_iff_deriv_of_open is_open_compl_singleton).2 _
simp [differentiable_on_log, times_cont_diff_on_inv]
intros
induction n with k ih
simp
{ simp }
rw [prod_range_succ_comm, mul_left_comm, ‚Üê ih, mul_succ, integral_sin_pow]
norm_cast
simp [-cast_add] with field_simps
intros
rw ‚Üê times_cont_diff_within_at_univ at *
{ rw ‚Üê times_cont_diff_within_at_univ at *, exact hf.rpow_const_of_le h }
exact hf.rpow_const_of_le h
intros
{ rw [‚Üê coe_one, coe_rpow_of_ne_zero one_ne_zero], simp }
rw [‚Üê coe_one, coe_rpow_of_ne_zero one_ne_zero]
simp
intros
rw [rpow_def_of_nonneg hx]; split_ifs; simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]
rw [rpow_def_of_nonneg hx]; split_ifs
rw [rpow_def_of_nonneg hx]
split_ifs
simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]
simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]
intros
rw [sub_eq_add_neg, cpow_add _ _ hx, cpow_neg, div_eq_mul_inv]
simpa only [sin_neg, sin_pi_div_two] using intermediate_value_Icc (neg_le_self pi_div_two_pos.le) continuous_sin.continuous_on
intros
exact_mod_cast @complex.sin_eq_sin_iff x y
simp [arccos]
intros
rcases ennreal.lt_iff_exists_coe.1 hr with ‚ü®r, rfl, hr'‚ü©
rw [‚Üê ennreal.coe_zero]
norm_cast at *
apply nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 hr
intros
have := (normed_ring.summable_geometric_of_norm_lt_1 x h).has_sum.mul_left (1 - x)
refine tendsto_nhds_unique this.tendsto_sum_nat _
have : tendsto (Œª (n : ‚Ñï), 1 - x ^ n) at_top (nhds 1)
simpa using tendsto_const_nhds.sub (tendsto_pow_at_top_nhds_0_of_norm_lt_1 h)
{ simpa using tendsto_const_nhds.sub (tendsto_pow_at_top_nhds_0_of_norm_lt_1 h) }
convert ‚Üê this
ext n
rw [‚Üêmul_neg_geom_sum, geom_sum_def, finset.mul_sum]
intros
apply epi_fst_of_is_limit _ _ (pullback_cone.is_limit_of_factors f g g‚ÇÇ f' g‚ÇÅ hf hg t ht)
intros
simp only [iso.inv_hom_id_assoc, arrow.w, arrow.mk_hom]
intros
convert transfer_nat_trans_counit _ _ (prod_comparison_nat_iso F A).inv B
ext
simp
intros
rw [‚Üê trans_conj, Œ±.self_symm_id, refl_conj]
intros
ext
ext; cases p; simp
ext; cases p
cases p
simp
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
let E := (forget C).map_cone D
let hE : is_limit E := is_limit_of_preserves _ hD
let G := types.limit_cone (F ‚ãô forget C)
let hG := types.limit_cone_is_limit (F ‚ãô forget C)
let T : E.X ‚âÖ G.X := hE.cone_point_unique_up_to_iso hG
change function.injective (T.hom ‚â´ (Œª x j, G.œÄ.app j x))
have h : function.injective T.hom
intros a b h
{ intros a b h, suffices : T.inv (T.hom a) = T.inv (T.hom b), by simpa, rw h }
suffices : T.inv (T.hom a) = T.inv (T.hom b)
simpa
simpa
rw h
suffices : function.injective (Œª (x : G.X) j, G.œÄ.app j x)
exact this.comp h
exact this.comp h
apply subtype.ext
intros
{ ext, simp }
ext
simp
intros
simp
intros
rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, prod_comparison_natural]
intros
simpa using B.Œπ_œÄ j j
intros
simp
intros
tidy
intros
rw [‚Üêfunctor.as_equivalence_functor F, equivalence_preserves_zero_morphisms]
intros
{ slice_rhs 1 2 { rw right_unitor_inv_naturality }, simp }
slice_rhs 1 2 { rw right_unitor_inv_naturality }
simp
intros
dsimp [tensor_hom]
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
rintro ‚ü®‚ü©
rintro ‚ü®‚ü©; simp
simp
simp
intros
simp only [cancel_epi]
intros
rw [iso.inv_comp_eq, ‚Üêcategory.assoc, iso.eq_comp_inv, additive_obj_iso_biproduct_naturality]
intros
simpa [covers_iff] using and.intro hS hR
intros
change _ ‚Üî ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : S f), P.map f.op (yoneda_equiv g) = x.app (op Y) ‚ü®f, h‚ü©
split
rintro rfl Y f hf
{ rintro rfl Y f hf, rw yoneda_equiv_naturality, dsimp, simp }
rw yoneda_equiv_naturality
dsimp
simp
intro h
{ intro h, ext Y ‚ü®f, hf‚ü©, have : _ = x.app Y _ := h f hf, rw yoneda_equiv_naturality at this, rw ‚Üê this, dsimp, simp }
ext Y ‚ü®f, hf‚ü©
have : _ = x.app Y _ := h f hf
rw yoneda_equiv_naturality at this
rw ‚Üê this
dsimp
simp
intros
rintro Z _ ‚ü®g, rfl, hg‚ü©
exact ‚ü®_, g, f, h, hg, rfl‚ü©
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
intros
simp [kernel_subobject_iso]
intros
simp only [colex.lt_def, not_exists, mem_image, exists_prop, not_and]
split
rintro ‚ü®k, z, q, k', _, rfl‚ü©
{ rintro ‚ü®k, z, q, k', _, rfl‚ü©, exact ‚ü®k', Œª x hx, by simpa [h‚ÇÅ.injective.eq_iff] using z (h‚ÇÅ hx), Œª t, q _ t rfl, ‚Äπk' ‚àà B‚Ä∫‚ü© }
exact ‚ü®k', Œª x hx, by simpa [h‚ÇÅ.injective.eq_iff] using z (h‚ÇÅ hx), Œª t, q _ t rfl, ‚Äπk' ‚àà B‚Ä∫‚ü©
rintro ‚ü®k, z, ka, _‚ü©
refine ‚ü®f k, Œª x hx, _, _, k, ‚Äπk ‚àà B‚Ä∫, rfl‚ü©
split
{ split, any_goals { rintro ‚ü®x', hx', rfl‚ü©, refine ‚ü®x', _, rfl‚ü©, rwa ‚Üê z _ <|> rwa z _, rwa strict_mono.lt_iff_lt h‚ÇÅ at hx } }
any_goals { rintro ‚ü®x', hx', rfl‚ü©, refine ‚ü®x', _, rfl‚ü©, rwa ‚Üê z _ <|> rwa z _, rwa strict_mono.lt_iff_lt h‚ÇÅ at hx }
rintro ‚ü®x', hx', rfl‚ü©
refine ‚ü®x', _, rfl‚ü©
rwa ‚Üê z _
rwa strict_mono.lt_iff_lt h‚ÇÅ at hx
rintro ‚ü®x', hx', rfl‚ü©
refine ‚ü®x', _, rfl‚ü©
rwa z _
rwa ‚Üê z _
rwa strict_mono.lt_iff_lt h‚ÇÅ at hx
simp only [h‚ÇÅ.injective, function.injective.eq_iff]
{ simp only [h‚ÇÅ.injective, function.injective.eq_iff], exact Œª x hx, ne_of_mem_of_not_mem hx ka }
exact Œª x hx, ne_of_mem_of_not_mem hx ka
intros
simp [boundary, fin.ext_iff]
intros
{ congr, exact map_length_split_wrt_composition l c }
congr
exact map_length_split_wrt_composition l c
intros
convert (fintype.of_equiv_card f.to_equiv).symm
intros
rw [eval_from, Œµ_NFA.eval_from, step_set, Œµ_NFA.step_set, to_Œµ_NFA_Œµ_closure]
congr
ext S s
simp only [exists_prop, set.mem_Union, set.bind_def]
apply exists_congr
simp only [and.congr_right_iff]
intros t ht
rw M.to_Œµ_NFA_Œµ_closure
refl
intros
simp only [star_eq_supr_pow, mul_supr, ‚Üê pow_succ, ‚Üê pow_zero l]
exact sup_supr_nat_succ _
intros
induction x; simp [rmatch, match_epsilon, deriv, *]
induction x
simp [rmatch, match_epsilon, deriv, *]
simp [rmatch, match_epsilon, deriv, *]
intros
rw [h, ‚Üê bind_pure_comp_eq_map]
congr
funext v
exact part.eq_some_iff.2 (mem_eval.2 ‚ü®refl_trans_gen.single rfl, rfl‚ü©)
intros
simp only [(>=>)] with functor_norm
intros
rw ‚Üê comp_bitraverse; simp [tfst,tsnd]
rw ‚Üê comp_bitraverse
simp [tfst,tsnd]
intros
induction xs; simp! * with functor_norm; refl
induction xs; simp! * with functor_norm
induction xs
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
rw [‚Üêrev_list_reverse, list.reverse_reverse]
intros
simp [pure_eq_done]
intros
have : cb.size - n = 0 := nat.sub_eq_zero_of_le hc
simp only [foldl, foldl_core_succ_eq_fail, this, and.left_comm, ne_iff_lt_iff_le, exists_eq_left, exists_and_distrib_right, and.congr_left_iff, exists_and_distrib_left, foldl_core_zero_eq_fail]
rintro (h | ‚ü®‚ü®a, h‚ü©, rfl‚ü©)
{ exact mono.of_fail h }
exact mono.of_fail h
{ exact mono.of_done h }
exact mono.of_done h
intros
rw [char.of_nat, dif_pos h]
cases c
simp [char.to_nat]
intros
induction n; simp [*, of_real_mul, pow_succ]
induction n
simp [*, of_real_mul, pow_succ]
simp [*, of_real_mul, pow_succ]
intros
rw [‚Üê mul_right_inj' (@two_ne_zero' ‚ÑÇ _ _ _), mul_add, two_cosh, two_sinh, add_add_sub_cancel, two_mul]
intros
{ ext, simp }
ext
simp
intros
{ unfold swap_core, split_ifs; cc }
unfold swap_core
split_ifs
split_ifs; cc
cc
cc
intros
{ subst h, simp }
subst h
simp
intros
cases n
{ simp }
simp
rcases i.le_last.eq_or_lt with rfl|h
{ simp [fin_rotate_last] }
simp [fin_rotate_last]
cases i
{ cases i, simp only [fin.lt_iff_coe_lt_coe, fin.coe_last, fin.coe_mk] at h, simp [fin_rotate_of_lt h, fin.eq_iff_veq, fin.add_def, nat.mod_eq_of_lt (nat.succ_lt_succ h)] }
simp only [fin.lt_iff_coe_lt_coe, fin.coe_last, fin.coe_mk] at h
simp [fin_rotate_of_lt h, fin.eq_iff_veq, fin.add_def, nat.mod_eq_of_lt (nat.succ_lt_succ h)]
intros
rw [‚Üê @encode_list_nil Œ±, of_nat_encode]
intros
rw succ_above_last
intros
simp only [mem_Icc, insert_nth_le_iff, le_insert_nth_iff, and.assoc, and.left_comm]
intros
{ rw fin.coe_nat_eq_last, exact fin.le_last i }
rw fin.coe_nat_eq_last
exact fin.le_last i
intros
simp [piecewise, h]
intros
simpa [‚Üêto_finset_eq hl, ‚Üêto_finset_eq hl'] using h
intros
simp [fin_range]
intros
rw [mem_erase, not_and] at hsa
exact not_imp_not.mp hsa hs
intros
simp
intros
induction hs : univ.sigma f using finset.strong_induction_on with s ihs generalizing f
subst s
cases eq_empty_or_nonempty (univ.sigma f) with he hne
{ convert h0, simpa [funext_iff] using he }
convert h0
simpa [funext_iff] using he
rcases sigma_nonempty.1 hne with ‚ü®i, -, hi‚ü©
{ rcases sigma_nonempty.1 hne with ‚ü®i, -, hi‚ü©, rcases H_ex i (f i) hi with ‚ü®x, x_mem, hr‚ü©, set g := update f i ((f i).erase x) with hg, clear_value g, have hx' : x ‚àâ g i, by { rw [hg, update_same], apply not_mem_erase }, obtain rfl : f = update g i (insert x (g i)), by rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self], clear hg, rw [update_same, erase_insert hx'] at hr, refine step _ _ _ hr (ihs (univ.sigma g) _ _ rfl), rw ssubset_iff_of_subset (sigma_mono (subset.refl _) _), exacts [‚ü®‚ü®i, x‚ü©, mem_sigma.2 ‚ü®mem_univ _, by simp‚ü©, by simp [hx']‚ü©, (@le_update_iff _ _ _ _ g g i _).2 ‚ü®subset_insert _ _, Œª _ _, le_rfl‚ü©] }
rcases H_ex i (f i) hi with ‚ü®x, x_mem, hr‚ü©
set g := update f i ((f i).erase x) with hg
clear_value g
have hx' : x ‚àâ g i
rw [hg, update_same]
rw [hg, update_same]
{ rw [hg, update_same], apply not_mem_erase }
{ rw [hg, update_same], apply not_mem_erase }
apply not_mem_erase
apply not_mem_erase
obtain rfl : f = update g i (insert x (g i))
rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self]
rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self]
clear hg
rw [update_same, erase_insert hx'] at hr
refine step _ _ _ hr (ihs (univ.sigma g) _ _ rfl)
rw ssubset_iff_of_subset (sigma_mono (subset.refl _) _)
exacts [‚ü®‚ü®i, x‚ü©, mem_sigma.2 ‚ü®mem_univ _, by simp‚ü©, by simp [hx']‚ü©, (@le_update_iff _ _ _ _ g g i _).2 ‚ü®subset_insert _ _, Œª _ _, le_rfl‚ü©]
intros
classical; rw [map_eq_image, image_subset_iff_subset_preimage]
classical
rw [map_eq_image, image_subset_iff_subset_preimage]
intros
simp only [finset.ext_iff, split_support, split, comap_domain, mem_image, mem_preimage, sigma.forall, mem_sigma]
simp only [finset.ext_iff, split_support, split, comap_domain, mem_image, mem_preimage, sigma.forall, mem_sigma]; tauto
tauto
intros
classical
convert fintype.card_congr (subtype_or_equiv p q h)
simp
intros
apply_instance
intros
convert fintype.card_unique
exact unique.subtype_eq _
intros
induction s using quotient.induction_on
simpa using perm_comm
intros
rcases int.units_eq_one_or x with (rfl | rfl); simp
rcases int.units_eq_one_or x with (rfl | rfl)
simp
simp
intros
{ cases n, cases h, simp, }
cases n
cases h
simp
intros
rw [‚Üê sub_sub, neg_succ_of_nat_coe, sub_sub (n:‚Ñ§)]
apply eq_neg_of_eq_neg
rw [neg_sub, sub_sub_self, add_right_comm]
exact @congr_arg ‚Ñï ‚Ñ§ _ _ (Œªi, (i + 1 : ‚Ñ§)) (nat.mod_add_div _ _).symm
intros
apply multiplicative.of_add.injective
rw [of_add_nsmul, of_add_zero, pow_gcd_eq_one]
rw [of_add_nsmul, of_add_zero, pow_gcd_eq_one]; rwa [‚Üêof_add_nsmul, ‚Üêof_add_zero, equiv.apply_eq_iff_eq]
rwa [‚Üêof_add_nsmul, ‚Üêof_add_zero, equiv.apply_eq_iff_eq]
rwa [‚Üêof_add_nsmul, ‚Üêof_add_zero, equiv.apply_eq_iff_eq]
intros
rw [odd_iff_not_even, nat.odd_iff_not_even, even_coe_nat]
intros
induction xs with x xs generalizing i j
{ cases h‚ÇÄ }
cases h‚ÇÄ
cases i; cases j
cases i
{ cases i; cases j, case nat.zero nat.zero { refl }, case nat.succ nat.succ { congr, cases h‚ÇÅ, apply xs_ih; solve_by_elim [lt_of_succ_lt_succ] }, iterate 2 { dsimp at h‚ÇÇ, cases h‚ÇÅ with _ _ h h', cases h x _ rfl, rw mem_iff_nth, exact ‚ü®_, h‚ÇÇ.symm‚ü© <|> exact ‚ü®_, h‚ÇÇ‚ü© } }
cases j
case nat.zero nat.zero { refl }
refl
case nat.succ nat.succ { congr, cases h‚ÇÅ, apply xs_ih; solve_by_elim [lt_of_succ_lt_succ] }
iterate 2 { dsimp at h‚ÇÇ, cases h‚ÇÅ with _ _ h h', cases h x _ rfl, rw mem_iff_nth, exact ‚ü®_, h‚ÇÇ.symm‚ü© <|> exact ‚ü®_, h‚ÇÇ‚ü© }
dsimp at h‚ÇÇ
cases h‚ÇÅ with _ _ h h'
cases h x _ rfl
rw mem_iff_nth
exact ‚ü®_, h‚ÇÇ.symm‚ü©
cases j
dsimp at h‚ÇÇ
cases h‚ÇÅ with _ _ h h'
cases h x _ rfl
rw mem_iff_nth
exact ‚ü®_, h‚ÇÇ.symm‚ü©
exact ‚ü®_, h‚ÇÇ‚ü©
congr
cases h‚ÇÅ
apply xs_ih; solve_by_elim [lt_of_succ_lt_succ]
apply xs_ih
solve_by_elim [lt_of_succ_lt_succ]
solve_by_elim [lt_of_succ_lt_succ]
solve_by_elim [lt_of_succ_lt_succ]
intros
simp only [nth_modify_nth, if_neg h, id_map']
intros
cases l; refl
cases l
refl
refl
intros
induction L generalizing i
simp only [length] at hi
{ simp only [length] at hi, exact (nat.not_succ_le_zero i hi).elim }
exact (nat.not_succ_le_zero i hi).elim
cases i
simp
{ simp }
have : i < L_tl.length
simp at hi
{ simp at hi, exact nat.lt_of_succ_lt_succ hi }
exact nat.lt_of_succ_lt_succ hi
simp [L_ih this]
refl
intros
intros x hx
rw [mem_filter] at hx ‚ä¢
exact ‚ü®h hx.left, hx.right‚ü©
intros
induction l with x l IH
{ simp }
simp
{ simpa using IH }
simpa using IH
intros
simp [erasep_cons, h]
intros
cases as; refl
cases as
refl
refl
intros
simp
intros
induction l‚ÇÅ with x l‚ÇÅ IH generalizing a; simp only [*, nil_append, cons_append, chain.nil, chain_cons, and_true, and_assoc]
induction l‚ÇÅ with x l‚ÇÅ IH generalizing a
simp only [*, nil_append, cons_append, chain.nil, chain_cons, and_true, and_assoc]
simp only [*, nil_append, cons_append, chain.nil, chain_cons, and_true, and_assoc]
intros
rw length_subsingleton_iff
induction s using quotient.induction_on'
simp only [mk'_eq_coe, nodup_coe_iff] at h
simp [h, nat.succ_le_iff]
intros
dsimp [Ico]; simp only [length_range']
dsimp [Ico]
simp only [length_range']
intros
rw nodup_iff_nth_le_inj
simp only [exists_prop, exists_and_distrib_right, not_forall]
exact ‚ü®n, m, ‚ü®hn, hm, h‚ü©, hne‚ü©
intros
induction l with hd tl IH generalizing l' f
{ simp }
simp
have : some hd = _ := hf 0
rw [eq_comm, list.nth_eq_some] at this
obtain ‚ü®w, h‚ü© := this
let f' : ‚Ñï ‚Ü™o ‚Ñï := order_embedding.of_map_le_iff (Œª i, f (i + 1) - (f 0 + 1)) (Œª a b, by simp [nat.sub_le_sub_right_iff, nat.succ_le_iff, nat.lt_succ_iff])
have : ‚àÄ ix, tl.nth ix = (l'.drop (f 0 + 1)).nth (f' ix)
intro ix
{ intro ix, simp [list.nth_drop, nat.add_sub_of_le, nat.succ_le_iff, ‚Üêhf] }
simp [list.nth_drop, nat.add_sub_of_le, nat.succ_le_iff, ‚Üêhf]
rw [‚Üêlist.take_append_drop (f 0 + 1) l', ‚Üêlist.singleton_append]
apply list.sublist.append _ (IH _ this)
rw [list.singleton_sublist, ‚Üêh, l'.nth_le_take _ (nat.lt_succ_self _)]
apply list.nth_le_mem
intros
induction h with hd l‚ÇÅ l‚ÇÇ h‚ÇÅ‚ÇÇ h_sz‚ÇÅ‚ÇÇ a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h_sz‚ÇÅ‚ÇÇ h_sz‚ÇÇ‚ÇÉ
{ refl }
refl
{ simp only [list.sizeof, h_sz‚ÇÅ‚ÇÇ] }
simp only [list.sizeof, h_sz‚ÇÅ‚ÇÇ]
{ simp only [list.sizeof, add_left_comm] }
simp only [list.sizeof, add_left_comm]
{ simp only [h_sz‚ÇÅ‚ÇÇ, h_sz‚ÇÇ‚ÇÉ] }
simp only [h_sz‚ÇÅ‚ÇÇ, h_sz‚ÇÇ‚ÇÉ]
intros
simp only [iota_eq_reverse_range', nodup_reverse, nodup_range']
intros
induction n with n hn
{ simp }
simp
{ rwa [rotate_cons_succ] }
rwa [rotate_cons_succ]
intros
obtain ‚ü®n, rfl‚ü© := h
rw map_rotate
use n
intros
induction l‚ÇÅ generalizing l‚ÇÇ
simp only [nil_kunion, nd‚ÇÇ]
case list.nil { simp only [nil_kunion, nd‚ÇÇ] }
case list.cons : s l‚ÇÅ ih { simp at nd‚ÇÅ, simp [not_or_distrib, nd‚ÇÅ.1, nd‚ÇÇ, ih nd‚ÇÅ.2 (kerase_nodupkeys s.1 nd‚ÇÇ)] }
intros
induction l with hd tl ih; [refl, simp only [reverse_cons, sublists_append, sublists'_cons, map_append, ih, sublists_singleton, map_eq_map, bind_eq_bind, map_map, cons_bind, append_nil, nil_bind, (‚àò)]]
induction l with hd tl ih
refl
simp only [reverse_cons, sublists_append, sublists'_cons, map_append, ih, sublists_singleton, map_eq_map, bind_eq_bind, map_map, cons_bind, append_nil, nil_bind, (‚àò)]
intros
ext
ext; simp
simp
intros
rw [conj_transpose, conj_transpose, transpose_map, transpose_map, update_row_transpose, map_update_column]
refl
intros
{ ext, refl, }
ext
refl
intros
ext i j
rcases i
rcases i; rcases j; simp [diagonal]
rcases i; rcases j
rcases j
simp [diagonal]
simp [diagonal]
rcases j
simp [diagonal]
simp [diagonal]
intros
rw [‚Üêsum_hadamard_eq, finset.sum_comm]
simp [dot_product, vec_mul, finset.sum_mul, mul_assoc]
intros
{ ext i, simp [vec_mul] }
ext i
simp [vec_mul]
intros
rw [‚Üêmultiset.sum_repeat, ‚Üêmultiset.map_const]
exact sum_map_le_sum _ h
intros
rw [strong_induction_on]
intros
rw [revzip, powerset_aux_eq_map_coe, ‚Üê map_reverse, zip_map, ‚Üê revzip] at h
simp at h
rcases h with ‚ü®l‚ÇÅ, l‚ÇÇ, h, rfl, rfl‚ü©
exact quot.sound (revzip_sublists _ _ _ h)
intros
simp [C_apply, monomial, single_mul_single]
intros
{ ext1 œÜ, simp only [rename_expand, alg_hom.comp_apply] }
ext1 œÜ
simp only [rename_expand, alg_hom.comp_apply]
intros
induction n with n ih
simp only [nat.nat_zero_eq_zero, zero_mul, pow_zero, total_degree_one]
{ simp only [nat.nat_zero_eq_zero, zero_mul, pow_zero, total_degree_one] }
rw pow_succ
calc total_degree (a * a ^ n) ‚â§ a.total_degree + (a^n).total_degree : total_degree_mul _ _ ... ‚â§ a.total_degree + n * a.total_degree : add_le_add_left ih _ ... = (n+1) * a.total_degree : by rw [add_mul, one_mul, add_comm]
intros
rw nat.mod_two_of_bodd
{ rw nat.mod_two_of_bodd, simp }
simp
intros
cases n; split; rintro ‚ü®‚ü©; refl
cases n; split; rintro ‚ü®‚ü©
cases n; split
cases n
split
rintro ‚ü®‚ü©
rintro ‚ü®‚ü©
split
rintro ‚ü®‚ü©
refl
rintro ‚ü®‚ü©
refl
intros
simp [lor]
intros
induction n; simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
induction n
simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
intros
simp [dist.def, add_comm]
intros
cases hn
rw factorial_one
{ rw factorial_one, exact lt_factorial_self (succ_le_succ hi) }
exact lt_factorial_self (succ_le_succ hi)
exact add_factorial_succ_lt_factorial_add_succ _ hi
intros
rw [‚Üêpochhammer_eval_cast, pochhammer_nat_eq_desc_factorial]
cases b
{ simp_rw desc_factorial_zero }
simp_rw desc_factorial_zero
simp_rw [add_succ, succ_sub_one]
obtain h | h := le_total a b
rw [desc_factorial_of_lt (lt_succ_of_le h), desc_factorial_of_lt (lt_succ_of_le _)]
{ rw [desc_factorial_of_lt (lt_succ_of_le h), desc_factorial_of_lt (lt_succ_of_le _)], rw [nat.sub_eq_zero_of_le h, zero_add] }
rw [nat.sub_eq_zero_of_le h, zero_add]
{ rw nat.sub_add_cancel h }
rw nat.sub_add_cancel h
intros
rw mul_comm at H2; exact H1.dvd_of_dvd_mul_right H2
rw mul_comm at H2
exact H1.dvd_of_dvd_mul_right H2
intros
cases eq_empty_or_nonempty s
subst h
{ subst h, simp only [or_true, eq_self_iff_true, iff_true, Inf, has_Inf.Inf, mem_empty_eq, exists_false, dif_neg, not_false_iff] }
simp only [or_true, eq_self_iff_true, iff_true, Inf, has_Inf.Inf, mem_empty_eq, exists_false, dif_neg, not_false_iff]
have := ne_empty_iff_nonempty.mpr h
{ have := ne_empty_iff_nonempty.mpr h, simp only [this, or_false, nat.Inf_def, h, nat.find_eq_zero] }
simp only [this, or_false, nat.Inf_def, h, nat.find_eq_zero]
intros
rw [add_comm, odd_add]
intros
refine (nat.prime_def_min_fac.1 (nat.prime_def_le_sqrt.2 ‚ü®nat.bit1_lt h.n_pos, _‚ü©)).2
rw ‚Üê e at hd
intros m m2 hm md
have := le_trans h.2 (le_trans (nat.min_fac_le_of_dvd m2 md) hm)
rw nat.le_sqrt at this
exact not_le_of_lt hd this
intros
rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with ‚ü®m, rfl‚ü©
rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with ‚ü®m, rfl‚ü©; exact totient_prime_pow_succ hp _
exact totient_prime_pow_succ hp _
intros
rw [‚Üê int.nat_cast_eq_coe_nat, cast_to_nat]
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp
cases x
simp
simp
intros
by_cases p a; simp [option.guard, h]; intro; contradiction
by_cases p a; simp [option.guard, h]; intro
by_cases p a; simp [option.guard, h]
by_cases p a
simp [option.guard, h]
simp [option.guard, h]
intros
linarith
intros
simp [balanced_sz] { contextual := tt }
intros
rw [to_list, foldr, foldr_cons_eq_to_list]; refl
rw [to_list, foldr, foldr_cons_eq_to_list]
refl
intros
split
rintros ‚ü®y, hy‚ü©
{ rintros ‚ü®y, hy‚ü©, cases h : y with a f, refine ‚ü®a, Œª i j, (f i j).val, _, Œª i j, (f i j).property‚ü©, rw [‚Üêhy, h, map_eq], refl }
cases h : y with a f
refine ‚ü®a, Œª i j, (f i j).val, _, Œª i j, (f i j).property‚ü©
rw [‚Üêhy, h, map_eq]
refl
rintros ‚ü®a, f, xeq, pf‚ü©
use ‚ü®a, Œª i j, ‚ü®f i j, pf i j‚ü©‚ü©
rw [xeq]
reflexivity
intros
simp only [iselect,isubtree_cons]
simp [factor_multiset, prime_multiset.of_nat_list, prime_multiset.of_nat_multiset]
intros
rw [coeff_C, if_neg h]
intros
simp [nat_degree]
intros
rw [C_mul_X_pow_eq_monomial, monomial_nat_degree_leading_coeff_eq_self h]
intros
induction n; [simp only [pow_zero, degree_one, zero_nsmul], simp only [*, pow_succ, succ_nsmul, degree_mul]]
induction n
simp only [pow_zero, degree_one, zero_nsmul]
simp only [*, pow_succ, succ_nsmul, degree_mul]
intros
have h0 : p ‚â† 0
contrapose! hp
{ contrapose! hp, simp [hp] }
simp [hp]
apply le_antisymm
rw derivative_apply
{ rw derivative_apply, apply le_trans (degree_sum_le _ _) (sup_le (Œª n hn, _)), apply le_trans (degree_C_mul_X_pow_le _ _) (with_bot.coe_le_coe.2 (nat.sub_le_sub_right _ _)), apply le_nat_degree_of_mem_supp _ hn }
apply le_trans (degree_sum_le _ _) (sup_le (Œª n hn, _))
apply le_trans (degree_C_mul_X_pow_le _ _) (with_bot.coe_le_coe.2 (nat.sub_le_sub_right _ _))
apply le_nat_degree_of_mem_supp _ hn
refine le_sup _
{ refine le_sup _, rw [mem_support_derivative, nat.sub_add_cancel, mem_support_iff], { show ¬¨ leading_coeff p = 0, rw [leading_coeff_eq_zero], assume h, rw [h, nat_degree_zero] at hp, exact lt_irrefl 0 (lt_of_le_of_lt (zero_le _) hp), }, exact hp }
rw [mem_support_derivative, nat.sub_add_cancel, mem_support_iff]
show ¬¨ leading_coeff p = 0
{ show ¬¨ leading_coeff p = 0, rw [leading_coeff_eq_zero], assume h, rw [h, nat_degree_zero] at hp, exact lt_irrefl 0 (lt_of_le_of_lt (zero_le _) hp), }
rw [leading_coeff_eq_zero]
assume h
rw [h, nat_degree_zero] at hp
exact lt_irrefl 0 (lt_of_le_of_lt (zero_le _) hp)
exact hp
intros
rw [mod_by_monic_eq_sub_mul_div p hq, eval‚ÇÇ_sub, eval‚ÇÇ_mul, hx, zero_mul, sub_zero]
intros
refine trans (eval‚ÇÇ_mul_noncomm _ _ $ Œª k, _) (by rw eval‚ÇÇ_X)
rcases em (k = 1) with (rfl|hk)
{ simp }
simp
{ simp [coeff_X_of_ne_one hk] }
simp [coeff_X_of_ne_one hk]
intros
simp only [bit1, add_comp, bit0_comp, one_comp]
intros
apply polynomial.induction_on' p
{ intros r s hr hs, simp [add_comp, hr, hs], }
intros r s hr hs
simp [add_comp, hr, hs]
{ intros n a, simp, }
intros n a
simp
intros
simp only [polynomial.ext_iff, f.map_eq_zero, coeff_map, coeff_zero]
intros
rw [hasse_deriv_apply, coeff_sum, sum_def, finset.sum_eq_single (n + k), coeff_monomial]
simp only [if_true, nat.add_sub_cancel, eq_self_iff_true]
{ simp only [if_true, nat.add_sub_cancel, eq_self_iff_true], }
intros i hi hink
{ intros i hi hink, rw [coeff_monomial], by_cases hik : i < k, { simp only [nat.choose_eq_zero_of_lt hik, if_t_t, nat.cast_zero, zero_mul], }, { push_neg at hik, rw if_neg, contrapose! hink, exact (nat.sub_eq_iff_eq_add hik).mp hink, } }
rw [coeff_monomial]
by_cases hik : i < k
simp only [nat.choose_eq_zero_of_lt hik, if_t_t, nat.cast_zero, zero_mul]
{ simp only [nat.choose_eq_zero_of_lt hik, if_t_t, nat.cast_zero, zero_mul], }
push_neg at hik
{ push_neg at hik, rw if_neg, contrapose! hink, exact (nat.sub_eq_iff_eq_add hik).mp hink, }
rw if_neg
contrapose! hink
exact (nat.sub_eq_iff_eq_add hik).mp hink
intro h
{ intro h, simp only [not_mem_support_iff.mp h, monomial_zero_right, mul_zero, coeff_zero] }
simp only [not_mem_support_iff.mp h, monomial_zero_right, mul_zero, coeff_zero]
intros
induction n with n ih
{ simp only [iterated_deriv_zero_right] }
simp only [iterated_deriv_zero_right]
{ simp only [iterated_deriv_succ, ih, derivative_neg] }
simp only [iterated_deriv_succ, ih, derivative_neg]
intros
{ ext, simp only [coeff_reflect, coeff_C_mul], }
ext
simp only [coeff_reflect, coeff_C_mul]
intros
split_ifs with hxy
rw hxy
{ rw hxy, exact root_multiplicity_X_sub_C_self }
exact root_multiplicity_X_sub_C_self
exact root_multiplicity_eq_zero (mt root_X_sub_C.mp (ne.symm hxy))
intros
rw [root_set_def, map_C, roots_C, multiset.to_finset_zero, finset.coe_empty]
intros
rw [mul_num, int.nat_abs_mul, nat.coprime.gcd_eq_one, int.coe_nat_one, int.div_one]
rw [mul_num, int.nat_abs_mul, nat.coprime.gcd_eq_one, int.coe_nat_one, int.div_one]; exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
intros
have := eq_neg_of_add_eq_zero (rat.nonneg_antisymm hba $ by rwa [‚Üê sub_eq_add_neg, neg_sub])
{ have := eq_neg_of_add_eq_zero (rat.nonneg_antisymm hba $ by rwa [‚Üê sub_eq_add_neg, neg_sub]), rwa neg_neg at this }
rwa neg_neg at this
intros
have := pos_add_lim_zero gh (neg_lim_zero fg); rwa [‚Üê sub_eq_add_neg, sub_sub_sub_cancel_right] at this
have := pos_add_lim_zero gh (neg_lim_zero fg)
rwa [‚Üê sub_eq_add_neg, sub_sub_sub_cancel_right] at this
intros
simp
intros
simp [h]
intros
rw [of_real_eq_coe_nnreal hp, ‚Üê coe_pow, ‚Üê of_real_coe_nnreal, nnreal.coe_pow, nnreal.coe_mk]
intros
by_cases ha : a = ‚ä§
rw h ha
{ rw h ha, exact le_top, }
exact le_top
by_cases hb : b = ‚ä§
rw hb
{ rw hb, exact le_top, }
exact le_top
rw [‚Üêcoe_to_nnreal hb, ‚Üêcoe_to_nnreal ha, coe_le_coe]
exact h_nnreal ha hb
intros
simp_rw [ennreal.of_real, ‚Üêcoe_finset_sum, coe_eq_coe]
exact real.to_nnreal_sum_of_nonneg hf
rw [fib_rec.geom_sol_iff_root_char_poly, fib_rec_char_poly_eq]
simp [sub_eq_zero]
intros
cases le_total 0 q with hq hq
apply nnreal.eq
{ apply nnreal.eq, simp [real.to_nnreal, hp, hq, max_eq_left, mul_nonneg] }
simp [real.to_nnreal, hp, hq, max_eq_left, mul_nonneg]
have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq
{ have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq, rw [to_nnreal_eq_zero.2 hq, to_nnreal_eq_zero.2 hpq, mul_zero] }
rw [to_nnreal_eq_zero.2 hq, to_nnreal_eq_zero.2 hpq, mul_zero]
intros
apply le_trans hz
rw sqrt_two_add_series_succ
apply sqrt_two_add_series_monotone_left
apply le_sqrt_of_sq_le
have hb' : 0 < (b:‚Ñù) := nat.cast_pos.2 hb
have hd' : 0 < (d:‚Ñù) := nat.cast_pos.2 hd
rw [div_pow, add_div_eq_mul_add_div _ _ (ne_of_gt hd'), div_le_div_iff (pow_pos hb' _) hd']
exact_mod_cast h
intros
rw [sq, sqrt_mul_self h]
intros
simp only [preimage, inv_id, image_id]
intros
apply eq_of_bisim (Œªc‚ÇÅ c‚ÇÇ, (empty Œ± <|> c‚ÇÇ) = c‚ÇÅ) _ rfl
intros s' s h
rw ‚Üêh
apply cases_on s; intros s; rw think_empty; simp
apply cases_on s; intros s; rw think_empty
apply cases_on s; intros s
apply cases_on s
intros s
rw think_empty
simp
intros s
rw think_empty
simp
rw ‚Üêthink_empty
intros
induction n with n IH generalizing s
refl
{ refl }
rw [nat.succ_eq_add_one, ‚Üênth_tail, ‚Üêdropn_tail]
apply IH
intros
ext ‚ü®‚ü®x, x_in‚ü©, ‚ü®y, y_in‚ü©‚ü©
simp [set.diagonal]
intros
simp only [subset_def, not_forall]
intros
simp [nonempty_def.mp h, ext_iff]
intros
exact (countable_singleton _).union h
intros
rw [‚Üê finset.coe_inj, h.coe_to_finset, finset.coe_empty]
intros
rw hf.image_inter'
refine subset.antisymm _ (inter_subset_inter_left _ (preimage_mono $ inter_subset_left _ _))
rintro _ ‚ü®h‚ÇÅ, x, hx, rfl‚ü©
exact ‚ü®‚ü®h‚ÇÅ, by rwa hf hx‚ü©, mem_image_of_mem _ hx‚ü©
intros
rw [‚Üê image_univ]
exact h.bij_on_image (bijective_iff_bij_on_univ.1 ha) (hf.inj_on univ)
intros
{ ext x, simp [‚Üê e.lt_iff_lt] }
ext x
simp [‚Üê e.lt_iff_lt]
intros
rw [‚Üê Icc_diff_left, diff_union_self, union_eq_self_of_subset_right (singleton_subset_iff.2 $ left_mem_Icc.2 hab)]
intros
ext1 x
simp_rw [mem_union, mem_Iic, mem_Ioc, le_max_iff]
by_cases hc : c < x
{ tauto }
tauto
have hxb : x ‚â§ b := (le_of_not_gt hc).trans h‚ÇÅ.le
{ have hxb : x ‚â§ b := (le_of_not_gt hc).trans h‚ÇÅ.le, tauto }
tauto
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ioo_of_neg a b h
intros
simp [proj_Icc, hx, h]
intros
simp only [div_eq_mul_inv, image_mul_const_interval]
intros
rw [diff_eq, compl_Union, inter_Inter]; refl
rw [diff_eq, compl_Union, inter_Inter]
refl
intros
simp [‚Üê ne_empty_iff_nonempty, Inter_eq_empty_iff]
intros
rw eqv_gen_eq; exact Inf_le h
rw eqv_gen_eq
exact Inf_le h
intros
rw [card_image_of_inj_on, diag_card]
rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© hx _ _ h
cases quotient.eq.1 h
{ refl }
refl
simp only [mem_coe, mem_diag] at hx
{ simp only [mem_coe, mem_diag] at hx, rw hx.2 }
rw hx.2
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
convert nth_cons_zero x nil
intros
rw [nth_eq_nth_le, ‚Üê list.nth_le_of_fn f]; congr; apply to_list_of_fn
rw [nth_eq_nth_le, ‚Üê list.nth_le_of_fn f]; congr
rw [nth_eq_nth_le, ‚Üê list.nth_le_of_fn f]
congr
apply to_list_of_fn
intros
casesI n
{ apply int.cast_add }
apply int.cast_add
simp only [coe_coe]
symmetry
erw [fin.coe_add, ‚Üê nat.cast_add, ‚Üê sub_eq_zero, ‚Üê nat.cast_sub (nat.mod_le _ _), @char_p.cast_eq_zero_iff R _ _ m]
exact h.trans (nat.dvd_sub_mod _)
intros
rw [add_comm, map_add_one, add_comm]
intros
refine tendsto_nhds_unique ((tendsto_add_at_top_iff_nat 1).1 _) hy
simp only [iterate_succ' f]
exact hf.tendsto.comp hy
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
rw ‚Üê iterate_one f
{ rw ‚Üê iterate_one f, refine function.is_periodic_pt.is_fixed_pt _, rw ‚Üê h, exact is_periodic_pt_minimal_period f x }
refine function.is_periodic_pt.is_fixed_pt _
rw ‚Üê h
exact is_periodic_pt_minimal_period f x
exact ((h.is_periodic_pt 1).minimal_period_le nat.one_pos).antisymm (nat.succ_le_of_lt ((h.is_periodic_pt 1).minimal_period_pos nat.one_pos))
{ exact ((h.is_periodic_pt 1).minimal_period_le nat.one_pos).antisymm (nat.succ_le_of_lt ((h.is_periodic_pt 1).minimal_period_pos nat.one_pos)) }
intros
rw [adjoin_adjoin_left, adjoin_adjoin_left, set.union_comm]
intros
have hf2 : f ‚à£ minpoly G F x
{ rw ‚Üê hfg, exact dvd_mul_right _ _ }
rw ‚Üê hfg
exact dvd_mul_right _ _
have hg2 : g ‚à£ minpoly G F x
{ rw ‚Üê hfg, exact dvd_mul_left _ _ }
rw ‚Üê hfg
exact dvd_mul_left _ _
have := eval‚ÇÇ G F x
rw [‚Üê hfg, polynomial.eval‚ÇÇ_mul, mul_eq_zero] at this
cases this
right
{ right, have hf3 : f = minpoly G F x, { exact polynomial.eq_of_monic_of_associated hf (monic G F x) (associated_of_dvd_dvd hf2 $ @of_eval‚ÇÇ G _ F _ _ _ x f this) }, rwa [‚Üê mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg }
have hf3 : f = minpoly G F x
exact polynomial.eq_of_monic_of_associated hf (monic G F x) (associated_of_dvd_dvd hf2 $ @of_eval‚ÇÇ G _ F _ _ _ x f this)
{ exact polynomial.eq_of_monic_of_associated hf (monic G F x) (associated_of_dvd_dvd hf2 $ @of_eval‚ÇÇ G _ F _ _ _ x f this) }
rwa [‚Üê mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg
left
{ left, have hg3 : g = minpoly G F x, { exact polynomial.eq_of_monic_of_associated hg (monic G F x) (associated_of_dvd_dvd hg2 $ @of_eval‚ÇÇ G _ F _ _ _ x g this) }, rwa [‚Üê one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg }
have hg3 : g = minpoly G F x
exact polynomial.eq_of_monic_of_associated hg (monic G F x) (associated_of_dvd_dvd hg2 $ @of_eval‚ÇÇ G _ F _ _ _ x g this)
{ exact polynomial.eq_of_monic_of_associated hg (monic G F x) (associated_of_dvd_dvd hg2 $ @of_eval‚ÇÇ G _ F _ _ _ x g this) }
rwa [‚Üê one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg
intros
obtain ‚ü®f, rfl‚ü© := hgf
{ obtain ‚ü®f, rfl‚ü© := hgf, exact (splits_of_splits_mul i hf0 hf).1 }
exact (splits_of_splits_mul i hf0 hf).1
intros
subst h
intros
simp [‚Üê cos_angle_mul_norm_mul_norm, h]
intros
rw [‚Üêmem_coe, ‚Üêset.singleton_subset_iff, ‚Üêinter_eq_singleton_orthogonal_projection_fn]
exact set.inter_subset_right _ _
intros
rcases exists_circumradius_eq_of_cospherical_subset h hd hc with ‚ü®r, hr‚ü©
rw [hr sx‚ÇÅ hsx‚ÇÅ, hr sx‚ÇÇ hsx‚ÇÇ]
intros
ext h
ext h; rw [times_cont_mdiff_map.comp_apply, L_apply, ‚Üêeval_at_apply, eval_at_mul, apply_hfdifferential, apply_fdifferential, eval_at_apply]
rw [times_cont_mdiff_map.comp_apply, L_apply, ‚Üêeval_at_apply, eval_at_mul, apply_hfdifferential, apply_fdifferential, eval_at_apply]
intros
simp only [chart_at] with mfld_simps
intros
simp [lift_prop_on, lift_prop, lift_prop_at]
intros
rw ‚Üê has_mfderiv_within_at_univ at ‚ä¢ h
apply h.congr_of_eventually_eq _ (mem_of_mem_nhds h‚ÇÅ : _)
rwa nhds_within_univ
intros
apply (ext_chart_continuous_at_symm I x).preimage_mem_nhds
rwa (ext_chart_at I x).left_inv (mem_ext_chart_source _ _)
intros
refine ((times_cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart (structure_groupoid.chart_mem_maximal_atlas _ x) hx (structure_groupoid.chart_mem_maximal_atlas _ y) hy).trans _
rw [times_cont_diff_within_at_prop, iff_eq_eq]
congr' 2
mfld_set_tac
intros
haveI := classical.prop_decidable; simp [card_eq_card_quotient_mul_card_subgroup s]
haveI := classical.prop_decidable
simp [card_eq_card_quotient_mul_card_subgroup s]
intros
rw [lift_spec, ‚Üêg.map_mul]; exact f.eq_of_eq hg (by rw [sec_spec', f.to_map.map_mul])
rw [lift_spec, ‚Üêg.map_mul]
exact f.eq_of_eq hg (by rw [sec_spec', f.to_map.map_mul])
intros
split
refl
intros x n hxn g
exact general_commutator_containment _ _ hxn (subgroup.mem_top g)
intros
apply minimal_period_eq_prime_pow; rwa is_periodic_pt_mul_iff_pow_eq_one
apply minimal_period_eq_prime_pow
rwa is_periodic_pt_mul_iff_pow_eq_one
rwa is_periodic_pt_mul_iff_pow_eq_one
intros
apply multiplicative.of_add.injective
rw [of_add_nsmul, of_add_zero]
exact pow_card_eq_one
intros
rw [swap_mul_eq_mul_swap, perm.inv_apply_self, perm.inv_apply_self]
intros
simp [cycle_type_def, cycle_factors_finset_eq_empty_iff]
intros
ext j
refine fin.cases _ (Œª j, _) j
{ simp }
simp
{ rw [cycle_range_of_gt (fin.succ_pos j), one_apply] }
rw [cycle_range_of_gt (fin.succ_pos j), one_apply]
intros
refine ‚ü®Œª h, _, Œª hr, form_perm_eq_of_is_rotated hd hr‚ü©
rw equiv.perm.ext_iff at h
have hx : x' ‚àà (x :: y :: l)
have : x' ‚àà {z | form_perm (x :: y :: l) z ‚â† z}
{ have : x' ‚àà {z | form_perm (x :: y :: l) z ‚â† z}, { rw [set.mem_set_of_eq, h x', form_perm_apply_head _ _ _ hd'], simp only [mem_cons_iff, nodup_cons] at hd', push_neg at hd', exact hd'.left.left.symm }, simpa using support_form_perm_le' _ this }
rw [set.mem_set_of_eq, h x', form_perm_apply_head _ _ _ hd']
{ rw [set.mem_set_of_eq, h x', form_perm_apply_head _ _ _ hd'], simp only [mem_cons_iff, nodup_cons] at hd', push_neg at hd', exact hd'.left.left.symm }
simp only [mem_cons_iff, nodup_cons] at hd'
push_neg at hd'
exact hd'.left.left.symm
simpa using support_form_perm_le' _ this
obtain ‚ü®n, hn, hx'‚ü© := nth_le_of_mem hx
have hl : (x :: y :: l).length = (x' :: y' :: l').length
rw [‚Üêerase_dup_eq_self.mpr hd, ‚Üêerase_dup_eq_self.mpr hd', ‚Üêcard_to_finset, ‚Üêcard_to_finset]
{ rw [‚Üêerase_dup_eq_self.mpr hd, ‚Üêerase_dup_eq_self.mpr hd', ‚Üêcard_to_finset, ‚Üêcard_to_finset], refine congr_arg finset.card _, rw [‚Üêfinset.coe_inj, ‚Üêsupport_form_perm_of_nodup' _ hd (by simp), ‚Üêsupport_form_perm_of_nodup' _ hd' (by simp)], simp only [h] }
refine congr_arg finset.card _
rw [‚Üêfinset.coe_inj, ‚Üêsupport_form_perm_of_nodup' _ hd (by simp), ‚Üêsupport_form_perm_of_nodup' _ hd' (by simp)]
simp only [h]
use n
apply list.ext_le
{ rw [length_rotate, hl] }
rw [length_rotate, hl]
intros k hk hk'
{ intros k hk hk', rw nth_le_rotate, induction k with k IH, { simp_rw [nat.zero_add, nat.mod_eq_of_lt hn], simpa }, { have : k.succ = (k + 1) % (x' :: y' :: l').length, { rw [‚Üênat.succ_eq_add_one, nat.mod_eq_of_lt hk'] }, simp_rw this, rw [‚Üêform_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ‚ÜêIH (k.lt_succ_self.trans hk), ‚Üêh, form_perm_apply_nth_le _ hd], congr' 1, have h1 : 1 = 1 % (x' :: y' :: l').length := by simp, rw [hl, nat.mod_eq_of_lt hk', h1, ‚Üênat.add_mod, nat.succ_add] } }
rw nth_le_rotate
induction k with k IH
simp_rw [nat.zero_add, nat.mod_eq_of_lt hn]
{ simp_rw [nat.zero_add, nat.mod_eq_of_lt hn], simpa }
simpa
have : k.succ = (k + 1) % (x' :: y' :: l').length
{ have : k.succ = (k + 1) % (x' :: y' :: l').length, { rw [‚Üênat.succ_eq_add_one, nat.mod_eq_of_lt hk'] }, simp_rw this, rw [‚Üêform_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ‚ÜêIH (k.lt_succ_self.trans hk), ‚Üêh, form_perm_apply_nth_le _ hd], congr' 1, have h1 : 1 = 1 % (x' :: y' :: l').length := by simp, rw [hl, nat.mod_eq_of_lt hk', h1, ‚Üênat.add_mod, nat.succ_add] }
{ rw [‚Üênat.succ_eq_add_one, nat.mod_eq_of_lt hk'] }
rw [‚Üênat.succ_eq_add_one, nat.mod_eq_of_lt hk']
simp_rw this
rw [‚Üêform_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ‚ÜêIH (k.lt_succ_self.trans hk), ‚Üêh, form_perm_apply_nth_le _ hd]
congr' 1
have h1 : 1 = 1 % (x' :: y' :: l').length := by simp
rw [hl, nat.mod_eq_of_lt hk', h1, ‚Üênat.add_mod, nat.succ_add]
intros
ext
ext; simp
simp
simp
intros
induction n with n ih
{ exact derived_series_one _ }
exact derived_series_one _
rw [derived_series_succ, ih]
cases (commutator.normal G).eq_bot_or_eq_top with h h
cases (commutator.normal G).eq_bot_or_eq_top with h h; simp [h]
simp [h]
simp [h]
intros
classical
apply card_order_of_eq_totient_aux‚ÇÇ (Œª n, is_cyclic.card_pow_eq_one_le) hd
intros
rw [f.mem_ker, f.map_mul, f.map_inv, inv_mul_eq_one, eq_comm]
intros
convert H.bot_or_nontrivial
rw nontrivial_iff_exists_ne_one
intros
simpa only [coe_pow] using ((‚ü®x, hx‚ü© : S) ^ n).coe_prop
intros
simp [line_map_apply_module', smul_sub, sub_smul]
simp [line_map_apply_module', smul_sub, sub_smul]; abel
abel
intros
split
intro hs
{ intro hs, have h := affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span ha hs (mem_affine_span k (set.mem_image_of_mem _ (set.mem_singleton _))), rwa [‚Üêset.nonempty_def, set.inter_singleton_nonempty] at h }
have h := affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span ha hs (mem_affine_span k (set.mem_image_of_mem _ (set.mem_singleton _)))
rwa [‚Üêset.nonempty_def, set.inter_singleton_nonempty] at h
exact Œª h, mem_affine_span k (set.mem_image_of_mem p h)
{ exact Œª h, mem_affine_span k (set.mem_image_of_mem p h) }
intros
simp only [line_map_apply_module]
rw [‚Üê le_sub_iff_add_le, add_sub_assoc, ‚Üê sub_le_iff_le_add', ‚Üê sub_smul, ‚Üê sub_smul, sub_sub_sub_cancel_left, smul_le_smul_iff_of_pos (sub_pos.2 h)]
apply_instance
intros
simp_rw [‚Üêmultilinear_map.dom_coprod'_apply, multilinear_map.alternatization_coe]
simp_rw [tensor_product.sum_tmul, tensor_product.tmul_sum, linear_map.map_sum, ‚Üêtensor_product.smul_tmul', tensor_product.tmul_smul, linear_map.map_smul_of_tower]
intros
rw complete_lattice.is_compact_element_iff_le_of_directed_Sup_le
intros d hemp hdir hsup
have : x ‚àà Sup d
from (set_like.le_def.mp hsup) (mem_span_singleton_self x)
have : x ‚àà Sup d
from (set_like.le_def.mp hsup) (mem_span_singleton_self x)
have : x ‚àà Sup d
from (set_like.le_def.mp hsup) (mem_span_singleton_self x)
obtain ‚ü®y, ‚ü®hyd, hxy‚ü©‚ü© := (mem_Sup_of_directed hemp hdir).mp this
exact ‚ü®y, ‚ü®hyd, by simpa only [span_le, singleton_subset_iff]‚ü©‚ü©
intros
rw [restrict_eq_cod_restrict_dom_restrict, ker_cod_restrict]
intros
have h‚ÇÅ : f.comp (0 : f.ker ‚Üí‚Çó[R] M) = 0 := comp_zero _
rw [‚Üêsubmodule.range_subtype f.ker, ‚Üêh 0 f.ker.subtype (eq.trans h‚ÇÅ (comp_ker_subtype f).symm)]
exact range_zero
intros
rw [sub_eq_add_neg, sub_eq_add_neg, add_right, neg_right]
intros
{ ext, refl }
ext
refl
intros
simp only [bilin_form.comp_right, bilin_form.to_matrix_comp b b, to_matrix_id, transpose_one, matrix.one_mul]
intros
convert reverse.commutes (1 : R); simp
convert reverse.commutes (1 : R)
simp
simp
simp
simp
intros
apply is_unit_det_of_left_inverse
simpa using (linear_map.to_matrix_comp v v' v f.symm f).symm
intros
rw [‚Üê mem_bot R, ‚Üê b.repr.ker, mem_ker, linear_equiv.coe_coe]
apply finsupp.ext
intro b
rw [‚Üê to_dual_eq_repr, a]
refl
intros
ext œÜ
split
split; intro hœÜ
intro hœÜ
rw mem_ker at hœÜ
{ rw mem_ker at hœÜ, rw submodule.mem_dual_annihilator, rintro y ‚ü®x, rfl‚ü©, rw [‚Üê dual_map_apply, hœÜ, zero_apply] }
rw submodule.mem_dual_annihilator
rintro y ‚ü®x, rfl‚ü©
rw [‚Üê dual_map_apply, hœÜ, zero_apply]
intro hœÜ
ext x
{ ext x, rw dual_map_apply, rw submodule.mem_dual_annihilator at hœÜ, exact hœÜ (f x) ‚ü®x, rfl‚ü© }
rw dual_map_apply
rw submodule.mem_dual_annihilator at hœÜ
exact hœÜ (f x) ‚ü®x, rfl‚ü©
intros
{ unfold finrank, simp [dim_top] }
unfold finrank
simp [dim_top]
intros
rw [range_total, subtype.range_coe_subtype, set.set_of_mem_eq]
intros
classical
refine ‚ü®‚ü®finset.univ.image b, _‚ü©‚ü©
simp only [set.image_univ, finset.coe_univ, finset.coe_image, basis.span_eq]
intros
rw [quotient_quotient_equiv_quotient_aux_mk, mapq_apply, linear_map.id_apply]
intros
simp [fintype.linear_independent_iff, linear_map.ker_eq_bot', funext_iff]
intros
have h' : v x ‚àà submodule.span R (v '' {x})
rw set.image_singleton
{ rw set.image_singleton, exact mem_span_singleton_self (v x), }
exact mem_span_singleton_self (v x)
intro w
apply linear_independent.ne_zero x hv
refine disjoint_def.1 (hv.disjoint_span_image _) (v x) h' w
simpa using h
intros
unfold matrix.charpoly
rw [charmatrix_reindex, matrix.det_reindex_self]
intros
rw [‚Üêmatrix.mul_assoc, ‚Üêmatrix.mul_assoc, det_mul, det_mul_comm M N, ‚Üêdet_mul]
intros
rw det_apply'
refine (finset.sum_eq_single 1 _ _).trans _
intros œÉ h1 h2
{ intros œÉ h1 h2, cases not_forall.1 (mt equiv.ext h2) with x h3, convert mul_zero _, apply finset.prod_eq_zero, { change x ‚àà _, simp }, exact if_neg h3 }
cases not_forall.1 (mt equiv.ext h2) with x h3
convert mul_zero _
apply finset.prod_eq_zero
{ change x ‚àà _, simp }
change x ‚àà _
simp
exact if_neg h3
{ simp }
simp
{ simp }
simp
intros
refine left_inv_eq_left_inv (mul_nonsing_inv _ h') _
rw h
refine mul_nonsing_inv _ _
rwa [‚Üêis_unit_nonsing_inv_det_iff, ‚Üêh, is_unit_nonsing_inv_det_iff]
intros
rw [linear_map.to_matrix_apply', lmul_apply]
intros
rw curry_fin_finset_symm_apply
congr
ext i
{ ext i, rw [fin_sum_equiv_of_finset_inl, finset.piecewise_eq_of_mem], apply finset.order_emb_of_fin_mem }
rw [fin_sum_equiv_of_finset_inl, finset.piecewise_eq_of_mem]
apply finset.order_emb_of_fin_mem
ext i
{ ext i, rw [fin_sum_equiv_of_finset_inr, finset.piecewise_eq_of_not_mem], exact finset.mem_compl.1 (finset.order_emb_of_fin_mem _ _ _) }
rw [fin_sum_equiv_of_finset_inr, finset.piecewise_eq_of_not_mem]
exact finset.mem_compl.1 (finset.order_emb_of_fin_mem _ _ _)
intros
simp
intros
{ rw [‚Üêone_smul R x, ‚Üêadd_smul, map_smul], norm_num }
rw [‚Üêone_smul R x, ‚Üêadd_smul, map_smul]
norm_num
intros
simp only [map_eq_top_iff p.range_mkq, sup_comm, ker_mkq]
intros
rw smodeq.def at hxy‚ÇÅ hxy‚ÇÇ ‚ä¢
{ rw smodeq.def at hxy‚ÇÅ hxy‚ÇÇ ‚ä¢, simp_rw [quotient.mk_add, hxy‚ÇÅ, hxy‚ÇÇ] }
simp_rw [quotient.mk_add, hxy‚ÇÅ, hxy‚ÇÇ]
intros
dsimp [tensor_product.lid]
simp
intros
{ have := @imp_not_self (¬¨a), rwa decidable.not_not at this }
have := @imp_not_self (¬¨a)
rwa decidable.not_not at this
intros
{ rw ‚Üê pi_univ_Ici, exact pi_Ioi_ae_eq_pi_Ici }
rw ‚Üê pi_univ_Ici
exact pi_Ioi_ae_eq_pi_Ici
intros
rw [‚Üê prod_swap, map_apply measurable_swap hs]
{ rw [‚Üê prod_swap, map_apply measurable_swap hs], simp only [prod_apply (measurable_swap hs)], refl }
simp only [prod_apply (measurable_swap hs)]
refl
intros
intros n m hnm x
simp only
refine bsupr_le (Œª k hk, _)
have : k ‚â§ m := le_trans hk hnm
exact le_bsupr k this
intros
rw [restrict_le_restrict_iff s 0, restrict_le_restrict_iff 0 s] at hi' hj'
split
rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hi.compl.inter hj) (set.inter_subset_left _ _)) (hj'.1 (hi.compl.inter hj) (set.inter_subset_right _ _)), le_antisymm (hj'.2 (hj.compl.inter hi) (set.inter_subset_left _ _)) (hi'.1 (hj.compl.inter hi) (set.inter_subset_right _ _)), zero_apply, zero_apply, zero_add]
{ rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hi.compl.inter hj) (set.inter_subset_left _ _)) (hj'.1 (hi.compl.inter hj) (set.inter_subset_right _ _)), le_antisymm (hj'.2 (hj.compl.inter hi) (set.inter_subset_left _ _)) (hi'.1 (hj.compl.inter hi) (set.inter_subset_right _ _)), zero_apply, zero_apply, zero_add], { exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (disjoint.comm.1 (is_compl.disjoint is_compl_compl))) }, { exact hj.compl.inter hi }, { exact hi.compl.inter hj } }
exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (disjoint.comm.1 (is_compl.disjoint is_compl_compl)))
{ exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (disjoint.comm.1 (is_compl.disjoint is_compl_compl))) }
{ exact hj.compl.inter hi }
exact hj.compl.inter hi
{ exact hi.compl.inter hj }
exact hi.compl.inter hj
rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, compl_compl, compl_compl, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hj.inter hi.compl) (set.inter_subset_right _ _)) (hj'.1 (hj.inter hi.compl) (set.inter_subset_left _ _)), le_antisymm (hj'.2 (hi.inter hj.compl) (set.inter_subset_right _ _)) (hi'.1 (hi.inter hj.compl) (set.inter_subset_left _ _)), zero_apply, zero_apply, zero_add]
{ rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, compl_compl, compl_compl, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hj.inter hi.compl) (set.inter_subset_right _ _)) (hj'.1 (hj.inter hi.compl) (set.inter_subset_left _ _)), le_antisymm (hj'.2 (hi.inter hj.compl) (set.inter_subset_right _ _)) (hi'.1 (hi.inter hj.compl) (set.inter_subset_left _ _)), zero_apply, zero_apply, zero_add], { exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (is_compl.disjoint is_compl_compl)) }, { exact hj.inter hi.compl }, { exact hi.inter hj.compl } }
exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (is_compl.disjoint is_compl_compl))
{ exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (is_compl.disjoint is_compl_compl)) }
{ exact hj.inter hi.compl }
exact hj.inter hi.compl
{ exact hi.inter hj.compl }
exact hi.inter hj.compl
measurability
all_goals { measurability }
intros
rw [‚Üê add_subgroup.mem_carrier, Lp_meas_subgroup, set.mem_set_of_eq]
intros
rw [‚Üê integrable_mk, mk_coe_fn]
intros
simp_rw [snorm', pi.smul_apply', nnnorm_smul, ennreal.coe_mul]
exact ennreal.lintegral_Lp_mul_le_Lq_mul_Lr hp0_lt hpq hpqr Œº hœÜ.ennnorm hf.ennnorm
intros
rw [norm_def, snorm_congr_ae (coe_fn_smul _ _), snorm_const_smul c, ennreal.to_real_mul, ennreal.coe_to_real, coe_nnnorm, norm_def]
intros
{ ext1 f, exact add_comp_Lp L L' f }
ext1 f
exact add_comp_Lp L L' f
intros
have := edist_approx_on_le hf h‚ÇÄ x n
rw edist_comm y‚ÇÄ at this
simp only [edist_nndist, nndist_eq_nnnorm] at this
exact_mod_cast this
intros
simp only [nearest_pt_ind, coe_piecewise, set.piecewise]
{ simp only [nearest_pt_ind, coe_piecewise, set.piecewise], congr, simp }
congr
simp
intros
simpa only [‚Üê finset.prod_apply] using s.measurable_prod' hf
intros
rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk]
exact integral_trim hm hf.measurable_mk
intros
simp [integrable_on, integrable_zero_measure]
intros
simp only [integral_symm b, integral_of_le h]
intros
simp only [sub_eq_add_neg, neg_mul_eq_neg_mul]
rw [integral_comp_add_mul f (neg_ne_zero.mpr hc) d, integral_symm]
simp only [inv_neg, smul_neg, neg_neg, neg_smul]
intros
simp only [‚Üê infi_apply]
{ simp only [‚Üê infi_apply], exact (monotone_lintegral Œº).map_infi_le }
exact (monotone_lintegral Œº).map_infi_le
intros
suffices : is_o (Œª s, ‚à´ x in s, f x ‚àÇŒº - (Œº s).to_real ‚Ä¢ b) (Œª s, (Œº s).to_real) (l.lift' powerset)
from (this.comp_tendsto hs).congr' (hsŒº.mono $ Œª a ha, ha ‚ñ∏ rfl) hsŒº
refine is_o_iff.2 (Œª Œµ Œµ‚ÇÄ, _)
have : ‚àÄ·∂† s in l.lift' powerset, ‚àÄ·∂† x in Œº.ae, x ‚àà s ‚Üí f x ‚àà closed_ball b Œµ := eventually_lift'_powerset_eventually.2 (h.eventually $ closed_ball_mem_nhds _ Œµ‚ÇÄ)
filter_upwards [hŒº.eventually, (hŒº.integrable_at_filter_of_tendsto_ae hfm h).eventually, hfm.eventually, this]
simp only [mem_closed_ball, dist_eq_norm]
intros s hŒºs h_integrable hfm h_norm
rw [‚Üê set_integral_const, ‚Üê integral_sub h_integrable (integrable_on_const.2 $ or.inr hŒºs), real.norm_eq_abs, abs_of_nonneg ennreal.to_real_nonneg]
exact norm_set_integral_le_of_norm_le_const_ae' hŒºs h_norm (hfm.sub ae_measurable_const)
intros
refine measurable_to_nat (Œª x, _)
rw [preimage_find_eq_disjointed]
exact measurable_set.disjointed hm _
intros
have := Œº.inner_content_Sup_nat (Œª i, ‚ü®U i, hU i‚ü©)
{ have := Œº.inner_content_Sup_nat (Œª i, ‚ü®U i, hU i‚ü©), rwa [opens.supr_def] at this }
rwa [opens.supr_def] at this
intros
simpa only [nnreal.coe_one, one_mul] using h.holder_on_with.hausdorff_measure_image_le zero_lt_one hd
intros
rw Œº.trimmed; refl
rw Œº.trimmed
refl
intros
intros U hU r hr
rw [map_apply hf (hB‚ÇÇ _ hU)] at hr
rcases H (hAB U hU) r hr with ‚ü®K, hKU, hKc, hK‚ü©
refine ‚ü®f '' K, image_subset_iff.2 hKU, hAB' _ hKc, _‚ü©
rwa [map_apply hf (hB‚ÇÅ _ $ hAB' _ hKc), f.preimage_image]
intros
refine ‚ü®s, hs, Œª t hst, _, Œª t hst, _‚ü©
refine ‚ü®s, hs, Œª t hst, _, Œª t hst, _‚ü©; by_cases ht : measurable_set t
by_cases ht : measurable_set t
{ exact h‚ÇÅ t hst ht }
exact h‚ÇÅ t hst ht
{ exact not_measurable v ht }
exact not_measurable v ht
by_cases ht : measurable_set t
{ exact h‚ÇÇ t hst ht }
exact h‚ÇÇ t hst ht
{ exact not_measurable w ht }
exact not_measurable w ht
intros
ext i hi
rw [to_signed_measure_apply_measurable hi, add_apply, ennreal.to_real_add (ne_of_lt (measure_lt_top _ _ )) (ne_of_lt (measure_lt_top _ _)), vector_measure.add_apply, to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi]
apply_instance
all_goals { apply_instance }
apply_instance
intros
by_cases hi‚ÇÅ : measurable_set i
exact (restrict_le_restrict_iff _ _ hi‚ÇÅ).1 hi‚ÇÇ hi‚ÇÅ set.subset.rfl
{ exact (restrict_le_restrict_iff _ _ hi‚ÇÅ).1 hi‚ÇÇ hi‚ÇÅ set.subset.rfl }
{ rw v.not_measurable hi‚ÇÅ }
rw v.not_measurable hi‚ÇÅ
intros
rw [mem_divisors_antidiagonal, mul_comm] at h
simp [h.1, h.2]
intros
intro heq
apply @not_fermat_42 _ _ (c ^ 2) ha hb
rw heq
ring
intros
induction n; simp
{ induction n; simp, }
induction n
simp
simp
intros
rw [‚Üê ideal.span_singleton_prime, ‚Üê maximal_ideal_eq_span_p]
{ apply_instance }
apply_instance
{ exact_mod_cast hp_prime.1.ne_zero }
exact_mod_cast hp_prime.1.ne_zero
intros
rw multiplicity.pow_dvd_iff_le_multiplicity
{ rw multiplicity.pow_dvd_iff_le_multiplicity, rw padic_val_nat_def (ne_of_gt hn), { rw [nat.cast_add, enat.coe_get], simp only [nat.cast_one, not_le], apply enat.lt_add_one (ne_top_iff_finite.2 (finite_nat_iff.2 ‚ü®hp.elim.ne_one, hn‚ü©)) }, { apply_instance } }
rw padic_val_nat_def (ne_of_gt hn)
rw [nat.cast_add, enat.coe_get]
{ rw [nat.cast_add, enat.coe_get], simp only [nat.cast_one, not_le], apply enat.lt_add_one (ne_top_iff_finite.2 (finite_nat_iff.2 ‚ü®hp.elim.ne_one, hn‚ü©)) }
simp only [nat.cast_one, not_le]
apply enat.lt_add_one (ne_top_iff_finite.2 (finite_nat_iff.2 ‚ü®hp.elim.ne_one, hn‚ü©))
{ apply_instance }
apply_instance
intros
split
intro hg
{ intro hg, ext x : 1, apply ext_of_to_zmod_pow.mp, intro n, show (to_zmod_pow n).comp g x = (to_zmod_pow n).comp g' x, rw hg n }
ext x : 1
apply ext_of_to_zmod_pow.mp
intro n
show (to_zmod_pow n).comp g x = (to_zmod_pow n).comp g' x
rw hg n
{ rintro rfl _, refl }
rintro rfl _
refl
intros
subst x
change nat.gcd 0 (int.nat_abs y) = 1 at hc
rw [nat.gcd_zero_left (int.nat_abs y)] at hc
cases int.nat_abs_eq y with hy hy
{ use [1, 0], rw [hy, hc, int.gcd_zero_right], norm_num }
use [1, 0]
rw [hy, hc, int.gcd_zero_right]
norm_num
{ use [0, 1], rw [hy, hc, int.gcd_zero_left], norm_num }
use [0, 1]
rw [hy, hc, int.gcd_zero_left]
norm_num
intros
induction n; simp *
induction n
simp *
simp *
intros
rw [‚Üênorm_eq_one_iff, ‚Üêint.coe_nat_inj', int.nat_abs_of_nonneg (norm_nonneg hd z), int.coe_nat_one]
intros
rw [‚Üê int.cast_coe_nat, coe_nat_abs_norm]
intros
rcases eq_Sup_atoms b with ‚ü®s, rfl, hs‚ü©
exact le_antisymm (Sup_le (Œª _, and.right)) (Sup_le_Sup (Œª a ha, ‚ü®hs a ha, le_Sup ha‚ü©))
intros
simp [lt_iff_le_not_le, pi.le_def] {contextual := tt}
intros
conv_rhs { rw [‚Üêsup_inf_sdiff x y, h.eq_bot, bot_sup_eq] }
intros
simp [is_least, lower_bounds_union, or_and_distrib_right, and_comm (a ‚àà t), and_assoc]
intros
simpa only [sup_comm] using @sup_Inf_eq Œ± _ b s
intros
rw set.eq_singleton_iff_nonempty_unique_mem
{ rw set.eq_singleton_iff_nonempty_unique_mem, rw Inf_eq_top at h_inf, exact ‚ü®hne, h_inf‚ü©, }
rw Inf_eq_top at h_inf
exact ‚ü®hne, h_inf‚ü©
intros
by_cases hs : bdd_below s
{ exact is_glb_Inf' hs }
exact is_glb_Inf' hs
{ exfalso, apply hs, use ‚ä•, intros _ _, exact bot_le }
exfalso
apply hs
use ‚ä•
intros _ _
exact bot_le
intros
rw [at_top_Ioi_eq, tendsto_comap_iff]
intros
rw filter.eventually_at_bot_prod_self
apply exists_congr
tauto
intros
simp only [‚Üê principal_singleton, hl.sup_principal]
intros
by_contradiction H
replace H : ‚àÄ·∂† x in f, ¬¨ p x
from eventually_of_forall (not_exists.1 H)
exact hp H
intros
simp [comap_ne_bot_iff, frequently_iff, ‚Üê exists_and_distrib_left, and.comm]
intros
simpa only [filter.eventually, set_of_forall] using bInter_mem hI
intros
ext
ext; refl
refl
intros
rw [partial_sups_eq_sup_range, finset.sup_eq_supr]
congr
ext a
exact supr_congr_Prop (by rw [finset.mem_range, nat.lt_succ_iff]) (Œª _, rfl)
intros
split
split; intro h
intro h
have H1 := congr_arg ((Œî) a) h
{ have H1 := congr_arg ((Œî) a) h, rwa [symm_diff_symm_diff_self, symm_diff_symm_diff_self] at H1, }
rwa [symm_diff_symm_diff_self, symm_diff_symm_diff_self] at H1
intro h
{ rw h, }
rw h
intros
rw [is_artinian_ring_iff, is_artinian_iff_well_founded] at H ‚ä¢
exact order_embedding.well_founded (ideal.order_embedding_of_surjective f hf) H
intros
{ rw is_coprime_comm, exact h.symm.add_mul_left_left z }
rw is_coprime_comm
exact h.symm.add_mul_left_left z
intros
refine or_iff_not_imp_left.2 (Œª h', _)
apply is_coprime_of_dvd
rintro ‚ü®rfl, rfl‚ü©
{ unfreezingI { rintro ‚ü®rfl, rfl‚ü© }, simpa using h }
unfreezingI { rintro ‚ü®rfl, rfl‚ü© }
simpa using h
rintro z nu nz ‚ü®w, rfl‚ü© dy
unfreezingI { rintro z nu nz ‚ü®w, rfl‚ü© dy }
{ unfreezingI { rintro z nu nz ‚ü®w, rfl‚ü© dy }, refine h' (dvd_trans _ dy), simpa using mul_dvd_mul_left z (is_unit_iff_dvd_one.1 $ (of_irreducible_mul h).resolve_left nu) }
refine h' (dvd_trans _ dy)
simpa using mul_dvd_mul_left z (is_unit_iff_dvd_one.1 $ (of_irreducible_mul h).resolve_left nu)
intros
rw (show a * c - b * d = (a - b) * c + b * (c - d), by {rw [sub_mul, mul_sub], abel})
exact I.add_mem (I.mul_mem_right _ h1) (I.mul_mem_left _ h2)
intros
refine ‚ü®‚ü®comap_ne_top _ H.1.1, Œª J hJ, _‚ü©‚ü©
suffices : map f J = ‚ä§
replace this := congr_arg (comap f) this
{ replace this := congr_arg (comap f) this, rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this, rw eq_top_iff, exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono (bot_le)) (le_of_lt hJ))) }
rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this
rw eq_top_iff
exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono (bot_le)) (le_of_lt hJ)))
refine H.1.2 (map f J) (lt_of_le_of_ne (le_map_of_comap_le_of_surjective _ hf (le_of_lt hJ)) (Œª h, ne_of_lt hJ (trans (congr_arg (comap f) h) _)))
rw [comap_map_of_surjective _ hf, sup_eq_left]
exact le_trans (comap_mono bot_le) (le_of_lt hJ)
intros
rw ideal.span_singleton_eq_span_singleton
{ rw ideal.span_singleton_eq_span_singleton, exact (associated_nat_abs _).symm }
exact (associated_nat_abs _).symm
intros
rcases h with ‚ü®p, ‚ü®hp, hp'‚ü©‚ü©
refine ‚ü®p.map (algebra_map R A), ‚ü®monic_map (algebra_map R A) hp, _‚ü©‚ü©
rw [is_scalar_tower.algebra_map_eq R A B, ‚Üê eval‚ÇÇ_map] at hp'
exact hp'
intros
refine is_jacobson_iff.trans ‚ü®Œª h I hI, h I (is_prime.radical hI), _‚ü©
refine Œª h I hI, le_antisymm (Œª x hx, _) (Œª x hx, mem_Inf.mpr (Œª _ hJ, hJ.left hx))
rw [‚Üê hI, radical_eq_Inf I, mem_Inf]
intros P hP
rw set.mem_set_of_eq at hP
erw mem_Inf at hx
erw [‚Üê h P hP.right, mem_Inf]
exact Œª J hJ, hx ‚ü®le_trans hP.left hJ.left, hJ.right‚ü©
intros
rw [algebra.smul_def, algebra.smul_def, ring_hom.map_mul, map_eq]
intros
have hx0 : x ‚â† 0 := mt (by { rintro rfl, rw zero_mul }) hxy0
have hy0 : y ‚â† 0 := mt (by { rintro rfl, rw mul_zero }) hxy0
obtain ‚ü®r, rfl‚ü© := ideal.quotient.mk_surjective x
obtain ‚ü®s, rfl‚ü© := ideal.quotient.mk_surjective y
rw ‚Üê ring_hom.map_mul at hxy0 ‚ä¢
rw [pre_val_mk hx0, pre_val_mk hy0, pre_val_mk hxy0, ring_hom.map_mul, v.map_mul]
intros
simp only [of_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, finset.sum_ite_eq', ite_eq_right_iff, ne.def, ite_not, not_not, ite_eq_left_iff]
assume h
rw h
refl
intros
simp only [int.coe_nat_eq_zero, bernstein_polynomial.iterate_derivative_at_0, ne.def, nat.cast_eq_zero]
simp only [‚Üêpochhammer_eval_cast]
norm_cast
apply ne_of_gt
obtain rfl|h' := nat.eq_zero_or_pos ŒΩ
{ simp, }
simp
rw ‚Üê nat.succ_pred_eq_of_pos h' at h
{ rw ‚Üê nat.succ_pred_eq_of_pos h' at h, exact pochhammer_pos _ _ (nat.sub_pos_of_lt (nat.lt_of_succ_le h)) }
exact pochhammer_pos _ _ (nat.sub_pos_of_lt (nat.lt_of_succ_le h))
intros
by_cases h0 : r = 0
simp [h0]
{ simp [h0] }
rw content
rw content
rw ‚Üê finset.gcd_mul_left
refine congr (congr rfl _) _; ext; simp [h0, mem_support_iff]
refine congr (congr rfl _) _; ext
refine congr (congr rfl _) _
ext
simp [h0, mem_support_iff]
ext
simp [h0, mem_support_iff]
intros
induction m with m ih
{ simp, }
simp
rw [pochhammer_succ_right, polynomial.mul_X_add_nat_cast_comp, ‚Üêmul_assoc, ih, nat.succ_eq_add_one, ‚Üêadd_assoc, pochhammer_succ_right, nat.cast_add, add_assoc]
{ rw [pochhammer_succ_right, polynomial.mul_X_add_nat_cast_comp, ‚Üêmul_assoc, ih, nat.succ_eq_add_one, ‚Üêadd_assoc, pochhammer_succ_right, nat.cast_add, add_assoc], }
intros
rw mem_span_pow'
split
split; { rintros ‚ü®f, h, hy‚ü©, refine ‚ü®f, _, hy‚ü©, by_cases hf : f = 0, { simp only [hf, nat_degree_zero, degree_zero] at h ‚ä¢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }, simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h }
{ rintros ‚ü®f, h, hy‚ü©, refine ‚ü®f, _, hy‚ü©, by_cases hf : f = 0, { simp only [hf, nat_degree_zero, degree_zero] at h ‚ä¢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }, simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h }
{ rintros ‚ü®f, h, hy‚ü©, refine ‚ü®f, _, hy‚ü©, by_cases hf : f = 0, { simp only [hf, nat_degree_zero, degree_zero] at h ‚ä¢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }, simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h }
rintros ‚ü®f, h, hy‚ü©
refine ‚ü®f, _, hy‚ü©
by_cases hf : f = 0
simp only [hf, nat_degree_zero, degree_zero] at h ‚ä¢
{ simp only [hf, nat_degree_zero, degree_zero] at h ‚ä¢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }
exact with_bot.bot_lt_coe d
exact lt_of_le_of_ne (nat.zero_le d) hd.symm
simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h
intros
rw [‚Üê pow_one (X : power_series R), X_pow_dvd_iff, ‚Üê coeff_zero_eq_constant_coeff_apply]
split
split; intro h
intro h
{ exact h 0 zero_lt_one }
exact h 0 zero_lt_one
intro h
intros m hm
{ intros m hm, rwa nat.eq_zero_of_le_zero (nat.le_of_succ_le_succ hm) }
rwa nat.eq_zero_of_le_zero (nat.le_of_succ_le_succ hm)
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
haveI := classical.dec_eq Œπ
haveI := classical.dec_eq Œ∫
rw [trace_eq_matrix_trace (b.smul c), trace_eq_matrix_trace b, trace_eq_matrix_trace c, matrix.trace_apply, matrix.trace_apply, matrix.trace_apply, ‚Üê finset.univ_product_univ, finset.sum_product]
refine finset.sum_congr rfl (Œª i _, _)
simp only [alg_hom.map_sum, smul_left_mul_matrix, finset.sum_apply, finset.sum_apply i _ (Œª y, left_mul_matrix b (left_mul_matrix c x y y))]
intros
induction k with n h
{ rw [zero_nsmul, pow_zero], exact factors_one }
rw [zero_nsmul, pow_zero]
exact factors_one
{ rw [pow_succ, succ_nsmul, factors_mul, h] }
rw [pow_succ, succ_nsmul, factors_mul, h]
intros
norm_cast
intros
suffices : ¬¨v (x + y) < max (v x) (v y)
from or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this
intro h'
wlog vyx : v y < v x using x y
{ apply lt_or_gt_of_ne h.symm }
apply lt_or_gt_of_ne h.symm
rw max_eq_left_of_lt vyx at h'
{ rw max_eq_left_of_lt vyx at h', apply lt_irrefl (v x), calc v x = v ((x+y) - y) : by simp ... ‚â§ max (v $ x + y) (v y) : map_sub _ _ _ ... < v x : max_lt h' vyx }
apply lt_irrefl (v x)
calc v x = v ((x+y) - y) : by simp ... ‚â§ max (v $ x + y) (v y) : map_sub _ _ _ ... < v x : max_lt h' vyx
apply this h.symm
{ apply this h.symm, rwa [add_comm, max_comm] at h' }
rwa [add_comm, max_comm] at h'
intros
map_fun_tac
intros
{ rw [frobenius_poly_aux, ‚Üê fin.sum_univ_eq_sum_range] }
rw [frobenius_poly_aux, ‚Üê fin.sum_univ_eq_sum_range]
intros
unfreezingI { obtain ‚ü®œÜ, hf‚ü© := hf, obtain ‚ü®œà, hg‚ü© := hg }
obtain ‚ü®œÜ, hf‚ü© := hf
obtain ‚ü®œà, hg‚ü© := hg
use (Œª n, bind‚ÇÅ œÜ (œà n))
intros
simp only [aeval_bind‚ÇÅ, function.comp, hg, hf]
intros
have inj : function.injective (int.cast_ring_hom ‚Ñö)
{ intros m n, exact int.cast_inj.mp, }
intros m n
exact int.cast_inj.mp
apply inj
rw [‚Üê constant_coeff_map, map_witt_structure_int, constant_coeff_witt_structure_rat, ring_hom.map_zero]
rw [constant_coeff_map, h, ring_hom.map_zero]
intros
rw [verschiebung_fun, coeff_mk]
intros
{ rw [sUnion_eq_Union], apply mk_Union_le }
rw [sUnion_eq_Union]
apply mk_Union_le
intros
by_cases ha : a = 0
simp [ha, zero_power_le]
exact le_trans (power_le_power_left ha h) (le_max_left _ _)
intros
induction n; simp [pow_succ', -_root_.add_comm, power_add, *]
induction n
simp [pow_succ', -_root_.add_comm, power_add, *]
simp [pow_succ', -_root_.add_comm, power_add, *]
simpa only [card_type, card_univ] using congr_arg card type_cardinal
intros
apply le_antisymm
apply le_trans (power_le_power_right $ le_of_lt $ cantor c)
{ apply le_trans (power_le_power_right $ le_of_lt $ cantor c), rw [‚Üê power_mul, mul_eq_self h] }
rw [‚Üê power_mul, mul_eq_self h]
{ convert power_le_power_right (le_trans (le_of_lt $ nat_lt_omega 2) h), apply nat.cast_two.symm }
convert power_le_power_right (le_trans (le_of_lt $ nat_lt_omega 2) h)
apply nat.cast_two.symm
intros
simp [‚Üê bit1_zero]
intros
have k : _root_.infinite (range f)
rw infinite_coe_iff
{ rw infinite_coe_iff, apply mt (union_finset_finite_of_range_finite f), rw w, exact infinite_univ, }
apply mt (union_finset_finite_of_range_finite f)
rw w
exact infinite_univ
by_contradiction h
simp only [not_le] at h
let u : Œ† b, ‚àÉ a, b ‚àà f a := Œª b, by simpa using (w.ge : _) (set.mem_univ b)
let u' : Œ≤ ‚Üí range f := Œª b, ‚ü®f (u b).some, by simp‚ü©
have v' : ‚àÄ a, u' ‚Åª¬π' {‚ü®f a, by simp‚ü©} ‚â§ f a
rintros a p m
begin rintros a p m, simp at m, rw ‚Üêm, apply (Œª b, (u b).some_spec), end
simp at m
rw ‚Üêm
apply (Œª b, (u b).some_spec)
obtain ‚ü®‚ü®-, ‚ü®a, rfl‚ü©‚ü©, p‚ü© := exists_infinite_fiber u' h k
exact (@infinite.of_injective _ _ p (inclusion (v' a)) (inclusion_injective _)).false
intros
simpa only [zero_add] using add_le_add_right (ordinal.zero_le b) a
intros
rw lt_def
dsimp
simp [forall_pempty, exists_pempty]
intros
rw two_nsmul
apply quotient.sound
exact pgame.add_pow_half_succ_self_eq_pow_half
intros
rw [mul_lt_mul_left, ‚Üêha, ‚Üêhb, ‚Üêmul_assoc, ‚Üêmul_assoc, mul_comm bd, mul_lt_mul_left]
exact mul_pos had hbd
exact one_div_pos.2 hgcd
intros
cases t
simp only [mul, mul_add, add_mul, list.length_map, coeffs.val, coeffs.val_between_map_mul, val, list.map]
intros
cc
intros
cc
intros
rw ‚Üê nhds_within_univ
exact tendsto_nhds_within_mono_right (subset_univ _) (tendsto_floor_left n)
intros
rw [show f = f‚Åª¬π‚Åª¬π, by { ext, simp }]
apply filter.tendsto.inv_tendsto_zero
apply tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ (summable.tendsto_at_top_zero hf)
rw eventually_iff_exists_mem
refine ‚ü®set.Ioi 0, Ioi_mem_at_top _, Œª _ _, _‚ü©
rw [set.mem_Ioi, inv_eq_one_div, one_div, pi.inv_apply, _root_.inv_pos]
exact hf' _
intros
cases t.nonempty_encodable
{ cases t.nonempty_encodable, rw [supr_subtype'], convert rel_supr_tsum m m0 R m_supr _, rw [‚Üê finset.tsum_subtype], assumption }
rw [supr_subtype']
convert rel_supr_tsum m m0 R m_supr _
rw [‚Üê finset.tsum_subtype]
assumption
intros
convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (order_dual Œ±) _ _ _ _ _ _ _
simp_rw (show ‚àÄ u : order_dual Œ±, @Icc (order_dual Œ±) _ a u = @Icc Œ± _ u a, from Œª u, dual_Icc)
refl
intros
rw [‚Üê map_coe_Ioi_at_bot, tendsto_map'_iff]
intros
split
split; intro h
intro h
{ exact h.comp hg }
exact h.comp hg
intro h
rcases tendsto_of_monotone hf with h' | ‚ü®l', hl'‚ü©
{ rcases tendsto_of_monotone hf with h' | ‚ü®l', hl'‚ü©, { exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim }, { rwa tendsto_nhds_unique h (hl'.comp hg) } }
{ exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim }
exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim
{ rwa tendsto_nhds_unique h (hl'.comp hg) }
rwa tendsto_nhds_unique h (hl'.comp hg)
intros
simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]
intros
have : is_topological_basis (‚ãÉ i, image (coe : U i ‚Üí Œ±) '' (countable_basis (U i)))
from is_topological_basis_of_cover Uo hc (Œª i, is_basis_countable_basis (U i))
exact this.second_countable_topology (countable_Union $ Œª i, (countable_countable_basis _).image _)
intros
rw frontier_eq_inter_compl_interior
simp only [compl_inter, compl_compl]
intros
tactic.unfreeze_local_instances
by_cases h : nonempty J
{ apply nonempty_sections_of_fintype_cofiltered_system, }
apply nonempty_sections_of_fintype_cofiltered_system
rw not_nonempty_iff_imp_false at h
{ rw not_nonempty_iff_imp_false at h, exact ‚ü®Œª j, false.elim (h j.unop), Œª j, false.elim (h j.unop)‚ü©, }
exact ‚ü®Œª j, false.elim (h j.unop), Œª j, false.elim (h j.unop)‚ü©
intros
tidy
intros
simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and.assoc, and.left_comm] using hx
intros
{ cases f, cases g, congr, ext, exact H x, }
cases f
cases g
congr
ext
exact H x
apply eq_top_iff.mpr
rintros f -
refine filter.frequently.mem_closure _
refine filter.tendsto.frequently (bernstein_approximation_uniform f) _
apply frequently_of_forall
intro n
simp only [set_like.mem_coe]
apply subalgebra.sum_mem
rintro n -
apply subalgebra.smul_mem
dsimp [bernstein, polynomial_functions]
simp
intros
rw [comap_principal, set.preimage_image_eq _ subtype.coe_injective]
intros
simpa only [exists_prop, and_assoc, and_comm] using (nhds_within_basis_open a s).mem_iff
intros
simp
intros
refine subset.antisymm_iff.mpr ‚ü®(Œª x hx, _), (Œª x hx, mem_inter _ _)‚ü©
rw [‚Üêe.target_eq] at hx
{ rw [‚Üêe.target_eq] at hx, simp only [mem_inter_iff, mem_preimage, e.proj_symm_apply hx.2] at hx, simp only [mem_inter_eq, and_true, mem_univ, mem_prod], exact ‚ü®hx.1, e.mem_target.mp hx.2‚ü©, }
simp only [mem_inter_iff, mem_preimage, e.proj_symm_apply hx.2] at hx
simp only [mem_inter_eq, and_true, mem_univ, mem_prod]
exact ‚ü®hx.1, e.mem_target.mp hx.2‚ü©
simp only [mem_inter_eq, and_true, mem_univ, mem_prod, e.mem_target.symm] at hx
{ simp only [mem_inter_eq, and_true, mem_univ, mem_prod, e.mem_target.symm] at hx, simp only [mem_preimage, e.proj_symm_apply hx.2], exact hx.1, }
simp only [mem_preimage, e.proj_symm_apply hx.2]
exact hx.1
rw [‚Üêinter_univ univ, ‚Üêprod_inter_prod, mem_inter_eq] at hx
{ rw [‚Üêinter_univ univ, ‚Üêprod_inter_prod, mem_inter_eq] at hx, exact hx.2, }
exact hx.2
intros
simp only [metric.diam, emetric.diam_closure]
intros
{ apply tendsto.mul_const hm, simp [ha] }
apply tendsto.mul_const hm
simp [ha]
intros
simp only [nhds_top', mem_Ioi, tendsto_infi, tendsto_principal]
intros
simp [mem_closure_iff_nhds_basis nhds_basis_ball, real.dist_eq]
intros
rw (of_set s hs).trans_of_set hs'
ext
ext; simp [hs'.interior_eq]
simp [hs'.interior_eq]
simp [hs'.interior_eq]
simp [hs'.interior_eq]
intros
{ ext x, rw [set.mem_preimage, ‚Üê closure_induced, hf.induced] }
ext x
rw [set.mem_preimage, ‚Üê closure_induced, hf.induced]
intros
{ rw [nndist_pi_def], exact finset.le_sup (finset.mem_univ b) }
rw [nndist_pi_def]
exact finset.le_sup (finset.mem_univ b)
intros
simpa [infi_subtype] using @completion.uniformity_dist' Œ± _
intros
have := not_congr (@diam_eq_zero_iff _ _ s)
dunfold set.subsingleton at this
push_neg at this
simpa only [pos_iff_ne_zero, exists_prop] using this
intros
rw Hausdorff_edist_def
simp only [sup_le_iff, supr_le_iff]
split
show ‚àÄx ‚àà s, inf_edist x u ‚â§ Hausdorff_edist s t + Hausdorff_edist t u
from Œªx xs, calc inf_edist x u ‚â§ inf_edist x t + Hausdorff_edist t u : inf_edist_le_inf_edist_add_Hausdorff_edist ... ‚â§ Hausdorff_edist s t + Hausdorff_edist t u : add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xs) _
show ‚àÄx ‚àà u, inf_edist x s ‚â§ Hausdorff_edist s t + Hausdorff_edist t u
from Œªx xu, calc inf_edist x s ‚â§ inf_edist x t + Hausdorff_edist t s : inf_edist_le_inf_edist_add_Hausdorff_edist ... ‚â§ Hausdorff_edist u t + Hausdorff_edist t s : add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xu) _ ... = Hausdorff_edist s t + Hausdorff_edist t u : by simp [Hausdorff_edist_comm, add_comm]
intros
simp [Hausdorff_dist, Hausdorff_edist_image h]
intros
cases (univ : set Œ±).eq_empty_or_nonempty with h h
use (Œª_, 0)
{ use (Œª_, 0), assume x, exact absurd h (nonempty.ne_empty ‚ü®x, mem_univ x‚ü©) }
assume x
exact absurd h (nonempty.ne_empty ‚ü®x, mem_univ x‚ü©)
rcases h with ‚ü®basepoint‚ü©
{ rcases h with ‚ü®basepoint‚ü©, haveI : inhabited Œ± := ‚ü®basepoint‚ü©, have : ‚àÉs:set Œ±, countable s ‚àß dense s := exists_countable_dense Œ±, rcases this with ‚ü®S, ‚ü®S_countable, S_dense‚ü©‚ü©, rcases countable_iff_exists_surjective.1 S_countable with ‚ü®x, x_range‚ü©, exact ‚ü®embedding_of_subset x, embedding_of_subset_isometry x (S_dense.mono x_range)‚ü© }
haveI : inhabited Œ± := ‚ü®basepoint‚ü©
have : ‚àÉs:set Œ±, countable s ‚àß dense s := exists_countable_dense Œ±
rcases this with ‚ü®S, ‚ü®S_countable, S_dense‚ü©‚ü©
rcases countable_iff_exists_surjective.1 S_countable with ‚ü®x, x_range‚ü©
exact ‚ü®embedding_of_subset x, embedding_of_subset_isometry x (S_dense.mono x_range)‚ü©
intros
rw [nhds_induced, map_comap_of_surjective hf]
intros
ext
simp only [path.trans, if_t_t, one_div, path.refl_extend]
refl
intros
contrapose! hf
simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc, ‚Üê exists_prop] at hf ‚ä¢
exact @hs _ hf inf_le_right
intros
simp [continuous_on, continuous_within_at_iff'_left]
intros
simp [mem_closure_iff_nhds_basis (has_basis_nhds x)]
tauto
intros
assume f hf _
rcases complete_space.complete hf with ‚ü®x, hx‚ü©
exact ‚ü®x, mem_univ x, hx‚ü©
intros
simp only [CU.lim, approx_of_nmem_U c _ h, csupr_const]
intros
cases b; simp
cases b
simp
simp
intros
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
have h := int.add_lt_add_right h c
rwa int.sub_add_cancel at h
intros
rw [sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm, vsub_add_vsub_cancel]
intros
simp [bit0, add_smul, smul_add]
intros
split
split; intros h
intros h
rw [‚Üê one_mul a, ‚Üê lmul_right_apply a 1, h, linear_map.zero_apply]
{ rw [‚Üê one_mul a, ‚Üê lmul_right_apply a 1, h, linear_map.zero_apply], }
intros h
{ rw h, exact lmul_right_zero_eq_zero, }
rw h
exact lmul_right_zero_eq_zero
intros
simpa only [one_eq_span, span_le, set.singleton_subset_iff]
intros
subst T; exact set.Union_lift_inclusion _ _
subst T
exact set.Union_lift_inclusion _ _
intros
split_ifs
apply prod_eq_one
{ apply prod_eq_one, intros i hi, rw if_pos (h i hi) }
intros i hi
rw if_pos (h i hi)
push_neg at h
{ push_neg at h, rcases h with ‚ü®i, hi, hq‚ü©, apply prod_eq_zero hi, rw [if_neg hq] }
rcases h with ‚ü®i, hi, hq‚ü©
apply prod_eq_zero hi
rw [if_neg hq]
intros
set s := {x | p x}
have : mul_support (s.mul_indicator f) ‚äÜ t
rw [set.mul_support_mul_indicator]
{ rw [set.mul_support_mul_indicator], intros x hx, exact (h hx.2).1 hx.1 }
intros x hx
exact (h hx.2).1 hx.1
erw [finprod_mem_def, finprod_eq_prod_of_mul_support_subset _ this]
refine finset.prod_congr rfl (Œª x hx, mul_indicator_apply_eq_self.2 $ Œª hxs, _)
contrapose! hxs
exact (h hxs).2 hx
intros
letI := classical.dec_eq R; exact classical.by_cases (assume H : ‚àÄ p:‚Ñï, (p:R) = 0 ‚Üí p = 0, ‚ü®0, ‚ü®Œª x, by rw [zero_dvd_iff]; exact ‚ü®H x, by rintro rfl; refl‚ü©‚ü©‚ü©) (Œª H, ‚ü®nat.find (not_forall.1 H), ‚ü®Œª x, ‚ü®Œª H1, nat.dvd_of_mod_eq_zero (by_contradiction $ Œª H2, nat.find_min (not_forall.1 H) (nat.mod_lt x $ nat.pos_of_ne_zero $ not_of_not_imp $ nat.find_spec (not_forall.1 H)) (not_imp_of_and_not ‚ü®by rwa [‚Üê nat.mod_add_div x (nat.find (not_forall.1 H)), nat.cast_add, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul, add_zero] at H1, H2‚ü©)), Œª H1, by rw [‚Üê nat.mul_div_cancel' H1, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul]‚ü©‚ü©‚ü©)
letI := classical.dec_eq R
exact classical.by_cases (assume H : ‚àÄ p:‚Ñï, (p:R) = 0 ‚Üí p = 0, ‚ü®0, ‚ü®Œª x, by rw [zero_dvd_iff]; exact ‚ü®H x, by rintro rfl; refl‚ü©‚ü©‚ü©) (Œª H, ‚ü®nat.find (not_forall.1 H), ‚ü®Œª x, ‚ü®Œª H1, nat.dvd_of_mod_eq_zero (by_contradiction $ Œª H2, nat.find_min (not_forall.1 H) (nat.mod_lt x $ nat.pos_of_ne_zero $ not_of_not_imp $ nat.find_spec (not_forall.1 H)) (not_imp_of_and_not ‚ü®by rwa [‚Üê nat.mod_add_div x (nat.find (not_forall.1 H)), nat.cast_add, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul, add_zero] at H1, H2‚ü©)), Œª H1, by rw [‚Üê nat.mul_div_cancel' H1, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul]‚ü©‚ü©‚ü©)
intros
obtain ‚ü®ppredConts, nth_conts_eq, ‚ü®rfl‚ü©‚ü© : ‚àÉ conts, g.continuants n = conts ‚àß conts.b = ppredB
from exists_conts_b_of_denom nth_denom_eq
obtain ‚ü®predConts, succ_nth_conts_eq, ‚ü®rfl‚ü©‚ü© : ‚àÉ conts, g.continuants (n + 1) = conts ‚àß conts.b = predB
from exists_conts_b_of_denom succ_nth_denom_eq
rw [denom_eq_conts_b, (continuants_recurrence succ_nth_s_eq nth_conts_eq succ_nth_conts_eq)]
intros
cases s_nth_eq : (g.s.nth n); simp [partial_denominators, s_nth_eq]
cases s_nth_eq : (g.s.nth n)
simp [partial_denominators, s_nth_eq]
simp [partial_denominators, s_nth_eq]
intros
by_cases h : b ‚àà s
rw [insert_eq_of_mem h, (gcd_eq_right_iff (f b) (s.gcd f) (multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)]
{ rw [insert_eq_of_mem h, (gcd_eq_right_iff (f b) (s.gcd f) (multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)] ,}
apply fold_insert h
intros
have := (commute.one_right x).geom_sum‚ÇÇ_mul n
rw [one_pow, geom_sum‚ÇÇ_with_one] at this
exact this
intros
rw [sub_eq_add_neg, add_comm _ _]
intros
{ dsimp [bit1], rw [mul_add, mul_bit0, mul_one], }
dsimp [bit1]
rw [mul_add, mul_bit0, mul_one]
intros
simpa only [sq] using abs_mul_self x
intros
{ ext, refl }
ext
refl
intros
rw [mul_comm, mul_div_cancel_of_imp h]
intros
simp [single_map_homological_complex]
intros
rw ‚Üêeq_to_hom_comp_d C r r'
apply image_subobject_iso_comp
intros
dsimp [d_next]
simp only [chain_complex.next_nat_zero]
refl
intros
{ ext, simp [image_to_kernel'], }
ext
simp [image_to_kernel']
intros
{ rw le_inf_iff, exact ‚ü®lie_le_left I J, lie_le_right J I‚ü©, }
rw le_inf_iff
exact ‚ü®lie_le_left I J, lie_le_right J I‚ü©
intros
rw abelian_iff_derived_succ_eq_bot
let s := {k | derived_series_of_ideal R L k I = ‚ä•}
change Inf s = k + 1 ‚Üî k + 1 ‚àà s ‚àß k ‚àâ s
have hs : ‚àÄ (k‚ÇÅ k‚ÇÇ : ‚Ñï), k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí k‚ÇÅ ‚àà s ‚Üí k‚ÇÇ ‚àà s
intros k‚ÇÅ k‚ÇÇ h‚ÇÅ‚ÇÇ h‚ÇÅ
{ intros k‚ÇÅ k‚ÇÇ h‚ÇÅ‚ÇÇ h‚ÇÅ, suffices : derived_series_of_ideal R L k‚ÇÇ I ‚â§ ‚ä•, { exact eq_bot_iff.mpr this, }, change derived_series_of_ideal R L k‚ÇÅ I = ‚ä• at h‚ÇÅ, rw ‚Üê h‚ÇÅ, exact derived_series_of_ideal_antitone I h‚ÇÅ‚ÇÇ, }
suffices : derived_series_of_ideal R L k‚ÇÇ I ‚â§ ‚ä•
exact eq_bot_iff.mpr this
{ exact eq_bot_iff.mpr this, }
change derived_series_of_ideal R L k‚ÇÅ I = ‚ä• at h‚ÇÅ
rw ‚Üê h‚ÇÅ
exact derived_series_of_ideal_antitone I h‚ÇÅ‚ÇÇ
exact nat.Inf_upward_closed_eq_succ_iff hs k
intros
{ ext, rw mem_of_le, refl, }
ext
rw mem_of_le
refl
intros
rw [‚Üê lie_submodule.mem_coe_submodule, coe_map_of_surjective h‚ÇÅ, submodule.mem_map] at h‚ÇÇ
obtain ‚ü®x, hx, rfl‚ü© := h‚ÇÇ
use ‚ü®x, hx‚ü©
refl
intros
rw [is_weight, lie_hom.coe_zero, zero_weight_space_eq_top_of_nilpotent]
{ rw [is_weight, lie_hom.coe_zero, zero_weight_space_eq_top_of_nilpotent], exact top_ne_bot, }
exact top_ne_bot
intros
simp [add_smul, sub_eq_add_neg]
intros
rcases eq_or_lt_of_le hb with rfl|hb'
{ rcases eq_or_lt_of_le hb with rfl|hb', simp [hc], rwa [div_le_iff hb'] }
simp [hc]
rwa [div_le_iff hb']
intros
simpa using inv_le_of_neg ha hb
intros
simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc)
intros
{ rw [‚Üê mul_le_mul_iff_left a], simp }
rw [‚Üê mul_le_mul_iff_left a]
simp
intros
rw [‚Üê mul_lt_mul_iff_right b, inv_mul_cancel_right]
intros
rw [‚Üê mul_lt_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
intros
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®le_imp_le_of_lt_imp_lt $ Œª h', mul_lt_mul_of_neg_left h' h, Œª h', decidable.mul_le_mul_of_nonpos_left h' h.le‚ü©
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®le_imp_le_of_lt_imp_lt $ Œª h', mul_lt_mul_of_neg_left h' h, Œª h', decidable.mul_le_mul_of_nonpos_left h' h.le‚ü©
intros
nontriviality
exact (one_mul (1 : Œ±)) ‚ñ∏ decidable.mul_lt_mul' ha hb zero_le_one (zero_lt_one.trans_le ha)
intros
rw [bit0, ‚Üê two_mul, zero_le_mul_left (zero_lt_two : 0 < (2:Œ±))]
intros
rcases int.even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©
rcases int.even_or_odd n with ‚ü®k, rfl‚ü© | ‚ü®k, rfl‚ü©; have hk : (k : Œ±) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ‚Üê mul_assoc]
have hk : (k : Œ±) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ‚Üê mul_assoc]
{ simpa [hk, hi] using (h.int_even_mul_periodic k).eq }
simpa [hk, hi] using (h.int_even_mul_periodic k).eq
have hk : (k : Œ±) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ‚Üê mul_assoc]
simpa [add_mul, hk, hi] using (h.int_odd_mul_antiperiodic k).eq
{ simpa [add_mul, hk, hi] using (h.int_odd_mul_antiperiodic k).eq }
intros
simp
intros
simp only [‚Üê image_smul, mem_image, inv_smul_eq_iff, exists_eq_right]
intros
rw [‚Üê leading_coeff_hom_apply, monoid_hom.map_multiset_prod]
{ rw [‚Üê leading_coeff_hom_apply, monoid_hom.map_multiset_prod], refl }
refl
intros
refine iff.trans _ is_regular_mul_and_mul_iff
refine ‚ü®Œª ab, ‚ü®ab, by rwa mul_comm‚ü©, Œª rab, rab.1‚ü©
intros
rw mul_support_subset_iff'
simp only [mem_Union, not_exists, nmem_mul_support]
exact Œª x, finset.prod_eq_one
intros
{ ext x, exact (submodule.gi R R).gc s x.as_ideal }
ext x
exact (submodule.gi R R).gc s x.as_ideal
intros
rw [‚Üê as_ideal_le_as_ideal, ‚Üê zero_locus_vanishing_ideal_eq_closure, mem_zero_locus, vanishing_ideal_singleton, set_like.coe_subset_coe]
intros
dsimp [Œ¥, œÉ]
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_œÉ_self, X.map_id]
intros
cases (zero_le p.radius).eq_or_lt with h h
{ simp [‚Üê h, continuous_on_empty] }
simp [‚Üê h, continuous_on_empty]
{ exact (p.has_fpower_series_on_ball h).continuous_on }
exact (p.has_fpower_series_on_ball h).continuous_on
intros
subst n
apply id_apply_one
intros
refine ((h‚ÇÅ.norm_norm.mul_is_O h‚ÇÇ.norm_norm).congr _ _).of_norm_norm
refine ((h‚ÇÅ.norm_norm.mul_is_O h‚ÇÇ.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
unfold is_o
{ unfold is_o, exact ball_congr (Œª c hc, is_O_with_congr (eq.refl c) hf hg) }
exact ball_congr (Œª c hc, is_O_with_congr (eq.refl c) hf hg)
intros
unfold is_O_with
apply univ_mem'
intro x
rw [mem_set_of_eq, div_mul_cancel]
rwa [ne.def, norm_eq_zero]
intros
simp [has_deriv_at_filter]
intros
simp_rw [has_deriv_within_at, nhds_within_eq_nhds_within' hu h]
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
simp only [‚Üê fderiv_within_univ, fderiv_within_const_sub unique_diff_within_at_univ]
intros
refine ‚ü®h'.dense_of_maps_to f'.continuous hs.1 _, h.continuous_within_at.mem_closure_image hs.2‚ü©
show submodule.span ùïú (tangent_cone_at ùïú s x) ‚â§ (submodule.span ùïú (tangent_cone_at ùïú (f '' s) (f x))).comap ‚Üëf'
rw [submodule.span_le]
exact h.maps_to_tangent_cone.mono (subset.refl _) submodule.subset_span
intros
{ ext x, simp [iterated_deriv_within] }
ext x
simp [iterated_deriv_within]
intros
have hdf : ‚àÄ x ‚àà Ioi a, differentiable_at ‚Ñù f x
from Œª x hx, (hdf x hx).differentiable_at (Ioi_mem_nhds hx)
have hdg : ‚àÄ x ‚àà Ioi a, differentiable_at ‚Ñù g x
from Œª x hx, classical.by_contradiction (Œª h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_at_top_on_Ioi (Œª x hx, (hdf x hx).has_deriv_at) (Œª x hx, (hdg x hx).has_deriv_at) hg' hftop hgtop hdiv
intros
rintros y ‚ü®c, d, ds, ctop, clim‚ü©
exact ‚ü®c, d, mem_of_superset ds (Œªn hn, h hn), ctop, clim‚ü©
intros
induction n with n IH
{ ext m, simp }
ext m
simp
ext x m
{ ext x m, rw [iterated_fderiv_succ_apply_left, IH], change (fderiv ùïú (Œª (x : E), (0 : (E [√ón]‚ÜíL[ùïú] F))) x : E ‚Üí (E [√ón]‚ÜíL[ùïú] F)) (m 0) (tail m) = _, rw fderiv_const, refl }
rw [iterated_fderiv_succ_apply_left, IH]
change (fderiv ùïú (Œª (x : E), (0 : (E [√ón]‚ÜíL[ùïú] F))) x : E ‚Üí (E [√ón]‚ÜíL[ùïú] F)) (m 0) (tail m) = _
rw fderiv_const
refl
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
simp [is_R_or_C.norm_sq, complex.norm_sq]
intros
have A : has_fderiv_at (coe : ‚Ñù ‚Üí ‚ÑÇ) of_real_clm z := of_real_clm.has_fderiv_at
have B : has_fderiv_at e ((continuous_linear_map.smul_right 1 e' : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).restrict_scalars ‚Ñù) (of_real_clm z) := h.has_fderiv_at.restrict_scalars ‚Ñù
have C : has_fderiv_at re re_clm (e (of_real_clm z)) := re_clm.has_fderiv_at
simpa using (C.comp z (B.comp z A)).has_deriv_at
intros
rintro z ‚ü®a, b, ha, hb, hab, rfl‚ü©
split
calc x = a ‚Ä¢ x + b ‚Ä¢ x : by rw [‚Üêadd_smul, hab, one_smul] ... ‚â§ a ‚Ä¢ x + b ‚Ä¢ y : add_le_add_left (smul_le_smul_of_nonneg h hb) _
calc a ‚Ä¢ x + b ‚Ä¢ y ‚â§ a ‚Ä¢ y + b ‚Ä¢ y : add_le_add_right (smul_le_smul_of_nonneg h ha) _ ... = y : by rw [‚Üêadd_smul, hab, one_smul]
intros
simpa using hs.add_smul_mem zero_mem (by simpa using hx) ht
intros
simpa only [set.finite.coe_to_finset, set.finite.mem_to_finset, exists_prop] using hs.to_finset.convex_hull_eq
intros
refine Œª x y hx hy a b ha hb hab, ‚ü®hf.1 hx.1 hy.1 ha hb hab, _‚ü©
obtain rfl | ha' := ha.eq_or_lt
rw zero_add at hab
{ rw zero_add at hab, rw [hab, zero_smul, one_smul, zero_add], exact hy.2 }
rw [hab, zero_smul, one_smul, zero_add]
exact hy.2
calc f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y : hf.2 hx.1 hy.1 ha hb hab ... < a ‚Ä¢ r + b ‚Ä¢ r : add_lt_add_of_lt_of_le (smul_lt_smul_of_pos hx.2 ha') (smul_le_smul_of_nonneg hy.2.le hb) ... = r : convex.combo_self hab _
{ calc f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y : hf.2 hx.1 hy.1 ha hb hab ... < a ‚Ä¢ r + b ‚Ä¢ r : add_lt_add_of_lt_of_le (smul_lt_smul_of_pos hx.2 ha') (smul_le_smul_of_nonneg hy.2.le hb) ... = r : convex.combo_self hab _ }
intros
rw ‚Üêneg_convex_on_iff
refine convex_on_of_slope_mono_adjacent hs (Œª x y z hx hz hxy hyz, _)
rw ‚Üêneg_le_neg_iff
simp_rw [‚Üêneg_div, neg_sub, pi.neg_apply, neg_sub_neg]
exact hf hx hz hxy hyz
intros
rw [norm_add_mul_self, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]
norm_num
intros
simp [disjoint_iff, K.inf_orthogonal_eq_bot]
intros
{ rw [inner_smul_left, conj_of_real, algebra.smul_def], refl }
rw [inner_smul_left, conj_of_real, algebra.smul_def]
refl
intros
split
intros hv i j
{ intros hv i j, split_ifs, { simp [h, inner_self_eq_norm_sq_to_K, hv.1] }, { exact hv.2 h } }
split_ifs
{ simp [h, inner_self_eq_norm_sq_to_K, hv.1] }
simp [h, inner_self_eq_norm_sq_to_K, hv.1]
{ exact hv.2 h }
exact hv.2 h
intros h
{ intros h, split, { intros i, have h' : ‚à•v i‚à• ^ 2 = 1 ^ 2 := by simp [norm_sq_eq_inner, h i i], have h‚ÇÅ : 0 ‚â§ ‚à•v i‚à• := norm_nonneg _, have h‚ÇÇ : (0:‚Ñù) ‚â§ 1 := zero_le_one, rwa sq_eq_sq h‚ÇÅ h‚ÇÇ at h' }, { intros i j hij, simpa [hij] using h i j } }
split
intros i
{ intros i, have h' : ‚à•v i‚à• ^ 2 = 1 ^ 2 := by simp [norm_sq_eq_inner, h i i], have h‚ÇÅ : 0 ‚â§ ‚à•v i‚à• := norm_nonneg _, have h‚ÇÇ : (0:‚Ñù) ‚â§ 1 := zero_le_one, rwa sq_eq_sq h‚ÇÅ h‚ÇÇ at h' }
have h' : ‚à•v i‚à• ^ 2 = 1 ^ 2 := by simp [norm_sq_eq_inner, h i i]
have h‚ÇÅ : 0 ‚â§ ‚à•v i‚à• := norm_nonneg _
have h‚ÇÇ : (0:‚Ñù) ‚â§ 1 := zero_le_one
rwa sq_eq_sq h‚ÇÅ h‚ÇÇ at h'
intros i j hij
{ intros i j hij, simpa [hij] using h i j }
simpa [hij] using h i j
intros
simp only [norm_add_mul_self, norm_sub_mul_self, inner_smul_right, I_mul_re]
{ simp only [norm_add_mul_self, norm_sub_mul_self, inner_smul_right, I_mul_re], ring }
ring
intros
conv_rhs { rw ‚Üê complex.isometry_euclidean_proj_eq_self z }
{ conv_rhs { rw ‚Üê complex.isometry_euclidean_proj_eq_self z }, simp }
simp
intros
simp [reflection_apply, orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero hv]
intros
rw [dist_comm, dist_homothety_self]
intros
simp only [lipschitz_on_with_iff_dist_le_mul, dist_eq_norm]
intros
simp [metric.mem_closure_iff, dist_eq_norm]
intros
change summable (norm ‚àò _)
rw ‚Üê exp_series_apply_eq'
exact norm_exp_series_summable_of_mem_ball x hx
intros
obtain ‚ü®c, hc‚ü© : ‚àÉ (c : ùïú), 1 < ‚à•c‚à• := normed_field.exists_one_lt_norm ùïú
have A : ‚à•c‚à• < ‚à•c‚à• + 1
linarith
linarith
rcases exists_seq_norm_le_one_le_norm_sub' hc A h with ‚ü®f, hf‚ü©
exact ‚ü®‚à•c‚à• + 1, f, hc.trans A, hf.1, hf.2‚ü©
intros
replace hyp : ‚àÄ h ‚àà j.range, ‚àÉ g, f g = h ‚àß ‚à•g‚à• ‚â§ C*‚à•h‚à•
intros h h_in
{ intros h h_in, rcases (j.mem_range _).mp h_in with ‚ü®k, rfl‚ü©, rw hj, exact hyp k }
rcases (j.mem_range _).mp h_in with ‚ü®k, rfl‚ü©
rw hj
exact hyp k
exact controlled_closure_of_complete hC hŒµ hyp
intros
rw [‚Üê tendsto_comap_iff, comap_exp_at_top]
intros
rw div_eq_inv_mul
exact (has_deriv_at_log hx).comp_has_deriv_within_at x hf
intros
rcases even_or_odd' n with ‚ü®k, (rfl | rfl)‚ü©
rcases even_or_odd' n with ‚ü®k, (rfl | rfl)‚ü©; simp only [integral_sin_pow_even, integral_sin_pow_odd]; refine mul_pos (by norm_num [pi_pos]) (prod_pos (Œª n hn, div_pos _ _)); norm_cast; linarith
rcases even_or_odd' n with ‚ü®k, (rfl | rfl)‚ü©; simp only [integral_sin_pow_even, integral_sin_pow_odd]; refine mul_pos (by norm_num [pi_pos]) (prod_pos (Œª n hn, div_pos _ _)); norm_cast
rcases even_or_odd' n with ‚ü®k, (rfl | rfl)‚ü©; simp only [integral_sin_pow_even, integral_sin_pow_odd]; refine mul_pos (by norm_num [pi_pos]) (prod_pos (Œª n hn, div_pos _ _))
rcases even_or_odd' n with ‚ü®k, (rfl | rfl)‚ü©; simp only [integral_sin_pow_even, integral_sin_pow_odd]
simp only [integral_sin_pow_even, integral_sin_pow_odd]
refine mul_pos (by norm_num [pi_pos]) (prod_pos (Œª n hn, div_pos _ _))
norm_cast
linarith
norm_cast
norm_cast
linarith
linarith
simp only [integral_sin_pow_even, integral_sin_pow_odd]
refine mul_pos (by norm_num [pi_pos]) (prod_pos (Œª n hn, div_pos _ _))
norm_cast
norm_cast
linarith
linarith
norm_cast
linarith
intros
convert (hf.has_fderiv_within_at.rpow hg.has_fderiv_within_at h).has_deriv_within_at using 1
dsimp
ring
intros
{ rw ‚Üê one_rpow z, exact rpow_lt_rpow hx1 hx2 hz }
rw ‚Üê one_rpow z
exact rpow_lt_rpow hx1 hx2 hz
intros
simpa using cpow_neg x 1
simp [two_mul, sin_add]
simpa only [cos_zero, cos_pi] using intermediate_value_Icc' pi_pos.le continuous_cos.continuous_on
intros
have h : (exp (Œ∏ * I) + exp (-Œ∏ * I)) / 2 = 0 ‚Üî exp (2 * Œ∏ * I) = -1
rw [@div_eq_iff _ _ (exp (Œ∏ * I) + exp (-Œ∏ * I)) 2 0 two_ne_zero', zero_mul, add_eq_zero_iff_eq_neg, neg_eq_neg_one_mul, ‚Üê div_eq_iff (exp_ne_zero _), ‚Üê exp_sub]
{ rw [@div_eq_iff _ _ (exp (Œ∏ * I) + exp (-Œ∏ * I)) 2 0 two_ne_zero', zero_mul, add_eq_zero_iff_eq_neg, neg_eq_neg_one_mul, ‚Üê div_eq_iff (exp_ne_zero _), ‚Üê exp_sub], field_simp only, congr' 3, ring }
congr' 3
field_simp only
ring
rw [cos, h, ‚Üê exp_pi_mul_I, exp_eq_exp_iff_exists_int, mul_right_comm]
refine exists_congr (Œª x, _)
refine (iff_of_eq $ congr_arg _ _).trans (mul_right_inj' $ mul_ne_zero two_ne_zero' I_ne_zero)
ring
simp [arccos]
intros
apply squeeze_zero_norm' (eventually_norm_pow_le x)
exact tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg _) h
intros
by_cases hr‚ÇÄ : 0 ‚â§ r
rw eventually_at_top at h
{ rw eventually_at_top at h, rcases h with ‚ü®N, hN‚ü©, rw ‚Üê @summable_nat_add_iff Œ± _ _ _ _ N, refine summable_of_norm_bounded (Œª n, ‚à•f N‚à• * r^n) (summable.mul_left _ $ summable_geometric_of_lt_1 hr‚ÇÄ hr‚ÇÅ) (Œª n, _), conv_rhs {rw [mul_comm, ‚Üê zero_add N]}, refine le_geom hr‚ÇÄ n (Œª i _, _), convert hN (i + N) (N.le_add_left i) using 3, ac_refl }
rcases h with ‚ü®N, hN‚ü©
rw ‚Üê @summable_nat_add_iff Œ± _ _ _ _ N
refine summable_of_norm_bounded (Œª n, ‚à•f N‚à• * r^n) (summable.mul_left _ $ summable_geometric_of_lt_1 hr‚ÇÄ hr‚ÇÅ) (Œª n, _)
conv_rhs {rw [mul_comm, ‚Üê zero_add N]}
refine le_geom hr‚ÇÄ n (Œª i _, _)
convert hN (i + N) (N.le_add_left i) using 3
ac_refl
push_neg at hr‚ÇÄ
{ push_neg at hr‚ÇÄ, refine summable_of_norm_bounded_eventually 0 summable_zero _, rw nat.cofinite_eq_at_top, filter_upwards [h], intros n hn, by_contra h, push_neg at h, exact not_lt.mpr (norm_nonneg _) (lt_of_le_of_lt hn $ mul_neg_of_neg_of_pos hr‚ÇÄ h) }
refine summable_of_norm_bounded_eventually 0 summable_zero _
rw nat.cofinite_eq_at_top
filter_upwards [h]
intros n hn
by_contra h
push_neg at h
exact not_lt.mpr (norm_nonneg _) (lt_of_le_of_lt hn $ mul_neg_of_neg_of_pos hr‚ÇÄ h)
intros
simp
intros
apply exponential_ideal.mk'
intros B A
exact ‚ü®_, ‚ü®(h A).app B‚ü©‚ü©
intros
subst h; refl
subst h
refl
intros
{ cases E, congr, }
cases E
congr
intros
ext
{ ext, simp, }
simp
intros
simp [limit_iso_limit_curry_comp_lim, is_limit.cone_point_unique_up_to_iso, is_limit.unique_up_to_iso]
intros
tidy
intros
simp
intros
rw [coprod_comparison, coprod_comparison, coprod.map_desc, ‚Üê F.map_comp, ‚Üê F.map_comp, coprod.desc_comp, ‚Üê F.map_comp, coprod.inl_map, ‚Üê F.map_comp, coprod.inr_map]
intros
rw biprod.map_eq_map'
exact is_colimit.Œπ_map (binary_biproduct.is_colimit W X) _ _ walking_pair.left
intros
simp
intros
tidy
intros
{ rw [‚Üêleft_unitor_tensor, left_unitor_naturality], simp, }
rw [‚Üêleft_unitor_tensor, left_unitor_naturality]
simp
intros
{ slice_rhs 1 2 { rw left_unitor_inv_naturality }, simp }
slice_rhs 1 2 { rw left_unitor_inv_naturality }
simp
intros
dsimp [tensor_hom]
simp
intros
simp only [cancel_mono]
intros
fsplit
intro h
{ intro h, rw finrank_eq_one_iff' at h, obtain ‚ü®f, nz, -‚ü© := h, rw ‚Üêis_iso_iff_nonzero at nz, exactI ‚ü®as_iso f‚ü©, }
rw finrank_eq_one_iff' at h
obtain ‚ü®f, nz, -‚ü© := h
rw ‚Üêis_iso_iff_nonzero at nz
exactI ‚ü®as_iso f‚ü©
rintro ‚ü®f‚ü©
{ rintro ‚ü®f‚ü©, have le_one := finrank_hom_simple_simple_le_one ùïú X Y, have zero_lt : 0 < finrank ùïú (X ‚ü∂ Y) := finrank_pos_iff_exists_ne_zero.mpr ‚ü®f.hom, (is_iso_iff_nonzero f.hom).mp infer_instance‚ü©, linarith, }
have le_one := finrank_hom_simple_simple_le_one ùïú X Y
have zero_lt : 0 < finrank ùïú (X ‚ü∂ Y) := finrank_pos_iff_exists_ne_zero.mpr ‚ü®f.hom, (is_iso_iff_nonzero f.hom).mp infer_instance‚ü©
linarith
intros
rw [is_sheaf_for, yoneda_sheaf_condition]
simp_rw [extension_iff_amalgamation]
rw equiv.forall_congr_left' nat_trans_equiv_compatible_family
rw subtype.forall
apply ball_congr
intros x hx
rw equiv.exists_unique_congr_left _
simp
intros
rw ‚Üê galois_connection f
apply pushforward_le_bind_of_mem
intros
{ rw eq_mk f, simp, }
rw eq_mk f
simp
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp underlying]
intros
rw [‚Üêkernel_subobject_arrow]
{ rw [‚Üêkernel_subobject_arrow], simp only [category.assoc, kernel.condition, comp_zero], }
simp only [category.assoc, kernel.condition, comp_zero]
intros
simp [boundaries]
intros
simp only [option.get_or_else_none, h, l.apply]
intros
rw [accepts, Œµ_NFA.accepts, eval, Œµ_NFA.eval, to_Œµ_NFA_eval_from_match]
refl
intros
rw [mul_self_star_comm, one_add_self_mul_star_eq_star]
intros
cases x with _ x
dec_trivial
cases x
rw [rmatch, deriv]
split_ifs; tauto
split_ifs
tauto
tauto
rw [rmatch, deriv]
split_ifs
rw one_rmatch_iff
tauto
rw zero_rmatch
tauto
intros
induction c generalizing k v
exact ‚ü®_, _, rfl‚ü©
iterate 3 { exact ‚ü®_, _, rfl‚ü© }
exact ‚ü®_, _, rfl‚ü©
exact ‚ü®_, _, rfl‚ü©
case cons : f fs IHf IHfs { apply IHf }
case comp : f g IHf IHg { apply IHg }
case case : f g IHf IHg { rw step_normal, cases v.head; simp only [nat.elim]; [apply IHf, apply IHg] }
case fix : f IHf { apply IHf }
intros
conv {to_lhs, rw [‚Üê list_blank.cons_head_tail l]}
exact quotient.induction_on' l.tail (Œª l, rfl)
intros
simp only [(>=>)] with functor_norm
intros
rw ‚Üê comp_bitraverse; simp [tfst,tsnd]
rw ‚Üê comp_bitraverse
simp [tfst,tsnd]
intros
ext
ext; apply h
{ ext; apply h }
apply h
intros
induction x; simp! * with functor_norm; refl
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
cases b; refl
cases b
refl
refl
intros
simp [pure_eq_done]
intros
simp [many, foldr_eq_done]
intros
rw [add_comm, cosh_add_sinh]
intros
rw [‚Üê of_real_nat_cast, abs_of_nonneg (nat.cast_nonneg n)]
intros
ext j
rcases eq_or_ne i j with rfl|hi
{ simp }
simp
{ simp [hi.symm] }
simp [hi.symm]
intros
{ unfold swap_core, split_ifs; cc }
unfold swap_core
split_ifs
split_ifs; cc
cc
cc
cc
cc
intros
rw [fin_rotate_succ_apply, zero_add]
intros
simp [succ_above, h.not_lt]
intros
ext j
by_cases h : j = 0
{ rw h, simp }
rw h
simp
simp only [h, update_noteq, ne.def, not_false_iff]
{ simp only [h, update_noteq, ne.def, not_false_iff], let j' := pred j h, have : j'.succ = j := succ_pred j h, rw [‚Üê this, cons_succ, cons_succ] }
let j' := pred j h
have : j'.succ = j := succ_pred j h
rw [‚Üê this, cons_succ, cons_succ]
intros
cases n
{ exact absurd h (nat.not_lt_zero _) }
exact absurd h (nat.not_lt_zero _)
rw [lt_iff_coe_lt_coe, coe_last, ‚Üêadd_lt_add_iff_right 1] at h
{ rw [lt_iff_coe_lt_coe, coe_last, ‚Üêadd_lt_add_iff_right 1] at h, rw [lt_iff_coe_lt_coe, coe_add, coe_zero, coe_one, nat.mod_eq_of_lt h], exact nat.zero_lt_succ _ }
rw [lt_iff_coe_lt_coe, coe_add, coe_zero, coe_one, nat.mod_eq_of_lt h]
exact nat.zero_lt_succ _
intros
simp [eq_iff_veq]
intros
rw [list.to_finmap, lookup_to_finmap, lookup_to_alist]
intros
classical
rw [‚Üê piecewise_coe, ‚Üê piecewise_coe, ‚Üê set.piecewise_insert, ‚Üê coe_insert j s]
congr
intros
rw [singleton_eq_cons, to_finset_cons, to_finset_zero, is_lawful_singleton.insert_emptyc_eq]
intros
simp only [subset_def, image_val, subset_erase_dup', erase_dup_subset', multiset.map_subset_map h]
intros
simp [finset.subtype]
intros
ext
{ ext, simp only [finset.mem_bUnion, iff_self, exists_and_distrib_left, finset.mem_erase] }
simp only [finset.mem_bUnion, iff_self, exists_and_distrib_left, finset.mem_erase]
intros
{ intros x hx, rw finset.mem_union at hx ‚ä¢, tauto }
intros x hx
rw finset.mem_union at hx ‚ä¢
tauto
intros
classical
apply finset.induction_on s
simp
{ simp }
clear s
intros a s ha IH
rw [finset.fold_insert ha, hr, IH, ‚Üê or_assoc, or_comm (r c (f a)), or_assoc]
apply or_congr iff.rfl
split
rintro (h‚ÇÅ|‚ü®x, hx, h‚ÇÇ‚ü©)
{ rintro (h‚ÇÅ|‚ü®x, hx, h‚ÇÇ‚ü©), { use a, simp [h‚ÇÅ] }, { refine ‚ü®x, by simp [hx], h‚ÇÇ‚ü© } }
{ use a, simp [h‚ÇÅ] }
use a
simp [h‚ÇÅ]
{ refine ‚ü®x, by simp [hx], h‚ÇÇ‚ü© }
refine ‚ü®x, by simp [hx], h‚ÇÇ‚ü©
rintro ‚ü®x, hx, h‚ü©
{ rintro ‚ü®x, hx, h‚ü©, rw mem_insert at hx, cases hx, { left, rwa hx at h }, { right, exact ‚ü®x, hx, h‚ü© } }
rw mem_insert at hx
cases hx
{ left, rwa hx at h }
left
rwa hx at h
{ right, exact ‚ü®x, hx, h‚ü© }
right
exact ‚ü®x, hx, h‚ü©
intros
subst hs; exact finset.fold_congr hfg
subst hs
exact finset.fold_congr hfg
intros
simp
intros
simp [to_finset]
intros
ext a
by_cases a ‚àà set.range f
rcases h with ‚ü®a', rfl‚ü©
{ rcases h with ‚ü®a', rfl‚ü©, rw [map_range_apply, emb_domain_apply, emb_domain_apply, map_range_apply] }
rw [map_range_apply, emb_domain_apply, emb_domain_apply, map_range_apply]
rw [map_range_apply, emb_domain_notin_range, emb_domain_notin_range, ‚Üê hg]
rw [map_range_apply, emb_domain_notin_range, emb_domain_notin_range, ‚Üê hg]; assumption
{ rw [map_range_apply, emb_domain_notin_range, emb_domain_notin_range, ‚Üê hg]; assumption }
assumption
assumption
assumption
assumption
intros
simp [compl_eq_univ_sdiff]
intros
convert fintype.card_unique
exact unique.subtype_eq' _
intros
have := le_trans (le_abs_self _) (abs_div_le_abs a b)
have := le_trans (le_abs_self _) (abs_div_le_abs a b); rwa [abs_of_nonneg Ha] at this
rwa [abs_of_nonneg Ha] at this
intros
simp [xgcd_aux]
intros
rw [odd_iff_not_even, nat.odd_iff_not_even, nat_abs_even]
intros
rw [insert_entries, kerase_of_not_mem_keys h]
intros
simp only [update_nth_eq_modify_nth, nth_modify_nth_eq]
intros
simp only [scanr, scanr_aux_cons, foldr_cons]; split; refl
simp only [scanr, scanr_aux_cons, foldr_cons]; split
simp only [scanr, scanr_aux_cons, foldr_cons]
split
refl
refl
intros
have : (L.map length).take i = ((L.take (i+1)).map length).take i
simp [map_take, take_take]
simp [map_take, take_take]
simp [take_sum_join, this, drop_sum_join, drop_take_succ_eq_cons_nth_le _ hi]
intros
simp only [subset_def, mem_cons_iff, or_imp_distrib, forall_and_distrib, forall_eq]
intros
induction l with a l ih
{ exact iff_of_true rfl (forall_mem_nil _) }
exact iff_of_true rfl (forall_mem_nil _)
rw forall_mem_cons
by_cases p a
rw [filter_cons_of_pos _ h, cons_inj, ih, and_iff_right h]
{ rw [filter_cons_of_pos _ h, cons_inj, ih, and_iff_right h] }
rw [filter_cons_of_neg _ h]
{ rw [filter_cons_of_neg _ h], refine iff_of_false _ (mt and.left h), intro e, have := filter_sublist l, rw e at this, exact not_lt_of_ge (length_le_of_sublist this) (lt_succ_self _) }
refine iff_of_false _ (mt and.left h)
intro e
have := filter_sublist l
rw e at this
exact not_lt_of_ge (length_le_of_sublist this) (lt_succ_self _)
intros
simp [inits_eq_tails]
intros
induction l with _ _ ih; [refl, simp [h _ (or.inl rfl), ih (forall_mem_of_forall_mem_cons h)]]
induction l with _ _ ih
refl
simp [h _ (or.inl rfl), ih (forall_mem_of_forall_mem_cons h)]
intros
simp only [concat_eq_append, length_append, length]
intros
{induction s, contradiction, refl}
induction s
contradiction
refl
intros
induction l generalizing b; simp only [map, chain.nil, chain_cons, *]
induction l generalizing b
simp only [map, chain.nil, chain_cons, *]
simp only [map, chain.nil, chain_cons, *]
intros
induction s using quotient.induction_on'
rw [lists, quotient.lift_on'_mk']
simp
intros
dsimp [Ico]; simp only [pairwise_lt_range']
dsimp [Ico]
simp only [pairwise_lt_range']
intros
simp only [iota_eq_reverse_range', mem_reverse, mem_range', add_comm, lt_succ_iff]
intros
induction n with n hn generalizing l
{ simp }
simp
cases l with hd tl
{ cases l with hd tl, { simp }, { simp [rotate_cons_succ, hn, append_eq_cons_iff, and_comm] } }
{ simp }
simp
{ simp [rotate_cons_succ, hn, append_eq_cons_iff, and_comm] }
simp [rotate_cons_succ, hn, append_eq_cons_iff, and_comm]
intros
obtain ‚ü®hd, tl, rfl‚ü© := exists_cons_of_ne_nil h
exact cyclic_permutations_cons _ _
intros
rw [‚Üê sublists_reverse, reverse_reverse]
intros
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l'
{ cases l', { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
ext i j; simp
ext i j
simp
intros
rw [conj_transpose, conj_transpose, transpose_map, transpose_map, update_column_transpose, map_update_row]
refl
intros
simp [dot_product]
intros
{ ext, refl, }
ext
refl
intros
{ ext i j, rcases i; rcases j; simp [one_apply] }
ext i j
rcases i
rcases i; rcases j; simp [one_apply]
rcases i; rcases j
rcases j
simp [one_apply]
simp [one_apply]
rcases j
simp [one_apply]
simp [one_apply]
intros
{ ext, by_cases h : i = j; simp [h] }
ext
by_cases h : i = j
by_cases h : i = j; simp [h]
simp [h]
simp [h]
intros
{ ext i, simp [vec_mul] }
ext i
simp [vec_mul]
intros
rw [union_comm, eq_union_left h]
intros
rw strong_downward_induction
intros
simp [nodup_ext]
intros
funext; simp [functor.map]
funext
simp [functor.map]
intros
rw [revzip, powerset_aux', ‚Üê map_reverse, zip_map, ‚Üê revzip] at h
simp at h
rcases h with ‚ü®l‚ÇÅ, l‚ÇÇ, h, rfl, rfl‚ü©
exact quot.sound (revzip_sublists' _ _ _ h)
intros
induction n; simp [pow_succ, *]
induction n
simp [pow_succ, *]
simp [pow_succ, *]
intros
rw [mul_comm n m, mul_comm k m] at H; exact nat.eq_of_mul_eq_mul_left Hm H
rw [mul_comm n m, mul_comm k m] at H
exact nat.eq_of_mul_eq_mul_left Hm H
intros
{ cases n, cases h, apply succ_pos, }
cases n
cases h
apply succ_pos
intros
rw [‚Üê nat.sub_one, nat.sub_sub, one_add]; refl
rw [‚Üê nat.sub_one, nat.sub_sub, one_add]
refl
intros
simp [lor]
intros
induction n; simp [*, choose, add_comm]
induction n
simp [*, choose, add_comm]
simp [*, choose, add_comm]
intros
induction L with d L ih
{ dsimp [of_digits], simp }
dsimp [of_digits]
simp
dsimp [of_digits]
{ dsimp [of_digits], replace w‚ÇÇ := w‚ÇÇ (by simp), rw digits_add b h, { rw ih, { simp, }, { intros l m, apply w‚ÇÅ, exact list.mem_cons_of_mem _ m, }, { intro h, { rw [list.last_cons _ h] at w‚ÇÇ, convert w‚ÇÇ, }}}, { convert w‚ÇÅ d (list.mem_cons_self _ _), simp, }, { by_cases h' : L = [], { rcases h' with rfl, simp at w‚ÇÇ, left, apply nat.pos_of_ne_zero, convert w‚ÇÇ, simp, }, { right, apply nat.pos_of_ne_zero, contrapose! w‚ÇÇ, apply digits_zero_of_eq_zero _ w‚ÇÇ, { rw list.last_cons _ h', exact list.last_mem h', }, { exact le_of_lt h, }, }, }, }
replace w‚ÇÇ := w‚ÇÇ (by simp)
rw digits_add b h
rw ih
{ rw ih, { simp, }, { intros l m, apply w‚ÇÅ, exact list.mem_cons_of_mem _ m, }, { intro h, { rw [list.last_cons _ h] at w‚ÇÇ, convert w‚ÇÇ, }}}
{ simp, }
simp
{ intros l m, apply w‚ÇÅ, exact list.mem_cons_of_mem _ m, }
intros l m
apply w‚ÇÅ
exact list.mem_cons_of_mem _ m
intro h
{ intro h, { rw [list.last_cons _ h] at w‚ÇÇ, convert w‚ÇÇ, }}
rw [list.last_cons _ h] at w‚ÇÇ
{ rw [list.last_cons _ h] at w‚ÇÇ, convert w‚ÇÇ, }
convert w‚ÇÇ
{ convert w‚ÇÅ d (list.mem_cons_self _ _), simp, }
convert w‚ÇÅ d (list.mem_cons_self _ _)
simp
by_cases h' : L = []
{ by_cases h' : L = [], { rcases h' with rfl, simp at w‚ÇÇ, left, apply nat.pos_of_ne_zero, convert w‚ÇÇ, simp, }, { right, apply nat.pos_of_ne_zero, contrapose! w‚ÇÇ, apply digits_zero_of_eq_zero _ w‚ÇÇ, { rw list.last_cons _ h', exact list.last_mem h', }, { exact le_of_lt h, }, }, }
rcases h' with rfl
{ rcases h' with rfl, simp at w‚ÇÇ, left, apply nat.pos_of_ne_zero, convert w‚ÇÇ, simp, }
simp at w‚ÇÇ
left
apply nat.pos_of_ne_zero
convert w‚ÇÇ
simp
right
{ right, apply nat.pos_of_ne_zero, contrapose! w‚ÇÇ, apply digits_zero_of_eq_zero _ w‚ÇÇ, { rw list.last_cons _ h', exact list.last_mem h', }, { exact le_of_lt h, }, }
apply nat.pos_of_ne_zero
contrapose! w‚ÇÇ
apply digits_zero_of_eq_zero _ w‚ÇÇ
rw list.last_cons _ h'
{ rw list.last_cons _ h', exact list.last_mem h', }
exact list.last_mem h'
exact le_of_lt h
{ exact le_of_lt h, }
intros
simp [dist.def, nat.sub_self]
intros
rw [‚Üêzero_asc_factorial, cast_asc_factorial, cast_zero, zero_add]
intros
induction n with n ih
{ simp }
simp
simp only [succ_eq_add_one, multiplicity.mul, hp, prime_iff.mp hp, ih, multiplicity_factorial_mul_succ, ‚Üêadd_assoc, nat.cast_one, nat.cast_add, factorial_succ]
{ simp only [succ_eq_add_one, multiplicity.mul, hp, prime_iff.mp hp, ih, multiplicity_factorial_mul_succ, ‚Üêadd_assoc, nat.cast_one, nat.cast_add, factorial_succ], congr' 1, rw [add_comm, add_assoc] }
congr' 1
rw [add_comm, add_assoc]
intros
induction n; simp [shiftl', bit_ne_zero, *]
induction n
simp [shiftl', bit_ne_zero, *]
simp [shiftl', bit_ne_zero, *]
intros
refine prime_def_lt.mpr ‚ü®h1, Œª m mlt mdvd, _‚ü©
have hm : m ‚â† 0
rintro rfl
{ rintro rfl, rw zero_dvd_iff at mdvd, exact mlt.ne' mdvd }
rw zero_dvd_iff at mdvd
exact mlt.ne' mdvd
exact (h m mlt hm).symm.eq_one_of_dvd mdvd
intros
rw [‚Üê pow_one p, totient_prime_pow hp]; simp
rw [‚Üê pow_one p, totient_prime_pow hp]
simp
simp
intros
cases a; refl
cases a
refl
refl
refl
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp only [map_none, map_some, eq_self_iff_true]
{ cases x; simp only [map_none, map_some, eq_self_iff_true] }
cases x
simp only [map_none, map_some, eq_self_iff_true]
simp only [map_none, map_some, eq_self_iff_true]
intros
unfold emem; induction t; simp [any, *, or_assoc]
unfold emem; induction t
unfold emem
induction t
simp [any, *, or_assoc]
simp [any, *, or_assoc]
intros
linarith
intros
cases f
cases f; refl
refl
intros
simp only [liftp_iff, sigma.mk.inj_iff]
simp only [liftp_iff, sigma.mk.inj_iff]; split; intro
simp only [liftp_iff, sigma.mk.inj_iff]; split
split
intro
{ casesm* [Exists _, _ ‚àß _], subst_vars, assumption }
casesm* [Exists _, _ ‚àß _]
subst_vars
assumption
intro
constructor
repeat { constructor <|> assumption }
constructor
constructor
constructor
constructor
constructor
constructor
assumption
intros
dsimp only [M.corec,M.mk]
congr' with n
cases n with n
{ dsimp only [s_corec,approx.s_mk], refl, }
dsimp only [s_corec,approx.s_mk]
refl
dsimp only [s_corec,approx.s_mk]
{ dsimp only [s_corec,approx.s_mk], cases h : (f x‚ÇÄ), dsimp only [(<$>),pfunctor.map], congr, }
cases h : (f x‚ÇÄ)
dsimp only [(<$>),pfunctor.map]
congr
intros
let u := factor_multiset n
have : n = u.prod := (prod_factor_multiset n).symm
rw[this, ‚Üê prime_multiset.prod_smul]
rw[prime_multiset.factor_multiset_prod]
repeat {rw[prime_multiset.factor_multiset_prod]}
rw[prime_multiset.factor_multiset_prod]
intros
simp
intros
split
intro H
{ intro H, rwa ‚Üê degree_eq_iff_nat_degree_eq, rintro rfl, rw degree_zero at H, exact option.no_confusion H }
rwa ‚Üê degree_eq_iff_nat_degree_eq
rintro rfl
rw degree_zero at H
exact option.no_confusion H
{ intro H, rwa degree_eq_iff_nat_degree_eq, rintro rfl, rw nat_degree_zero at H, rw H at hn, exact lt_irrefl _ hn }
intro H
rwa degree_eq_iff_nat_degree_eq
rintro rfl
rw nat_degree_zero at H
rw H at hn
exact lt_irrefl _ hn
intros
simp only [‚ÜêC_eq_int_cast, nat_degree_C]
intros
by_cases hp : p = 0
{ simp only [hp, zero_mul, leading_coeff_zero] }
simp only [hp, zero_mul, leading_coeff_zero]
by_cases hq : q = 0
{ by_cases hq : q = 0, { simp only [hq, mul_zero, leading_coeff_zero] }, { rw [leading_coeff_mul'], exact mul_ne_zero (mt leading_coeff_eq_zero.1 hp) (mt leading_coeff_eq_zero.1 hq) } }
{ simp only [hq, mul_zero, leading_coeff_zero] }
simp only [hq, mul_zero, leading_coeff_zero]
rw [leading_coeff_mul']
{ rw [leading_coeff_mul'], exact mul_ne_zero (mt leading_coeff_eq_zero.1 hp) (mt leading_coeff_eq_zero.1 hq) }
exact mul_ne_zero (mt leading_coeff_eq_zero.1 hp) (mt leading_coeff_eq_zero.1 hq)
intros
by_cases hf : f = 0
{ exact (congr_arg polynomial.nat_degree hf).trans rfl }
exact (congr_arg polynomial.nat_degree hf).trans rfl
rw nat_degree_eq_zero_iff_degree_le_zero
{ rw nat_degree_eq_zero_iff_degree_le_zero, by_contra absurd, have f_nat_degree_pos : 0 < f.nat_degree, { rwa [not_le, ‚Üênat_degree_pos_iff_degree_pos] at absurd }, let m := f.nat_degree - 1, have hm : m + 1 = f.nat_degree := nat.sub_add_cancel f_nat_degree_pos, have h2 := coeff_derivative f m, rw polynomial.ext_iff at h, rw [h m, coeff_zero, zero_eq_mul] at h2, cases h2, { rw [hm, ‚Üêleading_coeff, leading_coeff_eq_zero] at h2, exact hf h2, }, { norm_cast at h2 } }
by_contra absurd
have f_nat_degree_pos : 0 < f.nat_degree
{ rwa [not_le, ‚Üênat_degree_pos_iff_degree_pos] at absurd }
rwa [not_le, ‚Üênat_degree_pos_iff_degree_pos] at absurd
let m := f.nat_degree - 1
have hm : m + 1 = f.nat_degree := nat.sub_add_cancel f_nat_degree_pos
have h2 := coeff_derivative f m
rw polynomial.ext_iff at h
rw [h m, coeff_zero, zero_eq_mul] at h2
cases h2
rw [hm, ‚Üêleading_coeff, leading_coeff_eq_zero] at h2
{ rw [hm, ‚Üêleading_coeff, leading_coeff_eq_zero] at h2, exact hf h2, }
exact hf h2
{ norm_cast at h2 }
norm_cast at h2
intros
rw [X_mul, eval‚ÇÇ_mul_X]
intros
rw mem_roots (show p.map f ‚â† 0, by exact map_ne_zero hp)
dsimp only [is_root]
rw polynomial.eval_map
intros
simp only [hasse_deriv_apply, nat.sub_zero, nat.choose_zero_right, nat.cast_one, one_mul, sum_monomial_eq]
intros
rw [sub_eq_add_neg, iterated_deriv_add, iterated_deriv_neg, ‚Üêsub_eq_add_neg]
intros
rw [‚Üê one_mul (X ^ n), ‚Üê one_mul (X ^ (rev_at N n)), ‚Üê C_1, reflect_C_mul_X_pow]
intros
induction n with n hn
refine root_multiplicity_eq_zero _
{ refine root_multiplicity_eq_zero _, simp only [eval_one, is_root.def, not_false_iff, one_ne_zero, pow_zero] }
simp only [eval_one, is_root.def, not_false_iff, one_ne_zero, pow_zero]
have hzero := (ne_zero_of_monic (monic_pow (monic_X_sub_C a) n.succ))
rw pow_succ (X - C a) n at hzero ‚ä¢
simp only [root_multiplicity_mul hzero, root_multiplicity_X_sub_C_self, hn, nat.one_add]
intros
revert h
apply q.P.W_cases _ x
intros a‚ÇÄ f'‚ÇÄ f‚ÇÄ
apply q.P.W_cases _ y
intros a‚ÇÅ f'‚ÇÅ f‚ÇÅ
apply Wequiv.abs
intros
rw [rat.mul_denom, int.nat_abs_mul, nat.coprime.gcd_eq_one, nat.div_one]
rw [rat.mul_denom, int.nat_abs_mul, nat.coprime.gcd_eq_one, nat.div_one]; exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
intros
cases a with n; exact or.imp_right neg_nonneg_of_nonpos (le_total 0 n)
cases a with n
exact or.imp_right neg_nonneg_of_nonpos (le_total 0 n)
intros
{ simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero] }
simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero]
intros
simp [ennreal.to_real, ennreal.of_real, h]
intros
rw [ennreal.of_real, ennreal.of_real, ‚Üê@coe_inv (real.to_nnreal x) (by simp [hx]), coe_eq_coe, real.to_nnreal_inv.symm]
intros
simp [upper_bounds, ball_image_iff, -mem_image, *] {contextual := tt}
rw fib_rec.sol_eq_of_eq_init
intros i hi
{ intros i hi, fin_cases hi, { simp }, { simp only [golden_ratio, golden_conj], ring_exp, rw mul_inv_cancel; norm_num } }
fin_cases hi
{ simp }
simp
simp only [golden_ratio, golden_conj]
{ simp only [golden_ratio, golden_conj], ring_exp, rw mul_inv_cancel; norm_num }
ring_exp
rw mul_inv_cancel
rw mul_inv_cancel; norm_num
norm_num
norm_num
{ exact fib_is_sol_fib_rec }
exact fib_is_sol_fib_rec
ring_nf
{ ring_nf, exact (@fib_rec ‚Ñù _).sol_space.sub_mem (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)‚Åª¬π geom_gold_is_sol_fib_rec) (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)‚Åª¬π geom_gold_conj_is_sol_fib_rec) }
exact (@fib_rec ‚Ñù _).sol_space.sub_mem (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)‚Åª¬π geom_gold_is_sol_fib_rec) (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)‚Åª¬π geom_gold_conj_is_sol_fib_rec)
intros
rw [infinite_pos_iff_infinite_and_pos]; exact ‚ü®Œª hI, hI.1, Œª hI, ‚ü®hI, hp‚ü©‚ü©
rw [infinite_pos_iff_infinite_and_pos]
exact ‚ü®Œª hI, hI.1, Œª hI, ‚ü®hI, hp‚ü©‚ü©
intros
rcases le_iff_exists_add.mp mn with ‚ü®k, rfl‚ü©
rw [‚Üê mul_one (a ^ m), pow_add]
refine mul_le_mul rfl.le (pow_le_one _ (zero_le a) a1) _ _
refine mul_le_mul rfl.le (pow_le_one _ (zero_le a) a1) _ _; exact pow_nonneg (zero_le _) _
exact pow_nonneg (zero_le _) _
exact pow_nonneg (zero_le _) _
pi_lower_bound [23/16]
intros
rw [sq, sqrt_eq_iff_mul_self_eq hx hy]
intros
simp only [preimage, inv_comp, image_comp]
intros
apply eq_of_bisim (Œªc‚ÇÅ c‚ÇÇ, (c‚ÇÇ <|> empty Œ±) = c‚ÇÅ) _ rfl
intros s' s h
rw ‚Üêh
apply cases_on s; intros s; rw think_empty; simp
apply cases_on s; intros s; rw think_empty
apply cases_on s; intros s
apply cases_on s
intros s
rw think_empty
simp
intros s
rw think_empty
simp
rw‚Üêthink_empty
intros
apply subtype.eq
funext n
dsimp [to_seq]
apply get_eq_of_mem
rw nth_of_seq
apply ret_mem
intros
simp
intros
cases hs with a ha
{ cases hs with a ha, cases ht with b hb, exact ‚ü®f a b, ‚ü®a, b, ha, hb, rfl‚ü©‚ü© }
cases ht with b hb
exact ‚ü®f a b, ‚ü®a, b, ha, hb, rfl‚ü©‚ü©
intros
rw [image_image, image_congr hf, image_id']
intros
{ ext x, simp [‚Üê e.lt_iff_lt] }
ext x
simp [‚Üê e.lt_iff_lt]
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ioc_of_neg a b h
intros
simp [proj_Icc, hx.1, hx.2]
intros
rw [interval, min_eq_left h, max_eq_right h]
intros
{ ext, simp }
ext
simp
intros
rw [diff_eq, compl_Inter, inter_Union]; refl
rw [diff_eq, compl_Inter, inter_Union]
refl
intros
{ cases s, refl }
cases s
refl
intros
rw [card_eq_sum_card_fiberwise (Œª x, mem_image_of_mem _ : ‚àÄ x ‚àà s.off_diag, quotient.mk x ‚àà s.off_diag.image quotient.mk), sum_const_nat (quotient.ind _), mul_comm]
rintro ‚ü®x, y‚ü© hxy
simp_rw [mem_image, exists_prop, mem_off_diag, quotient.eq] at hxy
obtain ‚ü®a, ‚ü®ha‚ÇÅ, ha‚ÇÇ, ha‚ü©, h‚ü© := hxy
obtain ‚ü®hx, hy, hxy‚ü© : x ‚àà s ‚àß y ‚àà s ‚àß x ‚â† y
cases h; have := ha.symm; exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
cases h; have := ha.symm
{ cases h; have := ha.symm; exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü© }
cases h
have := ha.symm
exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
have := ha.symm
exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
have hxy' : y ‚â† x := hxy.symm
have : s.off_diag.filter (Œª z, ‚ü¶z‚üß = ‚ü¶(x, y)‚üß) = ({(x, y), (y, x)} : finset _)
ext ‚ü®x‚ÇÅ, y‚ÇÅ‚ü©
{ ext ‚ü®x‚ÇÅ, y‚ÇÅ‚ü©, rw [mem_filter, mem_insert, mem_singleton, sym2.eq_iff, prod.mk.inj_iff, prod.mk.inj_iff, and_iff_right_iff_imp], rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©); rw mem_off_diag; exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü© }
rw [mem_filter, mem_insert, mem_singleton, sym2.eq_iff, prod.mk.inj_iff, prod.mk.inj_iff, and_iff_right_iff_imp]
rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©); rw mem_off_diag; exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©); rw mem_off_diag
rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©)
rw mem_off_diag
exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
rw mem_off_diag
exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
rw [this, card_insert_of_not_mem, card_singleton]
simp only [not_and, prod.mk.inj_iff, mem_singleton]
exact Œª _, hxy'
intros
{ rw quotient.eq, apply rel.swap }
rw quotient.eq
apply rel.swap
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
rw [‚Üê nth_tail_succ, tail_cons]
intros
rcases v with ‚ü®l, rfl‚ü©
apply to_list_injective
change nth ‚ü®l, eq.refl _‚ü© with Œª i, nth ‚ü®l, rfl‚ü© i
simpa only [to_list_of_fn] using list.of_fn_nth_le _
intros
rw ring_hom.injective_iff
intro x
obtain ‚ü®k, rfl‚ü© := zmod.int_cast_surjective x
rw [ring_hom.map_int_cast, char_p.int_cast_eq_zero_iff R n, char_p.int_cast_eq_zero_iff (zmod n) n]
exact id
intros
fin_cases a; ext; simp [fin.coe_neg, int.nat_mod]; norm_num
fin_cases a; ext; simp [fin.coe_neg, int.nat_mod]
fin_cases a; ext
fin_cases a
ext
simp [fin.coe_neg, int.nat_mod]
ext
simp [fin.coe_neg, int.nat_mod]
intros
refine {..}; simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
refine {..}
{ refine {..}; simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt} }
simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
intros
simp_rw [is_periodic_pt_iff_minimal_period_dvd, dvd_right_iff_eq]
intros
ext x
show x ‚àà (subfield.closure (set.range (algebra_map F E) ‚à™ S)).map (f : E ‚Üí+* E') ‚Üî x ‚àà subfield.closure (set.range (algebra_map F E') ‚à™ f '' S)
rw [ring_hom.map_field_closure, set.image_union, ‚Üê set.range_comp, ‚Üê ring_hom.coe_comp, f.comp_algebra_map]
refl
intros
obtain ‚ü®x : lifts F E K, hx‚ü© := zorn.zorn_partial_order lifts.exists_upper_bound
refine ‚ü®alg_hom.mk (Œª s, x.2 ‚ü®s, adjoin_le_iff.mpr (Œª s hs, _) s.mem‚ü©) x.2.map_one (Œª s t, x.2.map_mul ‚ü®s, _‚ü© ‚ü®t, _‚ü©) x.2.map_zero (Œª s t, x.2.map_add ‚ü®s, _‚ü© ‚ü®t, _‚ü©) x.2.commutes‚ü©
rcases (x.exists_lift_of_splits (hK s hs).1 (hK s hs).2) with ‚ü®y, h1, h2‚ü©
rwa hx y h1 at h2
intros
{ ext a, rw [frobenius_def, zmod.pow_card, ring_hom.id_apply] }
ext a
rw [frobenius_def, zmod.pow_card, ring_hom.id_apply]
intros
apply (is_primitive.dvd_iff_fraction_map_dvd_fraction_map K (monic.is_primitive (monic hx)) hprim).2
rw ‚Üê gcd_domain_eq_field_fractions K hx
refine dvd _ _ _
rwa ‚Üê is_scalar_tower.aeval_apply
intros
split
intro H
{ intro H, replace H := quot.exact _ H, induction H, case eqv_gen.rel : x y H { cases H with n x, exact ‚ü®0, rfl‚ü© }, case eqv_gen.refl : H { exact ‚ü®0, rfl‚ü© }, case eqv_gen.symm : x y H ih { cases ih with w ih, exact ‚ü®w, ih.symm‚ü© }, case eqv_gen.trans : x y z H1 H2 ih1 ih2 { cases ih1 with z1 ih1, cases ih2 with z2 ih2, existsi z2+(y.1+z1), rw [‚Üê add_assoc, iterate_add_apply, ih1], rw [‚Üê iterate_add_apply, add_comm, iterate_add_apply, ih2], rw [‚Üê iterate_add_apply], simp only [add_comm, add_left_comm] } }
replace H := quot.exact _ H
induction H
case eqv_gen.rel : x y H { cases H with n x, exact ‚ü®0, rfl‚ü© }
case eqv_gen.refl : H { exact ‚ü®0, rfl‚ü© }
exact ‚ü®0, rfl‚ü©
case eqv_gen.symm : x y H ih { cases ih with w ih, exact ‚ü®w, ih.symm‚ü© }
case eqv_gen.trans : x y z H1 H2 ih1 ih2 { cases ih1 with z1 ih1, cases ih2 with z2 ih2, existsi z2+(y.1+z1), rw [‚Üê add_assoc, iterate_add_apply, ih1], rw [‚Üê iterate_add_apply, add_comm, iterate_add_apply, ih2], rw [‚Üê iterate_add_apply], simp only [add_comm, add_left_comm] }
intro H
cases x with m x
cases y with n y
cases H with z H
dsimp only at H
rw [r.sound K p (n+z) m x _ rfl, r.sound K p (m+z) n y _ rfl, H]
rw [add_assoc, add_comm, add_comm z]
intros
simp [splits, polynomial.map_map]
intros
simp [‚Üê cos_angle_mul_norm_mul_norm, h]
intros
haveI : nonempty (‚ä§ : affine_subspace ‚Ñù P) := set.univ.nonempty
rw [‚Üêfinrank_top, ‚Üêdirection_top ‚Ñù V P] at hd
refine exists_circumradius_eq_of_cospherical_subset _ hd hc
exact set.subset_univ _
intros
rcases ho with ‚ü®t, hto, hst‚ü©
rw hst at hps
rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto hps hpi with ‚ü®c, hcs, hc‚ü©
exact cospherical.affine_independent ‚ü®c, t.circumradius, hc‚ü© set.subset.rfl hpi
intros
simp only [chart_at] with mfld_simps
intros
unfold unique_mdiff_within_at
simp only [preimage_univ, univ_inter]
exact I.unique_diff _ (mem_range_self _)
intros
split
assume h
{ assume h, apply h.congr_of_eventually_eq h‚ÇÅ hx }
apply h.congr_of_eventually_eq h‚ÇÅ hx
assume h
{ assume h, apply h.congr_of_eventually_eq _ hx.symm, apply h‚ÇÅ.mono, intro y, apply eq.symm }
apply h.congr_of_eventually_eq _ hx.symm
apply h‚ÇÅ.mono
intro y
apply eq.symm
intros
rw [‚Üê image_univ, ‚Üê I.source_eq]
{ rw [‚Üê image_univ, ‚Üê I.source_eq], exact (I.to_local_equiv.image_source_eq_target).symm }
exact (I.to_local_equiv.image_source_eq_target).symm
intros
mfld_set_tac
intros
split
assume h
{ assume h, refine ‚ü®Œª x hx, (h x hx).1, Œª x y z hz, _‚ü©, simp only with mfld_simps at hz, let w := (ext_chart_at I x).symm z, have : w ‚àà s, by simp only [w, hz] with mfld_simps, specialize h w this, have w1 : w ‚àà (chart_at H x).source, by simp only [w, hz] with mfld_simps, have w2 : f w ‚àà (chart_at H' y).source, by simp only [w, hz] with mfld_simps, convert (((times_cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart (structure_groupoid.chart_mem_maximal_atlas _ x) w1 (structure_groupoid.chart_mem_maximal_atlas _ y) w2).1 h).2 using 1, { mfld_set_tac }, { simp only [w, hz] with mfld_simps } }
refine ‚ü®Œª x hx, (h x hx).1, Œª x y z hz, _‚ü©
simp only with mfld_simps at hz
let w := (ext_chart_at I x).symm z
have : w ‚àà s
simp only [w, hz] with mfld_simps
simp only [w, hz] with mfld_simps
specialize h w this
have w1 : w ‚àà (chart_at H x).source
simp only [w, hz] with mfld_simps
simp only [w, hz] with mfld_simps
have w2 : f w ‚àà (chart_at H' y).source
simp only [w, hz] with mfld_simps
simp only [w, hz] with mfld_simps
convert (((times_cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart (structure_groupoid.chart_mem_maximal_atlas _ x) w1 (structure_groupoid.chart_mem_maximal_atlas _ y) w2).1 h).2 using 1
{ mfld_set_tac }
mfld_set_tac
{ simp only [w, hz] with mfld_simps }
simp only [w, hz] with mfld_simps
rintros ‚ü®hcont, hdiff‚ü© x hx
{ rintros ‚ü®hcont, hdiff‚ü© x hx, refine ‚ü®hcont x hx, _‚ü©, have Z := hdiff x (f x) (ext_chart_at I x x) (by simp only [hx] with mfld_simps), dsimp [times_cont_diff_within_at_prop], convert Z using 1, mfld_set_tac }
refine ‚ü®hcont x hx, _‚ü©
have Z := hdiff x (f x) (ext_chart_at I x x) (by simp only [hx] with mfld_simps)
dsimp [times_cont_diff_within_at_prop]
convert Z using 1
mfld_set_tac
intros
let œï : H ‚Üí* H := { to_fun := Œª h, ‚ü®g * h * g‚Åª¬π, hH.conj_mem h.1 h.2 g‚ü©, map_one' := subtype.ext (by rw [coe_mk, coe_one, mul_one, mul_inv_self]), map_mul' := Œª h‚ÇÅ h‚ÇÇ, subtype.ext (by rw [coe_mk, coe_mul, coe_mul, coe_mk, coe_mk, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, inv_mul_cancel_left]) }
refine eq.trans (finset.prod_bij' (Œª q _, (‚Üëg)‚Åª¬π * q) (Œª _ _, finset.mem_univ _) (Œª q _, subtype.ext _) (Œª q _, ‚Üëg * q) (Œª _ _, finset.mem_univ _) (Œª q _, mul_inv_cancel_left g q) (Œª q _, inv_mul_cancel_left g q)) (œï.map_prod _ _).symm
change _ * _ = g * (_ * _) * g‚Åª¬π
simp_rw [smul_symm_apply_eq_mul_symm_apply_inv_smul, mul_inv_rev, mul_assoc]
refl
intros
simp [card_eq_card_quotient_mul_card_subgroup s]
intros
rw [lift_mk', lift_mk', mul_inv hg]
intros
rw [pow_eq_mod_order_of, ‚Üênat.mod_mod_of_dvd n order_of_dvd_card_univ, ‚Üê pow_eq_mod_order_of]
intros
rw [mul_swap_eq_swap_mul, mul_inv_cancel_right]
intros
rw [card_eq_zero, cycle_type_eq_zero]
intros
cases (disjoint_iff_eq_or_eq.mp h) x with hfx hgx
simp [h.commute.eq, cycle_of_mul_of_apply_right_eq_self h.symm.commute, hfx]
{ simp [h.commute.eq, cycle_of_mul_of_apply_right_eq_self h.symm.commute, hfx] }
simp [cycle_of_mul_of_apply_right_eq_self h.commute, hgx]
{ simp [cycle_of_mul_of_apply_right_eq_self h.commute, hgx] }
intros
{ ext i, rw [coe_cycle_range_of_le (le_last _), coe_fin_rotate] }
ext i
rw [coe_cycle_range_of_le (le_last _), coe_fin_rotate]
intros
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem hx
rw [form_perm_apply_nth_le _ hl, hl.nth_le_inj_iff]
cases hn : l.length
{ exact absurd k.zero_le (hk.trans_le hn.le).not_le }
exact absurd k.zero_le (hk.trans_le hn.le).not_le
rw hn at hk
{ rw hn at hk, cases (nat.le_of_lt_succ hk).eq_or_lt with hk' hk', { simp [‚Üêhk', nat.succ_le_succ_iff, eq_comm] }, { simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk' } }
cases (nat.le_of_lt_succ hk).eq_or_lt with hk' hk'
{ simp [‚Üêhk', nat.succ_le_succ_iff, eq_comm] }
simp [‚Üêhk', nat.succ_le_succ_iff, eq_comm]
simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk'
{ simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk' }
intros
simp
intros
rw [‚Üê monoid_hom.map_inv, inl_aut, inv_inv]
intros
rw [line_map_apply, vadd_vsub]
intros
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
apply sum_erase
rw [vsub_self, smul_zero]
intros
rw coe_reindex_repr
intros
simp [basis.singleton, unique.eq_default i]
intros
rw bilin_form.is_adjoint_pair_iff_comp_left_eq_comp_right
have h : ‚àÄ (B B' : bilin_form R‚ÇÉ M‚ÇÉ), B = B' ‚Üî (bilin_form.to_matrix b B) = (bilin_form.to_matrix b B')
intros B B'
{ intros B B', split; intros h, { rw h }, { exact (bilin_form.to_matrix b).injective h } }
split; intros h
split
intros h
{ rw h }
rw h
intros h
{ exact (bilin_form.to_matrix b).injective h }
exact (bilin_form.to_matrix b).injective h
rw [h, bilin_form.to_matrix_comp_left, bilin_form.to_matrix_comp_right, linear_map.to_matrix_to_lin, linear_map.to_matrix_to_lin, bilin_form.to_matrix_to_bilin, bilin_form.to_matrix_to_bilin]
refl
intros
{ ext, refl }
ext
refl
intros
rw [‚Üê linear_map.to_matrix_id_eq_basis_to_matrix, ‚Üê bilin_form.to_matrix_comp, bilin_form.comp_id_id]
intros
haveI := classical.dec_eq M; exact (f : M ‚Üí‚Çó[A] M).det_cases (Œª s b, f.is_unit_det _ _) is_unit_one
haveI := classical.dec_eq M
exact (f : M ‚Üí‚Çó[A] M).det_cases (Œª s b, f.is_unit_det _ _) is_unit_one
intros
dsimp [module.rank]
fapply cardinal.lift_sup_le_lift_sup'
rintro ‚ü®s, li‚ü©
{ rintro ‚ü®s, li‚ü©, use f '' s, convert (li.map' f (linear_map.ker_eq_bot.mpr i)).comp (equiv.set.image ‚áëf s i).symm (equiv.injective _), ext ‚ü®-, ‚ü®x, ‚ü®h, rfl‚ü©‚ü©‚ü©, simp, }
use f '' s
convert (li.map' f (linear_map.ker_eq_bot.mpr i)).comp (equiv.set.image ‚áëf s i).symm (equiv.injective _)
ext ‚ü®-, ‚ü®x, ‚ü®h, rfl‚ü©‚ü©‚ü©
simp
rintro ‚ü®s, li‚ü©
{ rintro ‚ü®s, li‚ü©, exact cardinal.lift_mk_le'.mpr ‚ü®(equiv.set.image f s i).to_embedding‚ü©, }
exact cardinal.lift_mk_le'.mpr ‚ü®(equiv.set.image f s i).to_embedding‚ü©
intros
rw eq_top_iff'
intro f
rw linear_map.mem_range
let lin_comb : Œπ ‚Üí‚ÇÄ R := finsupp.on_finset fin.elems (Œª i, f.to_fun (b i)) _
use finsupp.total Œπ M R b lin_comb
{ use finsupp.total Œπ M R b lin_comb, apply b.ext, { intros i, rw [b.to_dual_eq_repr _ i, repr_total b], { refl } } }
apply b.ext
intros i
{ intros i, rw [b.to_dual_eq_repr _ i, repr_total b], { refl } }
rw [b.to_dual_eq_repr _ i, repr_total b]
{ refl }
refl
intros a _
{ intros a _, apply fin.complete }
apply fin.complete
intros
dunfold eval
rw [linear_map.flip_apply, linear_map.id_apply]
intros
haveI : finite_dimensional F S := finite_dimensional_of_dim_eq_one h
rw ‚Üê finrank_eq_dim at h
norm_cast at h
exact subalgebra.eq_bot_of_finrank_one h
intros
apply span_eq_of_le
intros x hx
{ intros x hx, rw set.mem_image at hx, apply exists.elim hx, intros i hi, exact ‚ü®_, finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]‚ü© }
rw set.mem_image at hx
apply exists.elim hx
intros i hi
exact ‚ü®_, finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]‚ü©
refine map_le_iff_le_comap.2 (Œª z hz, _)
{ refine map_le_iff_le_comap.2 (Œª z hz, _), have : ‚àÄi, z i ‚Ä¢ v i ‚àà span R (v '' s), { intro c, haveI := classical.dec_pred (Œª x, x ‚àà s), by_cases c ‚àà s, { exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h)) }, { simp [(finsupp.mem_supported' R _).1 hz _ h] } }, refine sum_mem _ _, simp [this] }
have : ‚àÄi, z i ‚Ä¢ v i ‚àà span R (v '' s)
intro c
{ intro c, haveI := classical.dec_pred (Œª x, x ‚àà s), by_cases c ‚àà s, { exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h)) }, { simp [(finsupp.mem_supported' R _).1 hz _ h] } }
haveI := classical.dec_pred (Œª x, x ‚àà s)
by_cases c ‚àà s
{ exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h)) }
exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h))
{ simp [(finsupp.mem_supported' R _).1 hz _ h] }
simp [(finsupp.mem_supported' R _).1 hz _ h]
refine sum_mem _ _
simp [this]
intros
replace h : x ‚àâ (f.support : set Œπ) := h
have p := hv.not_mem_span_image h
intro w
rw ‚Üêw at p
rw finsupp.span_image_eq_map_total at p
simp only [not_exists, not_and, mem_map] at p
exact p f (f.mem_supported_support R) rfl
intros
simpa only [smul_mul_assoc] using det_sum_le s (Œª k i j, calc abv (c k * A k i j) = abv (c k) * abv (A k i j) : abv.map_mul _ _ ... ‚â§ y * x : mul_le_mul (hy k) (hx k i j) (abv.nonneg _) ((abv.nonneg _).trans (hy k)))
intros
rw [matrix.mul_assoc, matrix.mul_assoc, det_mul, det_mul_comm N P, ‚Üêdet_mul]
intros
rw [‚Üê diagonal_one]; simp [-diagonal_one]
rw [‚Üê diagonal_one]
simp [-diagonal_one]
intros
casesI (subsingleton_or_nontrivial Œ±) with ht ht
{ simp }
simp
cases (fintype.card n).zero_le.eq_or_lt with hc hc
rw [eq_comm, fintype.card_eq_zero_iff] at hc
{ rw [eq_comm, fintype.card_eq_zero_iff] at hc, haveI := hc, ext i, exact (is_empty.false i).elim }
haveI := hc
ext i
exact (is_empty.false i).elim
have hn : nonempty n := fintype.card_pos_iff.mp hc
{ have hn : nonempty n := fintype.card_pos_iff.mp hc, refine nonsing_inv_apply_not_is_unit _ _, simp [hn] }
refine nonsing_inv_apply_not_is_unit _ _
simp [hn]
intros
simp [module.algebra_map_End_eq_smul_id]
intros
rw [linear_map.to_matrix_apply', algebra.lsmul_coe, linear_equiv.map_smul, finsupp.smul_apply, b.repr_self_apply, smul_eq_mul, mul_boole]
{ rw [linear_map.to_matrix_apply', algebra.lsmul_coe, linear_equiv.map_smul, finsupp.smul_apply, b.repr_self_apply, smul_eq_mul, mul_boole], congr' 1; simp only [eq_comm] }
congr' 1; simp only [eq_comm]
congr' 1
simp only [eq_comm]
intros
induction L with t L IH
{ simp }
simp
{ simp [IH], }
simp [IH]
intros
refine (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _
rw linear_equiv.symm_apply_apply
intros
have C0 : C 0
have h‚ÇÅ := @C1 0 0
{ have h‚ÇÅ := @C1 0 0, rwa [zero_tprod_coeff] at h‚ÇÅ }
rwa [zero_tprod_coeff] at h‚ÇÅ
refine add_con.induction_on z (Œª x, free_add_monoid.rec_on x C0 _)
simp_rw add_con.coe_add
refine Œª f y ih, Cp _ ih
convert @C1 f.1 f.2
simp only [prod.mk.eta]
intros
simp
intros
dsimp [tailing, tunnel_aux]
rw [submodule.map_comp, submodule.map_comp]
apply submodule.map_subtype_le
intros
rw [‚Üê@zero_smul R _ _ _ _ (0 : M), map_smul, zero_mul, zero_mul]
intros
simp only [anisotropic, not_forall, exists_prop, and_comm]
intros
{ rw smodeq.def at hxy ‚ä¢, simp_rw [quotient.mk_smul, hxy] }
rw smodeq.def at hxy ‚ä¢
simp_rw [quotient.mk_smul, hxy]
intros
simp [to_tensor]
intros
dsimp [tensor_product.rid, tensor_product.comm, tensor_product.lid]
simp
intros
simp [decidable.not_not]
intros
induction hab
exact ‚ü®c, hac, refl‚ü©
case refl_trans_gen.refl { exact ‚ü®c, hac, refl‚ü© }
case refl_trans_gen.tail : d e had hde ih { clear hac had a, rcases ih with ‚ü®b, hdb, hcb‚ü©, have : ‚àÉ a, refl_trans_gen r e a ‚àß refl_gen r b a, { clear hcb, induction hdb, case refl_trans_gen.refl { exact ‚ü®e, refl, refl_gen.single hde‚ü© }, case refl_trans_gen.tail : f b hdf hfb ih { rcases ih with ‚ü®a, hea, hfa‚ü©, cases hfa with _ hfa, { exact ‚ü®b, hea.tail hfb, refl_gen.refl‚ü© }, { rcases h _ _ _ hfb hfa with ‚ü®c, hbc, hac‚ü©, exact ‚ü®c, hea.trans hac, hbc‚ü© } } }, rcases this with ‚ü®a, hea, hba‚ü©, cases hba with _ hba, { exact ‚ü®b, hea, hcb‚ü© }, { exact ‚ü®a, hea, hcb.tail hba‚ü© } }
intros
{ rw ‚Üê pi_univ_Icc, exact pi_Ioo_ae_eq_pi_Icc }
rw ‚Üê pi_univ_Icc
exact pi_Ioo_ae_eq_pi_Icc
intros
rw [‚Üê set_like.mem_coe, ‚Üê submodule.mem_carrier, Lp_meas, set.mem_set_of_eq]
intros
split
assume h
{ assume h, simpa only [smul_smul, inv_mul_cancel hc, one_smul] using h.smul c‚Åª¬π }
simpa only [smul_smul, inv_mul_cancel hc, one_smul] using h.smul c‚Åª¬π
exact has_finite_integral.smul _
intros
rw [‚Üê integrable_coe_fn, ‚Üê mem_‚Ñíp_one_iff_integrable, Lp.mem_Lp_iff_mem_‚Ñíp]
intros
suffices : f =·µê[Œº] 0 ‚àß g =·µê[Œº] 0
simp [snorm_congr_ae this.1, snorm_congr_ae this.2]
simp [snorm_congr_ae this.1, snorm_congr_ae this.2]
refine ‚ü®h.mono $ Œª x hx, _, h.mono $ Œª x hx, _‚ü©
refine norm_le_zero_iff.1 (hx.trans _)
{ refine norm_le_zero_iff.1 (hx.trans _), exact mul_nonpos_of_nonpos_of_nonneg hc.le (norm_nonneg _) }
exact mul_nonpos_of_nonpos_of_nonneg hc.le (norm_nonneg _)
refine norm_le_zero_iff.1 (nonpos_of_mul_nonneg_right _ hc)
{ refine norm_le_zero_iff.1 (nonpos_of_mul_nonneg_right _ hc), exact (norm_nonneg _).trans hx }
exact (norm_nonneg _).trans hx
intros
{ ext1 f, exact smul_comp_Lp c L f }
ext1 f
exact smul_comp_Lp c L f
intros
simp [snorm', hq_pos]
intros
rw @snorm_smul_measure_of_ne_top _ _ _ Œº _ 1 (@ennreal.coe_ne_top 1) f c
{ rw @snorm_smul_measure_of_ne_top _ _ _ Œº _ 1 (@ennreal.coe_ne_top 1) f c, simp, }
simp
intros
have := edist_approx_on_y0_le hf h‚ÇÄ x n
rw [edist_comm y‚ÇÄ, edist_eq_coe_nnnorm_sub] at this
repeat { rw [edist_comm y‚ÇÄ, edist_eq_coe_nnnorm_sub] at this }
rw [edist_comm y‚ÇÄ, edist_eq_coe_nnnorm_sub] at this
rw [edist_comm y‚ÇÄ, edist_eq_coe_nnnorm_sub] at this
exact_mod_cast this
intros
simpa only [‚Üê finset.prod_apply] using s.ae_measurable_prod' hf
intros
rwa [eventually_eq, ae_iff, trim_measurable_set_eq hm _]
exact (@measurable_set.compl Œ≤ _ m (@measurable_set_eq_fun Œ≤ m Œ≥ _ _ _ _ _ _ hf hg))
intros
{ simp only [mul_comm], exact integral_mul_left r f }
simp only [mul_comm]
exact integral_mul_left r f
intros
rw [integrable_on, measure.restrict_univ]
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
simp only [h]
intros
have : measurable_set {a : Œ± | Œµ ‚â§ f a }
from hf measurable_set_Ici
rw [‚Üê simple_func.restrict_const_lintegral _ this, ‚Üê simple_func.lintegral_eq_lintegral]
refine lintegral_mono (Œª a, _)
simp only [restrict_apply _ this]
exact indicator_apply_le id
intros
simp [lintegral_congr_ae (ae_eq_dirac' hf)]
intros
rw ‚Üê finset.not_nonempty_iff_eq_empty
by_contra
obtain ‚ü®y, hy_mem‚ü© := h
rw [simple_func.mem_range, set.mem_range] at hy_mem
obtain ‚ü®x, hxy‚ü© := hy_mem
rw is_empty_iff at hŒ±
exact hŒ± x
intros
refine supr_congr _ ((compacts.equiv f).surjective) _
intro K
refine supr_congr_Prop image_subset_iff _
intro hK
simp only [equiv.coe_fn_mk, subtype.mk_eq_mk, ennreal.coe_eq_coe, compacts.equiv]
apply h
intros
classical
let M := f.to_matrix'
have A : f.det = det M
simp only [linear_map.det_to_matrix']
simp only [linear_map.det_to_matrix']
have B : f = M.to_lin'
simp only [to_lin'_to_matrix']
simp only [to_lin'_to_matrix']
rw [A, B]
apply map_matrix_volume_pi_eq_smul_volume_pi
rwa A at hf
intros
{ congr, ext1 n, exact h n }
congr
ext1 n
exact h n
intros
rw [mem_map, mem_ae_iff, measure.restrict_apply' hs]
intros
rw [measure_eq_trim, outer_measure.trim_eq_infi]
rw [measure_eq_trim, outer_measure.trim_eq_infi]; refl
refl
intros
simp only [le_antisymm_iff, trim_le_trim_iff, forall_and_distrib]
intros
intros U hU r hr
rw [smul_apply, H.measure_eq_supr hU] at hr
simpa only [ennreal.mul_supr, lt_supr_iff, exists_prop] using hr
intros
rw [‚Üê coe_injective.eq_iff, function.funext_iff]
intros
ext i hi
rw [to_signed_measure_apply_measurable hi, vector_measure.smul_apply, to_signed_measure_apply_measurable hi, coe_nnreal_smul, pi.smul_apply, ennreal.to_real_smul]
simp
intros
rw mem_divisors_antidiagonal at h
simp [dvd.intro _ h.1, h.2]
intros
delta fermat_42
split
intro f42
{ intro f42, split, { exact mul_ne_zero hk0 f42.1 }, split, { exact mul_ne_zero hk0 f42.2.1 }, { calc (k * a) ^ 4 + (k * b) ^ 4 = k ^ 4 * (a ^ 4 + b ^ 4) : by ring ... = k ^ 4 * c ^ 2 : by rw f42.2.2 ... = (k ^ 2 * c) ^ 2 : by ring }}
split
exact mul_ne_zero hk0 f42.1
{ exact mul_ne_zero hk0 f42.1 }
split
exact mul_ne_zero hk0 f42.2.1
{ exact mul_ne_zero hk0 f42.2.1 }
calc (k * a) ^ 4 + (k * b) ^ 4 = k ^ 4 * (a ^ 4 + b ^ 4) : by ring ... = k ^ 4 * c ^ 2 : by rw f42.2.2 ... = (k ^ 2 * c) ^ 2 : by ring
{ calc (k * a) ^ 4 + (k * b) ^ 4 = k ^ 4 * (a ^ 4 + b ^ 4) : by ring ... = k ^ 4 * c ^ 2 : by rw f42.2.2 ... = (k ^ 2 * c) ^ 2 : by ring }
intro f42
{ intro f42, split, { exact right_ne_zero_of_mul f42.1 }, split, { exact right_ne_zero_of_mul f42.2.1 }, apply (mul_right_inj' (pow_ne_zero 4 hk0)).mp, { calc k ^ 4 * (a ^ 4 + b ^ 4) = (k * a) ^ 4 + (k * b) ^ 4 : by ring ... = (k ^ 2 * c) ^ 2 : by rw f42.2.2 ... = k ^ 4 * c ^ 2 : by ring }}
split
exact right_ne_zero_of_mul f42.1
{ exact right_ne_zero_of_mul f42.1 }
split
exact right_ne_zero_of_mul f42.2.1
{ exact right_ne_zero_of_mul f42.2.1 }
apply (mul_right_inj' (pow_ne_zero 4 hk0)).mp
calc k ^ 4 * (a ^ 4 + b ^ 4) = (k * a) ^ 4 + (k * b) ^ 4 : by ring ... = (k ^ 2 * c) ^ 2 : by rw f42.2.2 ... = k ^ 4 * c ^ 2 : by ring
{ calc k ^ 4 * (a ^ 4 + b ^ 4) = (k * a) ^ 4 + (k * b) ^ 4 : by ring ... = (k ^ 2 * c) ^ 2 : by rw f42.2.2 ... = k ^ 4 * c ^ 2 : by ring }
intros
induction n; simp
{ induction n; simp, }
induction n
simp
simp
intros
convert int.mod_lt _ _
{ simp }
simp
{ exact_mod_cast hp_prime.1.ne_zero }
exact_mod_cast hp_prime.1.ne_zero
intros
induction n; simp *
induction n
simp *
simp *
intros
split
intro h
{ intro h, rw [ext, zero_re, zero_im], rw [norm_def, sub_eq_add_neg, mul_assoc] at h, have left := mul_self_nonneg z.re, have right := neg_nonneg.mpr (mul_nonpos_of_nonpos_of_nonneg hd.le (mul_self_nonneg z.im)), obtain ‚ü®ha, hb‚ü© := (add_eq_zero_iff' left right).mp h, split; apply eq_zero_of_mul_self_eq_zero, { exact ha }, { rw [neg_eq_zero, mul_eq_zero] at hb, exact hb.resolve_left hd.ne } }
rw [ext, zero_re, zero_im]
rw [norm_def, sub_eq_add_neg, mul_assoc] at h
have left := mul_self_nonneg z.re
have right := neg_nonneg.mpr (mul_nonpos_of_nonpos_of_nonneg hd.le (mul_self_nonneg z.im))
obtain ‚ü®ha, hb‚ü© := (add_eq_zero_iff' left right).mp h
split; apply eq_zero_of_mul_self_eq_zero
split
apply eq_zero_of_mul_self_eq_zero
{ exact ha }
exact ha
apply eq_zero_of_mul_self_eq_zero
rw [neg_eq_zero, mul_eq_zero] at hb
{ rw [neg_eq_zero, mul_eq_zero] at hb, exact hb.resolve_left hd.ne }
exact hb.resolve_left hd.ne
{ rintro rfl, exact norm_zero }
rintro rfl
exact norm_zero
intros
refine eq.trans (congr rfl (set.ext (Œª x, _))) (Sup_atoms_le_eq ‚ä§)
exact (and_iff_left le_top).symm
intros
simp [update_le_iff] {contextual := tt}
intros
simpa only [compl_compl] using compl_le_compl h
intros
rw [‚Üêc.closure_eq_self_of_mem_closed hy, ‚Üêle_closure_iff]
intros
simpa only [inf_comm] using @inf_Sup_eq Œ± _ b s
intros
rw set.eq_singleton_iff_nonempty_unique_mem
{ rw set.eq_singleton_iff_nonempty_unique_mem, rw Sup_eq_bot at h_sup, exact ‚ü®hne, h_sup‚ü©, }
rw Sup_eq_bot at h_sup
exact ‚ü®hne, h_sup‚ü©
intros
rw [at_bot_Iio_eq, tendsto_comap_iff]
intros
simp only [tendsto_at_bot, neg_le]
exact Œª b, eventually_ge_at_top _
intros
rw filter.eventually_at_top_prod_self
apply exists_congr
tauto
intros
casesI is_empty_or_nonempty Œ≤
rw [filter_eq_bot_of_is_empty (f.comap _), ‚Üê not_iff_not]
rw [filter_eq_bot_of_is_empty (f.comap _), ‚Üê not_iff_not]; [simp *, apply_instance]
{ rw [filter_eq_bot_of_is_empty (f.comap _), ‚Üê not_iff_not]; [simp *, apply_instance] }
simp *
apply_instance
{ simp [comap_ne_bot_iff_frequently, h] }
simp [comap_ne_bot_iff_frequently, h]
intros
simp
intros
simp only [‚Üê filter.mem_sets, infi_sets_eq h, mem_Union]
intros
rw [filter.lift, infi_subtype', infi_ne_bot_iff_of_directed', subtype.forall']
rintros ‚ü®s, hs‚ü© ‚ü®t, ht‚ü©
{ rintros ‚ü®s, hs‚ü© ‚ü®t, ht‚ü©, exact ‚ü®‚ü®s ‚à© t, inter_mem hs ht‚ü©, hm (inter_subset_left s t), hm (inter_subset_right s t)‚ü© }
exact ‚ü®‚ü®s ‚à© t, inter_mem hs ht‚ü©, hm (inter_subset_left s t), hm (inter_subset_right s t)‚ü©
intros
unfold rtendsto' rcomap'
simp [le_def, rel.mem_image]
split
{ exact Œª h s hs, h _ _ hs set.subset.rfl }
exact Œª h s hs, h _ _ hs set.subset.rfl
{ exact Œª h s t ht, mem_of_superset (h t ht) }
exact Œª h s t ht, mem_of_superset (h t ht)
intros
ext
ext; refl
refl
intros
refine (supr_le $ Œª n, _).antisymm (supr_le_supr $ le_partial_sups f)
rw partial_sups_eq_bsupr
exact bsupr_le_supr _ _
intros
rw [symm_diff_comm a b, symm_diff_comm c b, symm_diff_right_inj]
intros
obtain ‚ü®g, h1 | h2‚ü© := exists_increasing_or_nonincreasing_subseq r f
refine ‚ü®g, Œª m n hle, _‚ü©
{ refine ‚ü®g, Œª m n hle, _‚ü©, obtain hlt | heq := lt_or_eq_of_le hle, { exact h1 m n hlt, }, { rw [heq], apply refl_of r } }
obtain hlt | heq := lt_or_eq_of_le hle
{ exact h1 m n hlt, }
exact h1 m n hlt
rw [heq]
{ rw [heq], apply refl_of r }
apply refl_of r
exfalso
{ exfalso, obtain ‚ü®m, n, hlt, hle‚ü© := h (f ‚àò g) (subset.trans (range_comp_subset_range _ _) hf), exact h2 m n hlt hle }
obtain ‚ü®m, n, hlt, hle‚ü© := h (f ‚àò g) (subset.trans (range_comp_subset_range _ _) hf)
exact h2 m n hlt hle
intros
simp [is_max_chain, not_and_distrib, not_forall_not] at hc‚ÇÇ
cases hc‚ÇÇ.neg_resolve_left hc‚ÇÅ with c' hc'
exact succ_spec ‚ü®c', hc‚ÇÅ, hc'‚ü©
intros
{ rw is_coprime_comm, exact h.symm.add_mul_right_left z }
rw is_coprime_comm
exact h.symm.add_mul_right_left z
intros
refine ‚ü®Œª h, _, Œª h, @add_monoid_algebra.finite_type_of_fg _ _ _ _ h‚ü©
obtain ‚ü®S, hS‚ü© := @exists_finset_adjoin_eq_top R M _ _ h
refine add_monoid.fg_def.2 ‚ü®S, (eq_top_iff' _).2 (Œª m, _)‚ü©
have hm : of' R M m ‚àà (adjoin R (of' R M '' ‚ÜëS)).to_submodule
{ simp only [hS, top_to_submodule, submodule.mem_top], }
simp only [hS, top_to_submodule, submodule.mem_top]
rw [adjoin_eq_span] at hm
exact mem_closure_of_mem_span_closure hm
intros
use [1, S.one_mem]
intros b hb
rw one_smul
obtain ‚ü®b', b'_mem, rfl‚ü© := h hb
exact set.mem_range_self b'
intros
rw ‚Üê coe_to_fractional_ideal_bot
{ rw ‚Üê coe_to_fractional_ideal_bot, exact coe_ideal_injective.eq_iff }
exact coe_ideal_injective.eq_iff
intros
simp [‚Üê ring_equiv.to_ring_hom_eq_coe, map_map]
intros
rw hp.multiset_prod_le (mt multiset.map_eq_zero.mp hne)
simp_rw [exists_prop, multiset.mem_map, exists_exists_and_eq_and]
intros
apply ideal.ext
rintro ‚ü®r, s‚ü©
rw [mem_prod, mem_map_iff_of_surjective (ring_hom.fst R S) prod.fst_surjective, mem_map_iff_of_surjective (ring_hom.snd R S) prod.snd_surjective]
refine ‚ü®Œª h, ‚ü®‚ü®_, ‚ü®h, rfl‚ü©‚ü©, ‚ü®_, ‚ü®h, rfl‚ü©‚ü©‚ü©, _‚ü©
rintro ‚ü®‚ü®‚ü®r, s'‚ü©, ‚ü®h‚ÇÅ, rfl‚ü©‚ü©, ‚ü®‚ü®r', s‚ü©, ‚ü®h‚ÇÇ, rfl‚ü©‚ü©‚ü©
simpa using I.add_mem (I.mul_mem_left (1, 0) h‚ÇÅ) (I.mul_mem_left (0, 1) h‚ÇÇ)
intros
rintros ‚ü®x‚ü©
obtain ‚ü®p, ‚ü®p_monic, hpx‚ü©‚ü© := hf x
refine ‚ü®p.map (ideal.quotient.mk _), ‚ü®monic_map _ p_monic, _‚ü©‚ü©
simpa only [hom_eval‚ÇÇ, eval‚ÇÇ_map] using congr_arg (ideal.quotient.mk I) hpx
intros
simp only [coeff_integer_normalization, h, mem_support_iff, eq_self_iff_true, not_true, ne.def, dif_neg, not_false_iff]
intros
simp [to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
refl
intros
by_cases hx0 : x = 0
rw [hx0, zero_add]
{ rw [hx0, zero_add], exact le_max_right _ _ }
exact le_max_right _ _
by_cases hy0 : y = 0
rw [hy0, add_zero]
{ rw [hy0, add_zero], exact le_max_left _ _ }
exact le_max_left _ _
by_cases hxy0 : x + y = 0
rw [hxy0, pre_val_zero]
{ rw [hxy0, pre_val_zero], exact zero_le _ }
exact zero_le _
obtain ‚ü®r, rfl‚ü© := ideal.quotient.mk_surjective x
obtain ‚ü®s, rfl‚ü© := ideal.quotient.mk_surjective y
rw ‚Üê ring_hom.map_add at hxy0 ‚ä¢
rw [pre_val_mk hx0, pre_val_mk hy0, pre_val_mk hxy0, ring_hom.map_add]
exact v.map_add _ _
intros
assume i hi
simp only [frange, set.mem_image, mem_support_iff, ne.def, finset.mem_coe, finset.coe_image] at hi
rcases hi with ‚ü®n, hn, h'n‚ü©
rw [‚Üê h'n, coeff_of_subring]
exact subtype.mem (coeff p n : T)
intros
rw [monomial_eq_C_mul_X, content_C_mul, content_X_pow, mul_one]
{ rw [monomial_eq_C_mul_X, content_C_mul, content_X_pow, mul_one] }
intros
simp [coeff_mul_of_lt_order h, mul_sub]
intros
{ rw [‚Üê coeff_zero_eq_constant_coeff_apply, coeff_exp], simp }
rw [‚Üê coeff_zero_eq_constant_coeff_apply, coeff_exp]
simp
intros
refine ‚ü®_, h.pow_of_coprime i‚ü©
intro hi
obtain ‚ü®a, ha‚ü© := i.gcd_dvd_left k
obtain ‚ü®b, hb‚ü© := i.gcd_dvd_right k
suffices : b = k
rwa [this, ‚Üê one_mul k, nat.mul_left_inj h0, eq_comm] at hb { occs := occurrences.pos [1] }
{ rwa [this, ‚Üê one_mul k, nat.mul_left_inj h0, eq_comm] at hb { occs := occurrences.pos [1] } }
rw [ha] at hi
rw [mul_comm] at hb
apply nat.dvd_antisymm ‚ü®i.gcd k, hb‚ü© (hi.dvd_of_pow_eq_one b _)
rw [‚Üê pow_mul', ‚Üê mul_assoc, ‚Üê hb, pow_mul, h.pow_eq_one, one_pow]
intros
ext
{ ext, rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace_of_basis b c] }
rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace_of_basis b c]
intros
have := valuation.map_add_of_distinct_val v (ne_of_gt h).symm
rw max_eq_right (le_of_lt h) at this
simpa using this
intros
rw witt_structure_rat
intros x hx
simp only [finset.mem_product, true_and, finset.mem_univ, finset.mem_range]
obtain ‚ü®k, hk, hx'‚ü© := mem_vars_bind‚ÇÅ _ _ hx
obtain ‚ü®i, -, hx''‚ü© := mem_vars_bind‚ÇÅ _ _ hx'
obtain ‚ü®j, hj, rfl‚ü© := mem_vars_rename _ _ hx''
rw [witt_polynomial_vars, finset.mem_range] at hj
replace hk := X_in_terms_of_W_vars_subset p _ hk
rw finset.mem_range at hk
exact lt_of_lt_of_le hj hk
intros
rw [verschiebung_fun_coeff, if_pos rfl]
intros
{ rw [bUnion_eq_Union], apply mk_Union_le }
rw [bUnion_eq_Union]
apply mk_Union_le
rw [‚Üê nonpos_iff_eq_zero, ‚Üê aleph'_aleph_idx 0, aleph'_le]
rw [‚Üê nonpos_iff_eq_zero, ‚Üê aleph'_aleph_idx 0, aleph'_le]; apply ordinal.zero_le
apply ordinal.zero_le
intros
simp [‚Üê bit1_zero]
intros
{ apply sup_lt_ord _ _ H2, rw [hc.2], exact H1 }
apply sup_lt_ord _ _ H2
rw [hc.2]
exact H1
intros
induction l‚ÇÅ
exact subset.nil
{exact subset.nil}
refine subset.cons (lists.equiv.refl _) _ (l‚ÇÅ_ih (list.subset_of_cons_subset h))
simp at h
simp [h]
intros
{ rw [lt_ord], apply cardinal.lt_succ_self }
rw [lt_ord]
apply cardinal.lt_succ_self
intros
simpa only [zero_add] using add_sub_cancel 0 a
intros
rw [mul_le_mul_left, ‚Üêha, ‚Üêhb, ‚Üêmul_assoc, ‚Üêmul_assoc, mul_comm bd, mul_le_mul_left]
exact mul_pos had hbd
exact one_div_pos.2 hgcd
intros
simp *
intros
rw ‚Üê h
rw ‚Üê h; simp
simp
intros
simp
simp; cc
cc
intros
cc
intros
induction xs with x xs generalizing k
{ cases hk' }
cases hk'
cases k
{ cases hk }
cases hk
have : sizeof xs < sizeof (x :: xs)
{ unfold_wf, linarith }
unfold_wf
linarith
cases k
{ simp only [this, list.drop] }
simp only [this, list.drop]
simp only [list.drop]
{ simp only [list.drop], transitivity, { solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ] }, { assumption } }
transitivity
{ solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ] }
solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ]
{ assumption }
assumption
intros
rw [‚Üê is_open_compl_iff, is_open_iff_of_mem (mem_compl h), ‚Üê preimage_compl, compl_compl]
intros
rw ‚Üê nhds_within_univ
exact tendsto_nhds_within_mono_right (subset_univ _) (tendsto_ceil_right n)
intros
convert rel_supr_tsum m m0 R m_supr (Œª b, cond b s‚ÇÅ s‚ÇÇ)
{ simp only [supr_bool_eq, cond] }
simp only [supr_bool_eq, cond]
{ rw [tsum_fintype, fintype.sum_bool, cond, cond] }
rw [tsum_fintype, fintype.sum_bool, cond, cond]
intros
by_cases hf : summable f
{ exact tsum_le_of_sum_le hf h }
exact tsum_le_of_sum_le hf h
rw tsum_eq_zero_of_not_summable hf
{ rw tsum_eq_zero_of_not_summable hf, exact ha‚ÇÇ }
exact ha‚ÇÇ
intros
simp only [coe_sum', finset.sum_apply]
intros
simp only [‚Üê finprod_subtype_eq_finprod_cond]
exact continuous_finprod (Œª i, hc i i.2) (hf.comp_injective subtype.coe_injective)
intros
rw mem_nhds_within_Ici_iff_exists_Ico_subset
split
rintros ‚ü®u, au, as‚ü©
{ rintros ‚ü®u, au, as‚ü©, rcases exists_between au with ‚ü®v, hv‚ü©, exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© }
rcases exists_between au with ‚ü®v, hv‚ü©
exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü©
rintros ‚ü®u, au, as‚ü©
{ rintros ‚ü®u, au, as‚ü©, exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü©
intros
{ rw [‚Üêclosure_le_eq hf hg], exact closure_mono (Œª b, le_of_lt) }
rw [‚Üêclosure_le_eq hf hg]
exact closure_mono (Œª b, le_of_lt)
intros
rw [‚Üê comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]
intros
haveI : nonempty Œ≤ := nonempty.intro b
exact ge_of_tendsto ha ((eventually_ge_at_top b).mono (Œª _ hxy, hf hxy))
intros
simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]
intros
rw nhds
intros
simpa only [inter_comm] using closure_inter_open h
intros
refine le_antisymm (continuous_at_fst.mono_left inf_le_left) (Œª s hs, _)
rcases x with ‚ü®x, y‚ü©
rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs
rcases hs with ‚ü®u, hu, v, hv, H‚ü©
simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H
exact mem_of_superset hu (Œª z hz, H _ hz _ (mem_of_mem_nhds hv) rfl)
intros
rw [pi_def, bInter_mem hi]
{ rw [pi_def, bInter_mem hi], exact Œª a ha, (continuous_apply a).continuous_at (hs a ha) }
exact Œª a ha, (continuous_apply a).continuous_at (hs a ha)
intros
simpa only [hs.closure_eq] using mem_closure_iff_nhds_within_ne_bot.2 hx
intros
ext ‚ü®‚ü©
{ ext ‚ü®‚ü©, refl }
refl
intros
rw [e.source_eq, mem_preimage]
intros
rcases eq_empty_or_nonempty s with rfl|hne
simp
{ simp }
refine le_antisymm (metric.ediam_le_of_forall_dist_le $ Œª x hx y hy, _) _
have := real.subset_Icc_Inf_Sup_of_bounded h
{ have := real.subset_Icc_Inf_Sup_of_bounded h, exact real.dist_le_of_mem_Icc (this hx) (this hy) }
exact real.dist_le_of_mem_Icc (this hx) (this hy)
apply ennreal.of_real_le_of_le_to_real
{ apply ennreal.of_real_le_of_le_to_real, rw [‚Üê metric.diam, ‚Üê metric.diam_closure], have h' := real.bounded_iff_bdd_below_bdd_above.1 h, calc Sup s - Inf s ‚â§ dist (Sup s) (Inf s) : le_abs_self _ ... ‚â§ diam (closure s) : dist_le_diam_of_mem h.closure (cSup_mem_closure hne h'.2) (cInf_mem_closure hne h'.1) }
rw [‚Üê metric.diam, ‚Üê metric.diam_closure]
have h' := real.bounded_iff_bdd_below_bdd_above.1 h
calc Sup s - Inf s ‚â§ dist (Sup s) (Inf s) : le_abs_self _ ... ‚â§ diam (closure s) : dist_le_diam_of_mem h.closure (cSup_mem_closure hne h'.2) (cInf_mem_closure hne h'.1)
intros
by_cases h : summable f
{ rw [‚Üê ennreal.coe_tsum h, ennreal.to_nnreal_coe] }
rw [‚Üê ennreal.coe_tsum h, ennreal.to_nnreal_coe]
have A := tsum_eq_zero_of_not_summable h
{ have A := tsum_eq_zero_of_not_summable h, simp only [‚Üê ennreal.tsum_coe_ne_top_iff_summable, not_not] at h, simp only [h, ennreal.top_to_nnreal, A] }
simp only [‚Üê ennreal.tsum_coe_ne_top_iff_summable, not_not] at h
simp only [h, ennreal.top_to_nnreal, A]
intros
rw [nhds_list, list.traverse_nil _]; apply_instance
rw [nhds_list, list.traverse_nil _]
intros
ext
{ ext, refl }
refl
intros
rw [hf.induced, is_closed_induced_iff]
intros
simp only [dist_nndist, nnreal.coe_le_coe, nndist_le_pi_nndist f g b]
intros
refine filter.has_basis_cocompact.ge_iff.2 (Œª s hs, mem_comap.2 _)
rcases hs.bounded.subset_ball x with ‚ü®r, hr‚ü©
exact ‚ü®Ioi r, Ioi_mem_at_top r, Œª y hy hys, (mem_closed_ball.1 $ hr hys).not_lt hy‚ü©
intros
rw [ball_eq_empty]
intros
simp [continuous_on, continuous_within_at_iff']
intros
rw [mul_comm, ‚Üê div_eq_mul_inv]
exact ennreal.div_le_of_le_mul' (h x y)
intros
rw [nhds_induced, filter.map_comap, nhds_within]
intros
rw path.trans
apply eq_of_subset_of_subset
rintros x ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©
{ rintros x ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©, by_cases h : t ‚â§ 1/2, { left, use [2*t, ‚ü®by linarith, by linarith‚ü©], rw ‚Üê Œ≥‚ÇÅ.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_true] at hxt, exact hxt }, { right, use [2*t-1, ‚ü®by linarith, by linarith‚ü©], rw ‚Üê Œ≥‚ÇÇ.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_false] at hxt, exact hxt } }
by_cases h : t ‚â§ 1/2
left
{ left, use [2*t, ‚ü®by linarith, by linarith‚ü©], rw ‚Üê Œ≥‚ÇÅ.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_true] at hxt, exact hxt }
use [2*t, ‚ü®by linarith, by linarith‚ü©]
rw ‚Üê Œ≥‚ÇÅ.extend_extends
unfold_coes at hxt
simp only [h, comp_app, if_true] at hxt
exact hxt
right
{ right, use [2*t-1, ‚ü®by linarith, by linarith‚ü©], rw ‚Üê Œ≥‚ÇÇ.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_false] at hxt, exact hxt }
use [2*t-1, ‚ü®by linarith, by linarith‚ü©]
rw ‚Üê Œ≥‚ÇÇ.extend_extends
unfold_coes at hxt
simp only [h, comp_app, if_false] at hxt
exact hxt
rintros x (‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü© | ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©)
{ rintros x (‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü© | ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©), { use ‚ü®t/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, have : t/2 ‚â§ 1/2 := by linarith, simp only [this, comp_app, if_true], ring_nf, rwa Œ≥‚ÇÅ.extend_extends }, { by_cases h : t = 0, { use ‚ü®1/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ‚Ñù _ _)], rw Œ≥‚ÇÅ.extend_one, rwa [‚Üê Œ≥‚ÇÇ.extend_extends, h, Œ≥‚ÇÇ.extend_zero] at hxt }, { use ‚ü®(t+1)/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, change t ‚â† 0 at h, have ht0 := lt_of_le_of_ne ht0 h.symm, have : ¬¨ (t+1)/2 ‚â§ 1/2 := by {rw not_le, linarith}, simp only [comp_app, if_false, this], ring_nf, rwa Œ≥‚ÇÇ.extend_extends } } }
use ‚ü®t/2, ‚ü®by linarith, by linarith‚ü©‚ü©
{ use ‚ü®t/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, have : t/2 ‚â§ 1/2 := by linarith, simp only [this, comp_app, if_true], ring_nf, rwa Œ≥‚ÇÅ.extend_extends }
unfold_coes
have : t/2 ‚â§ 1/2 := by linarith
simp only [this, comp_app, if_true]
ring_nf
rwa Œ≥‚ÇÅ.extend_extends
by_cases h : t = 0
{ by_cases h : t = 0, { use ‚ü®1/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ‚Ñù _ _)], rw Œ≥‚ÇÅ.extend_one, rwa [‚Üê Œ≥‚ÇÇ.extend_extends, h, Œ≥‚ÇÇ.extend_zero] at hxt }, { use ‚ü®(t+1)/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, change t ‚â† 0 at h, have ht0 := lt_of_le_of_ne ht0 h.symm, have : ¬¨ (t+1)/2 ‚â§ 1/2 := by {rw not_le, linarith}, simp only [comp_app, if_false, this], ring_nf, rwa Œ≥‚ÇÇ.extend_extends } }
use ‚ü®1/2, ‚ü®by linarith, by linarith‚ü©‚ü©
{ use ‚ü®1/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ‚Ñù _ _)], rw Œ≥‚ÇÅ.extend_one, rwa [‚Üê Œ≥‚ÇÇ.extend_extends, h, Œ≥‚ÇÇ.extend_zero] at hxt }
unfold_coes
simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ‚Ñù _ _)]
rw Œ≥‚ÇÅ.extend_one
rwa [‚Üê Œ≥‚ÇÇ.extend_extends, h, Œ≥‚ÇÇ.extend_zero] at hxt
use ‚ü®(t+1)/2, ‚ü®by linarith, by linarith‚ü©‚ü©
{ use ‚ü®(t+1)/2, ‚ü®by linarith, by linarith‚ü©‚ü©, unfold_coes, change t ‚â† 0 at h, have ht0 := lt_of_le_of_ne ht0 h.symm, have : ¬¨ (t+1)/2 ‚â§ 1/2 := by {rw not_le, linarith}, simp only [comp_app, if_false, this], ring_nf, rwa Œ≥‚ÇÇ.extend_extends }
unfold_coes
change t ‚â† 0 at h
have ht0 := lt_of_le_of_ne ht0 h.symm
have : ¬¨ (t+1)/2 ‚â§ 1/2 := by {rw not_le, linarith}
simp only [comp_app, if_false, this]
ring_nf
rwa Œ≥‚ÇÇ.extend_extends
intros
have : is_path_connected (univ : set X) := path_connected_space_iff_univ.mp (by apply_instance)
rcases this.exists_path_through_family p (Œª i, true.intro) with ‚ü®Œ≥, -, h‚ü©
exact ‚ü®Œ≥, h‚ü©
intros
split
introI h
{ introI h, exact tot_sep_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim, }
exact tot_sep_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim
apply totally_separated_space.totally_disconnected_space
intros
{ rw find, split_ifs, exacts [h.some_spec.fst, ne.some_spec] }
rw find
split_ifs
exacts [h.some_spec.fst, ne.some_spec]
intros
rw (filter.has_basis_cocompact.comap f).le_basis_iff filter.has_basis_cocompact
intros t ht
refine ‚ü®f '' t, ht.image hf, _‚ü©
simpa using t.subset_preimage_image f
intros
refine tendsto_nhds_unique (c.tendsto_approx_at_top x) ((tendsto_add_at_top_iff_nat 1).1 _)
simp only [approx]
exact (c.left.tendsto_approx_at_top x).midpoint (c.right.tendsto_approx_at_top x)
intros
rw [corec_def, map_eq, head_iterate, tail_iterate]
refl
intros
unfold inits_core corec_on
rw [corec_eq]
refl
contradiction
intros
{cases a with n n, cases n; refl, refl}
cases a with n n
cases n
cases n; refl
refl
refl
refl
intros
have h := int.add_lt_add_right h (-b)
rwa int.add_right_neg at h
intros
have h := int.add_lt_add_right h (-c)
rwa int.add_neg_cancel_right at h
intros
induction s; simp [*, or_assoc]
induction s
simp [*, or_assoc]
simp [*, or_assoc]
intros
cases nat.eq_zero_or_pos n with h‚ÇÄ h‚ÇÄ
{ rw [h‚ÇÄ, nat.div_zero, nat.div_zero, nat.zero_sub] }
rw [h‚ÇÄ, nat.div_zero, nat.div_zero, nat.zero_sub]
induction p with p
{ induction p with p, { rw [nat.mul_zero, nat.sub_zero, nat.sub_zero] }, { have h‚ÇÇ : n*p ‚â§ x, { transitivity, { apply nat.mul_le_mul_left, apply le_succ }, { apply h‚ÇÅ } }, have h‚ÇÉ : x - n * p ‚â• n, { apply nat.le_of_add_le_add_right, rw [nat.sub_add_cancel h‚ÇÇ, nat.add_comm], rw [mul_succ] at h‚ÇÅ, apply h‚ÇÅ }, rw [sub_succ, ‚Üê p_ih h‚ÇÇ], rw [@div_eq_sub_div (x - n*p) _ h‚ÇÄ h‚ÇÉ], simp [add_one, pred_succ, mul_succ, nat.sub_sub] } }
{ rw [nat.mul_zero, nat.sub_zero, nat.sub_zero] }
rw [nat.mul_zero, nat.sub_zero, nat.sub_zero]
have h‚ÇÇ : n*p ‚â§ x
{ have h‚ÇÇ : n*p ‚â§ x, { transitivity, { apply nat.mul_le_mul_left, apply le_succ }, { apply h‚ÇÅ } }, have h‚ÇÉ : x - n * p ‚â• n, { apply nat.le_of_add_le_add_right, rw [nat.sub_add_cancel h‚ÇÇ, nat.add_comm], rw [mul_succ] at h‚ÇÅ, apply h‚ÇÅ }, rw [sub_succ, ‚Üê p_ih h‚ÇÇ], rw [@div_eq_sub_div (x - n*p) _ h‚ÇÄ h‚ÇÉ], simp [add_one, pred_succ, mul_succ, nat.sub_sub] }
transitivity
{ transitivity, { apply nat.mul_le_mul_left, apply le_succ }, { apply h‚ÇÅ } }
apply nat.mul_le_mul_left
{ apply nat.mul_le_mul_left, apply le_succ }
apply le_succ
apply h‚ÇÅ
{ apply h‚ÇÅ }
have h‚ÇÉ : x - n * p ‚â• n
apply nat.le_of_add_le_add_right
{ apply nat.le_of_add_le_add_right, rw [nat.sub_add_cancel h‚ÇÇ, nat.add_comm], rw [mul_succ] at h‚ÇÅ, apply h‚ÇÅ }
rw [nat.sub_add_cancel h‚ÇÇ, nat.add_comm]
rw [mul_succ] at h‚ÇÅ
apply h‚ÇÅ
rw [sub_succ, ‚Üê p_ih h‚ÇÇ]
rw [@div_eq_sub_div (x - n*p) _ h‚ÇÄ h‚ÇÉ]
simp [add_one, pred_succ, mul_succ, nat.sub_sub]
intros
rw [nat.mul_comm m k, nat.mul_comm n k] at H; exact dvd_of_mul_dvd_mul_left kpos H
rw [nat.mul_comm m k, nat.mul_comm n k] at H
exact dvd_of_mul_dvd_mul_left kpos H
intros
rw [nat.add_comm, nat.add_sub_of_le h]
intros
rw [nat.mul_comm, mul_pred_left, nat.mul_comm]
intros
rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_sub_cancel']
intros
simp [bit0, add_smul, smul_add]
intros
ext
ext; simp
simp
intros
induction n with k hk
{ simp only [h0, finset.prod_range_zero] }
simp only [h0, finset.prod_range_zero]
{ simp only [hk, finset.prod_range_succ, h, mul_comm] }
simp only [hk, finset.prod_range_succ, h, mul_comm]
intros
lift s to finset Œ± using hs
lift t to finset Œ≤ using ht
simp only [finprod_mem_coe_finset]
exact finset.prod_comm
intros
exact_mod_cast n.succ_ne_zero
intros
change s.nth (n + 1) = none at terminated_at_succ_n
cases s_nth_eq : (s.nth n); simp only [*, squash_seq]
cases s_nth_eq : (s.nth n)
simp only [*, squash_seq]
simp only [*, squash_seq]
intros
rw [terminated_at_iff_s_none, part_denom_none_iff_s_none]
intros
rw [‚Üê mul_div_mul_right _ b hd, ‚Üê mul_div_mul_left c d hb, div_add_div_same]
intros
simp [gcd_def]
intros
simp [h]
intros
rw [sub_eq_add_neg, neg_add a b]
intros
rw [‚Üê powers_hom_symm_apply, ‚Üê powers_hom_apply, equiv.apply_symm_apply]
intros
simpa only [sq_abs] using pow_lt_pow_of_lt_left h (abs_nonneg x) (1:‚Ñï).succ_pos
intros
rw [div_eq_mul_inv, mul_inv_cancel h]
intros
rw [mul_comm, div_mul_cancel_of_imp h]
intros
simp [single_map_homological_complex, h]
intros
{ dsimp [of], rw [if_pos rfl, category.comp_id] }
dsimp [of]
rw [if_pos rfl, category.comp_id]
intros
{ ext, simp [image_to_kernel'], }
ext
simp [image_to_kernel']
intros
rw [‚Üê mul_indicator_mul_indicator, mul_indicator_mul_support]
intros
simp
intros
rw ‚Üê f.ker_eq_bot at h‚ÇÅ
change comap f ‚ä• = ‚ä• at h‚ÇÅ
rw [eq_bot_iff, map_le_iff_le_comap, h‚ÇÅ] at h‚ÇÇ
rw eq_bot_iff
exact h‚ÇÇ
intros
ext x
let f : H ‚Üí module.End R L := Œª y, to_endomorphism R H L y - (œá y) ‚Ä¢ 1
let g : H ‚Üí module.End R H := Œª y, to_endomorphism R H H y - (œá y) ‚Ä¢ 1
suffices : (‚àÄ (y : H), ‚àÉ (k : ‚Ñï), ((f y)^k).comp (H.incl : H ‚Üí‚Çó[R] L) x = 0) ‚Üî ‚àÄ (y : H), ‚àÉ (k : ‚Ñï), (H.incl : H ‚Üí‚Çó[R] L).comp ((g y)^k) x = 0
simp only [lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, function.comp_app, linear_map.coe_comp, submodule.coe_eq_zero] at this
{ simp only [lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, function.comp_app, linear_map.coe_comp, submodule.coe_eq_zero] at this, simp only [mem_weight_space, mem_pre_weight_space, lie_subalgebra.coe_incl', lie_submodule.mem_comap, this], }
simp only [mem_weight_space, mem_pre_weight_space, lie_subalgebra.coe_incl', lie_submodule.mem_comap, this]
have hfg : ‚àÄ (y : H), (f y).comp (H.incl : H ‚Üí‚Çó[R] L) = (H.incl : H ‚Üí‚Çó[R] L).comp (g y)
rintros ‚ü®y, hz‚ü©
{ rintros ‚ü®y, hz‚ü©, ext ‚ü®z, hz‚ü©, simp only [submodule.coe_sub, to_endomorphism_apply_apply, lie_hom.coe_to_linear_map, linear_map.one_apply, lie_subalgebra.coe_incl, lie_subalgebra.coe_bracket_of_module, lie_subalgebra.coe_bracket, linear_map.smul_apply, function.comp_app, submodule.coe_smul_of_tower, linear_map.coe_comp, linear_map.sub_apply], }
ext ‚ü®z, hz‚ü©
simp only [submodule.coe_sub, to_endomorphism_apply_apply, lie_hom.coe_to_linear_map, linear_map.one_apply, lie_subalgebra.coe_incl, lie_subalgebra.coe_bracket_of_module, lie_subalgebra.coe_bracket, linear_map.smul_apply, function.comp_app, submodule.coe_smul_of_tower, linear_map.coe_comp, linear_map.sub_apply]
simp_rw [linear_map.commute_pow_left_of_commute (hfg _)]
intros
{ ext, rw [single_one_mul_apply, mul_single_one_apply, mul_comm] }
ext
rw [single_one_mul_apply, mul_single_one_apply, mul_comm]
intros
rintro ‚ü®f, _‚ü© ‚ü®g, _‚ü© ‚ü®h‚ü©; congr
rintro ‚ü®f, _‚ü© ‚ü®g, _‚ü© ‚ü®h‚ü©
congr
intros
simpa using inv_lt_of_neg ha hb
intros
rw [‚Üê mul_lt_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
intros
norm_cast
intros
rw [mul_comm, ha.le_mul_iff_one_le_right]
intros
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®le_imp_le_of_lt_imp_lt $ Œª h', mul_lt_mul_of_neg_right h' h, Œª h', decidable.mul_le_mul_of_nonpos_right h' h.le‚ü©
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®le_imp_le_of_lt_imp_lt $ Œª h', mul_lt_mul_of_neg_right h' h, Œª h', decidable.mul_le_mul_of_nonpos_right h' h.le‚ü©
intros
lift a to Œ± using ne_bot_of_gt ha
lift b to Œ± using ne_bot_of_gt hb
simp only [‚Üê coe_mul, bot_lt_coe]
intros
rw [bit0, ‚Üê two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2:Œ±))]
intros
simp only [eq_neg_iff_eq_neg.mp (h (x - c)), sub_add_cancel]
intros
simp only [‚Üê image2_mul, image2_swap _ s, mul_comm]
intros
simpa using leading_coeff_multiset_prod (s.1.map f)
intros
simp [right_distrib]
intros
ext f
rw [vanishing_ideal, set_like.mem_coe, submodule.mem_infi]
apply forall_congr
intro x
rw [submodule.mem_infi]
intros
{ cases x, refl }
cases x
refl
intros
dsimp [Œ¥, œÉ]
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_œÉ_succ, X.map_id]
intros
{ cases n, { refl }, cases n, { contradiction }, refl }
cases n
refl
{ refl }
cases n
contradiction
{ contradiction }
refl
intros
refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm
refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
{ unfold is_O_with, exact mem_map }
unfold is_O_with
exact mem_map
intros
rw is_O_with
rw is_O_with; refl
refl
intros
rw has_strict_deriv_at at hh‚ÇÅ
{ rw has_strict_deriv_at at hh‚ÇÅ, convert hh‚ÇÅ.comp x hf, ext x, simp [mul_comm] }
convert hh‚ÇÅ.comp x hf
ext x
simp [mul_comm]
intros
simp [div_eq_inv_mul, differentiable_within_at.const_mul, hc]
intros
simp only [has_deriv_within_at_iff_tendsto_slope, sdiff_idem]
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
rw [‚Üê e.image_symm_eq_preimage, e.symm.unique_diff_on_image_iff]
intros
simp [iterated_deriv_within, iterated_fderiv_within_one_apply hs hx]
{ simp [iterated_deriv_within, iterated_fderiv_within_one_apply hs hx], refl }
refl
intros
have hdf : ‚àÄ x ‚àà Iio a, differentiable_at ‚Ñù f x
from Œª x hx, (hdf x hx).differentiable_at (Iio_mem_nhds hx)
have hdg : ‚àÄ x ‚àà Iio a, differentiable_at ‚Ñù g x
from Œª x hx, classical.by_contradiction (Œª h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_at_bot_on_Iio (Œª x hx, (hdf x hx).has_deriv_at) (Œª x hx, (hdg x hx).has_deriv_at) hg' hfbot hgbot hdiv
intros
apply (f_aux_deriv n x (ne_of_gt hx)).congr_of_eventually_eq
filter_upwards [lt_mem_nhds hx]
assume y hy
simp [f_aux, hy.not_le]
intros
apply times_cont_diff_of_differentiable_iterated_fderiv (Œªm hm, _)
rw iterated_fderiv_within_zero_fun
apply differentiable_const (0 : (E [√óm]‚ÜíL[ùïú] F))
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
intros m hm
rcases h m hm with ‚ü®u, u_mem, p', hp'‚ü©
exact ‚ü®u, u_mem, _, hp'.restrict_scalars _‚ü©
intros
simp [is_R_or_C.abs, complex.abs]
intros
simpa only [nat.cast_one, one_div] using is_primitive_root_exp_of_coprime 1 n h0 n.coprime_one_left
intros
rintro z ‚ü®a, b, ha, hb, hab, rfl‚ü©
split
calc x = a ‚Ä¢ x + b ‚Ä¢ x : by rw [‚Üêadd_smul, hab, one_smul] ... < a ‚Ä¢ x + b ‚Ä¢ y : add_lt_add_left (smul_lt_smul_of_pos h hb) _
calc a ‚Ä¢ x + b ‚Ä¢ y < a ‚Ä¢ y + b ‚Ä¢ y : add_lt_add_right (smul_lt_smul_of_pos h ha) _ ... = y : by rw [‚Üêadd_smul, hab, one_smul]
intros
apply h.segment_subset hx hy
rw segment_eq_image'
exact mem_image_of_mem _ ht
intros
refl
intros
refine ‚ü®hf.left, Œª x y hx hy a b ha hb hab, sup_le _ _‚ü©
calc f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y : hf.right hx hy ha hb hab ... ‚â§ a ‚Ä¢ (f x ‚äî g x) + b ‚Ä¢ (f y ‚äî g y) : add_le_add (smul_le_smul_of_nonneg le_sup_left ha) (smul_le_smul_of_nonneg le_sup_left hb)
{ calc f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y : hf.right hx hy ha hb hab ... ‚â§ a ‚Ä¢ (f x ‚äî g x) + b ‚Ä¢ (f y ‚äî g y) : add_le_add (smul_le_smul_of_nonneg le_sup_left ha) (smul_le_smul_of_nonneg le_sup_left hb) }
calc g (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ g x + b ‚Ä¢ g y : hg.right hx hy ha hb hab ... ‚â§ a ‚Ä¢ (f x ‚äî g x) + b ‚Ä¢ (f y ‚äî g y) : add_le_add (smul_le_smul_of_nonneg le_sup_right ha) (smul_le_smul_of_nonneg le_sup_right hb)
{ calc g (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ g x + b ‚Ä¢ g y : hg.right hx hy ha hb hab ... ‚â§ a ‚Ä¢ (f x ‚äî g x) + b ‚Ä¢ (f y ‚äî g y) : add_le_add (smul_le_smul_of_nonneg le_sup_right ha) (smul_le_smul_of_nonneg le_sup_right hb) }
intros
have A : deriv (Œª (x : ‚Ñù), x ^ p) = Œª x, p * x^(p-1)
ext x
ext x
{ ext x, simp [hp] }
{ ext x, simp [hp] }
simp [hp]
simp [hp]
apply convex_on_of_deriv2_nonneg (convex_Ici 0)
exact continuous_on_id.rpow_const (Œª x _, or.inr (zero_le_one.trans hp))
{ exact continuous_on_id.rpow_const (Œª x _, or.inr (zero_le_one.trans hp)) }
exact (differentiable_rpow_const hp).differentiable_on
{ exact (differentiable_rpow_const hp).differentiable_on }
rw A
{ rw A, assume x hx, replace hx : x ‚â† 0, by { simp at hx, exact ne_of_gt hx }, simp [differentiable_at.differentiable_within_at, hx] }
assume x hx
replace hx : x ‚â† 0
simp at hx
simp at hx
{ simp at hx, exact ne_of_gt hx }
{ simp at hx, exact ne_of_gt hx }
exact ne_of_gt hx
exact ne_of_gt hx
simp [differentiable_at.differentiable_within_at, hx]
assume x hx
{ assume x hx, replace hx : 0 < x, by simpa using hx, suffices : 0 ‚â§ p * ((p - 1) * x ^ (p - 1 - 1)), by simpa [ne_of_gt hx, A], apply mul_nonneg (le_trans zero_le_one hp), exact mul_nonneg (sub_nonneg_of_le hp) (rpow_nonneg_of_nonneg (le_of_lt hx) _) }
replace hx : 0 < x
simpa using hx
simpa using hx
suffices : 0 ‚â§ p * ((p - 1) * x ^ (p - 1 - 1))
simpa [ne_of_gt hx, A]
simpa [ne_of_gt hx, A]
apply mul_nonneg (le_trans zero_le_one hp)
exact mul_nonneg (sub_nonneg_of_le hp) (rpow_nonneg_of_nonneg (le_of_lt hx) _)
intros
rw [norm_add_mul_self, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]
apply or.inr
simp only [h, zero_re']
intros
apply le_antisymm
rw le_infi_iff
{ rw le_infi_iff, rintros ‚ü®v, hv‚ü© w hw, simpa using hw _ hv }
rintros ‚ü®v, hv‚ü© w hw
simpa using hw _ hv
intros v hv w hw
{ intros v hv w hw, simp only [submodule.mem_infi] at hv, exact hv ‚ü®w, hw‚ü© }
simp only [submodule.mem_infi] at hv
exact hv ‚ü®w, hw‚ü©
intros
rw [‚Üêinner_conj_sym, inner_smul_left, ring_hom.map_mul, conj_conj, inner_conj_sym]
intros
rw orthonormal_iff_ite
split
intros h v hv w hw
{ intros h v hv w hw, convert h ‚ü®v, hv‚ü© ‚ü®w, hw‚ü© using 1, simp }
convert h ‚ü®v, hv‚ü© ‚ü®w, hw‚ü© using 1
simp
rintros h ‚ü®v, hv‚ü© ‚ü®w, hw‚ü©
{ rintros h ‚ü®v, hv‚ü© ‚ü®w, hw‚ü©, convert h v hv w hw using 1, simp }
convert h v hv w hw using 1
simp
intros
obtain ‚ü®y, hy, z, hz, hwyz‚ü© := K.exists_sum_mem_mem_orthogonal w
convert hwyz
exact eq_orthogonal_projection_of_mem_orthogonal' hy hz hwyz
{ exact eq_orthogonal_projection_of_mem_orthogonal' hy hz hwyz }
rw add_comm at hwyz
{ rw add_comm at hwyz, refine eq_orthogonal_projection_of_mem_orthogonal' hz _ hwyz, simp [hy] }
refine eq_orthogonal_projection_of_mem_orthogonal' hz _ hwyz
simp [hy]
intros
rw [midpoint, ‚Üê homothety_eq_line_map, dist_center_homothety, inv_of_eq_inv, ‚Üê normed_field.norm_inv]
intros
ext
{ ext, refl }
refl
intros
simpa [dist_eq_norm] using abs_dist_sub_le g h 0
intros
simp only [lipschitz_with_iff_dist_le_mul, dist_eq_norm]
intros
rcases h.bound with ‚ü®C, Cpos : 0 < C, hC‚ü©
refine is_linear_map.with_bound ‚ü®Œª p‚ÇÅ p‚ÇÇ, _, Œª c p, _‚ü© (C + C) (Œª p, _)
{ ext; simp [h.add_left, h.add_right]; abel }
ext
ext; simp [h.add_left, h.add_right]; abel
ext; simp [h.add_left, h.add_right]
simp [h.add_left, h.add_right]
abel
simp [h.add_left, h.add_right]
abel
{ ext; simp [h.smul_left, h.smul_right, smul_add] }
ext
ext; simp [h.smul_left, h.smul_right, smul_add]
simp [h.smul_left, h.smul_right, smul_add]
simp [h.smul_left, h.smul_right, smul_add]
refine continuous_linear_map.op_norm_le_bound _ (mul_nonneg (add_nonneg Cpos.le Cpos.le) (norm_nonneg _)) (Œª q, _)
{ refine continuous_linear_map.op_norm_le_bound _ (mul_nonneg (add_nonneg Cpos.le Cpos.le) (norm_nonneg _)) (Œª q, _), calc ‚à•f (p.1, q.2) + f (q.1, p.2)‚à• ‚â§ C * ‚à•p.1‚à• * ‚à•q.2‚à• + C * ‚à•q.1‚à• * ‚à•p.2‚à• : norm_add_le_of_le (hC _ _) (hC _ _) ... ‚â§ C * ‚à•p‚à• * ‚à•q‚à• + C * ‚à•q‚à• * ‚à•p‚à• : by apply_rules [add_le_add, mul_le_mul, norm_nonneg, Cpos.le, le_refl, le_max_left, le_max_right, mul_nonneg] ... = (C + C) * ‚à•p‚à• * ‚à•q‚à• : by ring }
calc ‚à•f (p.1, q.2) + f (q.1, p.2)‚à• ‚â§ C * ‚à•p.1‚à• * ‚à•q.2‚à• + C * ‚à•q.1‚à• * ‚à•p.2‚à• : norm_add_le_of_le (hC _ _) (hC _ _) ... ‚â§ C * ‚à•p‚à• * ‚à•q‚à• + C * ‚à•q‚à• * ‚à•p‚à• : by apply_rules [add_le_add, mul_le_mul, norm_nonneg, Cpos.le, le_refl, le_max_left, le_max_right, mul_nonneg] ... = (C + C) * ‚à•p‚à• * ‚à•q‚à• : by ring
intros
change summable (norm ‚àò _)
rw ‚Üê exp_series_apply_eq_field'
exact norm_exp_series_summable_of_mem_ball x hx
intros
apply coe_inj
intros
refine le_antisymm _ (norm_nonneg _)
apply op_norm_le_bound _ rfl.ge
intros x
simp [subsingleton.elim x 0]
intros
convert add_le_add_left (le_sum_condensed' hf n) (f 0)
rw [‚Üê sum_range_add_sum_Ico _ n.one_le_two_pow, sum_range_succ, sum_range_zero, zero_add]
intros
simp [bernstein_approximation]
intros
rw [‚Üê tendsto_map'_iff, map_exp_at_top]
intros
rw ‚Üê has_deriv_within_at_univ at *
exact hf.log hx
intros
rw ‚Üê has_deriv_within_at_univ at *
exact hf.rpow hg h
intros
{ rw ‚Üê one_rpow z, exact rpow_le_rpow hx1 hx2 hz }
rw ‚Üê one_rpow z
exact rpow_le_rpow hx1 hx2 hz
intros
rcases ne_or_eq x 0 with hx | rfl
exact (has_strict_deriv_at_rpow_const_of_ne hx _).has_deriv_at
{ exact (has_strict_deriv_at_rpow_const_of_ne hx _).has_deriv_at }
replace h : 1 ‚â§ p := h.neg_resolve_left rfl
apply has_deriv_at_of_has_deriv_at_of_ne (Œª x hx, (has_strict_deriv_at_rpow_const_of_ne hx p).has_deriv_at)
exacts [continuous_at_id.rpow_const (or.inr (zero_le_one.trans h)), continuous_at_const.mul (continuous_at_id.rpow_const (or.inr (sub_nonneg.2 h)))]
simp [two_mul, cos_add]
{ rw real.range_cos, exact Icc.infinite (by norm_num) }
rw real.range_cos
exact Icc.infinite (by norm_num)
rw [tan_eq_sin_div_cos, cos_pi_div_four, sin_pi_div_four]
have h : (sqrt 2) / 2 > 0 := by cancel_denoms
exact div_self (ne_of_gt h)
intros
rw [‚Üê not_exists, not_iff_not, cos_eq_zero_iff]
simp [arccos, add_halves]
intros
rcases exists_between hl‚ÇÅ with ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü©
refine summable_of_ratio_norm_eventually_le hr‚ÇÅ _
filter_upwards [eventually_le_of_tendsto_lt hr‚ÇÄ h, hf]
intros n h‚ÇÄ h‚ÇÅ
rwa ‚Üê div_le_iff (norm_pos_iff.mpr h‚ÇÅ)
intros
simp
intros
{ convert cancel_epi f, simp, }
convert cancel_epi f
simp
intros
{ rw [Œ±.naturality_assoc], simp }
rw [Œ±.naturality_assoc]
simp
intros
{ cases E, congr, }
cases E
congr
intros
ext
{ ext, simp, }
simp
intros
rw [‚Üêcancel_epi (limit_iso_limit_curry_comp_lim G).hom]
simp
intros
ext
simp only [whisker_right_app, lim_map_œÄ, assoc, limit.post_œÄ_assoc, limit.post_œÄ, ‚Üê H.map_comp]
intros
simp
intros
simp
intros
rw biprod.map_eq_map'
exact is_colimit.Œπ_map (binary_biproduct.is_colimit W X) _ _ walking_pair.right
intros
rw [(has_zero_object.unique_from X).uniq f, (has_zero_object.unique_from X).uniq g]
intros
rw [‚Üêtensor_comp, f.hom_inv_id]
intros
{ cases f, cases g, congr, exact w, }
cases f
cases g
congr
exact w
intros
dsimp [tensor_hom]
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
rintro ‚ü®‚ü©
{ simp, }
simp
apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit
{ apply is_limit.hom_ext (‚Ñ¨ _ _).is_limit, rintro ‚ü®‚ü©, { simp, }, { simp, }, }
rintro ‚ü®‚ü©
{ simp, }
simp
{ simp, }
simp
intros
simp only [cancel_mono]
intros
rw [‚Üê not_nonempty_iff, ‚Üê not_congr (finrank_hom_simple_simple_eq_one_iff ùïú X Y)]
refine ‚ü®Œª h, by { rw h, simp, }, Œª h, _‚ü©
have := finrank_hom_simple_simple_le_one ùïú X Y
interval_cases finrank ùïú (X ‚ü∂ Y) with h'
{ exact h', }
exact h'
{ exact false.elim (h h'), }
exact false.elim (h h')
intros
classical
by_contradiction h
haveI := is_iso_of_epi_of_nonzero h
exact w (eq_zero_of_mono_cokernel f)
intros
rw [is_separated_for, ‚Üêforall_and_distrib]
apply forall_congr
intro x
split
intros z hx
{ intros z hx, exact exists_unique_of_exists_of_unique (z.2 hx) z.1 }
exact exists_unique_of_exists_of_unique (z.2 hx) z.1
intros h
{ intros h, refine ‚ü®_, (exists_of_exists_unique ‚àò h)‚ü©, intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ, apply (h _).unique ht‚ÇÅ ht‚ÇÇ, exact is_compatible_of_exists_amalgamation x ‚ü®_, ht‚ÇÇ‚ü© }
refine ‚ü®_, (exists_of_exists_unique ‚àò h)‚ü©
intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
apply (h _).unique ht‚ÇÅ ht‚ÇÇ
exact is_compatible_of_exists_amalgamation x ‚ü®_, ht‚ÇÇ‚ü©
intros
{ rw eq_mk h, simp, }
rw eq_mk h
simp
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
intros
convert underlying_iso_hom_comp_eq_mk (ùüô B)
{ convert underlying_iso_hom_comp_eq_mk (ùüô B), simp only [comp_id], }
simp only [comp_id]
intros
simp [kernel_subobject_map]
intros
rw [l.apply, option.get_or_else_of_ne_none h]
intros
ext x
rw [accepts, NFA.accepts, eval, NFA.eval, ‚Üêto_NFA_eval_from_match]
refl
intros
simp only [mjoin, (‚àò), id.def, (bind_pure_comp_eq_map _ _).symm, bind_assoc, map_bind, pure_bind]
intros
rw ‚Üê comp_bitraverse; simp [tsnd]; refl
rw ‚Üê comp_bitraverse; simp [tsnd]
rw ‚Üê comp_bitraverse
simp [tsnd]
refl
intros
induction x; simp! * with functor_norm; refl
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
rw [of_fin,to_nat_of_nat,nat.mod_eq_of_lt]; apply i.is_lt
rw [of_fin,to_nat_of_nat,nat.mod_eq_of_lt]
apply i.is_lt
intros
induction l with hd tl hl generalizing b
{ simp }
simp
{ simp [append_list, hl, add_comm, add_assoc] }
simp [append_list, hl, add_comm, add_assoc]
intros
have : char_buf cb' cb' 0 = done cb'.size () := by simp [char_buf_eq_done]
split
introI
{ introI, simpa using of_done this }
simpa using of_done this
intro h
{ intro h, constructor, intros cb n n' _, rw [char_buf_eq_done, h], rintro ‚ü®rfl, -‚ü©, refl }
constructor
intros cb n n' _
rw [char_buf_eq_done, h]
rintro ‚ü®rfl, -‚ü©
refl
intros
simp [many, foldr_eq_done, and.comm, and.assoc, and.left_comm]
intros
rw [sub_eq_add_neg, norm_sq_add]; simp [-mul_re, add_comm, add_left_comm, sub_eq_add_neg]
rw [sub_eq_add_neg, norm_sq_add]
simp [-mul_re, add_comm, add_left_comm, sub_eq_add_neg]
intros
simp only [‚Üê tan_mul_cos hx, mul_pow, ‚Üê inv_one_add_tan_sq hx, div_eq_mul_inv, one_mul]
intros
rw [‚Üê mul_right_inj' (@two_ne_zero' ‚ÑÇ _ _ _), mul_sub, two_cosh, two_sinh, add_sub_sub_cancel, two_mul]
intros
rw [‚Üê of_real_cos_of_real_re, of_real_im]
intros
rw ext_iff
by_cases r = 0
simp [h]
{ simp [h] }
{ simp; field_simp [h, norm_sq] }
simp
simp; field_simp [h, norm_sq]
field_simp [h, norm_sq]
intros
{ unfold swap_core, split_ifs; cc }
unfold swap_core
split_ifs
split_ifs; cc
cc
cc
cc
cc
intros
cases e
{ cases e, refl }
refl
intros
rw fin_rotate_succ_apply
have : (i : ‚Ñï) < n := lt_of_le_of_ne (nat.succ_le_succ_iff.mp i.2) (fin.coe_injective.ne h)
exact fin.coe_add_one_of_lt this
intros
refine iff.intro _ _
intro h
{ intro h, cases succ_above_lt_ge p i with H H, { exact H }, { rw succ_above_above _ _ H at h, exact lt_trans (cast_succ_lt_succ i) h } }
cases succ_above_lt_ge p i with H H
{ exact H }
exact H
rw succ_above_above _ _ H at h
{ rw succ_above_above _ _ H at h, exact lt_trans (cast_succ_lt_succ i) h }
exact lt_trans (cast_succ_lt_succ i) h
intro h
{ intro h, rw succ_above_below _ _ h, exact h }
rw succ_above_below _ _ h
exact h
intros
ext j
by_cases h : j = 0
{ rw h, simp }
rw h
simp
let j' := pred j h
{ let j' := pred j h, have : j'.succ = j := succ_pred j h, rw [‚Üê this, tail, cons_succ] }
have : j'.succ = j := succ_pred j h
rw [‚Üê this, tail, cons_succ]
intros
simp [‚Üê cast_add_nat]
intros
rw [disjoint.symm_iff, disjoint_union_left, disjoint.symm_iff _ x, disjoint.symm_iff _ x]
intros
classical
{ classical, rw ‚Üê piecewise_coe, exact set.piecewise_mem_pi ‚Üës hf hg }
rw ‚Üê piecewise_coe
exact set.piecewise_mem_pi ‚Üës hf hg
intros
simp [finset.nonempty, ‚Üê exists_and_distrib_left, @exists_swap Œ±]
intros
{ ext, simp }
ext
simp
intros
apply finset.induction_on s
{ simp only [fold_empty], }
simp only [fold_empty]
intros a s has ih
{ intros a s has ih, rw [fold_insert has, ih, insert_eq], }
rw [fold_insert has, ih, insert_eq]
intros
simp
intros
simp [to_finset]
intros
ext x
ext x; refl
refl
intros
convert rfl
intros
simp [single_eq_indicator]
intros
{ext, refl}
ext
refl
intros
{ rw ‚Üê subtype_card s H, congr }
rw ‚Üê subtype_card s H
congr
intros
simp only [finset.prod_attach_univ, prod_sum, finset.sum_univ_pi]
intros
change sub_nat_nat _ _ = _
have h' : n.succ - m = 0
apply nat.sub_eq_zero_of_le h
simp [*, sub_nat_nat]
intros
simpa only [bit0_zero] using bit1_ne_bit0 m 0
intros
induction i
induction i
{ induction i, { exact hz }, { exact hp _ i_ih } }
{ exact hz }
exact hz
{ exact hp _ i_ih }
exact hp _ i_ih
have : ‚àÄ n:‚Ñï, p (- n)
{ have : ‚àÄ n:‚Ñï, p (- n), { intro n, induction n, { simp [hz] }, { convert hn _ n_ih using 1, simp [sub_eq_neg_add] } }, exact this (i + 1) }
intro n
{ intro n, induction n, { simp [hz] }, { convert hn _ n_ih using 1, simp [sub_eq_neg_add] } }
induction n
{ simp [hz] }
simp [hz]
{ convert hn _ n_ih using 1, simp [sub_eq_neg_add] }
convert hn _ n_ih using 1
simp [sub_eq_neg_add]
exact this (i + 1)
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
induction k
apply int.coe_nat_dvd.2
{ apply int.coe_nat_dvd.2, apply pow_dvd_of_le_of_pow_dvd hmn, apply int.coe_nat_dvd.1 hdiv }
apply pow_dvd_of_le_of_pow_dvd hmn
apply int.coe_nat_dvd.1 hdiv
change -[1+k] with -(‚Üë(k+1) : ‚Ñ§)
apply dvd_neg_of_dvd
apply int.coe_nat_dvd.2
apply pow_dvd_of_le_of_pow_dvd hmn
apply int.coe_nat_dvd.1
apply dvd_of_dvd_neg
exact hdiv
intros
refine nat.dvd_antisymm _ (int.coe_nat_dvd.1 (int.dvd_gcd h‚ÇÅ h‚ÇÇ))
rw [‚Üê int.coe_nat_dvd, ‚Üê h‚ÇÉ]
apply dvd_add
{ exact (int.gcd_dvd_left _ _).mul_right _ }
exact (int.gcd_dvd_left _ _).mul_right _
{ exact (int.gcd_dvd_right _ _).mul_right _ }
exact (int.gcd_dvd_right _ _).mul_right _
intros
unfold modeq nat.modeq; rw ‚Üê int.coe_nat_eq_coe_nat_iff; simp [coe_nat_mod]
unfold modeq nat.modeq; rw ‚Üê int.coe_nat_eq_coe_nat_iff
unfold modeq nat.modeq
rw ‚Üê int.coe_nat_eq_coe_nat_iff
simp [coe_nat_mod]
intros
cases mod_two_eq_zero_or_one n with h h; simp [h]
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
{ congr, exact h}
congr
exact h
intros
rw [nth_update_nth_eq, nth_le_nth h]; refl
rw [nth_update_nth_eq, nth_le_nth h]
refl
intros
simp [hi, sum_take_succ, hj]
intros
rw [‚Üê map_id (l.lookmap f), lookmap_map_eq, map_id]
rw [‚Üê map_id (l.lookmap f), lookmap_map_eq, map_id]; exact h
exact h
intros
simp only [eq_nil_iff_forall_not_mem, mem_filter, not_and]
intros
rw ‚Üê reverse_suffix; simp only [reverse_reverse]
rw ‚Üê reverse_suffix
simp only [reverse_reverse]
intros
induction l with x l IH generalizing n
{ simp }
simp
cases n
{ cases n, { simp }, { simpa using IH n _ } }
{ simp }
simp
{ simpa using IH n _ }
simpa using IH n _
intros
induction l with b l IH
cases al
{cases al}
by_cases pb : p b
{ exact ‚ü®b, [], l, forall_mem_nil _, pb, by simp [pb]‚ü© }
exact ‚ü®b, [], l, forall_mem_nil _, pb, by simp [pb]‚ü©
rcases al with rfl | al
{ rcases al with rfl | al, {exact pb.elim pa}, rcases IH al with ‚ü®c, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©, exact ‚ü®c, b::l‚ÇÅ, l‚ÇÇ, forall_mem_cons.2 ‚ü®pb, h‚ÇÅ‚ü©, h‚ÇÇ, by rw h‚ÇÉ; refl, by simp [pb, h‚ÇÑ]‚ü© }
exact pb.elim pa
{exact pb.elim pa}
rcases IH al with ‚ü®c, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
exact ‚ü®c, b::l‚ÇÅ, l‚ÇÇ, forall_mem_cons.2 ‚ü®pb, h‚ÇÅ‚ü©, h‚ÇÇ, by rw h‚ÇÉ; refl, by simp [pb, h‚ÇÑ]‚ü©
intros
rw map_const at h; exact eq_of_mem_repeat h
rw map_const at h
exact eq_of_mem_repeat h
intros
simp
intros
{ induction l, contradiction, rw [tail,cons_append,tail], }
induction l
contradiction
rw [tail,cons_append,tail]
intros
induction l with lh lt l_ih generalizing a
{ simp }
simp
simp [H _ _ _ _ (rel_of_chain_cons hl‚ÇÅ), l_ih _ (chain_of_chain_cons hl‚ÇÅ)]
{ simp [H _ _ _ _ (rel_of_chain_cons hl‚ÇÅ), l_ih _ (chain_of_chain_cons hl‚ÇÅ)] }
intros
rw [sub, nil_pointwise]
congr' with x
have : @default Œ± ‚ü®0‚ü© = 0 := rfl
have : @default Œ± ‚ü®0‚ü© = 0 := rfl
have : @default Œ± ‚ü®0‚ü© = 0 := rfl
rw [this, zero_sub]
intros
dsimp [Ico]; simp only [nodup_range']
dsimp [Ico]
simp only [nodup_range']
intros
simp only [nodup, pairwise_append, disjoint_iff_ne]
intros
simp only [mem_of_fn, set.forall_range_iff]
intros
induction hlu generalizing v
cases huv
case perm.nil { cases huv, exact ‚ü®[], forall‚ÇÇ.nil, perm.nil‚ü© }
exact ‚ü®[], forall‚ÇÇ.nil, perm.nil‚ü©
case perm.cons : a l u hlu ih { cases huv with _ b _ v hab huv', rcases ih huv' with ‚ü®l‚ÇÇ, h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ‚ü©, exact ‚ü®b::l‚ÇÇ, forall‚ÇÇ.cons hab h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ.cons _‚ü© }
case perm.swap : a‚ÇÅ a‚ÇÇ l‚ÇÅ l‚ÇÇ h‚ÇÇ‚ÇÉ { cases h‚ÇÇ‚ÇÉ with _ b‚ÇÅ _ l‚ÇÇ h‚ÇÅ hr_‚ÇÇ‚ÇÉ, cases hr_‚ÇÇ‚ÇÉ with _ b‚ÇÇ _ l‚ÇÇ h‚ÇÇ h‚ÇÅ‚ÇÇ, exact ‚ü®b‚ÇÇ::b‚ÇÅ::l‚ÇÇ, forall‚ÇÇ.cons h‚ÇÇ (forall‚ÇÇ.cons h‚ÇÅ h‚ÇÅ‚ÇÇ), perm.swap _ _ _‚ü© }
case perm.trans : la‚ÇÅ la‚ÇÇ la‚ÇÉ _ _ ih‚ÇÅ ih‚ÇÇ { rcases ih‚ÇÇ huv with ‚ü®lb‚ÇÇ, hab‚ÇÇ, h‚ÇÇ‚ÇÉ‚ü©, rcases ih‚ÇÅ hab‚ÇÇ with ‚ü®lb‚ÇÅ, hab‚ÇÅ, h‚ÇÅ‚ÇÇ‚ü©, exact ‚ü®lb‚ÇÅ, hab‚ÇÅ, perm.trans h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ‚ü© }
intros
rw [eq_comm, rotate_eq_singleton_iff, eq_comm]
intros
simp [cyclic_permutations_of_ne_nil]
intros
have := nodup_of_sublist ((lookup_all_sublist a l).map _) h
have := nodup_of_sublist ((lookup_all_sublist a l).map _) h; rw map_map at this; rwa [‚Üê nodup_repeat, ‚Üê map_const _ a]
have := nodup_of_sublist ((lookup_all_sublist a l).map _) h; rw map_map at this
rw map_map at this
rwa [‚Üê nodup_repeat, ‚Üê map_const _ a]
intros
induction l‚ÇÅ with s _ ih generalizing l‚ÇÇ
induction l‚ÇÅ with s _ ih generalizing l‚ÇÇ; simp at h; cases h; cases s with a'
induction l‚ÇÅ with s _ ih generalizing l‚ÇÇ; simp at h; cases h
induction l‚ÇÅ with s _ ih generalizing l‚ÇÇ; simp at h
simp at h
cases h
simp at h
cases h
cases s with a'
{ subst h, simp }
subst h
simp
cases s with a'
rw kunion_cons
{ rw kunion_cons, by_cases h' : a = a', { subst h', simp }, { simp [h', ih h] } }
by_cases h' : a = a'
{ subst h', simp }
subst h'
simp
{ simp [h', ih h] }
simp [h', ih h]
intros
simp only [sublists_eq_sublists', map_map, map_id' (reverse_reverse)]
intros
{ rw [length_zip_with, lt_min_iff] at h, exact h.left }
rw [length_zip_with, lt_min_iff] at h
exact h.left
intros
simp [conj_transpose]
intros
simp [dot_product]
intros
{ cases ik, cases jk, refl }
cases ik
cases jk
refl
intros
ext ‚ü®i‚ÇÅ, i‚ÇÇ‚ü© ‚ü®j‚ÇÅ, j‚ÇÇ‚ü©
simp [diagonal, apply_ite f, ite_and, ite_apply, apply_ite (f (a i‚ÇÅ)), hf‚ÇÅ, hf‚ÇÇ]
intros
{ ext i, refine fin.cases _ _ i; simp [mul_vec] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [mul_vec]
simp [mul_vec]
simp [mul_vec]
intros
dunfold strong_downward_induction_on
{ dunfold strong_downward_induction_on, rw strong_downward_induction }
rw strong_downward_induction
intros
simp [erase_dup_ext]
intros
induction n; simp [nat.succ_eq_add_one, *]
induction n
simp [nat.succ_eq_add_one, *]
simp [nat.succ_eq_add_one, *]
intros
simp [eval‚ÇÇ_monomial, f.map_one, X, prod_single_index, pow_one]
intros
funext i
{ funext i, simp only [comap, alg_hom.id_apply, id.def, aeval_X], }
simp only [comap, alg_hom.id_apply, id.def, aeval_X]
intros
refine quotient.induction_on s (assume l, _)
rw [multiset.quot_mk_to_coe, multiset.coe_prod, multiset.coe_map, multiset.coe_sum]
exact total_degree_list_prod l
intros
bitwise_assoc_tac
intros
{ rw [‚Üêcoe_nat n], apply coe_ne_top }
rw [‚Üêcoe_nat n]
apply coe_ne_top
intros
rw [‚Üê add_mul_div_left, mul_comm 2 n, ‚Üê mul_add, nat.add_sub_cancel, mul_comm]
cases n; refl
cases n
refl
refl
apply zero_lt_succ
intros
rw [h, dist_self]
intros
cases n1 with h
{ exact self_le_factorial _ }
exact self_le_factorial _
exact add_factorial_succ_le_factorial_add_succ i h
intros
rw cast_desc_factorial
cases a
rw [nat.zero_sub, cast_zero, pochhammer_ne_zero_eval_zero _ (two_ne_zero), zero_mul]
{ rw [nat.zero_sub, cast_zero, pochhammer_ne_zero_eval_zero _ (two_ne_zero), zero_mul] }
rw [succ_sub_succ, nat.sub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one, polynomial.X_mul, polynomial.eval_mul_X, polynomial.eval_add, polynomial.eval_X, cast_one, polynomial.eval_one]
{ rw [succ_sub_succ, nat.sub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one, polynomial.X_mul, polynomial.eval_mul_X, polynomial.eval_add, polynomial.eval_X, cast_one, polynomial.eval_one] }
intros
rw [mul_comm m k, H.gcd_mul_left_cancel m]
intros
rw [hp.multiplicity_factorial (lt_succ_self _), enat.coe_le_coe]
exact nat.geom_sum_Ico_le hp.two_le _ _
intros
rw [odd_iff_not_even, even_sub h, not_iff, odd_iff_not_even]
simp [size]
intros
unfold divmod_aux
have : ‚àÄ {r‚ÇÇ}, num.of_znum' (num.sub' r (num.pos d)) = some r‚ÇÇ ‚Üî (r : ‚Ñï) = r‚ÇÇ + d
intro r‚ÇÇ
{ intro r‚ÇÇ, apply num.mem_of_znum'.trans, rw [‚Üê znum.to_int_inj, num.cast_to_znum, num.cast_sub', sub_eq_iff_eq_add, ‚Üê int.coe_nat_inj'], simp }
apply num.mem_of_znum'.trans
rw [‚Üê znum.to_int_inj, num.cast_to_znum, num.cast_sub', sub_eq_iff_eq_add, ‚Üê int.coe_nat_inj']
simp
cases e : num.of_znum' (num.sub' r (num.pos d)) with r‚ÇÇ
cases e : num.of_znum' (num.sub' r (num.pos d)) with r‚ÇÇ; simp [divmod_aux]
simp [divmod_aux]
refine ‚ü®h‚ÇÅ, lt_of_not_ge (Œª h, _)‚ü©
{ refine ‚ü®h‚ÇÅ, lt_of_not_ge (Œª h, _)‚ü©, cases nat.le.dest h with r‚ÇÇ e', rw [‚Üê num.to_of_nat r‚ÇÇ, add_comm] at e', cases e.symm.trans (this.2 e'.symm) }
cases nat.le.dest h with r‚ÇÇ e'
rw [‚Üê num.to_of_nat r‚ÇÇ, add_comm] at e'
cases e.symm.trans (this.2 e'.symm)
simp [divmod_aux]
have := this.1 e
{ have := this.1 e, split, { rwa [_root_.bit1, add_comm _ 1, mul_add, mul_one, ‚Üê add_assoc, ‚Üê this] }, { rwa [this, two_mul, add_lt_add_iff_right] at h‚ÇÇ } }
split
rwa [_root_.bit1, add_comm _ 1, mul_add, mul_one, ‚Üê add_assoc, ‚Üê this]
{ rwa [_root_.bit1, add_comm _ 1, mul_add, mul_one, ‚Üê add_assoc, ‚Üê this] }
{ rwa [this, two_mul, add_lt_add_iff_right] at h‚ÇÇ }
rwa [this, two_mul, add_lt_add_iff_right] at h‚ÇÇ
intros
cases a; refl
cases a
refl
refl
refl
intros
cases x; simp only [map_none', map_some', eq_self_iff_true]
{ cases x; simp only [map_none', map_some', eq_self_iff_true] }
cases x
simp only [map_none', map_some', eq_self_iff_true]
simp only [map_none', map_some', eq_self_iff_true]
intros
induction t
exact H0
{exact H0}
rw hl.eq_node'
exact H1 _ _ _ (t_ih_l hl.2.1) (t_ih_r hl.2.2)
intros
refine or_iff_not_imp_left.2 (Œª h, _)
refine ‚ü®_, h‚ÇÇ.resolve_left h‚ü©
cases H
cases r‚ÇÇ
{ cases r‚ÇÇ, { cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H) }, { exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _) } }
{ cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H) }
cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H)
exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _)
{ exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _) }
{ exact le_trans H.1 (nat.mul_le_mul_left _ h‚ÇÅ) }
exact le_trans H.1 (nat.mul_le_mul_left _ h‚ÇÅ)
intros
linarith
intros
simp only [eq_none_iff_forall_not_mem, mem_trans, imp_iff_not_or.symm]
push_neg
tauto
intros
ext
ext; simp [mem_preimage, mem_dom]
simp [mem_preimage, mem_dom]
intros
split
rintros ‚ü®u, xeq, yeq‚ü©
{ rintros ‚ü®u, xeq, yeq‚ü©, cases h : u with a f, use [a, Œª i j, (f i j).val.fst, Œª i j, (f i j).val.snd], split, { rw [‚Üêxeq, h], refl }, split, { rw [‚Üêyeq, h], refl }, intros i j, exact (f i j).property }
cases h : u with a f
use [a, Œª i j, (f i j).val.fst, Œª i j, (f i j).val.snd]
split
rw [‚Üêxeq, h]
{ rw [‚Üêxeq, h], refl }
refl
split
rw [‚Üêyeq, h]
{ rw [‚Üêyeq, h], refl }
refl
intros i j
exact (f i j).property
rintros ‚ü®a, f‚ÇÄ, f‚ÇÅ, xeq, yeq, h‚ü©
use ‚ü®a, Œª i j, ‚ü®(f‚ÇÄ i j, f‚ÇÅ i j), h i j‚ü©‚ü©
dsimp
split
{ rw [xeq], refl }
rw [xeq]
refl
rw [yeq]
refl
intros
ext
ext; dsimp [v, vp, w, z, a, b, succ‚ÇÇ]; repeat { rw [nat.succ_eq_add_one] }; ring
ext; dsimp [v, vp, w, z, a, b, succ‚ÇÇ]; repeat { rw [nat.succ_eq_add_one] }
ext; dsimp [v, vp, w, z, a, b, succ‚ÇÇ]
{ ext; dsimp [v, vp, w, z, a, b, succ‚ÇÇ]; repeat { rw [nat.succ_eq_add_one] }; ring }
dsimp [v, vp, w, z, a, b, succ‚ÇÇ]
repeat { rw [nat.succ_eq_add_one] }
ring
dsimp [v, vp, w, z, a, b, succ‚ÇÇ]
rw [nat.succ_eq_add_one]
repeat { rw [nat.succ_eq_add_one] }
rw [nat.succ_eq_add_one]
rw [nat.succ_eq_add_one]
rw [nat.succ_eq_add_one]
rw [nat.succ_eq_add_one]
ring
intros
change (‚ü®1‚ü© : polynomial R) = monomial_fun 0 (1 : R)
rw [monomial_fun]
refl
intros
rw next_coeff
{ rw next_coeff, simp }
simp
intros
simp [nat_trailing_degree]
intros
rw [eval‚ÇÇ_mul_noncomm, eval‚ÇÇ_C]
intro k
by_cases hk : k = 0
{ simp only [hk, h, coeff_C_zero, coeff_C_ne_zero] }
simp only [hk, h, coeff_C_zero, coeff_C_ne_zero]
simp only [coeff_C_ne_zero hk, ring_hom.map_zero, commute.zero_left]
{ simp only [coeff_C_ne_zero hk, ring_hom.map_zero, commute.zero_left] }
intros
apply polynomial.induction_on œÜ; { intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ‚Üê mul_assoc, *] at * }
apply polynomial.induction_on œÜ
{ intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ‚Üê mul_assoc, *] at * }
{ intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ‚Üê mul_assoc, *] at * }
intros
{ intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ‚Üê mul_assoc, *] at * }
simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ‚Üê mul_assoc, *] at *
intros
rw [‚ÜêC_mul_X_pow_eq_monomial, root_set_C_mul_X_pow hn ha]
intros
obtain ‚ü®q, hq‚ü© := exists_eq_mul_right_of_dvd h
rw hq at hzero
simp only [hq, root_multiplicity_mul hzero, root_multiplicity_X_sub_C_pow, ge_iff_le, _root_.zero_le, le_add_iff_nonneg_right]
intros
conv in (0) { rw [‚Üê nat_degree_coe_units u] }
rw [‚Üê leading_coeff, ne.def, leading_coeff_eq_zero]
exact units.ne_zero _
intros
apply q.P.W_cases _ x; intros a f' f; exact Wequiv.abs a f' f a f' f rfl
apply q.P.W_cases _ x; intros a f' f
apply q.P.W_cases _ x
intros a f' f
exact Wequiv.abs a f' f a f' f rfl
intros
by_cases b0 : b = 0
subst b0
{ subst b0, simp }
simp
apply (mk_eq (mul_ne_zero b0 c0) b0).2
simp [mul_comm, mul_assoc]
intros
simp
intros
rw [div_eq_inv_mul, div_eq_mul_inv, of_real_mul (inv_nonneg.2 hy.le), of_real_inv_of_pos hy, mul_comm]
intros
simp [ennreal.to_real, to_nnreal_eq_zero_iff]
intros
simpa only [bit0_zero] using @bit0_inj a 0
intros
induction z using ereal.rec
{ simpa only using hz }
simpa only using hz
calc x + z < y + z : add_lt_add_right_coe h _ ... ‚â§ y + t : add_le_add (le_refl _) h'
{ calc x + z < y + z : add_lt_add_right_coe h _ ... ‚â§ y + t : add_le_add (le_refl _) h' }
{ exact (ht (top_le_iff.1 h')).elim }
exact (ht (top_le_iff.1 h')).elim
simpa using nat.prime_two.irrational_sqrt
pi_lower_bound [99/70, 874/473, 1940/989, 1447/727]
intros
rw [‚Üê abs_mul_abs_self x, sqrt_mul_self (abs_nonneg _)]
intros
{ rw [preimage, image_univ, codom_inv] }
rw [preimage, image_univ, codom_inv]
intros
{ casesI h, cases h with a' h, rw p h, exact h }
casesI h
cases h with a' h
rw p h
exact h
intros
have := h
revert this
generalize e : append s‚ÇÅ s‚ÇÇ = ss
intro h
revert s‚ÇÅ
apply mem_rec_on h _
intros b s' o s‚ÇÅ
apply s‚ÇÅ.cases_on _ (Œª c t‚ÇÅ, _); intros m e; have := congr_arg destruct e
apply s‚ÇÅ.cases_on _ (Œª c t‚ÇÅ, _); intros m e
apply s‚ÇÅ.cases_on _ (Œª c t‚ÇÅ, _)
intros m e
have := congr_arg destruct e
{ apply or.inr, simpa using m }
apply or.inr
simpa using m
intros m e
have := congr_arg destruct e
cases (show a = c ‚à® a ‚àà append t‚ÇÅ s‚ÇÇ, by simpa using m) with e' m
{ cases (show a = c ‚à® a ‚àà append t‚ÇÅ s‚ÇÇ, by simpa using m) with e' m, { rw e', exact or.inl (mem_cons _ _) }, { cases (show c = b ‚àß append t‚ÇÅ s‚ÇÇ = s', by simpa) with i1 i2, cases o with e' IH, { simp [i1, e'] }, { exact or.imp_left (mem_cons_of_mem _) (IH m i2) } } }
{ rw e', exact or.inl (mem_cons _ _) }
rw e'
exact or.inl (mem_cons _ _)
cases (show c = b ‚àß append t‚ÇÅ s‚ÇÇ = s', by simpa) with i1 i2
{ cases (show c = b ‚àß append t‚ÇÅ s‚ÇÇ = s', by simpa) with i1 i2, cases o with e' IH, { simp [i1, e'] }, { exact or.imp_left (mem_cons_of_mem _) (IH m i2) } }
cases o with e' IH
{ simp [i1, e'] }
simp [i1, e']
{ exact or.imp_left (mem_cons_of_mem _) (IH m i2) }
exact or.imp_left (mem_cons_of_mem _) (IH m i2)
intros
subst hT'
cases set.mem_Union.1 x.prop with i hi
cases set.mem_Union.1 y.prop with j hj
rcases dir i j with ‚ü®k, hik, hjk‚ü©
rw [Union_lift_of_mem x (hik hi), Union_lift_of_mem y (hjk hj), ‚Üê h k]
have hx : x = (set.inclusion (set.subset_Union S k) ‚ü®x, hik hi‚ü©)
cases x
{ cases x, refl }
refl
have hy : y = (set.inclusion (set.subset_Union S k) ‚ü®y, hjk hj‚ü©)
cases y
{ cases y, refl }
refl
have hxy : (set.inclusion (set.subset_Union S k) (opi k ‚ü®x, hik hi‚ü© ‚ü®y, hjk hj‚ü©) : Œ±) ‚àà S k
from (opi k ‚ü®x, hik hi‚ü© ‚ü®y, hjk hj‚ü©).prop
conv_lhs { rw [hx, hy, ‚Üê hopi, Union_lift_of_mem _ hxy] }
simp only [coe_inclusion, subtype.coe_eta]
intros
safe [ext_iff, iff_def]
intros
{ ext, simp }
ext
simp
intros
{ intro s, use f '' s, rw hf.preimage_image }
intro s
use f '' s
rw hf.preimage_image
intros
split_ifs; simp [h]
{ split_ifs; simp [h] }
split_ifs
simp [h]
simp [h]
intros
ext x
{ ext x, simp [@forall_update_iff _ (Œª i, set (Œ± i)) _ _ _ _ (Œª i' y, x i' ‚àà y)] }
simp [@forall_update_iff _ (Œª i, set (Œ± i)) _ _ _ _ (Œª i' y, x i' ‚àà y)]
intros
simp only [set.nonempty, eq_empty_iff_forall_not_mem, not_exists]
intros
letI : fintype s := hs.fintype
convert finite_range (Œª x : s, F x x.2)
simp only [set_coe.exists, subtype.coe_mk, eq_comm]
intros
intros x hx y hy H
have := congr_arg f H
rw [h.eq, h.eq] at this
exact hf hx hy (hb hx hy this)
intros
simp [‚Üê Ici_inter_Iic]
intros
rw [mem_Icc, le_iff_lt_or_eq, le_iff_lt_or_eq] at hmem
rcases hmem with ‚ü®hxa | hxa, hxb | hxb‚ü©
{ exact or.inr (or.inr ‚ü®hxa, hxb‚ü©) }
exact or.inr (or.inr ‚ü®hxa, hxb‚ü©)
{ exact or.inr (or.inl hxb) }
exact or.inr (or.inl hxb)
exact or.inl hxa.symm
all_goals { exact or.inl hxa.symm }
exact or.inl hxa.symm
intros
ext x
cases lt_or_le x b with hba hba
{ simp [hba, h‚ÇÅ] }
simp [hba, h‚ÇÅ]
simp only [mem_Iio, mem_union_eq, mem_Ioo, lt_max_iff]
{ simp only [mem_Iio, mem_union_eq, mem_Ioo, lt_max_iff], refine or_congr iff.rfl ‚ü®and.right, _‚ü©, exact Œª h‚ÇÇ, ‚ü®h‚ÇÅ.trans_le hba, h‚ÇÇ‚ü© }
refine or_congr iff.rfl ‚ü®and.right, _‚ü©
exact Œª h‚ÇÇ, ‚ü®h‚ÇÅ.trans_le hba, h‚ÇÇ‚ü©
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
refine ‚ü®Œª _ h, ‚ü®add_lt_add_right h.1 _, add_lt_add_right h.2 _‚ü©, Œª _ _ _ _ h, add_right_cancel h, Œª _ h, _‚ü©
obtain ‚ü®c, rfl‚ü© := exists_add_of_le h.1.le
rw [mem_Ioo, add_right_comm, add_lt_add_iff_right, add_lt_add_iff_right] at h
exact ‚ü®a + c, h, by rw add_right_comm‚ü©
intros
{ cases x, apply proj_Icc_of_mem }
cases x
apply proj_Icc_of_mem
intros
{ rw [interval, min_eq_right h, max_eq_left h] }
rw [interval, min_eq_right h, max_eq_left h]
intros
ext ‚ü®z, w‚ü©
simp only [mem_prod, mem_Union, exists_imp_distrib, and_imp, iff_def]
split
{ intros x hz hw, exact ‚ü®‚ü®x, hz‚ü©, x, hw‚ü© }
intros x hz hw
exact ‚ü®‚ü®x, hz‚ü©, x, hw‚ü©
intros x hz x' hw
{ intros x hz x' hw, exact ‚ü®x ‚äî x', hs le_sup_left hz, ht le_sup_right hw‚ü© }
exact ‚ü®x ‚äî x', hs le_sup_left hz, ht le_sup_right hw‚ü©
intros
simp [‚Üê ne_empty_iff_nonempty, sInter_eq_empty_iff]
intros
rw [nat.choose_two_right, nat.mul_sub_left_distrib, mul_one, ‚Üêoff_diag_card, nat.div_eq_of_eq_mul_right zero_lt_two (two_mul_card_image_off_diag s).symm]
intros
split; intro h
{ split; intro h, { rw quotient.eq at h, cases h; refl }, rw h }
split
intro h
rw quotient.eq at h
{ rw quotient.eq at h, cases h; refl }
cases h
cases h; refl
refl
refl
intro h
rw h
intros
induction i; [refl, erw [repeat_eq,@i_ih (drop Œ±) x y]]
induction i
refl
erw [repeat_eq,@i_ih (drop Œ±) x y]
intros
have : 0 = v.to_list.length - 1 - n
simp only [nat.add_succ_sub_one, add_zero, to_list_length, nat.sub_self, list.length_reverse]
{ simp only [nat.add_succ_sub_one, add_zero, to_list_length, nat.sub_self, list.length_reverse] }
rw [‚Üênth_zero, last_def, nth_eq_nth_le, nth_eq_nth_le]
simp_rw [to_list_reverse, fin.val_eq_coe, fin.coe_last, fin.coe_zero, this]
rw list.nth_le_reverse
intros
rcases x with ‚ü®_|_, h‚ü©; refl
{ rcases x with ‚ü®_|_, h‚ü©; refl, }
rcases x with ‚ü®_|_, h‚ü©
refl
refl
intros
haveI : fact (0 < n) := ‚ü®begin rw [pos_iff_ne_zero], intro hn, rw hn at h, exact (fintype.card_eq_zero_iff.mp h).elim' 0 end‚ü©
rw [fintype.bijective_iff_injective_and_card, zmod.card, h, eq_self_iff_true, and_true]
apply zmod.cast_hom_injective
intros
cases a
simp only [int.nat_abs_of_nat, int.cast_coe_nat, int.of_nat_eq_coe]
{ simp only [int.nat_abs_of_nat, int.cast_coe_nat, int.of_nat_eq_coe] }
simp only [neg_eq_self_mod_two, nat.cast_succ, int.nat_abs, int.cast_neg_succ_of_nat]
{ simp only [neg_eq_self_mod_two, nat.cast_succ, int.nat_abs, int.cast_neg_succ_of_nat] }
intros
rw [‚Üê is_periodic_pt_iff_minimal_period_dvd, is_periodic_pt, h.comp_iterate]
refine is_fixed_pt.comp _ _; rw [‚Üê is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]; exact nat.dvd_lcm_left _ _ <|> exact dvd_lcm_right _ _
refine is_fixed_pt.comp _ _; rw [‚Üê is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]
refine is_fixed_pt.comp _ _
rw [‚Üê is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]
exact nat.dvd_lcm_left _ _
rw [‚Üê is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]
exact dvd_lcm_right _ _
exact nat.dvd_lcm_left _ _
intros
apply to_subalgebra_injective
rw h
refine (adjoin_eq_algebra_adjoin _ _ _).symm
intros x
convert K.inv_mem
rw ‚Üê h
refl
intros
cases alg_hom_mk_adjoin_splits hK with œï
rw hS at œï
exact ‚ü®œï.comp top_equiv.symm.to_alg_hom‚ü©
intros
simpa only [add_zero, C_0, sub_eq_add_neg, neg_zero, ring_hom.map_zero] using eq_X_sub_C B (0:A)
intros
induction n with n ih
induction x with x ih
{ induction x with x ih, {refl}, rw [nat.cast_succ, nat.cast_succ, ih], refl }
refl
{refl}
rw [nat.cast_succ, nat.cast_succ, ih]
refl
rw ih
apply quot.sound
conv {congr, skip, skip, rw ‚Üê frobenius_nat_cast K p x}
apply r.intro
intros
rcases is_empty_or_nonempty (fintype F) with F_inf|‚ü®‚ü®F_finite‚ü©‚ü©
let P : intermediate_field F E ‚Üí Prop := Œª K, ‚àÉ Œ± : E, F‚üÆŒ±‚üØ = K
{ let P : intermediate_field F E ‚Üí Prop := Œª K, ‚àÉ Œ± : E, F‚üÆŒ±‚üØ = K, have base : P ‚ä• := ‚ü®0, adjoin_zero‚ü©, have ih : ‚àÄ (K : intermediate_field F E) (x : E), P K ‚Üí P ‚ÜëK‚üÆx‚üØ, { intros K Œ≤ hK, cases hK with Œ± hK, rw [‚ÜêhK, adjoin_simple_adjoin_simple], haveI : infinite F := is_empty_fintype.mp F_inf, cases primitive_element_inf_aux F Œ± Œ≤ with Œ≥ hŒ≥, exact ‚ü®Œ≥, hŒ≥.symm‚ü© }, exact induction_on_adjoin P base ih ‚ä§ }
have base : P ‚ä• := ‚ü®0, adjoin_zero‚ü©
have ih : ‚àÄ (K : intermediate_field F E) (x : E), P K ‚Üí P ‚ÜëK‚üÆx‚üØ
intros K Œ≤ hK
{ intros K Œ≤ hK, cases hK with Œ± hK, rw [‚ÜêhK, adjoin_simple_adjoin_simple], haveI : infinite F := is_empty_fintype.mp F_inf, cases primitive_element_inf_aux F Œ± Œ≤ with Œ≥ hŒ≥, exact ‚ü®Œ≥, hŒ≥.symm‚ü© }
cases hK with Œ± hK
rw [‚ÜêhK, adjoin_simple_adjoin_simple]
haveI : infinite F := is_empty_fintype.mp F_inf
cases primitive_element_inf_aux F Œ± Œ≤ with Œ≥ hŒ≥
exact ‚ü®Œ≥, hŒ≥.symm‚ü©
exact induction_on_adjoin P base ih ‚ä§
{ exactI exists_primitive_element_of_fintype_bot F E }
exactI exists_primitive_element_of_fintype_bot F E
intros
rw [splits_map_iff, ring_hom.id_comp]
intros
{ ext, rw ‚Üê (reflection s).injective.eq_iff, simp }
ext
rw ‚Üê (reflection s).injective.eq_iff
simp
intros
refine ‚ü®Œª h, _, inner_eq_mul_norm_of_angle_eq_zero‚ü©
have h‚ÇÅ : (‚à•x‚à• * ‚à•y‚à•) ‚â† 0 := (mul_pos (norm_pos_iff.mpr hx) (norm_pos_iff.mpr hy)).ne'
rw [angle, h, div_self h‚ÇÅ, real.arccos_one]
intros
rcases exists_circumradius_eq_of_cospherical hd hc with ‚ü®r, hr‚ü©
rw [hr sx‚ÇÅ hsx‚ÇÅ, hr sx‚ÇÇ hsx‚ÇÇ]
intros
have ha := ho.affine_independent hps hpi
rcases ho with ‚ü®t, hto, hts‚ü©
have hs : affine_span ‚Ñù s = affine_span ‚Ñù (set.range t.points)
rw [hts, affine_span_insert_eq_affine_span ‚Ñù t.orthocenter_mem_affine_span]
{ rw [hts, affine_span_insert_eq_affine_span ‚Ñù t.orthocenter_mem_affine_span] }
refine ext_of_direction_eq _ ‚ü®p 0, mem_affine_span ‚Ñù (set.mem_range_self _), mem_affine_span ‚Ñù (hps (set.mem_range_self _))‚ü©
have hfd : finite_dimensional ‚Ñù (affine_span ‚Ñù s).direction
rw hs
{ rw hs, apply_instance }
apply_instance
haveI := hfd
refine eq_of_le_of_finrank_eq (direction_le (affine_span_mono ‚Ñù hps)) _
rw [hs, direction_affine_span, direction_affine_span, ha.finrank_vector_span (fintype.card_fin _), t.independent.finrank_vector_span (fintype.card_fin _)]
intros
apply unique_diff_within_at_congr
rw [nhds_within_inter, nhds_within_inter, nhds_within_ext_chart_target_eq]
intros
{ refine I.left_inv' _, simp }
refine I.left_inv' _
simp
intros
simp only with mfld_simps
intros
classical; calc card Œ± = card (f.range : subgroup H) : card_congr (equiv.of_injective f hf) ...‚à£ card H : card_subgroup_dvd_card _
classical
calc card Œ± = card (f.range : subgroup H) : card_congr (equiv.of_injective f hf) ...‚à£ card H : card_subgroup_dvd_card _
intros
{ symmetry, rw [‚Üê mk_one, mk_eq_mk_iff], exact one_rel a }
symmetry
rw [‚Üê mk_one, mk_eq_mk_iff]
exact one_rel a
intros
ext
ext; exact f.lift_eq hg _
exact f.lift_eq hg _
intros
induction n with d hd
{ simp }
simp
rw [lower_central_series_succ, lower_central_series_succ, monoid_hom.map_closure]
{ rw [lower_central_series_succ, lower_central_series_succ, monoid_hom.map_closure], apply subgroup.closure_mono, rintros x1 ‚ü®x2, ‚ü®x3, hx3, x4, hx4, rfl‚ü©, rfl‚ü©, exact ‚ü®x3, (hd (mem_map.mpr ‚ü®x3, hx3, rfl‚ü©)), x4, by simp‚ü© }
apply subgroup.closure_mono
rintros x1 ‚ü®x2, ‚ü®x3, hx3, x4, hx4, rfl‚ü©, rfl‚ü©
exact ‚ü®x3, (hd (mem_map.mpr ‚ü®x3, hx3, rfl‚ü©)), x4, by simp‚ü©
intros
rw [‚Üêmul_assoc, swap_mul_self, one_mul]
intros
simp only [cycle_type_def, ‚Üêfinset.mem_def, function.comp_app, multiset.mem_map, mem_cycle_factors_finset_iff] at h
obtain ‚ü®_, ‚ü®hc, -‚ü©, rfl‚ü© := h
exact hc.two_le_card_support
intros
simp
intros
cases n with n
{ cases h }
cases h
exact cycle_range_zero n
intros
rw [ne.def, form_perm_apply_mem_eq_self_iff _ hl x hx, not_le]
exact ‚ü®nat.succ_le_of_lt, nat.lt_of_succ_le‚ü©
intros
rw ‚Üê sign_aux_inv g
unfold sign_aux
rw ‚Üê prod_mul_distrib
refine prod_bij (Œª a ha, sign_bij_aux g a) sign_bij_aux_mem _ sign_bij_aux_inj sign_bij_aux_surj
rintros ‚ü®a, b‚ü© hab
rw [sign_bij_aux, mul_apply, mul_apply]
rw mem_fin_pairs_lt at hab
by_cases h : g b < g a
rw dif_pos h
{ rw dif_pos h, simp only [not_le_of_gt hab, mul_one, perm.inv_apply_self, if_false] }
simp only [not_le_of_gt hab, mul_one, perm.inv_apply_self, if_false]
rw [dif_neg h, inv_apply_self, inv_apply_self, if_pos hab.le]
{ rw [dif_neg h, inv_apply_self, inv_apply_self, if_pos hab.le], by_cases h‚ÇÅ : f (g b) ‚â§ f (g a), { have : f (g b) ‚â† f (g a), { rw [ne.def, f.injective.eq_iff, g.injective.eq_iff], exact ne_of_lt hab }, rw [if_pos h‚ÇÅ, if_neg (h‚ÇÅ.lt_of_ne this).not_le], refl }, { rw [if_neg h‚ÇÅ, if_pos (lt_of_not_ge h‚ÇÅ).le], refl } }
by_cases h‚ÇÅ : f (g b) ‚â§ f (g a)
have : f (g b) ‚â† f (g a)
{ have : f (g b) ‚â† f (g a), { rw [ne.def, f.injective.eq_iff, g.injective.eq_iff], exact ne_of_lt hab }, rw [if_pos h‚ÇÅ, if_neg (h‚ÇÅ.lt_of_ne this).not_le], refl }
rw [ne.def, f.injective.eq_iff, g.injective.eq_iff]
{ rw [ne.def, f.injective.eq_iff, g.injective.eq_iff], exact ne_of_lt hab }
exact ne_of_lt hab
rw [if_pos h‚ÇÅ, if_neg (h‚ÇÅ.lt_of_ne this).not_le]
refl
rw [if_neg h‚ÇÅ, if_pos (lt_of_not_ge h‚ÇÅ).le]
{ rw [if_neg h‚ÇÅ, if_pos (lt_of_not_ge h‚ÇÅ).le], refl }
refl
intros
rw [finset.card_eq_zero, support_eq_empty_iff]
intros
ext
ext; simp
simp
simp
intros
introI h
have key : nonempty (fin 5 ‚Ü™ X)
rwa [‚Üêcardinal.lift_mk_le, cardinal.mk_fin, cardinal.lift_nat_cast, nat.cast_bit1, nat.cast_bit0, nat.cast_one, cardinal.lift_id]
{ rwa [‚Üêcardinal.lift_mk_le, cardinal.mk_fin, cardinal.lift_nat_cast, nat.cast_bit1, nat.cast_bit0, nat.cast_one, cardinal.lift_id] }
exact equiv.perm.fin_5_not_solvable (solvable_of_solvable_injective (equiv.perm.via_embedding_hom_injective (nonempty.some key)))
intros
{ ext, simp [mem_ker] }
ext
simp [mem_ker]
intros
simp [mem_center_iff]
intros
simp [line_map_apply]
intros
rw mem_direction_iff_eq_vsub_right hp
simp
intros
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
apply sum_insert_zero
rw [vsub_self, smul_zero]
intros
simp [weighted_vsub_of_point, linear_map.sum_apply]
intros
rcases s.eq_empty_or_nonempty with rfl | ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
have p‚ÇÅ : P := add_torsor.nonempty.some
{ have p‚ÇÅ : P := add_torsor.nonempty.some, let hsv := basis.of_vector_space k V, have hsvi := hsv.linear_independent, have hsvt := hsv.span_eq, rw basis.coe_of_vector_space at hsvi hsvt, have h0 : ‚àÄ v : V, v ‚àà (basis.of_vector_space_index _ _) ‚Üí v ‚â† 0, { intros v hv, simpa using hsv.ne_zero ‚ü®v, hv‚ü© }, rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p‚ÇÅ at hsvi, exact ‚ü®{p‚ÇÅ} ‚à™ (Œª v, v +·µ• p‚ÇÅ) '' _, set.empty_subset _, hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p‚ÇÅ hsvt‚ü© }
let hsv := basis.of_vector_space k V
have hsvi := hsv.linear_independent
have hsvt := hsv.span_eq
rw basis.coe_of_vector_space at hsvi hsvt
have h0 : ‚àÄ v : V, v ‚àà (basis.of_vector_space_index _ _) ‚Üí v ‚â† 0
{ intros v hv, simpa using hsv.ne_zero ‚ü®v, hv‚ü© }
intros v hv
simpa using hsv.ne_zero ‚ü®v, hv‚ü©
rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p‚ÇÅ at hsvi
exact ‚ü®{p‚ÇÅ} ‚à™ (Œª v, v +·µ• p‚ÇÅ) '' _, set.empty_subset _, hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p‚ÇÅ hsvt‚ü©
rw affine_independent_set_iff_linear_independent_vsub k hp‚ÇÅ at h
{ rw affine_independent_set_iff_linear_independent_vsub k hp‚ÇÅ at h, let bsv := basis.extend h, have hsvi := bsv.linear_independent, have hsvt := bsv.span_eq, rw basis.coe_extend at hsvi hsvt, have hsv := h.subset_extend (set.subset_univ _), have h0 : ‚àÄ v : V, v ‚àà (h.extend _) ‚Üí v ‚â† 0, { intros v hv, simpa using bsv.ne_zero ‚ü®v, hv‚ü© }, rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p‚ÇÅ at hsvi, refine ‚ü®{p‚ÇÅ} ‚à™ (Œª v, v +·µ• p‚ÇÅ) '' h.extend (set.subset_univ _), _, _‚ü©, { refine set.subset.trans _ (set.union_subset_union_right _ (set.image_subset _ hsv)), simp [set.image_image] }, { use [hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p‚ÇÅ hsvt] } }
let bsv := basis.extend h
have hsvi := bsv.linear_independent
have hsvt := bsv.span_eq
rw basis.coe_extend at hsvi hsvt
have hsv := h.subset_extend (set.subset_univ _)
have h0 : ‚àÄ v : V, v ‚àà (h.extend _) ‚Üí v ‚â† 0
{ intros v hv, simpa using bsv.ne_zero ‚ü®v, hv‚ü© }
intros v hv
simpa using bsv.ne_zero ‚ü®v, hv‚ü©
rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p‚ÇÅ at hsvi
refine ‚ü®{p‚ÇÅ} ‚à™ (Œª v, v +·µ• p‚ÇÅ) '' h.extend (set.subset_univ _), _, _‚ü©
refine set.subset.trans _ (set.union_subset_union_right _ (set.image_subset _ hsv))
{ refine set.subset.trans _ (set.union_subset_union_right _ (set.image_subset _ hsv)), simp [set.image_image] }
simp [set.image_image]
use [hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p‚ÇÅ hsvt]
{ use [hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p‚ÇÅ hsvt] }
intros
rw [multilinear_map.dom_coprod_alternization, coe_alternatization, coe_alternatization, mul_smul, ‚Üêdom_coprod'_apply, ‚Üêdom_coprod'_apply, ‚Üêtensor_product.smul_tmul', tensor_product.tmul_smul, linear_map.map_smul_of_tower dom_coprod', linear_map.map_smul_of_tower dom_coprod']
apply_instance
apply_instance
apply_instance
apply_instance
intros
simp [f.range_cod_restrict _]
intros
rw [range_comp, equiv.range_eq_univ, set.image_univ]
intros
{ ext, refl }
ext
refl
intros
simp only [B.to_matrix_comp b c, to_matrix_to_lin, transpose_transpose]
intros
ext m
simp only [linear_map.id_apply, linear_map.comp_apply]
induction m using clifford_algebra.induction
rw [reverse.commutes, reverse.commutes]
case h_grade0 : { rw [reverse.commutes, reverse.commutes] }
rw [reverse_Œπ, reverse_Œπ]
case h_grade1 : { rw [reverse_Œπ, reverse_Œπ] }
case h_mul : a b ha hb { rw [reverse.map_mul, reverse.map_mul, ha, hb], }
case h_add : a b ha hb { rw [reverse.map_add, reverse.map_add, ha, hb], }
intros
rw dim_submodule_le_one_iff
split
rintros ‚ü®v‚ÇÄ, hv‚ÇÄ, h‚ü©
{ rintros ‚ü®v‚ÇÄ, hv‚ÇÄ, h‚ü©, exact ‚ü®v‚ÇÄ, h‚ü© }
exact ‚ü®v‚ÇÄ, h‚ü©
rintros ‚ü®v‚ÇÄ, h‚ü©
{ rintros ‚ü®v‚ÇÄ, h‚ü©, by_cases hw : ‚àÉ w : V, w ‚àà s ‚àß w ‚â† 0, { rcases hw with ‚ü®w, hw, hw0‚ü©, use [w, hw], rcases mem_span_singleton.1 (h hw) with ‚ü®r', rfl‚ü©, have h0 : r' ‚â† 0, { rintro rfl, simpa using hw0 }, rwa span_singleton_smul_eq _ h0 }, { push_neg at hw, rw ‚Üêsubmodule.eq_bot_iff at hw, simp [hw] } }
by_cases hw : ‚àÉ w : V, w ‚àà s ‚àß w ‚â† 0
rcases hw with ‚ü®w, hw, hw0‚ü©
{ rcases hw with ‚ü®w, hw, hw0‚ü©, use [w, hw], rcases mem_span_singleton.1 (h hw) with ‚ü®r', rfl‚ü©, have h0 : r' ‚â† 0, { rintro rfl, simpa using hw0 }, rwa span_singleton_smul_eq _ h0 }
use [w, hw]
rcases mem_span_singleton.1 (h hw) with ‚ü®r', rfl‚ü©
have h0 : r' ‚â† 0
rintro rfl
{ rintro rfl, simpa using hw0 }
simpa using hw0
rwa span_singleton_smul_eq _ h0
push_neg at hw
{ push_neg at hw, rw ‚Üêsubmodule.eq_bot_iff at hw, simp [hw] }
rw ‚Üêsubmodule.eq_bot_iff at hw
simp [hw]
intros
rw [‚Üê @set_of_mem_eq _ s, ‚Üê subtype.range_coe_subtype]
{ rw [‚Üê @set_of_mem_eq _ s, ‚Üê subtype.range_coe_subtype], exact dim_span hs }
exact dim_span hs
intros
rw [finsupp.total_apply, finsupp.sum_fintype, linear_map.sum_apply]
simp_rw [linear_map.smul_apply, smul_eq_mul, dual_basis_apply_self, mul_boole, finset.sum_ite_eq, if_pos (finset.mem_univ i)]
{ simp_rw [linear_map.smul_apply, smul_eq_mul, dual_basis_apply_self, mul_boole, finset.sum_ite_eq, if_pos (finset.mem_univ i)] }
{ intro, rw zero_smul }
intro
rw zero_smul
intros
simp [to_exterior]
intros
rw [‚Üê dim_top, ‚Üê subalgebra_top_dim_eq_submodule_top_dim] at h
exact eq.symm (subalgebra.eq_bot_of_dim_one h)
intros
obtain ‚ü®f, sum, total, nonzero‚ü© := exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card h
exact ‚ü®f, sum, total, exists_pos_of_sum_zero_of_exists_nonzero f total nonzero‚ü©
intros
have := finrank_range_add_finrank_ker f
rw [‚Üê ker_eq_bot, ‚Üê range_eq_top]
refine ‚ü®Œª h, _, Œª h, _‚ü©
rw [h, finrank_bot, add_zero, H] at this
{ rw [h, finrank_bot, add_zero, H] at this, exact eq_top_of_finrank_eq this }
exact eq_top_of_finrank_eq this
rw [h, finrank_top, H] at this
{ rw [h, finrank_top, H] at this, exact finrank_eq_zero.1 (add_right_injective _ this) }
exact finrank_eq_zero.1 (add_right_injective _ this)
intros
{ rw span_image_eq_map_total, simp, }
rw span_image_eq_map_total
simp
intros
refine submodule.mem_map.trans ‚ü®_, _‚ü©
refine submodule.mem_map.trans ‚ü®_, _‚ü©; simp_rw submodule.mem_comap
simp_rw submodule.mem_comap
rintro ‚ü®‚ü®y, yO‚ü©, (yN : y ‚àà N), h‚ü©
{ rintro ‚ü®‚ü®y, yO‚ü©, (yN : y ‚àà N), h‚ü©, exact ‚ü®y, yO, yN, h‚ü© }
exact ‚ü®y, yO, yN, h‚ü©
simp_rw submodule.mem_comap
rintro ‚ü®y, yO, yN, h‚ü©
{ rintro ‚ü®y, yO, yN, h‚ü©, exact ‚ü®‚ü®y, yO‚ü©, yN, h‚ü© }
exact ‚ü®‚ü®y, yO‚ü©, yN, h‚ü©
intros
rw [linear_independent_iff, finsupp.total_comp]
intros l hl
have h_map_domain : ‚àÄ x, (finsupp.map_domain f l) (f x) = 0
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl; simp
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl; simp
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl
simp
simp
ext x
convert h_map_domain x
rw [finsupp.map_domain_apply hf]
intros
rw [det_mul_right_comm, ‚Üêmul_eq_mul, ‚Üêmul_eq_mul, units.mul_inv, one_mul]
intros
simp [det_apply]
intros
rcases t
{ rcases t, simp [to_matrix, transvection_mul_transvection_same, t_hij] }
simp [to_matrix, transvection_mul_transvection_same, t_hij]
intros
rw [‚Üê@neg_one_smul R _ _ _ _ x, map_smul, neg_one_mul, neg_neg, one_mul]
intros
intros x hx
refine hB _ _
rw ‚Üê hx x
exact (associated_eq_self_apply _ _ x).symm
intros
ext x
ext x; refl
refl
intros
rw [smodeq.def, submodule.quotient.eq, sub_zero]
intros
simp
intros
dunfold update
congr
funext
rw eq_rec_constant
intros
induction n with n ihn generalizing k
{ rw [nat.zero_add], exact id_left }
rw [nat.zero_add]
exact id_left
rw [nat.succ_eq_add_one, nat.add_right_comm, nat.add_assoc]
{ rw [nat.succ_eq_add_one, nat.add_right_comm, nat.add_assoc], exact (H k).comp_left (ihn (k + 1)) }
exact (H k).comp_left (ihn (k + 1))
intros
induction h' with b c hab hbc ih
{ exact hr _ }
exact hr _
{ exact ht ih (h _ _ hbc) }
exact ht ih (h _ _ hbc)
intros
{ rw ‚Üê pi_univ_Icc, exact pi_Ioc_ae_eq_pi_Icc }
rw ‚Üê pi_univ_Icc
exact pi_Ioc_ae_eq_pi_Icc
intros
simp_rw [‚Üê integral_prod_swap f hf.ae_measurable]
{ simp_rw [‚Üê integral_prod_swap f hf.ae_measurable], exact integral_prod _ hf.swap }
exact integral_prod _ hf.swap
intros
have hf_Lp : mem_‚Ñíp f 1 Œº
from mem_‚Ñíp_one_iff_integrable.mpr hf
let f_Lp := hf_Lp.to_Lp f
have hf_f_Lp : f =·µê[Œº] f_Lp
from (mem_‚Ñíp.coe_fn_to_Lp hf_Lp).symm
refine hf_f_Lp.trans _
refine Lp.ae_eq_zero_of_forall_set_integral_eq_zero f_Lp one_ne_zero ennreal.coe_ne_top _ _
exact Œª s hs hŒºs, integrable.integrable_on (L1.integrable_coe_fn _)
{ exact Œª s hs hŒºs, integrable.integrable_on (L1.integrable_coe_fn _), }
intros s hs hŒºs
{ intros s hs hŒºs, rw integral_congr_ae (ae_restrict_of_ae hf_f_Lp.symm), exact hf_zero s hs hŒºs, }
rw integral_congr_ae (ae_restrict_of_ae hf_f_Lp.symm)
exact hf_zero s hs hŒºs
intros
have hf : ae_measurable' m f Œº
from (mem_Lp_meas_subgroup_iff_ae_measurable'.mp hf_meas)
let g := hf.some
obtain ‚ü®hg, hfg‚ü© := hf.some_spec
change mem_‚Ñíp g p (Œº.trim hm)
refine ‚ü®hg.ae_measurable, _‚ü©
have h_snorm_fg : snorm g p (Œº.trim hm) = snorm f p Œº
rw snorm_trim hm hg
rw snorm_trim hm hg
{ rw snorm_trim hm hg, exact snorm_congr_ae hfg.symm, }
{ rw snorm_trim hm hg, exact snorm_congr_ae hfg.symm, }
exact snorm_congr_ae hfg.symm
exact snorm_congr_ae hfg.symm
rw h_snorm_fg
exact Lp.snorm_lt_top f
intros
refine lintegral_le_of_forall_fin_meas_le' hm (Œº s * ‚à•x‚à•‚Çä) _ (Œª t ht hŒºt, _)
rw Lp_meas_coe
{ rw Lp_meas_coe, exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal, }
exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal
refine (set_lintegral_nnnorm_condexp_L2_indicator_le hm hs hŒºs x ht hŒºt).trans _
refine ennreal.mul_le_mul _ le_rfl
exact measure_mono (set.inter_subset_left _ _)
intros
simp_rw [mul_comm, h.const_mul _]
intros
simp
intros
cases le_or_lt 0 c with hc hc
{ exact snorm_le_mul_snorm_aux_of_nonneg h hc p }
exact snorm_le_mul_snorm_aux_of_nonneg h hc p
{ simp [snorm_le_mul_snorm_aux_of_neg h hc p] }
simp [snorm_le_mul_snorm_aux_of_neg h hc p]
intros
ext1
refine indicator_const_Lp_coe_fn.trans _
have h_comp_Lp := (continuous_linear_map.to_span_singleton ‚Ñù x).coe_fn_comp_Lp (indicator_const_Lp 2 hs hŒºs (1 : ‚Ñù))
rw ‚Üê eventually_eq at h_comp_Lp
refine eventually_eq.trans _ h_comp_Lp.symm
refine (@indicator_const_Lp_coe_fn _ _ _ 2 Œº _ _ s hs hŒºs (1 : ‚Ñù) _ _).mono (Œª y hy, _)
dsimp only
rw hy
simp_rw [continuous_linear_map.to_span_singleton_apply]
by_cases hy_mem : y ‚àà s; simp [hy_mem, continuous_linear_map.lsmul_apply]
by_cases hy_mem : y ‚àà s
simp [hy_mem, continuous_linear_map.lsmul_apply]
simp [hy_mem, continuous_linear_map.lsmul_apply]
intros
induction N with N ihN
simp
{ simp }
simp only [nearest_pt_ind_succ]
split_ifs
exacts [le_rfl, ihN.trans N.le_succ]
intros
split
introI h
{ introI h, rw ‚ÜêŒº.inv_inv, exact measure.regular.inv }
rw ‚ÜêŒº.inv_inv
exact measure.regular.inv
introI h
{ introI h, exact measure.regular.inv }
exact measure.regular.inv
intros
simp_rw [integral_eq_lintegral_of_nonneg_ae (eventually_of_forall (Œª x, (f x).coe_nonneg)) hfi.ae_measurable, ‚Üê ennreal.coe_nnreal_eq]
rw [ennreal.of_real_to_real]
rw [‚Üê lt_top_iff_ne_top]
convert hfi.has_finite_integral
ext1 x
rw [nnreal.nnnorm_eq]
intros
simp [weighted_smul]
intros
have := integral_sub_integral_sub_linear_is_o_of_tendsto_ae hf hmeas_a hmeas_b ha hb ((continuous_fst.comp continuous_snd).tendsto ((a, b), (a, b))) ((continuous_fst.comp continuous_fst).tendsto ((a, b), (a, b))) ((continuous_snd.comp continuous_snd).tendsto ((a, b), (a, b))) ((continuous_snd.comp continuous_fst).tendsto ((a, b), (a, b)))
refine (this.congr_left _).trans_is_O _
{ intro x, simp [sub_smul] }
intro x
simp [sub_smul]
exact is_O_fst_prod.norm_left.add is_O_snd_prod.norm_left
{ exact is_O_fst_prod.norm_left.add is_O_snd_prod.norm_left }
intros
cases le_total a b with hab hab; simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]; refine integral_undef (not_imp_not.mpr integrable.integrable_on' _); simpa [hab] using not_and_distrib.mp h
cases le_total a b with hab hab; simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]; refine integral_undef (not_imp_not.mpr integrable.integrable_on' _)
cases le_total a b with hab hab; simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]
cases le_total a b with hab hab
simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]
refine integral_undef (not_imp_not.mpr integrable.integrable_on' _)
simpa [hab] using not_and_distrib.mp h
simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]
refine integral_undef (not_imp_not.mpr integrable.integrable_on' _)
simpa [hab] using not_and_distrib.mp h
intros
simp [lintegral_congr_ae (ae_eq_dirac f)]
intros
convert Œº.inner_content_comap (homeomorph.mul_left g) (Œª K, h g) U
intros
simp_rw [‚Üê ennreal.coe_one, haar_content_apply, ennreal.coe_eq_coe, chaar_self]
{ simp_rw [‚Üê ennreal.coe_one, haar_content_apply, ennreal.coe_eq_coe, chaar_self], refl }
refl
intros
simp only [hausdorff_measure, ‚Üê outer_measure.coe_mk_metric, ‚Üê outer_measure.comap_apply]
rw [outer_measure.isometry_comap_mk_metric _ hf (hd.imp_left _)]
exact Œª hd x y hxy, ennreal.rpow_le_rpow hxy hd
intros
rcases h.exists_Ioo_subset with ‚ü®l, u, hx, hs‚ü©
refine lt_of_lt_of_le _ (measure_mono hs)
simpa [-mem_Ioo] using hx.1.trans hx.2
intros
ext1 s hs
simp only [add_apply, sum_apply _ hs, pi.add_apply, coe_add, tsum_add ennreal.summable ennreal.summable]
intros
simp [ae_iff, hc]
intros
rw [restrict_apply ht]
intros
simp_rw [infi_subtype, infi_and, subtype.coe_mk, ‚Üê measure_eq_infi]
intros
simp only [infi_comm] {single_pass := tt}
{ simp only [infi_comm] {single_pass := tt}, exact induced_outer_measure_eq_infi measurable_set.Union (Œª f _, m.Union_nat f) (Œª _ _ _ _ h, m.mono h) s }
exact induced_outer_measure_eq_infi measurable_set.Union (Œª f _, m.Union_nat f) (Œª _ _ _ _ h, m.mono h) s
intros
rcases outer_regular.outer_regular (measurable_set_to_measurable Œº A) r (by rwa measure_to_measurable) with ‚ü®U, hAU, hUo, hU‚ü©
exact ‚ü®U, (subset_to_measurable _ _).trans hAU, hUo, hU‚ü©
intros
rw [squarefree_iff_nodup_factors h0, card_distinct_factors_apply]
split
split; intro h
intro h
rw ‚Üê list.eq_of_sublist_of_length_eq n.factors.erase_dup_sublist h
{ rw ‚Üê list.eq_of_sublist_of_length_eq n.factors.erase_dup_sublist h, apply list.nodup_erase_dup }
apply list.nodup_erase_dup
intro h
rw list.erase_dup_eq_self.2 h
{ rw list.erase_dup_eq_self.2 h, refl }
refl
intros
rw mem_divisors_antidiagonal at h
simp [dvd.intro_left _ h.1, h.2]
intros
apply ne_zero_pow (dec_trivial : 2 ‚â† 0)
apply ne_of_gt
rw [‚Üê h.2.2, (by ring : a ^ 4 + b ^ 4 = (a ^ 2) ^ 2 + (b ^ 2) ^ 2)]
exact add_pos (sq_pos_of_ne_zero _ (pow_ne_zero 2 h.1)) (sq_pos_of_ne_zero _ (pow_ne_zero 2 h.2.1))
intros
{ ext; simp; ring }
ext
ext; simp; ring
ext; simp
simp
simp
intros
simp [cast_eq_of_rat, of_rat_eq]
intros
ring
intros
cases n; simp [*, int.of_nat_eq_coe, int.neg_succ_of_nat_eq]
cases n
simp [*, int.of_nat_eq_coe, int.neg_succ_of_nat_eq]
simp [*, int.of_nat_eq_coe, int.neg_succ_of_nat_eq]
intros
obtain ‚ü®u, rfl‚ü© := h
rw [norm_mul, (norm_eq_one_iff' hd _).mpr u.is_unit, mul_one]
intros
rw [sdiff_eq_self_iff_disjoint, disjoint.comm]
intros
simpa only [compl_compl] using compl_le_compl h
intros
rw [sup_comm, closure_sup_closure_left, sup_comm]
intros
rw [supr, Sup_inf_eq, supr_range]
intros
rw [at_top_Ici_eq, tendsto_comap_iff]
intros
refine tendsto_at_top_mono' _ _ hg
filter_upwards [hg.eventually (eventually_ge_at_top 0), hf.eventually (eventually_ge_at_top 1)]
exact Œª x, le_mul_of_one_le_left
intros
refine le_antisymm (hf.tendsto_at_top_at_top $ Œª b, ‚ü®g (b ‚äî b'), le_sup_left.trans $ hgi _ le_sup_right‚ü©) _
rw [@map_at_top_eq _ _ ‚ü®g b'‚ü©]
refine le_infi (Œª a, infi_le_of_le (f a ‚äî b') $ principal_mono.2 $ Œª b hb, _)
rw [mem_Ici, sup_le_iff] at hb
exact ‚ü®g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 (le_refl _)) (hgi _ hb.2)‚ü©
intros
rw frequently_iff_forall_eventually_exists_and
split
split ; intro h
intro h
intros U U_in
{ intros U U_in, simpa [exists_prop, and_comm] using h U_in }
simpa [exists_prop, and_comm] using h U_in
intro h
intros H H'
{ intros H H', simpa [and_comm] using h H' }
simpa [and_comm] using h H'
intros
casesI is_empty_or_nonempty Œ± with hŒ± hŒ±
rw [filter_eq_bot_of_is_empty (f.comap _), ‚Üê not_iff_not]
rw [filter_eq_bot_of_is_empty (f.comap _), ‚Üê not_iff_not]; [simpa using hŒ±.elim, apply_instance]
{ rw [filter_eq_bot_of_is_empty (f.comap _), ‚Üê not_iff_not]; [simpa using hŒ±.elim, apply_instance] }
simpa using hŒ±.elim
apply_instance
{ simp [comap_ne_bot_iff_frequently, hŒ±] }
simp [comap_ne_bot_iff_frequently, hŒ±]
intros
rw [tendsto, ‚Üê map_compose]
{ rw [tendsto, ‚Üê map_compose], simp only [(‚àò), map_comap_of_mem h, tendsto] }
simp only [(‚àò), map_comap_of_mem h, tendsto]
intros
split
intro h
{ intro h, rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ‚ü®s, hs, t, ht, hst‚ü©, rw [subset_empty_iff, set.prod_eq_empty_iff] at hst, cases hst with s_eq t_eq, { left, exact empty_mem_iff_bot.1 (s_eq ‚ñ∏ hs) }, { right, exact empty_mem_iff_bot.1 (t_eq ‚ñ∏ ht) } }
rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ‚ü®s, hs, t, ht, hst‚ü©
rw [subset_empty_iff, set.prod_eq_empty_iff] at hst
cases hst with s_eq t_eq
{ left, exact empty_mem_iff_bot.1 (s_eq ‚ñ∏ hs) }
left
exact empty_mem_iff_bot.1 (s_eq ‚ñ∏ hs)
{ right, exact empty_mem_iff_bot.1 (t_eq ‚ñ∏ ht) }
right
exact empty_mem_iff_bot.1 (t_eq ‚ñ∏ ht)
rintro (rfl | rfl)
{ rintro (rfl | rfl), exact bot_prod, exact prod_bot }
exact bot_prod
exact prod_bot
intros
haveI : nonempty {x // x ‚àà s} := ne.to_subtype
haveI : nonempty {x // x ‚àà s} := ne.to_subtype; erw [infi_subtype', mem_infi_of_directed h.directed_coe, subtype.exists]; refl
haveI : nonempty {x // x ‚àà s} := ne.to_subtype; erw [infi_subtype', mem_infi_of_directed h.directed_coe, subtype.exists]
erw [infi_subtype', mem_infi_of_directed h.directed_coe, subtype.exists]
refl
intros
simp only [or_comm _ q, eventually_or_distrib_left]
intros
rw [abs_def, map_const]
intros
simp only [filter.lift, infi_inf_eq, eq_self_iff_true]
intros
simp [tendsto_def, function.graph, rtendsto_def, rel.core, set.preimage]
{ simp [tendsto_def, function.graph, rtendsto_def, rel.core, set.preimage] }
intros
rw [‚Üê compl_not_mem_iff, compl_compl]
intros
rw [‚Üêsupr_partial_sups_eq f, ‚Üêsupr_partial_sups_eq g]
exact supr_le_supr h
intros
rw [symm_diff_comm, symm_diff_eq_left]
intros
haveI : is_strict_order Œ± (Œª a b, r a b ‚àß a ‚â† b) := { to_is_irrefl := ‚ü®Œª a con, con.2 rfl‚ü©, to_is_trans := ‚ü®Œª a b c ab bc, ‚ü®trans ab.1 bc.1, Œª ac, ab.2 (antisymm ab.1 (ac.symm ‚ñ∏ bc.1))‚ü©‚ü© }
rw well_founded_on_iff_no_descending_seq
intros f con
obtain ‚ü®m, n, hlt, hle‚ü© := h f con
exact (f.map_rel_iff.2 hlt).2 (antisymm hle (f.map_rel_iff.2 hlt).1).symm
intros
{ rw add_comm, exact h.add_mul_left_left z }
rw add_comm
exact h.add_mul_left_left z
intros
rw [‚Üêmul_one r, ring_hom.map_mul, ring_hom.map_one, ‚Üêsmul_def, map_smul, map_one_eq_zero, smul_zero]
intros
simpa [add_group.fg_iff_add_monoid.fg] using finite_type_iff_fg
intros
conv {to_rhs, rw ‚Üê sub_zero a }; exact quotient.eq'
conv {to_rhs, rw ‚Üê sub_zero a }
exact quotient.eq'
intros
refine le_trans (Œª x hx, _) bot_le
rw [mem_comap, submodule.mem_bot, ‚Üê ring_hom.map_zero f] at hx
exact eq.symm (hf hx) ‚ñ∏ (submodule.zero_mem ‚ä•)
intros
ext
rw mem_map_iff_of_surjective (ring_hom.fst R S) prod.fst_surjective
exact ‚ü®by { rintro ‚ü®x, ‚ü®h, rfl‚ü©‚ü©, exact h.1 }, Œª h, ‚ü®‚ü®x, 0‚ü©, ‚ü®‚ü®h, ideal.zero_mem _‚ü©, rfl‚ü©‚ü©‚ü©
intros
let g := ideal.quotient.mk (I.comap f)
have := ideal.quotient_map_comp_mk le_rfl
refine ‚ü®Œª h, _, Œª h, ring_hom.is_integral_tower_top_of_is_integral g _ (this ‚ñ∏ h)‚ü©
refine this ‚ñ∏ ring_hom.is_integral_trans g (ideal.quotient_map I f le_rfl) _ h
exact ring_hom.is_integral_of_surjective g ideal.quotient.mk_surjective
intros
contrapose h
rw [ne.def, not_not, coeff_integer_normalization, dif_neg h]
intros
by_cases triv : (1 : R‚Çò) = 0
exact ‚ü®0, ‚ü®trans leading_coeff_zero triv.symm, eval‚ÇÇ_zero _ _‚ü©‚ü©
{ exact ‚ü®0, ‚ü®trans leading_coeff_zero triv.symm, eval‚ÇÇ_zero _ _‚ü©‚ü© }
haveI : nontrivial R‚Çò := nontrivial_of_ne 1 0 triv
obtain ‚ü®b, hb‚ü© := is_unit_iff_exists_inv.mp (map_units R‚Çò ‚ü®p.leading_coeff, hM‚ü©)
refine ‚ü®(p.map (algebra_map R R‚Çò)) * C b, ‚ü®_, _‚ü©‚ü©
refine monic_mul_C_of_leading_coeff_mul_eq_one _
{ refine monic_mul_C_of_leading_coeff_mul_eq_one _, rwa leading_coeff_map_of_leading_coeff_ne_zero (algebra_map R R‚Çò), refine Œª hfp, zero_ne_one (trans (zero_mul b).symm (hfp ‚ñ∏ hb) : (0 : R‚Çò) = 1) }
rwa leading_coeff_map_of_leading_coeff_ne_zero (algebra_map R R‚Çò)
refine Œª hfp, zero_ne_one (trans (zero_mul b).symm (hfp ‚ñ∏ hb) : (0 : R‚Çò) = 1)
refine eval‚ÇÇ_mul_eq_zero_of_left _ _ _ _
{ refine eval‚ÇÇ_mul_eq_zero_of_left _ _ _ _, erw [eval‚ÇÇ_map, is_localization.map_comp, ‚Üê hom_eval‚ÇÇ _ f (algebra_map S S‚Çò) x], exact trans (congr_arg (algebra_map S S‚Çò) hf) (ring_hom.map_zero _) }
erw [eval‚ÇÇ_map, is_localization.map_comp, ‚Üê hom_eval‚ÇÇ _ f (algebra_map S S‚Çò) x]
exact trans (congr_arg (algebra_map S S‚Çò) hf) (ring_hom.map_zero _)
intros
simp [inv_fun]
intros
split
intros hf
{ intros hf, apply submodule.span_induction hf, { intros f hf n, cases (set.mem_image _ _ _).mp hf with x hx, rw [‚Üê hx.right, coeff_C], by_cases (n = 0), { simpa [h] using hx.left }, { simp [h] } }, { simp }, { exact Œª f g hf hg n, by simp [I.add_mem (hf n) (hg n)] }, { refine Œª f g hg n, _, rw [smul_eq_mul, coeff_mul], exact I.sum_mem (Œª c hc, I.smul_mem (f.coeff c.fst) (hg c.snd)) } }
apply submodule.span_induction hf
intros f hf n
{ intros f hf n, cases (set.mem_image _ _ _).mp hf with x hx, rw [‚Üê hx.right, coeff_C], by_cases (n = 0), { simpa [h] using hx.left }, { simp [h] } }
cases (set.mem_image _ _ _).mp hf with x hx
rw [‚Üê hx.right, coeff_C]
by_cases (n = 0)
{ simpa [h] using hx.left }
simpa [h] using hx.left
{ simp [h] }
simp [h]
{ simp }
simp
{ exact Œª f g hf hg n, by simp [I.add_mem (hf n) (hg n)] }
exact Œª f g hf hg n, by simp [I.add_mem (hf n) (hg n)]
refine Œª f g hg n, _
{ refine Œª f g hg n, _, rw [smul_eq_mul, coeff_mul], exact I.sum_mem (Œª c hc, I.smul_mem (f.coeff c.fst) (hg c.snd)) }
rw [smul_eq_mul, coeff_mul]
exact I.sum_mem (Œª c hc, I.smul_mem (f.coeff c.fst) (hg c.snd))
intros hf
{ intros hf, rw ‚Üê sum_monomial_eq f, refine (I.map C : ideal (polynomial R)).sum_mem (Œª n hn, _), simp [monomial_eq_C_mul_X], rw mul_comm, exact (I.map C : ideal (polynomial R)).mul_mem_left _ (mem_map_of_mem _ (hf n)) }
rw ‚Üê sum_monomial_eq f
refine (I.map C : ideal (polynomial R)).sum_mem (Œª n hn, _)
simp [monomial_eq_C_mul_X]
rw mul_comm
exact (I.map C : ideal (polynomial R)).mul_mem_left _ (mem_map_of_mem _ (hf n))
intros
rw flip' _ _ _ h
simp [polynomial.eval_comp, h]
obtain rfl | h' := h.eq_or_lt
{ simp, }
simp
congr
{ congr, norm_cast, rw [nat.sub_sub, nat.sub_sub_self (nat.succ_le_iff.mpr h')] }
norm_cast
rw [nat.sub_sub, nat.sub_sub_self (nat.succ_le_iff.mpr h')]
intros
rw [content, finset.gcd_eq_zero_iff]
split
split; intro h
intro h
ext n
{ ext n, by_cases h0 : n ‚àà p.support, { rw [h n h0, coeff_zero], }, { rw mem_support_iff at h0, push_neg at h0, simp [h0] } }
by_cases h0 : n ‚àà p.support
{ rw [h n h0, coeff_zero], }
rw [h n h0, coeff_zero]
rw mem_support_iff at h0
{ rw mem_support_iff at h0, push_neg at h0, simp [h0] }
push_neg at h0
simp [h0]
intro h
intros x h0
{ intros x h0, simp [h] }
simp [h]
intros
obtain ‚ü®P, hP‚ü© := int_coeff_of_cyclotomic' h
refine ‚ü®P, hP.1, Œª Q hQ, _‚ü©
apply (map_injective (int.cast_ring_hom K) int.cast_injective)
rw [hP.1, hQ]
intros
rw dickson_one_one_eq_chebyshev_T
simp only [comp_assoc, mul_comp, C_comp, X_comp, ‚Üê mul_assoc, ‚Üê C_1, ‚Üê C_bit0, ‚Üê C_mul]
rw [inv_of_mul_self, C_1, one_mul, one_mul, comp_X]
intros
cases b
rw [nat.desc_factorial_zero, pochhammer_zero, polynomial.eval_one]
{ rw [nat.desc_factorial_zero, pochhammer_zero, polynomial.eval_one] }
rw [nat.add_succ, nat.succ_sub_succ, nat.sub_zero]
cases a
rw [pochhammer_ne_zero_eval_zero _ b.succ_ne_zero, zero_add, nat.desc_factorial_of_lt b.lt_succ_self]
{ rw [pochhammer_ne_zero_eval_zero _ b.succ_ne_zero, zero_add, nat.desc_factorial_of_lt b.lt_succ_self] }
rw [nat.succ_add, ‚Üênat.add_succ, nat.add_desc_factorial_eq_asc_factorial, pochhammer_nat_eq_asc_factorial]
{ rw [nat.succ_add, ‚Üênat.add_succ, nat.add_desc_factorial_eq_asc_factorial, pochhammer_nat_eq_asc_factorial] }
intros
rw [esymm, (map f).map_sum]
refine sum_congr rfl (Œª x hx, _)
rw (map f).map_prod
simp
intros
nontriviality S
obtain ‚ü®f, _, hf‚ü© := exists_eq_aeval pb y
exact ‚ü®f, hf‚ü©
intros
ext
simp only [function.comp_app, ring_hom.coe_comp, rescale, ring_hom.coe_mk, power_series.coeff_mk _ _, coeff_C]
split_ifs
simp only [h, one_mul, coeff_zero_eq_constant_coeff, pow_zero]
{ simp only [h, one_mul, coeff_zero_eq_constant_coeff, pow_zero], }
{ rw [zero_pow' n h, zero_mul], }
rw [zero_pow' n h, zero_mul]
intros
simp [X]
intros
ext
{ ext, simp }
simp
intros
have h0 : C 0 := add_neg_self (1:R) ‚ñ∏ ha h1 hneg1
rcases exists_list_of_mem_closure hx with ‚ü®L, HL, rfl‚ü©
clear hx
induction L with hd tl ih
exact h0
{ exact h0 }
rw list.forall_mem_cons at HL
suffices : C (list.prod hd)
rw [list.map_cons, list.sum_cons]
{ rw [list.map_cons, list.sum_cons], exact ha this (ih HL.2) }
exact ha this (ih HL.2)
replace HL := HL.1
clear ih tl
suffices : ‚àÉ L : list R, (‚àÄ x ‚àà L, x ‚àà s) ‚àß (list.prod hd = list.prod L ‚à® list.prod hd = -list.prod L)
rcases this with ‚ü®L, HL', HP | HP‚ü©
{ rcases this with ‚ü®L, HL', HP | HP‚ü©, { rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }, rw HP, clear HP HL hd, induction L with hd tl ih, { exact hneg1 }, rw [list.prod_cons, neg_mul_eq_mul_neg], rw list.forall_mem_cons at HL', exact hs _ HL'.1 _ (ih HL'.2) }
rw HP
{ rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }
clear HP HL hd
induction L with hd tl ih
exact h1
{ exact h1 }
rw list.forall_mem_cons at HL'
rw list.prod_cons
exact hs _ HL'.1 _ (ih HL'.2)
rw HP
clear HP HL hd
induction L with hd tl ih
exact hneg1
{ exact hneg1 }
rw [list.prod_cons, neg_mul_eq_mul_neg]
rw list.forall_mem_cons at HL'
exact hs _ HL'.1 _ (ih HL'.2)
induction hd with hd tl ih
{ exact ‚ü®[], list.forall_mem_nil _, or.inl rfl‚ü© }
exact ‚ü®[], list.forall_mem_nil _, or.inl rfl‚ü©
rw list.forall_mem_cons at HL
rcases ih HL.2 with ‚ü®L, HL', HP | HP‚ü©
rcases ih HL.2 with ‚ü®L, HL', HP | HP‚ü©; cases HL.1 with hhd hhd
cases HL.1 with hhd hhd
exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]‚ü©
{ exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]‚ü© }
exact ‚ü®L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]‚ü©
{ exact ‚ü®L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]‚ü© }
cases HL.1 with hhd hhd
exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]‚ü©
{ exact ‚ü®hd :: L, list.forall_mem_cons.2 ‚ü®hhd, HL'‚ü©, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]‚ü© }
exact ‚ü®L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]‚ü©
{ exact ‚ü®L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]‚ü© }
intros
apply tensor_product.induction_on x
{ simp, }
simp
apply tensor_product.induction_on y
{ simp, }
simp
apply tensor_product.induction_on z
{ simp, }
simp
{ intros, simp [h], }
intros
simp [h]
{ intros, simp [linear_map.map_add, *], }
intros
simp [linear_map.map_add, *]
{ intros, simp [linear_map.map_add, *], }
intros
simp [linear_map.map_add, *]
{ intros, simp [linear_map.map_add, *], }
intros
simp [linear_map.map_add, *]
intros
ext
{ ext, rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace] }
rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace]
intros
rw count_pow ha hp
{ rw count_pow ha hp, apply dvd_mul_right }
apply dvd_mul_right
intros
{ subst h }
subst h
intros
apply (zmod_equiv_trunc p n).injective
rw ‚Üê commutes'
simp
intros
unfreezingI { obtain ‚ü®œÜ, hf‚ü© := hf, obtain ‚ü®œà, hg‚ü© := hg, obtain ‚ü®œá, hh‚ü© := hh }
obtain ‚ü®œÜ, hf‚ü© := hf
obtain ‚ü®œà, hg‚ü© := hg
obtain ‚ü®œá, hh‚ü© := hh
refine ‚ü®‚ü®(Œª n, bind‚ÇÅ (uncurry $ ![Œª k, rename (prod.mk (0 : fin 2)) (œÜ k), Œª k, rename (prod.mk (1 : fin 2)) (œà k)]) (œá n)), _‚ü©‚ü©
intros
funext n
simp only [peval, aeval_bind‚ÇÅ, function.comp, hh, hf, hg, uncurry]
apply eval‚ÇÇ_hom_congr rfl _ rfl
ext ‚ü®i, n‚ü©
fin_cases i; simp only [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
fin_cases i
simp only [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
simp only [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
intros
have : function.injective (int.cast_ring_hom ‚Ñö) := int.cast_injective
rw [‚Üê vars_map_of_injective _ this, map_witt_structure_int]
apply witt_structure_rat_vars
intros
rw [ghost_component_apply, aeval_witt_polynomial, finset.range_one, finset.sum_singleton, verschiebung_fun_coeff_zero, pow_zero, pow_zero, pow_one, one_mul]
intros
{ rw [lt_omega_iff_fintype], exact ‚ü®finset.subtype.fintype s‚ü© }
rw [lt_omega_iff_fintype]
exact ‚ü®finset.subtype.fintype s‚ü©
intros
simp [lt_iff_le_not_le, -not_le]
intros
{ apply sup_lt _ _ H2, rwa [hc.2] }
apply sup_lt _ _ H2
rwa [hc.2]
intros
rw ‚Üê lists'.of_to_list l; exact of_list_subset (list.subset.refl _)
rw ‚Üê lists'.of_to_list l
exact of_list_subset (list.subset.refl _)
intros
simp only [lt_ord, card_ord]
intros
simpa only [one_mul] using mul_div_cancel a ordinal.one_ne_zero
intros
simp [scale_eq_mul]
intros
simp [h]
intros
simp only [int.to_nat_of_nonpos, h.le, neg_nonpos]
intros
simp [horner]
intros
cc
intros
unfold_wf; assumption
unfold_wf
assumption
intros
rw [is_open_iff_of_not_mem infty_not_mem_image_coe, preimage_image_eq _ coe_injective]
intros
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_left' n)
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_left' n); [{norm_cast, ring}, apply_instance, apply_instance]
norm_cast
ring
apply_instance
apply_instance
intros
{ ext, simp }
ext
simp
intros
rw mem_nhds_within_Iic_iff_exists_Ioc_subset
split
rintros ‚ü®l, la, as‚ü©
{ rintros ‚ü®l, la, as‚ü©, rcases exists_between la with ‚ü®v, hv‚ü©, refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©, }
rcases exists_between la with ‚ü®v, hv‚ü©
refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©
rintros ‚ü®l, la, as‚ü©
{ rintros ‚ü®l, la, as‚ü©, exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü© }
exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü©
intros
rw [‚Üê comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]
intros
have := @continuous_on_Ico_extend_from_Ioo (order_dual Œ±) _ _ _ _ _ _ _ f _ _ _ hab
erw [dual_Ico, dual_Ioi, dual_Ioo] at this
exact this hf hb
intros
rw [‚Üêis_open_compl_iff, compl_compl]
intros
split
intros h x
{ intros h x, apply h.1, { exact subset_univ _ }, exact is_preconnected_connected_component }
apply h.1
{ exact subset_univ _ }
exact subset_univ _
exact is_preconnected_connected_component
intro h
constructor
intros s s_sub hs
rcases eq_empty_or_nonempty s with rfl | ‚ü®x, x_in‚ü©
{ exact subsingleton_empty }
exact subsingleton_empty
{ exact (h x).mono (hs.subset_connected_component x_in) }
exact (h x).mono (hs.subset_connected_component x_in)
intros
refine le_antisymm (continuous_at_snd.mono_left inf_le_left) (Œª s hs, _)
rcases x with ‚ü®x, y‚ü©
rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs
rcases hs with ‚ü®u, hu, v, hv, H‚ü©
simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H
exact mem_of_superset hv (Œª z hz, H _ (mem_of_mem_nhds hu) _ hz rfl)
intros
{ rw algebra.algebra_map_eq_smul_one, refl, }
rw algebra.algebra_map_eq_smul_one
refl
intros
change continuous (comp_right_continuous_map R f)
continuity
intros
rw polynomial_functions_closure_eq_top _ _
simp
intros
simp only [mem_closure_iff_nhds_within_ne_bot, nhds_within_pi_ne_bot]
intros
simpa only [nhds_within_univ, image_univ] using (h.left_inv_on univ).map_nhds_within_eq (h x) (by rwa image_univ) hg.continuous_within_at
intros
simp
intros
rw [‚Üê e.coe_fst ex, ‚Üê map_congr (e.coe_fst_eventually_eq_proj ex), ‚Üê map_map, ‚Üê e.coe_coe, e.to_local_homeomorph.map_nhds_eq ex, map_fst_nhds]
intros
rw [metric.diam, real.ediam_eq h, ennreal.to_real_of_real]
rw real.bounded_iff_bdd_below_bdd_above at h
exact sub_nonneg.2 (real.Inf_le_Sup s h.1 h.2)
intros
rw [Sup_eq_supr, bsupr_add hs]
intros
rw [nhds_list, list.traverse_cons _, ‚Üê nhds_list]
rw [nhds_list, list.traverse_cons _, ‚Üê nhds_list]; apply_instance
intros
ext
{ ext, refl }
refl
intros
{ ext p, simp [dist_pi_lt_iff hr] }
ext p
simp [dist_pi_lt_iff hr]
intros
simpa only [dist_comm _ x] using comap_dist_right_at_top_le_cocompact x
intros
{ rw dist_comm, refl }
rw dist_comm
refl
intros
apply induction_on x
refine is_closed_eq _ continuous_const
{ refine is_closed_eq _ continuous_const, exact (completion.uniform_continuous_dist.continuous.comp (continuous.prod_mk continuous_id continuous_id : _) : _) }
exact (completion.uniform_continuous_dist.continuous.comp (continuous.prod_mk continuous_id continuous_id : _) : _)
assume a
{ assume a, rw [completion.dist_eq, dist_self] }
rw [completion.dist_eq, dist_self]
intros
rw ‚Üê image_univ
refine dimH_image_le_of_locally_holder_on hr (Œª x _, _)
simpa only [exists_prop, nhds_within_univ] using hf x
intros
rw [Hausdorff_edist_zero_iff_closure_eq_closure, closure_closure]
intros
rw Hausdorff_edist_comm at fin
have I : Hausdorff_dist u s ‚â§ Hausdorff_dist u t + Hausdorff_dist t s := Hausdorff_dist_triangle fin
simpa [add_comm, Hausdorff_dist_comm] using I
intros
{ rw [(@gc Œ± _).l_Sup, set.sUnion_image], refl }
rw [(@gc Œ± _).l_Sup, set.sUnion_image]
refl
intros
rw [nhds_induced, filter.map_comap_of_mem h]
intros
have : is_path_connected (univ : set X) := path_connected_space_iff_univ.mp (by apply_instance)
rcases this.exists_path_through_family' p (Œª i, true.intro) with ‚ü®Œ≥, t, -, h‚ü©
exact ‚ü®Œ≥, t, h‚ü©
intros
rintros u v hu hv ‚ü®_, ‚ü®‚ü®x, hx, rfl‚ü©, hxu‚ü©‚ü© ‚ü®_, ‚ü®‚ü®y, hy, rfl‚ü©, hyv‚ü©‚ü©
rw ‚Üê mem_preimage at hxu hyv
rcases continuous_on_iff'.1 hf u hu with ‚ü®u', hu', u'_eq‚ü©
rcases continuous_on_iff'.1 hf v hv with ‚ü®v', hv', v'_eq‚ü©
have := H u' v' hu' hv'
rw [inter_comm s u', ‚Üê u'_eq] at this
rw [inter_comm s v', ‚Üê v'_eq] at this
rcases this ‚ü®x, hxu, hx‚ü© ‚ü®y, hyv, hy‚ü© with ‚ü®z, hzs, hzu', hzv'‚ü©
refine ‚ü®f z, mem_image_of_mem f hzs, _, _‚ü©
all_goals { rw ‚Üê mem_preimage, apply mem_of_mem_inter_left, show z ‚àà _ ‚à© s, simp [*] }
rw ‚Üê mem_preimage
apply mem_of_mem_inter_left
show z ‚àà _ ‚à© s
simp [*]
rw ‚Üê mem_preimage
apply mem_of_mem_inter_left
show z ‚àà _ ‚à© s
simp [*]
intros
rw ‚Üê image_univ; exact compact_univ.image hf
rw ‚Üê image_univ
exact compact_univ.image hf
intros
ext p
ext p; cases p; simp only [mem_comp_rel]; tauto
ext p; cases p; simp only [mem_comp_rel]
ext p; cases p
cases p
simp only [mem_comp_rel]
tauto
intros
unfold inits
rw inits_core_eq
refl
contradiction
intros
rw [‚Üê h]
apply int.nat_abs_bit0
intros
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
rw int.add_comm at h
exact int.lt_add_of_sub_left_lt h
intros
funext m n
revert n
dsimp [function.swap]
apply binary_rec _ (Œª a m' IH, _) m; intro n
apply binary_rec _ (Œª a m' IH, _) m
intro n
{ rw [bitwise_zero_left, bitwise_zero_right], exact h }
rw [bitwise_zero_left, bitwise_zero_right]
exact h
intro n
apply bit_cases_on n; intros b n'
apply bit_cases_on n
intros b n'
rw [bitwise_bit, bitwise_bit, IH]; exact h
rw [bitwise_bit, bitwise_bit, IH]
exact h
exact h
exact h
exact h
intros
by_cases hba : b ‚â§ a
simp [le_antisymm hba h‚ÇÅ]
{ simp [le_antisymm hba h‚ÇÅ] }
by_cases hc0 : c ‚â§ 0
simp [le_antisymm hc0 c.zero_le, nat.zero_mul]
{ simp [le_antisymm hc0 c.zero_le, nat.zero_mul] }
exact (le_not_le_of_lt (nat.mul_lt_mul_of_pos_left (lt_of_le_not_le h‚ÇÅ hba) (lt_of_le_not_le c.zero_le hc0))).left
intros
rw [‚Üê@vsub_eq_zero_iff_eq G, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub]
simp
intros
simp [bit0, add_smul, smul_add]
intros
subst hT; exact set.Union_lift_mk x hx
subst hT
exact set.Union_lift_mk x hx
intros
induction n with n ih
rw pow_zero at h
{ rw pow_zero at h, have := is_unit_of_dvd_one _ h, have := not_unit hp, contradiction }
have := is_unit_of_dvd_one _ h
have := not_unit hp
contradiction
rw pow_succ at h
cases dvd_or_dvd hp h with dvd_a dvd_pow
{ assumption }
assumption
exact ih dvd_pow
intros
haveI := classical.dec_eq Œ±; from classical.by_cases (assume : a ‚àà s, prod_eq_single_of_mem a this h‚ÇÄ) (assume : a ‚àâ s, (prod_congr rfl $ Œª b hb, h‚ÇÄ b hb $ by rintro rfl; cc).trans $ prod_const_one.trans (h‚ÇÅ this).symm)
haveI := classical.dec_eq Œ±
from classical.by_cases (assume : a ‚àà s, prod_eq_single_of_mem a this h‚ÇÄ) (assume : a ‚àâ s, (prod_congr rfl $ Œª b hb, h‚ÇÄ b hb $ by rintro rfl; cc).trans $ prod_const_one.trans (h‚ÇÅ this).symm)
intros
{ rw [sum_product, sum_mul, sum_congr rfl], intros, rw mul_sum }
rw [sum_product, sum_mul, sum_congr rfl]
intros
rw mul_sum
intros
cases char_p.char_is_prime_or_zero R p with h h
{ exact h, }
exact h
{ contradiction, }
contradiction
intros
by_cases hn : n = 0
subst hn
{ subst hn, simp }
simp
{ exact cast_dvd n_dvd (cast_ne_zero.mpr hn), }
exact cast_dvd n_dvd (cast_ne_zero.mpr hn)
intros
simp [*, squash_seq, (seq.zip_with_nth_some (seq.nats_nth n) s_nth_eq _)]
intros
simp [partial_numerators, s_nth_eq]
intros
{ conv {to_lhs, rw [xgcd_aux]}, exact if_neg h}
conv {to_lhs, rw [xgcd_aux]}
exact if_neg h
intros
rw [div_add_div _ _ ha hb, one_mul, mul_one, add_comm]
intros
rw [of_mul_assoc, of_mul_assoc, of_mul_assoc, of_mul_assoc_left]
intros
simp
intros
rw [sub_add_eq_sub_sub_swap]; simp
rw [sub_add_eq_sub_sub_swap]
simp
intros
simp [sub_eq_neg_add, add_comm]
intros
simpa only [sq_abs] using pow_le_pow_of_le_left (abs_nonneg x) h 2
intros
simp [div_eq_mul_inv a 1]
intros
rw [mul_comm, (div_mul_cancel _ hb)]
intros
simp [single_map_homological_complex]
intros
{ dsimp [of], rw [dif_neg h] }
dsimp [of]
rw [dif_neg h]
intros
rcases i with (_|_|i); { dsimp, simp, }
rcases i with (_|_|i)
{ dsimp, simp, }
{ dsimp, simp, }
dsimp
{ dsimp, simp, }
simp
intros
{ simp only [mul_indicator], split_ifs; refl }
simp only [mul_indicator]
split_ifs
split_ifs; refl
refl
refl
intros
rw is_semisimple_iff_no_solvable_ideals
split
split; intros h‚ÇÅ I h‚ÇÇ
intros h‚ÇÅ I h‚ÇÇ
haveI : is_lie_abelian I := h‚ÇÇ
{ haveI : is_lie_abelian I := h‚ÇÇ, apply h‚ÇÅ, exact lie_algebra.of_abelian_is_solvable R I, }
apply h‚ÇÅ
exact lie_algebra.of_abelian_is_solvable R I
intros h‚ÇÅ I h‚ÇÇ
haveI : is_solvable R I := h‚ÇÇ
{ haveI : is_solvable R I := h‚ÇÇ, rw ‚Üê abelian_of_solvable_ideal_eq_bot_iff, apply h‚ÇÅ, exact abelian_derived_abelian_of_ideal I, }
rw ‚Üê abelian_of_solvable_ideal_eq_bot_iff
apply h‚ÇÅ
exact abelian_derived_abelian_of_ideal I
intros
dunfold derived_abelian_of_ideal
cases h : derived_length_of_ideal R L I with k
{ exact is_lie_abelian_bot R L, }
exact is_lie_abelian_bot R L
rw derived_series_of_derived_length_succ at h
{ rw derived_series_of_derived_length_succ at h, exact h.1, }
exact h.1
intros
{ intros m hm, erw mem_lie_span, intros K hK, exact hK hm, }
intros m hm
erw mem_lie_span
intros K hK
exact hK hm
intros
{ intros m hm, erw mem_lie_span, intros N hN, exact hN hm, }
intros m hm
erw mem_lie_span
intros N hN
exact hN hm
intros
apply lie_module.weight_vector_multiplication H L M M ((to_module_hom R L M).restrict_lie H) œá‚ÇÅ œá‚ÇÇ
simp only [lie_module_hom.coe_to_linear_map, function.comp_app, linear_map.coe_comp, tensor_product.map_incl, linear_map.mem_range]
use [‚ü®x, hx‚ü© ‚äó‚Çú ‚ü®m, hm‚ü©]
simp only [submodule.subtype_apply, to_module_hom_apply, submodule.coe_mk, lie_module_hom.coe_restrict_lie, tensor_product.map_tmul]
intros
induction n with n ih
{ rw [nat.cast_zero, zero_smul, zero_smul] }
rw [nat.cast_zero, zero_smul, zero_smul]
rw [nat.succ_eq_add_one, nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul]
{ rw [nat.succ_eq_add_one, nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul], }
intros
rwa [‚Üê one_div a, le_div_iff' ha, ‚Üê div_eq_mul_inv, div_le_iff (ha.trans_le h), one_mul]
intros
simpa using le_inv_of_neg ha hb
intros
rw [abs_div, abs_one]
intros
rw [‚Üê mul_lt_mul_iff_right b, inv_mul_cancel_right, one_mul]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, ‚Üê mul_lt_mul_iff_left a‚Åª¬π, inv_mul_cancel_left, inv_mul_cancel_left, inv_lt_inv_iff]
intros
norm_cast
intros
rw [mul_comm, ha.mul_le_iff_le_one_right]
intros
by_cases ba : b ‚â§ a
simp [ba.antisymm h‚ÇÅ]
{ simp [ba.antisymm h‚ÇÅ] }
by_cases c0 : c ‚â§ 0
simp [c0.antisymm h‚ÇÇ]
{ simp [c0.antisymm h‚ÇÇ] }
exact (mul_lt_mul_of_pos_right (h‚ÇÅ.lt_of_not_le ba) (h‚ÇÇ.lt_of_not_le c0)).le
intros
simpa only [sub_eq_neg_add] using h (-x)
intros
rw [‚Üêleft_cancel x, right_inv]
exact ((h x).left_inverse y).symm
intros
rcases ua with ‚ü®a, rfl‚ü©
exact units.is_regular a
intros
simp
intros
rw [sub_eq_add_neg, mul_support_one_add', support_neg']
intros
rw [‚Üê set_like.mem_coe, coe_vanishing_ideal, set.mem_set_of_eq]
intros
{ cases x, refl }
cases x
refl
intros
ext j
suffices : ite (fin.cast_succ i < ite (j < i) (fin.cast_succ j) j.succ) (ite (j < i) (j:‚Ñï) (j + 1) - 1) (ite (j < i) j (j + 1)) = j
dsimp [Œ¥, œÉ, fin.succ_above, fin.pred_above]
{ dsimp [Œ¥, œÉ, fin.succ_above, fin.pred_above], simpa [fin.pred_above] with push_cast }
simpa [fin.pred_above] with push_cast
rcases i with ‚ü®i, _‚ü©
rcases j with ‚ü®j, _‚ü©
dsimp
simp only [if_congr, subtype.mk_lt_mk]
split_ifs; { simp at *; linarith, }
split_ifs
{ simp at *; linarith, }
{ simp at *; linarith, }
{ simp at *; linarith, }
simp at *
simp at *; linarith
{ simp at *; linarith, }
linarith
intros
dsimp [Œ¥, œÉ]
{ dsimp [Œ¥, œÉ], simp only [‚ÜêX.map_comp, simplex_category.œÉ_comp_œÉ H] }
simp only [‚ÜêX.map_comp, simplex_category.œÉ_comp_œÉ H]
intros
simp only [change_origin_series_term, linear_isometry_equiv.norm_map]
intros
ext1 n
dsimp [formal_multilinear_series.comp]
rw finset.sum_eq_single (composition.ones n)
show comp_along_composition p (id ùïú E) (composition.ones n) = p n
ext v
{ ext v, rw comp_along_composition_apply, apply p.congr (composition.ones_length n), intros, rw apply_composition_ones, refine congr_arg v _, rw [fin.ext_iff, fin.coe_cast_le, fin.coe_mk, fin.coe_mk], }
rw comp_along_composition_apply
apply p.congr (composition.ones_length n)
intros
rw apply_composition_ones
refine congr_arg v _
rw [fin.ext_iff, fin.coe_cast_le, fin.coe_mk, fin.coe_mk]
show ‚àÄ (b : composition n), b ‚àà finset.univ ‚Üí b ‚â† composition.ones n ‚Üí comp_along_composition p (id ùïú E) b = 0
assume b _ hb
{ assume b _ hb, obtain ‚ü®k, hk, lt_k‚ü© : ‚àÉ (k : ‚Ñï) (H : k ‚àà composition.blocks b), 1 < k := composition.ne_ones_iff.1 hb, obtain ‚ü®i, i_lt, hi‚ü© : ‚àÉ (i : ‚Ñï) (h : i < b.blocks.length), b.blocks.nth_le i h = k := nth_le_of_mem hk, let j : fin b.length := ‚ü®i, b.blocks_length ‚ñ∏ i_lt‚ü©, have A : 1 < b.blocks_fun j := by convert lt_k, ext v, rw [comp_along_composition_apply, continuous_multilinear_map.zero_apply], apply continuous_multilinear_map.map_coord_zero _ j, dsimp [apply_composition], rw id_apply_ne_one _ _ (ne_of_gt A), refl }
obtain ‚ü®k, hk, lt_k‚ü© : ‚àÉ (k : ‚Ñï) (H : k ‚àà composition.blocks b), 1 < k := composition.ne_ones_iff.1 hb
obtain ‚ü®i, i_lt, hi‚ü© : ‚àÉ (i : ‚Ñï) (h : i < b.blocks.length), b.blocks.nth_le i h = k := nth_le_of_mem hk
let j : fin b.length := ‚ü®i, b.blocks_length ‚ñ∏ i_lt‚ü©
have A : 1 < b.blocks_fun j := by convert lt_k
ext v
rw [comp_along_composition_apply, continuous_multilinear_map.zero_apply]
apply continuous_multilinear_map.map_coord_zero _ j
dsimp [apply_composition]
rw id_apply_ne_one _ _ (ne_of_gt A)
refl
{ simp }
simp
intros
rw left_inv
intros
rw is_o
intros
simp only [is_O, is_O_with_map]
intros
rw is_O_iff
rw is_O_iff; refl
refl
intros
simpa only [div_eq_mul_inv] using (hc.has_deriv_at.mul_const d‚Åª¬π).differentiable_at
intros
simp [deriv_within, fderiv_within_const_sub hxs]
intros
simpa only [add_comm] using fderiv_within_add_const hxs c
intros
rw differentiable_at.fderiv_within (h.differentiable_at p) hxs
exact h.fderiv p
intros
rw [has_fderiv_at, has_fderiv_at_filter, ‚Üê map_add_left_nhds_zero x, is_o_map]
simp [(‚àò)]
intros
apply filter.eventually_eq.fderiv_within_eq hs _ hx
apply mem_of_superset self_mem_nhds_within
exact hL
intros
{ rw ‚Üê nat.succ_pred_eq_of_pos h, refl }
rw ‚Üê nat.succ_pred_eq_of_pos h
refl
intros
rw times_cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on
congr' 2
rw ‚Üê iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact fderiv_within_of_open hs hx
intros
have := (h.cont 0 bot_le).congr (Œª x hx, (h.zero_eq' hx).symm)
rwa linear_isometry_equiv.comp_continuous_on_iff at this
intros
split
assume h
{ assume h, exact ‚ü®h.of_le (with_top.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (with_top.coe_lt_coe.2 (lt_add_one n)), h.cont (n + 1) (le_refl _)‚ü© }
exact ‚ü®h.of_le (with_top.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (with_top.coe_lt_coe.2 (lt_add_one n)), h.cont (n + 1) (le_refl _)‚ü©
assume h
{ assume h, split, { exact h.1.zero_eq }, { assume m hm, by_cases h' : m < n, { exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') }, { have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h', rw this, exact h.2.1 } }, { assume m hm, by_cases h' : m ‚â§ n, { apply h.1.cont m (with_top.coe_le_coe.2 h') }, { have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'), rw this, exact h.2.2 } } }
split
{ exact h.1.zero_eq }
exact h.1.zero_eq
assume m hm
{ assume m hm, by_cases h' : m < n, { exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') }, { have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h', rw this, exact h.2.1 } }
by_cases h' : m < n
{ exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') }
exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h')
have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h'
{ have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h', rw this, exact h.2.1 }
rw this
exact h.2.1
assume m hm
{ assume m hm, by_cases h' : m ‚â§ n, { apply h.1.cont m (with_top.coe_le_coe.2 h') }, { have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'), rw this, exact h.2.2 } }
by_cases h' : m ‚â§ n
{ apply h.1.cont m (with_top.coe_le_coe.2 h') }
apply h.1.cont m (with_top.coe_le_coe.2 h')
have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h')
{ have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'), rw this, exact h.2.2 }
rw this
exact h.2.2
intros
rintro z ‚ü®hxz, hyz‚ü©
obtain rfl | h := (hxz.trans hyz).eq_or_lt
rw segment_same
{ rw segment_same, exact hyz.antisymm hxz }
exact hyz.antisymm hxz
rw ‚Üêsub_nonneg at hxz hyz
rw ‚Üêsub_pos at h
refine ‚ü®(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _‚ü©
{ rw [‚Üêadd_div, sub_add_sub_cancel, div_self h.ne'] }
rw [‚Üêadd_div, sub_add_sub_cancel, div_self h.ne']
rw [smul_eq_mul, smul_eq_mul, ‚Üêmul_div_right_comm, ‚Üêmul_div_right_comm, ‚Üêadd_div, div_eq_iff h.ne', add_comm, sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]
{ rw [smul_eq_mul, smul_eq_mul, ‚Üêmul_div_right_comm, ‚Üêmul_div_right_comm, ‚Üêadd_div, div_eq_iff h.ne', add_comm, sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub] }
intros
simp only [convex.combo_eq_vadd h, ‚Üê vsub_eq_sub]
exact f.apply_line_map _ _ _
intros
rw [norm_sub_mul_self, add_right_cancel_iff, sub_eq_add_neg, add_right_eq_self, neg_eq_zero, mul_eq_zero]
norm_num
intros
{ rw [inner_smul_right, algebra.smul_def], refl }
rw [inner_smul_right, algebra.smul_def]
refl
intros
simp [inner_eq_sum_norm_sq_div_four, ‚Üê f.norm_map]
intros
rw [pi_Lp.norm_eq_of_nat 2]; simp [sqrt_eq_rpow]
{ rw [pi_Lp.norm_eq_of_nat 2]; simp [sqrt_eq_rpow] }
rw [pi_Lp.norm_eq_of_nat 2]
simp [sqrt_eq_rpow]
simp [sqrt_eq_rpow]
intros
ext w
{ ext w, exact eq_sum_orthogonal_projection_self_orthogonal_complement K w }
exact eq_sum_orthogonal_projection_self_orthogonal_complement K w
intros
rw [dist_comm, dist_left_midpoint]
intros
rw [‚Üê mem_closure_iff_nhds_within_ne_bot, metric.mem_closure_iff]
rintros Œµ Œµ0
rcases normed_field.exists_norm_lt Œ± Œµ0 with ‚ü®b, hb0, hbŒµ‚ü©
refine ‚ü®x + b, mt (set.mem_singleton_iff.trans add_right_eq_self).1 $ norm_pos_iff.1 hb0, _‚ü©
rwa [dist_comm, dist_eq_norm, add_sub_cancel']
intros
rw [frontier, closure_ball x hr, is_open_ball.interior_eq]
ext x
exact (@eq_iff_le_not_lt ‚Ñù _ _ _).symm
intros
have : bounded (f '' s) := (hs.image_of_continuous_on hf).bounded
rcases bounded_iff_forall_norm_le.1 this with ‚ü®C, hC‚ü©
exact ‚ü®C, Œª x hx, hC _ (set.mem_image_of_mem _ hx)‚ü©
intros
conv_rhs { rw ‚Üê norm_le_zero_iff' }
split
split ; intro h
intro h
{ rw h }
rw h
intro h
{ exact le_antisymm h (norm_nonneg g) }
exact le_antisymm h (norm_nonneg g)
intros
rw ‚Üê exp_series_apply_eq'
exact exp_series_has_sum_exp_of_mem_ball x hx
intros
apply multilinear_map.mk_continuous_norm_le
exact mul_nonneg (norm_nonneg _) (pow_nonneg (norm_nonneg _) _)
intros
ext x
rw [normed_group_hom.completion_def, normed_group_hom.coe_id, completion.map_id]
refl
intros
obtain ‚ü®m, rfl‚ü© := hquot.surjective n
have nonemp : ((Œª m', ‚à•m + m'‚à•) '' f.ker).nonempty
rw set.nonempty_image_iff
{ rw set.nonempty_image_iff, exact ‚ü®0, f.ker.zero_mem‚ü© }
exact ‚ü®0, f.ker.zero_mem‚ü©
rcases real.lt_Inf_add_pos nonemp hŒµ with ‚ü®_, ‚ü®‚ü®x, hx, rfl‚ü©, H : ‚à•m + x‚à• < Inf ((Œª (m' : M), ‚à•m + m'‚à•) '' f.ker) + Œµ‚ü©‚ü©
exact ‚ü®m+x, by rw [f.map_add,(normed_group_hom.mem_ker f x).mp hx, add_zero], by rwa hquot.norm‚ü©
intros
simp [norm_eq, h, real.sqrt_eq_rpow, ‚Üêreal.rpow_nat_cast]
intros
apply f.dist_lt_of_dist_lt_modulus (Œµ/2) (half_pos h)
simpa [S] using m
rw [‚Üê coe_comp_exp_order_iso, ‚Üê filter.map_map, exp_order_iso.map_at_bot, ‚Üê map_coe_Ioi_at_bot]
intros
rw div_eq_inv_mul
exact (has_strict_deriv_at_log hx).comp x hf
intros
have : (n : ‚Ñù) + 2 ‚â† 0 := by exact_mod_cast succ_ne_zero n.succ
field_simp
convert eq_sub_iff_add_eq.mp (integral_cos_pow_aux n)
ring
intros
convert (has_deriv_at_rpow_const hx).comp_has_deriv_within_at x hf using 1
ring
intros
simp [rpow_eq_top_iff, hy, asymm hy]
intros
rw [ennreal.to_real, ennreal.to_real, ‚Üênnreal.coe_rpow, ennreal.to_nnreal_rpow]
intros
convert rpow_lt_rpow_of_exponent_lt hx hz
{ convert rpow_lt_rpow_of_exponent_lt hx hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
simp [sin_add]
{ rw real.range_sin, exact Icc.infinite (by norm_num) }
rw real.range_sin
exact Icc.infinite (by norm_num)
simp [tan_eq_sin_div_cos]
intros
rw [‚Üê complex.cos_sub_pi_div_two, cos_eq_zero_iff]
split
rintros ‚ü®k, hk‚ü©
{ rintros ‚ü®k, hk‚ü©, use k + 1, field_simp [eq_add_of_sub_eq hk], ring }
use k + 1
field_simp [eq_add_of_sub_eq hk]
ring
rintros ‚ü®k, rfl‚ü©
{ rintros ‚ü®k, rfl‚ü©, use k - 1, field_simp, ring }
use k - 1
field_simp
ring
intros
simp [arccos, sub_eq_zero]
convert has_sum_geometric_of_lt_1 _ _; norm_num
convert has_sum_geometric_of_lt_1 _ _
norm_num
norm_num
norm_num
intros
rw eventually_at_top at h
rcases h with ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü©
rw frequently_at_top at hf
rcases hf N‚ÇÄ with ‚ü®N, hNN‚ÇÄ : N‚ÇÄ ‚â§ N, hN‚ü©
rw ‚Üê @summable_nat_add_iff Œ± _ _ _ _ N
refine mt summable.tendsto_at_top_zero (Œª h', not_tendsto_at_top_of_tendsto_nhds (tendsto_norm_zero.comp h') _)
convert tendsto_at_top_of_geom_le _ hr _
refine lt_of_le_of_ne (norm_nonneg _) _
{ refine lt_of_le_of_ne (norm_nonneg _) _, intro h'', specialize hN‚ÇÄ N hNN‚ÇÄ, simp only [comp_app, zero_add] at h'', exact hN h''.symm }
intro h''
specialize hN‚ÇÄ N hNN‚ÇÄ
simp only [comp_app, zero_add] at h''
exact hN h''.symm
intro i
{ intro i, dsimp only [comp_app], convert (hN‚ÇÄ (i + N) (hNN‚ÇÄ.trans (N.le_add_left i))) using 3, ac_refl }
dsimp only [comp_app]
convert (hN‚ÇÄ (i + N) (hNN‚ÇÄ.trans (N.le_add_left i))) using 3
ac_refl
intros
rw [cokernel.condition_assoc, zero_comp]
intros
simp only [‚Üêmk_hom g, lift.fac_right]
intros
{ convert cancel_mono f, simp, }
convert cancel_mono f
simp
intros
simp only [category.id_comp, eq_to_hom_refl, category.comp_id]
intros
erw [nat_iso.naturality_2]
refl
intros
cases f; cases g
cases f
cases g
congr
dsimp at w_base
induction w_base
refl
dsimp at w_base
induction w_base
simpa using w_fiber
intros
ext
{ ext, simp, }
simp
intros
{ rw c.Œπ.naturality f, apply comp_id }
rw c.Œπ.naturality f
apply comp_id
intros
dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim]
simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_hom_œÄ, iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_œÄ_œÄ, eq_to_iso_refl, category.assoc]
erw [nat_trans.id_app]
dsimp
simp
intros
simp
intros
simp
intros
simp [is_iso.inv_comp_eq]
intros
simpa [h] using B.Œπ_œÄ j j'
intros
tidy
intros
rw [‚Üêcofork.left_app_one, cokernel_cofork.condition]
intros
letI := is_reflexive_pair.mk' r rf rg
apply_instance
intros
rw [(has_zero_object.unique_to X).uniq f, (has_zero_object.unique_to X).uniq g]
intros
{ ext, simp [‚Üêtensor_comp], }
ext
simp [‚Üêtensor_comp]
intros
rw [‚Üêtensor_comp, f.inv_hom_id]
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
haveI : mono f := preadditive.mono_of_kernel_zero (kernel_zero_of_nonzero_from_simple w)
exact is_iso_of_mono_of_nonzero w
intros
classical
by_contradiction h
apply w
exact is_iso_of_epi_of_nonzero h
intros
{ apply (cancel_mono X.arrow).mp, simp }
apply (cancel_mono X.arrow).mp
simp
intros
{ ext, simp, dsimp, simp, }
ext
simp
dsimp
simp
intros
refine (finset.order_emb_of_fin_unique' _ _).symm
exact Œª i, (finset.mem_map' _).2 (finset.mem_univ _)
intros
simp only [eq_self_iff_true, and_self, eq_iff_join_eq, join_split_wrt_composition, map_length_split_wrt_composition, h]
intros
simp only [line.apply, line.map, option.get_or_else_map]
intros
ext d
simp only [mem_image, true_and, mem_filter, set_coe.exists, mem_univ, exists_prop_of_true]
split
rintro rfl
{ rintro rfl, exact ‚ü®_, d.is_adj, dart.ext _ _ rfl rfl‚ü©, }
exact ‚ü®_, d.is_adj, dart.ext _ _ rfl rfl‚ü©
rintro ‚ü®e, he, rfl‚ü©
{ rintro ‚ü®e, he, rfl‚ü©, refl, }
refl
intros
rw ‚Üêto_NFA_correct at hx ‚ä¢
exact M.to_NFA.pumping_lemma hx hlen
intros
induction x with a x ih generalizing P Q
rw [rmatch, match_epsilon]
{ rw [rmatch, match_epsilon], split, { intro h, refine ‚ü® [], [], rfl, _ ‚ü©, rw [rmatch, rmatch], rwa band_coe_iff at h }, { rintro ‚ü® t, u, h‚ÇÅ, h‚ÇÇ ‚ü©, cases list.append_eq_nil.1 h‚ÇÅ.symm with ht hu, subst ht, subst hu, repeat {rw rmatch at h‚ÇÇ}, finish } }
split
intro h
{ intro h, refine ‚ü® [], [], rfl, _ ‚ü©, rw [rmatch, rmatch], rwa band_coe_iff at h }
refine ‚ü® [], [], rfl, _ ‚ü©
rw [rmatch, rmatch]
rwa band_coe_iff at h
rintro ‚ü® t, u, h‚ÇÅ, h‚ÇÇ ‚ü©
{ rintro ‚ü® t, u, h‚ÇÅ, h‚ÇÇ ‚ü©, cases list.append_eq_nil.1 h‚ÇÅ.symm with ht hu, subst ht, subst hu, repeat {rw rmatch at h‚ÇÇ}, finish }
cases list.append_eq_nil.1 h‚ÇÅ.symm with ht hu
subst ht
subst hu
rw rmatch at h‚ÇÇ
repeat {rw rmatch at h‚ÇÇ}
rw rmatch at h‚ÇÇ
rw rmatch at h‚ÇÇ
finish
rw [rmatch, deriv]
{ rw [rmatch, deriv], split_ifs with hepsilon, { rw [add_rmatch_iff, ih], split, { rintro (‚ü® t, u, _ ‚ü© | h), { exact ‚ü® a :: t, u, by tauto ‚ü© }, { exact ‚ü® [], a :: x, rfl, hepsilon, h ‚ü© } }, { rintro ‚ü® t, u, h, hP, hQ ‚ü©, cases t with b t, { right, rw list.nil_append at h, rw ‚Üêh at hQ, exact hQ }, { left, refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish } } }, { rw ih, split; rintro ‚ü® t, u, h, hP, hQ ‚ü©, { exact ‚ü® a :: t, u, by tauto ‚ü© }, { cases t with b t, { contradiction }, { refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish } } } }
split_ifs with hepsilon
rw [add_rmatch_iff, ih]
{ rw [add_rmatch_iff, ih], split, { rintro (‚ü® t, u, _ ‚ü© | h), { exact ‚ü® a :: t, u, by tauto ‚ü© }, { exact ‚ü® [], a :: x, rfl, hepsilon, h ‚ü© } }, { rintro ‚ü® t, u, h, hP, hQ ‚ü©, cases t with b t, { right, rw list.nil_append at h, rw ‚Üêh at hQ, exact hQ }, { left, refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish } } }
split
rintro (‚ü® t, u, _ ‚ü© | h)
{ rintro (‚ü® t, u, _ ‚ü© | h), { exact ‚ü® a :: t, u, by tauto ‚ü© }, { exact ‚ü® [], a :: x, rfl, hepsilon, h ‚ü© } }
exact ‚ü® a :: t, u, by tauto ‚ü©
{ exact ‚ü® a :: t, u, by tauto ‚ü© }
exact ‚ü® [], a :: x, rfl, hepsilon, h ‚ü©
{ exact ‚ü® [], a :: x, rfl, hepsilon, h ‚ü© }
rintro ‚ü® t, u, h, hP, hQ ‚ü©
{ rintro ‚ü® t, u, h, hP, hQ ‚ü©, cases t with b t, { right, rw list.nil_append at h, rw ‚Üêh at hQ, exact hQ }, { left, refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish } }
cases t with b t
right
{ right, rw list.nil_append at h, rw ‚Üêh at hQ, exact hQ }
rw list.nil_append at h
rw ‚Üêh at hQ
exact hQ
left
{ left, refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish }
refine ‚ü® t, u, by finish, _, hQ ‚ü©
rw rmatch at hP
convert hP
finish
rw ih
{ rw ih, split; rintro ‚ü® t, u, h, hP, hQ ‚ü©, { exact ‚ü® a :: t, u, by tauto ‚ü© }, { cases t with b t, { contradiction }, { refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish } } }
split; rintro ‚ü® t, u, h, hP, hQ ‚ü©
split
rintro ‚ü® t, u, h, hP, hQ ‚ü©
{ exact ‚ü® a :: t, u, by tauto ‚ü© }
exact ‚ü® a :: t, u, by tauto ‚ü©
rintro ‚ü® t, u, h, hP, hQ ‚ü©
cases t with b t
{ cases t with b t, { contradiction }, { refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish } }
contradiction
{ contradiction }
refine ‚ü® t, u, by finish, _, hQ ‚ü©
{ refine ‚ü® t, u, by finish, _, hQ ‚ü©, rw rmatch at hP, convert hP, finish }
rw rmatch at hP
convert hP
finish
intros
induction c; intros k v; rw step_normal
induction c; intros k v
induction c
intros k v
rw step_normal
simp only [code.eval, pure_bind]
iterate 3 { simp only [code.eval, pure_bind] }
intros k v
rw step_normal
simp only [code.eval, pure_bind]
intros k v
rw step_normal
simp only [code.eval, pure_bind]
intros k v
rw step_normal
case cons : f fs IHf IHfs { rw [code.eval, IHf], simp only [bind_assoc, cont.eval, pure_bind], congr, funext v, rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [step_ret, IHfs], congr, funext v', refine eq.trans _ (eq.symm _); try {exact reaches_eval (refl_trans_gen.single rfl)} }
intros k v
rw step_normal
case comp : f g IHf IHg { rw [code.eval, IHg], simp only [bind_assoc, cont.eval, pure_bind], congr, funext v, rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [step_ret, IHf] }
intros k v
rw step_normal
case case : f g IHf IHg { simp only [code.eval], cases v.head; simp only [nat.elim, code.eval]; [apply IHf, apply IHg] }
intros k v
rw step_normal
case fix : f IHf { rw cont_eval_fix IHf }
intros
induction n with n IH generalizing i L
cases i; simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons]
cases i
{ cases i; simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons] }
simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons]
simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons]
cases i
{ cases i, { rw if_neg (nat.succ_ne_zero _).symm, simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth] }, { simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons], congr } }
rw if_neg (nat.succ_ne_zero _).symm
{ rw if_neg (nat.succ_ne_zero _).symm, simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth] }
simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth]
simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons]
{ simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons], congr }
intros
simp only [mjoin, (‚àò), id.def, map_bind, (bind_pure_comp_eq_map _ _).symm, bind_assoc, pure_bind]
intros
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
simp! * with functor_norm
intros
induction l with hd tl hl
{ simpa }
simpa
rw [to_buffer_cons]
{ rw [to_buffer_cons], have : [hd].to_buffer.size = 1 := rfl, simp [add_comm, this] }
have : [hd].to_buffer.size = 1 := rfl
simp [add_comm, this]
intros
introI h
have : (failure : parser Œ±) buffer.nil 0 = fail 0 dlist.empty := by simp
exact of_fail this
intros
simp [str_eq_char_buf, char_buf_iff, ‚Üêstring.to_list_inj, buffer.ext_iff]
intros
cases hp : p cb n; simp [‚Üêis_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc, pure_eq_done]
cases hp : p cb n
simp [‚Üêis_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc, pure_eq_done]
simp [‚Üêis_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc, pure_eq_done]
intros
simp [many_char, many_eq_done_nil, map_eq_done, list.as_string_eq]
intros
simp
intros
simp [inv_def, division_def]
intros
rw [‚Üê of_real_nat_cast, abs_of_nonneg (nat.cast_nonneg n)]
intros
rw [‚Üê sqrt_sq hx.le, ‚Üê sqrt_inv, inv_one_add_tan_sq hx.ne']
intros
rw [sq_sub_sq, cosh_add_sinh, cosh_sub_sinh, ‚Üê exp_add, add_neg_self, exp_zero]
intros
{ simp_rw [‚Üê smul_eq_mul, of_real_alg r], simp, }
simp_rw [‚Üê smul_eq_mul, of_real_alg r]
simp
intros
rw [‚Üê of_real_zero, ‚Üê of_real_inv, inv_zero]
intros
ext i
ext i; simp
simp
intros
by_cases h : b = a; simp [swap_apply_def, h]
{ by_cases h : b = a; simp [swap_apply_def, h], }
by_cases h : b = a
simp [swap_apply_def, h]
simp [swap_apply_def, h]
intros
cases e
{ cases e, refl }
refl
intros
rw [fin_rotate_succ_apply, fin.coe_add_one i]
intros
refine iff.intro _ _
intro h
{ intro h, cases succ_above_lt_ge p i with H H, { rw succ_above_below _ _ H at h, exact le_of_lt h }, { exact H } }
cases succ_above_lt_ge p i with H H
rw succ_above_below _ _ H at h
{ rw succ_above_below _ _ H at h, exact le_of_lt h }
exact le_of_lt h
{ exact H }
exact H
intro h
{ intro h, rw succ_above_above _ _ h, exact lt_of_le_of_lt h (cast_succ_lt_succ i) }
rw succ_above_above _ _ h
exact lt_of_le_of_lt h (cast_succ_lt_succ i)
intros
{ ext j, simp [tail, fin.succ_ne_zero] }
ext j
simp [tail, fin.succ_ne_zero]
intros
rw [eq_comm, zero_eq_one_iff]
intros
cases i; refl
cases i
refl
intros
rw [‚Üê insert_emptyc_eq, piecewise_insert, piecewise_empty]
intros
{ ext, simp [-finset.mem_map, -equiv.trans_to_embedding] }
ext
simp [-finset.mem_map, -equiv.trans_to_embedding]
intros
show _ ‚â• _ ‚Üî _
apply fold_op_rel_iff_or
intros x y z
show _ ‚â§ _ ‚Üî _
exact min_le_iff
intros
simp [to_finset]
intros
{ ext x, simp [and_comm] }
ext x
simp [and_comm]
intros
ext x
ext x; refl
refl
intros
{ ext, refl }
ext
refl
intros
rw ‚Üêcard_of_finset s H; congr
rw ‚Üêcard_of_finset s H
congr
intros
simpa using fintype.sum_pow_mul_eq_add_pow (fin n) a b
intros
rw [to_nat_eq_max, max_eq_left h]
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
have := mod_add_div a b; rwa [H, zero_add] at this
have := mod_add_div a b
rwa [H, zero_add] at this
intros
rw ‚Üêpow_one p; exact pow_dvd_of_le_of_pow_dvd hk hpk
rw ‚Üêpow_one p
exact pow_dvd_of_le_of_pow_dvd hk hpk
intros
rw [modeq, zero_mod, dvd_iff_mod_eq_zero]
intros
cases mod_two_eq_zero_or_one n with h h; simp [h]
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
simp only [insert_entries]; exact p.kinsert s‚ÇÅ.nodupkeys
simp only [insert_entries]
exact p.kinsert s‚ÇÅ.nodupkeys
intros
simp only [update_nth_eq_modify_nth, nth_modify_nth_ne _ _ h]
intros
rw [modify_nth_eq_take_drop, drop_eq_nth_le_cons h]
rw [modify_nth_eq_take_drop, drop_eq_nth_le_cons h]; refl
refl
intros
apply ext_le h (Œª i h‚ÇÅ h‚ÇÇ, _)
have : (L.take (i + 1)).sum = (L'.take (i + 1)).sum := h' _ (nat.succ_le_of_lt h‚ÇÅ)
rw [sum_take_succ L i h‚ÇÅ, sum_take_succ L' i h‚ÇÇ, h' i (le_of_lt h‚ÇÅ)] at this
exact add_left_cancel this
intros
convert lt_of_lt_of_le (sum_take_map_length_lt1 L hi hj) (monotone_sum_take _ hi)
have : L.length = (L.map length).length
simp
simp
simp [this, -length_map]
intros
rw [‚Üê length_map, lookmap_map_eq _ (Œª _, ()), length_map]
rw [‚Üê length_map, lookmap_map_eq _ (Œª _, ()), length_map]; simp
simp
intros
rw [eq_comm, append_eq_nil]
intros
induction l with x l IH generalizing n
{ simp }
simp
cases n
{ cases n, { simp }, { simpa using IH n _ } }
{ simp }
simp
{ simpa using IH n _ }
simpa using IH n _
intros
by_cases h : ‚àÉ a ‚àà l, p a
rcases h with ‚ü®a, ha, pa‚ü©
{ rcases h with ‚ü®a, ha, pa‚ü©, exact or.inr (exists_of_erasep ha pa) }
exact or.inr (exists_of_erasep ha pa)
{ simp at h, exact or.inl (erasep_of_forall_not h) }
simp at h
exact or.inl (erasep_of_forall_not h)
intros
revert hd
suffices : ‚àÄ (xs' : list Œ±) (h : ‚àÄ x ‚àà xs, x ‚àà xs') (hd : d ‚àà xs'), next_or xs x d ‚àà xs'
{ exact this xs (Œª _, id) }
exact this xs (Œª _, id)
intros xs' hxs' hd
induction xs with y ys ih
{ exact hd }
exact hd
cases ys with z zs
{ exact hd }
exact hd
rw next_or
split_ifs with h
{ exact hxs' _ (mem_cons_of_mem _ (mem_cons_self _ _)) }
exact hxs' _ (mem_cons_of_mem _ (mem_cons_self _ _))
{ exact ih (Œª _ h, hxs' _ (mem_cons_of_mem _ h)) }
exact ih (Œª _ h, hxs' _ (mem_cons_of_mem _ h))
intros
generalize eq : f a = b
cases b
{ rw filter_map_cons_none _ _ eq }
rw filter_map_cons_none _ _ eq
{ rw filter_map_cons_some _ _ _ eq }
rw filter_map_cons_some _ _ _ eq
intros
simp only [nodup_append, and.left_comm, disjoint_comm]
intros
rw [fin_range, length_pmap, length_range]
intros
simp [cyclic_permutations_of_ne_nil _ h]
intros
induction l‚ÇÅ generalizing l‚ÇÇ
simp
case list.nil { simp }
case list.cons : _ _ ih { simp [not_or_distrib] at h, simp [h.1, ih h.2] }
intros
rw [‚Üê sublists'_reverse, reverse_reverse]
intros
{ rw [length_zip_with, lt_min_iff] at h, exact h.right }
rw [length_zip_with, lt_min_iff] at h
exact h.right
intros
ext i j
ext i j; simp
simp
intros
simp [matrix.mul_apply, ring_hom.map_sum]
intros
simp [sub_eq_add_neg]
intros
ext
simp only [map_apply, block_diagonal_apply, eq_comm]
rw [apply_ite f, hf]
intros
{ ext i, refine fin.cases _ _ i; simp [vec_mul_vec] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_mul_vec]
simp [vec_mul_vec]
simp [vec_mul_vec]
intros
rw [add_comm, union_add_distrib, add_comm s, add_comm s]
intros
ext a
by_cases h : a ‚àà s; simp [h,h0]
by_cases h : a ‚àà s
simp [h,h0]
simp [h,h0]
intros
haveI := classical.dec_eq Œ±
rw [revzip_powerset_aux_lemma l revzip_powerset_aux, revzip_powerset_aux_lemma l revzip_powerset_aux']
exact powerset_aux_perm_powerset_aux'.map _
intros
{ funext x, exact comap_id_apply x }
funext x
exact comap_id_apply x
intros
refine le_trans (total_degree_multiset_prod _) _
rw [multiset.map_map]
refl
intros
rw [‚Üênat.div_mul_cancel w, h, one_mul]
intros
bitwise_assoc_tac
intros
{ rw [‚Üêcoe_nat n], apply top_ne_coe }
rw [‚Üêcoe_nat n]
apply top_ne_coe
intros
induction n with n ih
simp
rw triangle_succ n
{rw triangle_succ n, simp [choose, ih], rw add_comm}
simp [choose, ih]
rw add_comm
intros
rw [dist.def, nat.sub_eq_zero_of_le h, zero_add]
intros
rw [add_comm z, add_comm z, enat.add_lt_add_iff_right hz]
intros
induction k with t ht
refl
unfold asc_factorial
rw [ht, zero_add, nat.factorial_succ]
intros
rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]
intros
rw even_mul
convert n.even_or_odd
simp with parity_simps
intros
rw size
conv { to_lhs, rw [binary_rec], simp [h] }
rw div2_bit
intros
rw nat.div_mod_unique (pos_num.cast_pos _)
induction n with n IH n IH
exact divmod_to_nat_aux (by simp; refl) (nat.mul_le_mul_left 2 (pos_num.cast_pos d : (0 : ‚Ñï) < d))
{ exact divmod_to_nat_aux (by simp; refl) (nat.mul_le_mul_left 2 (pos_num.cast_pos d : (0 : ‚Ñï) < d)) }
unfold divmod
{ unfold divmod, cases divmod d n with q r, simp only [divmod] at IH ‚ä¢, apply divmod_to_nat_aux; simp, { rw [_root_.bit1, _root_.bit1, add_right_comm, bit0_eq_two_mul ‚Üën, ‚Üê IH.1, mul_add, ‚Üê bit0_eq_two_mul, mul_left_comm, ‚Üê bit0_eq_two_mul] }, { rw ‚Üê bit0_eq_two_mul, exact nat.bit1_lt_bit0 IH.2 } }
cases divmod d n with q r
simp only [divmod] at IH ‚ä¢
apply divmod_to_nat_aux; simp
apply divmod_to_nat_aux
simp
rw [_root_.bit1, _root_.bit1, add_right_comm, bit0_eq_two_mul ‚Üën, ‚Üê IH.1, mul_add, ‚Üê bit0_eq_two_mul, mul_left_comm, ‚Üê bit0_eq_two_mul]
{ rw [_root_.bit1, _root_.bit1, add_right_comm, bit0_eq_two_mul ‚Üën, ‚Üê IH.1, mul_add, ‚Üê bit0_eq_two_mul, mul_left_comm, ‚Üê bit0_eq_two_mul] }
simp
rw ‚Üê bit0_eq_two_mul
{ rw ‚Üê bit0_eq_two_mul, exact nat.bit1_lt_bit0 IH.2 }
exact nat.bit1_lt_bit0 IH.2
unfold divmod
{ unfold divmod, cases divmod d n with q r, simp only [divmod] at IH ‚ä¢, apply divmod_to_nat_aux; simp, { rw [bit0_eq_two_mul ‚Üën, ‚Üê IH.1, mul_add, ‚Üê bit0_eq_two_mul, mul_left_comm, ‚Üê bit0_eq_two_mul] }, { rw ‚Üê bit0_eq_two_mul, exact nat.bit0_lt IH.2 } }
cases divmod d n with q r
simp only [divmod] at IH ‚ä¢
apply divmod_to_nat_aux; simp
apply divmod_to_nat_aux
simp
rw [bit0_eq_two_mul ‚Üën, ‚Üê IH.1, mul_add, ‚Üê bit0_eq_two_mul, mul_left_comm, ‚Üê bit0_eq_two_mul]
{ rw [bit0_eq_two_mul ‚Üën, ‚Üê IH.1, mul_add, ‚Üê bit0_eq_two_mul, mul_left_comm, ‚Üê bit0_eq_two_mul] }
simp
rw ‚Üê bit0_eq_two_mul
{ rw ‚Üê bit0_eq_two_mul, exact nat.bit0_lt IH.2 }
exact nat.bit0_lt IH.2
intros
rw [‚Üê size_eq_nat_size, size_to_nat]
intros
cases x; simp only [map_none', map_some', h, mem_def]
{ cases x; simp only [map_none', map_some', h, mem_def] }
cases x
simp only [map_none', map_some', h, mem_def]
simp only [map_none', map_some', h, mem_def]
intros
cases b; refl
cases b
refl
refl
intros
refine valid'.dual_iff.2 _
rw dual_rotate_r
refine hr.dual.rotate_l hl.dual _ _ _
{ rwa [size_dual, size_dual, add_comm] }
rwa [size_dual, size_dual, add_comm]
{ rwa [size_dual, size_dual] }
rwa [size_dual, size_dual]
{ rwa [size_dual, size_dual] }
rwa [size_dual, size_dual]
intros
rw [length_to_list', size_eq_real_size h]
intros
linarith
intros
ext
ext; dsimp [pequiv.trans]; refl
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
refl
intros
simp [mem_core, mem_res]
intros
ext
simp only [supp, image_univ, mem_range, mem_set_of_eq]
split
split; intro h
intro h
apply @h (Œª i x, ‚àÉ (y : P.B a i), f i y = x)
{ apply @h (Œª i x, ‚àÉ (y : P.B a i), f i y = x), rw liftp_iff', intros, refine ‚ü®_,rfl‚ü© }
rw liftp_iff'
intros
refine ‚ü®_,rfl‚ü©
intro h
simp only [liftp_iff']
{ simp only [liftp_iff'], cases h, subst x, tauto }
cases h
subst x
tauto
intros
{ cases n with n h, cases n; [exact absurd h dec_trivial, refl] }
cases n with n h
cases n
cases n; [exact absurd h dec_trivial, refl]
exact absurd h dec_trivial
refl
intros
let h := @factor_multiset_le_iff m v.prod
{ let h := @factor_multiset_le_iff m v.prod, rw [v.factor_multiset_prod] at h, exact h }
rw [v.factor_multiset_prod] at h
exact h
intros
rw [‚Üê with_bot.coe_le_coe, ‚Üê degree_eq_nat_degree]
exact le_degree_of_ne_zero h
{ assume h, subst h, exact h rfl }
assume h
subst h
exact h rfl
intros
{ rw [next_coeff, if_neg], contrapose! hp, simpa }
rw [next_coeff, if_neg]
contrapose! hp
simpa
intros
simp only [‚ÜêC_eq_int_cast, nat_trailing_degree_C]
intros
simp [multiplicity, root_multiplicity, part.dom]
simp [multiplicity, root_multiplicity, part.dom]; congr; funext; congr
simp [multiplicity, root_multiplicity, part.dom]; congr; funext
simp [multiplicity, root_multiplicity, part.dom]; congr
congr
funext
congr
intros
induction ps using list.reverse_rec_on with ps p ihp
{ simp }
simp
simp only [list.forall_mem_append, list.forall_mem_singleton] at hf
{ simp only [list.forall_mem_append, list.forall_mem_singleton] at hf, simp [eval‚ÇÇ_mul_noncomm _ _ hf.2, ihp hf.1] }
simp [eval‚ÇÇ_mul_noncomm _ _ hf.2, ihp hf.1]
intros
rw [bit0, eval‚ÇÇ_add, bit0]
intros
rw [‚Üê monomial_zero_left, hasse_deriv_monomial, nat.choose_eq_zero_of_lt hk, nat.cast_zero, zero_mul, monomial_zero_right]
intros
rw [leading_coeff, trailing_coeff, mirror_nat_trailing_degree, coeff_mirror, rev_at_le (nat.le_add_left _ _), nat.add_sub_cancel]
intros
rw [reverse, coeff_reflect]
intros
refine root_multiplicity_of_dvd hzero _
have hdivp : (X - C a) ^ root_multiplicity a p ‚à£ p := pow_root_multiplicity_dvd p a
have hdivq : (X - C a) ^ root_multiplicity a q ‚à£ q := pow_root_multiplicity_dvd q a
exact min_pow_dvd_add hdivp hdivq
intros
rw [corecF, pfunctor.M.dest_corec]
intros
rw [bit1, cast_add, cast_one, cast_bit0]; refl
rw [bit1, cast_add, cast_one, cast_bit0]
refl
intros
simp [ennreal.of_real]
intros
assume x y hxy
obtain ‚ü®n, rfl‚ü© := nat.exists_eq_succ_of_ne_zero hn
induction n with n IH
{ simp only [hxy, pow_one] }
simp only [hxy, pow_one]
simp only [pow_succ _ n.succ, mul_lt_mul hxy (IH (nat.succ_pos _).ne')]
{ simp only [pow_succ _ n.succ, mul_lt_mul hxy (IH (nat.succ_pos _).ne')] }
intros
rw [bit0, add_eq_top, or_self]
intros
simpa [add_comm] using add_lt_add_right_coe h z
have : 1 + real.sqrt 5 ‚â† 0
from ne_of_gt (add_pos (by norm_num) $ real.sqrt_pos.mpr (by norm_num))
field_simp [sub_mul, mul_add]
norm_num
intros
rw [infinite_neg_iff_infinite_and_neg]; exact ‚ü®Œª hI, hI.1, Œª hI, ‚ü®hI, hn‚ü©‚ü©
rw [infinite_neg_iff_infinite_and_neg]
exact ‚ü®Œª hI, hI.1, Œª hI, ‚ü®hI, hn‚ü©‚ü©
pi_upper_bound [140/99, 279/151, 51/26, 412/207]
intros
rw [sq, sqrt_mul_self_eq_abs]
intros
rw ‚Üêget_eq_of_mem _ h; apply results_of_terminates
rw ‚Üêget_eq_of_mem _ h
apply results_of_terminates
intros
simp only [terminates_iff, exists_congr h]
intros
finish [subset_def, mem_image_eq]
intros
{ ext, simp }
ext
simp
intros
{ intro s, use f ‚Åª¬π' s, rw hf.image_preimage }
intro s
use f ‚Åª¬π' s
rw hf.image_preimage
intros
split_ifs; simp [h]
{ split_ifs; simp [h] }
split_ifs
simp [h]
simp [h]
intros
{ ext, simp }
ext
simp
intros
rw [‚Üênot_forall, ‚Üêeq_univ_iff_forall]
intros
{ rw ‚Üê image_prod, exact (hs.prod ht).image _ }
rw ‚Üê image_prod
exact (hs.prod ht).image _
intros
simp [‚Üêfinset.coe_inj]
intros
rw [restrict, image_comp, image_preimage_eq_inter_range, subtype.range_coe]
intros
ext1 x
simp_rw [mem_union, mem_Ioc, min_lt_iff, le_max_iff]
by_cases hc : c < x; by_cases hd : x ‚â§ d
by_cases hc : c < x
by_cases hd : x ‚â§ d
{ tauto }
tauto
have hax : a < x := h‚ÇÇ.trans_lt (lt_of_not_ge hd)
{ have hax : a < x := h‚ÇÇ.trans_lt (lt_of_not_ge hd), tauto }
tauto
by_cases hd : x ‚â§ d
have hxb : x ‚â§ b := (le_of_not_gt hc).trans h‚ÇÅ
{ have hxb : x ‚â§ b := (le_of_not_gt hc).trans h‚ÇÅ, tauto }
tauto
{ tauto }
tauto
intros
simp [‚Üê Ioi_inter_Iic]
intros
rw [mem_Ico, le_iff_lt_or_eq] at hmem
rcases hmem with ‚ü®hxa | hxa, hxb‚ü©
{ exact or.inr ‚ü®hxa, hxb‚ü© }
exact or.inr ‚ü®hxa, hxb‚ü©
{ exact or.inl hxa.symm }
exact or.inl hxa.symm
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ico_of_neg a b h
intros
ext y
{ ext y, split; simp only [mem_Union]; rintro ‚ü®a, ha, x, hx, ax‚ü©; exact ‚ü®a, x, ha, hx, ax‚ü© }
split
split; simp only [mem_Union]; rintro ‚ü®a, ha, x, hx, ax‚ü©; exact ‚ü®a, x, ha, hx, ax‚ü©
split; simp only [mem_Union]; rintro ‚ü®a, ha, x, hx, ax‚ü©
split; simp only [mem_Union]
simp only [mem_Union]
rintro ‚ü®a, ha, x, hx, ax‚ü©
exact ‚ü®a, x, ha, hx, ax‚ü©
simp only [mem_Union]
rintro ‚ü®a, ha, x, hx, ax‚ü©
exact ‚ü®a, x, ha, hx, ax‚ü©
intros
rintro x ‚ü®_, ‚ü®i, rfl‚ü©, xs, xt‚ü©
{ rintro x ‚ü®_, ‚ü®i, rfl‚ü©, xs, xt‚ü©, exact ‚ü®‚ü®_, ‚ü®i, rfl‚ü©, xs‚ü©, _, ‚ü®i, rfl‚ü©, xt‚ü© }
exact ‚ü®‚ü®_, ‚ü®i, rfl‚ü©, xs‚ü©, _, ‚ü®i, rfl‚ü©, xt‚ü©
intros
rw ‚Üêeqv_gen_of_setoid (map_of_surjective r f h hf)
rw ‚Üêeqv_gen_of_setoid (map_of_surjective r f h hf); refl
refl
intros
convert card_image_diag (univ : finset Œ±)
rw [fintype.card_of_subtype, ‚Üêfilter_image_quotient_mk_is_diag]
rintro x
rw [mem_filter, univ_product_univ, mem_image]
obtain ‚ü®a, ha‚ü© := quotient.exists_rep x
exact and_iff_right ‚ü®a, mem_univ _, ha‚ü©
intros
split; intro h
{ split; intro h, { rw quotient.eq at h, cases h; refl }, rw h }
split
intro h
rw quotient.eq at h
{ rw quotient.eq at h, cases h; refl }
cases h
cases h; refl
refl
refl
intro h
rw h
intros
convert zmod.int_coe_eq_int_coe_iff a b c
simp [nat.modeq_iff_dvd, int.modeq_iff_dvd]
intros
intros a‚ÇÅ a‚ÇÇ hfa
simp [ext_iff, ker, is_subgroup.trivial] at h
have ha : a‚ÇÅ * a‚ÇÇ‚Åª¬π = 1
rw ‚Üêh
rw ‚Üêh
rw ‚Üêh; exact hf.inv_ker_one hfa
rw ‚Üêh; exact hf.inv_ker_one hfa
exact hf.inv_ker_one hfa
exact hf.inv_ker_one hfa
rw [eq_inv_of_mul_eq_one ha, inv_inv a‚ÇÇ]
intros
simp only [‚Üê units_coe, ‚Üê mul_apply, f.inv_mul, coe_one, id]
intros
conv_rhs { rw ‚Üê adjoin_simple.algebra_map_gen F Œ± }
{ conv_rhs { rw ‚Üê adjoin_simple.algebra_map_gen F Œ± }, rw is_integral_algebra_map_iff (algebra_map F‚üÆŒ±‚üØ E).injective, apply_instance }
rw is_integral_algebra_map_iff (algebra_map F‚üÆŒ±‚üØ E).injective
apply_instance
intros
{ have h := pow_card_sub_one_eq_one a ha, rwa zmod.card p at h }
have h := pow_card_sub_one_eq_one a ha
rwa zmod.card p at h
intros
simpa only [ring_hom.map_one, C_1, sub_eq_add_neg] using eq_X_sub_C B (1:A)
intros
induction x; simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]; refl
induction x; simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]
induction x
simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]
simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]
refl
intros
rw ‚Üê sq_eq_sq (norm_nonneg (x - y)) (add_nonneg (norm_nonneg x) (norm_nonneg y))
rw [norm_sub_pow_two_real, inner_eq_neg_mul_norm_of_angle_eq_pi h]
ring
intros
rw cospherical_iff_exists_mem_of_finite_dimensional h at hc
rcases hc with ‚ü®c, hc, r, hcr‚ü©
use c
intros sx hsxps
have hsx : affine_span ‚Ñù (set.range sx.points) = s
refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _
{ refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _, simp [hd] }
simp [hd]
have hc : c ‚àà affine_span ‚Ñù (set.range sx.points) := hsx.symm ‚ñ∏ hc
exact (sx.eq_circumcenter_of_dist_eq hc (Œª i, hcr (sx.points i) (hsxps (set.mem_range_self i)))).symm
intros
rcases ho with ‚ü®t, hto, hts‚ü©
use t.circumradius
intros t‚ÇÇ ht‚ÇÇ
have ht‚ÇÇs := ht‚ÇÇ
rw hts at ht‚ÇÇ
rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto ht‚ÇÇ t‚ÇÇ.independent.injective with ‚ü®c, hc, h‚ü©
rw set.forall_range_iff at h
have hs : set.range t.points ‚äÜ s
rw hts
{ rw hts, exact set.subset_insert _ _ }
exact set.subset_insert _ _
rw [affine_span_of_orthocentric_system ‚ü®t, hto, hts‚ü© hs t.independent.injective, ‚Üêaffine_span_of_orthocentric_system ‚ü®t, hto, hts‚ü© ht‚ÇÇs t‚ÇÇ.independent.injective] at hc
exact (t‚ÇÇ.eq_circumradius_of_dist_eq hc h).symm
intros
refine structure_groupoid.le_iff.2 (Œª e he, _)
rw mem_groupoid_of_pregroupoid at he ‚ä¢
exact ‚ü®h _ _ he.1, h _ _ he.2‚ü©
intros
rw [unique_mdiff_within_at, ext_chart_preimage_inter_eq]
exact unique_diff_within_at.inter' hs (ext_chart_preimage_mem_nhds_within I x ht)
intros
simp only [tangent_map_within, h p.fst hp, true_and, eq_self_iff_true, heq_iff_eq, sigma.mk.inj_iff]
congr' 1
exact mfderiv_within_congr hs h (h _ hp)
intros
refine (I.to_local_equiv.image_eq_target_inter_inv_preimage _).trans _
{ rw I.source_eq, exact subset_univ _ }
rw I.source_eq
exact subset_univ _
rw [inter_comm, I.target_eq, I.to_local_equiv_coe_symm]
{ rw [inter_comm, I.target_eq, I.to_local_equiv_coe_symm] }
intros
simp only [times_cont_mdiff_within_at, lift_prop_within_at, times_cont_diff_within_at_prop, iff_def] with mfld_simps {contextual := tt}
exact times_cont_diff_within_at.continuous_within_at
intros
simp [‚Üê times_cont_mdiff_on_univ, times_cont_mdiff_on_iff, continuous_iff_continuous_on_univ]
intros
rw [rcons, dif_neg]
{ rw [rcons, dif_neg], refl, exact h1 ‚ü®i, m‚ü© (ls.mem_cons_self _) }
refl
exact h1 ‚ü®i, m‚ü© (ls.mem_cons_self _)
intros
rw [mul_comm, sec_spec]
intros
ext
rw lift_spec
show j _ = j _ * _
erw [‚Üêj.map_mul, sec_spec']
intros
rw [mul_assoc, swap_mul_self, mul_one]
intros
apply cycle_induction_on _ g
rw [extend_domain_one, cycle_type_one, cycle_type_one]
{ rw [extend_domain_one, cycle_type_one, cycle_type_one] }
intros œÉ hœÉ
{ intros œÉ hœÉ, rw [(hœÉ.extend_domain f).cycle_type, hœÉ.cycle_type, card_support_extend_domain] }
rw [(hœÉ.extend_domain f).cycle_type, hœÉ.cycle_type, card_support_extend_domain]
intros œÉ œÑ hd hc hœÉ hœÑ
{ intros œÉ œÑ hd hc hœÉ hœÑ, rw [hd.cycle_type, ‚Üê extend_domain_mul, (hd.extend_domain f).cycle_type, hœÉ, hœÑ] }
rw [hd.cycle_type, ‚Üê extend_domain_mul, (hd.extend_domain f).cycle_type, hœÉ, hœÑ]
intros
intros f g h
rw ‚Üêcycle_factors_finset_noncomm_prod f
simpa [h] using cycle_factors_finset_noncomm_prod g
intros
by_cases hx : f x = x
rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]
{ rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx] }
rw [‚Üêcycle_of_pow_apply_self, ‚Üêcycle_of_pow_apply_self f, ‚Üêorder_of_is_cycle (is_cycle_cycle_of f hx), ‚Üêpow_eq_mod_order_of]
{ rw [‚Üêcycle_of_pow_apply_self, ‚Üêcycle_of_pow_apply_self f, ‚Üêorder_of_is_cycle (is_cycle_cycle_of f hx), ‚Üêpow_eq_mod_order_of] }
intros
simp [cycle_range]
intros
suffices : x ‚àà {y | form_perm l y ‚â† y}
rw ‚Üêmem_to_finset
{ rw ‚Üêmem_to_finset, exact support_form_perm_le' _ this }
exact support_form_perm_le' _ this
simpa using h
intros
refine ‚ü®Œª h, _, Œª h, by rw [mul_apply, h.2, h.1]‚ü©
cases hœÉœÑ a with hœÉ hœÑ
{ exact ‚ü®hœÉ, œÉ.injective (h.trans hœÉ.symm)‚ü© }
exact ‚ü®hœÉ, œÉ.injective (h.trans hœÉ.symm)‚ü©
{ exact ‚ü®(congr_arg œÉ hœÑ).symm.trans h, hœÑ‚ü© }
exact ‚ü®(congr_arg œÉ hœÑ).symm.trans h, hœÑ‚ü©
intros
simp_rw [one_lt_card_iff, mem_support, ‚Üênot_or_distrib]
contrapose! h
ext a
specialize h (f a) a
rwa [apply_eq_iff_eq, or_self, or_self] at h
intros
ext
ext; simp
simp
simp
intros
split
intros h x y hxy
{ intros h x y hxy, rwa [‚Üêmul_inv_eq_one, ‚Üêmap_inv, ‚Üêmap_mul, ‚Üêmem_ker, h, mem_bot, mul_inv_eq_one] at hxy }
rwa [‚Üêmul_inv_eq_one, ‚Üêmap_inv, ‚Üêmap_mul, ‚Üêmem_ker, h, mem_bot, mul_inv_eq_one] at hxy
exact Œª h, le_bot_iff.mp (Œª x hx, h (hx.trans f.map_one.symm))
{ exact Œª h, le_bot_iff.mp (Œª x hx, h (hx.trans f.map_one.symm)) }
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
simp [mem_center_iff]
intros
simp [line_map_apply]
intros
rw mem_direction_iff_eq_vsub_left hp
simp
intros
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
exact set.sum_indicator_subset_of_eq_zero w (Œª i wi, wi ‚Ä¢ (p i -·µ• b : V)) h (Œª i, zero_smul k _)
intros
split
{ exact eq_affine_combination_of_mem_affine_span }
exact eq_affine_combination_of_mem_affine_span
rintros ‚ü®s, w, hw, rfl‚ü©
{ rintros ‚ü®s, w, hw, rfl‚ü©, exact affine_combination_mem_affine_span hw p }
exact affine_combination_mem_affine_span hw p
intros
rw [‚Üê span_singleton_le_iff_mem, le_supr_iff]
simp only [span_singleton_le_iff_mem]
intros
simpa only [range_eq_map] using submodule.map_zero _
intros
{ext, refl}
ext
refl
intros
rintros x ‚ü®m, hm, rfl‚ü©
exact add_mem_sup (mem_map_of_mem hm) (mem_map_of_mem hm)
intros
rw [coe_reindex, range_reindex']
intros
simp [basis.equiv_fun, finsupp.total_apply, finsupp.sum_fintype]
intros
{ erw mem_pair_self_adjoint_matrices_submodule, refl, }
erw mem_pair_self_adjoint_matrices_submodule
refl
intros
{ ext, refl }
ext
refl
intros
rw [B.to_matrix_comp_left b, to_matrix_to_lin, transpose_transpose]
intros
apply cardinal.sup_le.mpr
rintro ‚ü®s, li‚ü©
exact linear_independent_bounded_of_finset_linear_independent_bounded H _ li
intros
rw [‚Üêcardinal.lift_inj, ‚Üê (basis.singleton punit R).mk_eq_dim, cardinal.mk_punit]
intros
rw [‚Üê total_dual_basis b, basis.total_repr b.dual_basis l]
intros
refine eq_of_le_of_finrank_eq f.range_dual_map_le_dual_annihilator_ker _
have := submodule.finrank_quotient_add_finrank f.ker
rw (subspace.quot_equiv_annihilator f.ker).finrank_eq at this
refine add_left_injective (finrank K f.ker) _
simp_rw [this, finrank_range_dual_map_eq_finrank_range]
exact finrank_range_add_finrank_ker f
intros
erw [‚Üêalg_hom.map_mul, ring_quot.mk_alg_hom_rel R (rel.of m), alg_hom.map_zero _]
intros
rw [‚Üê finrank_top, ‚Üê subalgebra_top_finrank_eq_submodule_top_finrank] at h
exact eq.symm (subalgebra.eq_bot_of_finrank_one h)
intros
rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]
intros
rw [total_apply, sum_option_index_smul, total_apply]
intros
refine linear_map.mem_submodule_image.trans ‚ü®_, _‚ü©
rintro ‚ü®y, yO, yN, h‚ü©
{ rintro ‚ü®y, yO, yN, h‚ü©, exact ‚ü®y, yN, h‚ü© }
exact ‚ü®y, yN, h‚ü©
rintro ‚ü®y, yN, h‚ü©
{ rintro ‚ü®y, yN, h‚ü©, exact ‚ü®y, hNO yN, yN, h‚ü© }
exact ‚ü®y, hNO yN, yN, h‚ü©
intros
simp [of_le_apply]
intros
simpa using i.comp _ (range_splitting_injective v)
intros
rw [det_apply', det_apply']
refine fintype.sum_bijective _ inv_involutive.bijective _ _ _
intros œÉ
rw sign_inv
congr' 1
apply fintype.prod_equiv œÉ
intros
simp
intros
haveI : is_empty n := fintype.card_eq_zero_iff.mp h
exact det_is_empty
intros
simp [linear_map.to_matrix_alg_equiv']
intros
rcases t
{ rcases t, simp [to_matrix, transvection_mul_transvection_same, t_hij] }
simp [to_matrix, transvection_mul_transvection_same, t_hij]
intros
have : (0 : R) ‚Ä¢ (0 : M‚ÇÅ i) = 0
simp
simp
rw [‚Üê update_eq_self i m, h, ‚Üê this, f.map_smul, zero_smul]
intros
split
rintros ‚ü®_, _‚ü© ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü©
{ rintros ‚ü®_, _‚ü© ‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü©, simp only [prod.ext_iff, inl_apply, inr_apply, mem_bot] at hx hy ‚ä¢, exact ‚ü®hy.1.symm, hx.2.symm‚ü© }
simp only [prod.ext_iff, inl_apply, inr_apply, mem_bot] at hx hy ‚ä¢
exact ‚ü®hy.1.symm, hx.2.symm‚ü©
rintros ‚ü®x, y‚ü© -
{ rintros ‚ü®x, y‚ü© -, simp only [mem_sup, mem_range, exists_prop], refine ‚ü®(x, 0), ‚ü®x, rfl‚ü©, (0, y), ‚ü®y, rfl‚ü©, _‚ü©, simp }
simp only [mem_sup, mem_range, exists_prop]
refine ‚ü®(x, 0), ‚ü®x, rfl‚ü©, (0, y), ‚ü®y, rfl‚ü©, _‚ü©
simp
intros
rw [smodeq.def] at h ‚ä¢
show ideal.quotient.mk I (f.eval x) = ideal.quotient.mk I (f.eval y)
change ideal.quotient.mk I x = ideal.quotient.mk I y at h
rw [‚Üê polynomial.eval‚ÇÇ_at_apply, ‚Üê polynomial.eval‚ÇÇ_at_apply, h]
intros
simp [xor, and_comm, or_comm]
intros
simp [and_comm]
intros
rw [‚Üê not_nontrivial_iff_subsingleton, or_comm]
{ rw [‚Üê not_nontrivial_iff_subsingleton, or_comm], exact classical.em _ }
exact classical.em _
intros
have : ŒΩ = ŒΩ.restrict set.univ := measure.restrict_univ.symm
have : ŒΩ = ŒΩ.restrict set.univ := measure.restrict_univ.symm
rwa [this, measure.prod_restrict, ‚Üê this]
intros
{ rw [real_smul_def, ‚Üê smul_pos_part, dif_pos hr] }
rw [real_smul_def, ‚Üê smul_pos_part, dif_pos hr]
intros
rwa [‚Üê f.mk_coe_fn, ‚Üê g.mk_coe_fn, mk_eq_mk]
intros
let hf_mem_‚Ñíp := mem_‚Ñíp_of_mem_‚Ñíp_trim hm (Lp.mem_‚Ñíp f)
rw mem_Lp_meas_subgroup_iff_ae_measurable'
refine ae_measurable'.congr _ (mem_‚Ñíp.coe_fn_to_Lp hf_mem_‚Ñíp).symm
refine ae_measurable'_of_ae_measurable'_trim hm _
exact (Lp.ae_measurable f)
intros
have : ae_measurable (Œª (x : Œ±), c) Œº := measurable_const.ae_measurable
rw [integrable, and_iff_right this, has_finite_integral_const_iff]
intros
{ rw ‚Üê mem_‚Ñíp_one_iff_integrable, exact Lp.mem_‚Ñíp f }
rw ‚Üê mem_‚Ñíp_one_iff_integrable
exact Lp.mem_‚Ñíp f
intros
simp only [mem_‚Ñíp, hf, true_and]
apply lt_of_le_of_lt (snorm_le_mul_snorm_of_ae_le_mul hfg p)
simp [lt_top_iff_ne_top, hg.snorm_ne_top]
intros
simp [snorm']
intros
rw [lintegral_coe_eq_integral f hfi, ennreal.of_real, ennreal.coe_le_coe, real.to_nnreal_le_iff_le_coe]
intros
{ ext1, simp [weighted_smul], }
ext1
simp [weighted_smul]
intros
simp only [‚Üê L1.integral_eq_integral]
{ simp only [‚Üê L1.integral_eq_integral], exact L1.continuous_integral }
exact L1.continuous_integral
intros
simpa only [‚Üê integral_symm] using (integral_has_strict_deriv_at_of_tendsto_ae_right hf.symm hmeas ha).neg
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw lintegral_congr_ae
{ rw lintegral_congr_ae, rw eventually_eq, rwa ae_restrict_iff' hs, }
rw eventually_eq
rwa ae_restrict_iff' hs
intros
conv_lhs { rw [‚Üê sum_smul_dirac Œº, lintegral_sum_measure] }
congr' 1 with a : 1
rw [lintegral_smul_measure, lintegral_dirac, mul_comm]
intros
rw ‚Üê funext L.integral_comp_Lp
{ rw ‚Üê funext L.integral_comp_Lp, exact continuous_integral.comp (L.comp_LpL 1 Œº).continuous, }
exact continuous_integral.comp (L.comp_LpL 1 Œº).continuous
intros
rw [set_to_L1_eq_set_to_L1' hT h_smul, set_to_L1_eq_set_to_L1' hT h_smul]
exact continuous_linear_map.map_smul _ _ _
intros
intros u hu
convert (hs.subtype_image (hc hu)).union (ht.subtype_image (hd hu))
change f ‚Åª¬π' u = coe '' (coe ‚Åª¬π' (f ‚Åª¬π' u) : set s) ‚à™ coe '' (coe ‚Åª¬π' (f ‚Åª¬π' u) : set t)
rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, subtype.range_coe, subtype.range_coe, ‚Üê inter_distrib_left, univ_subset_iff.1 h, inter_univ]
intros
simpa only [ennreal.coe_eq_coe, ‚Üênnreal.coe_eq, haar_content_apply] using is_left_invariant_chaar g K
intros
ext1 s hs
rw [map_apply hf.continuous.measurable hs, restrict_apply hs, hf.hausdorff_measure_preimage hd]
intros
simpa only [prod_univ, region_between, set.preimage, set_of_subset_set_of] using Œª a, and.left
intros
ext1 s hs
have : ‚àÄ y ‚àà s, measurable_set (f ‚Åª¬π' {y})
from Œª y _, hf (measurable_set_singleton _)
simp [‚Üê tsum_measure_preimage_singleton (countable_encodable s) this, *, tsum_subtype s (Œª b, Œº (f ‚Åª¬π' {b})), ‚Üê indicator_mul_right s (Œª b, Œº (f ‚Åª¬π' {b}))]
intros
refine ‚ü®Œª h, h.mono (Œª x hx, _), Œª h, h.mono (Œª x hx, _)‚ü©
{ rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero] at hx, }
rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero] at hx
{ rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero], }
rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero]
intros
refine ‚ü®measure_inter_eq_zero_of_restrict, Œª h, _‚ü©
rcases exists_measurable_superset_of_null h with ‚ü®t', htt', ht', ht'0‚ü©
apply measure_mono_null ((inter_subset _ _ _).1 htt')
rw [restrict_apply (hs.compl.union ht'), union_inter_distrib_right, compl_inter_self, set.empty_union]
exact measure_mono_null (inter_subset_left _ _) ht'0
intros
simpa only [‚Üê measure_eq_trim] using outer_measure.exists_measurable_superset_forall_eq_trim (Œª i, (Œº i).to_outer_measure) s
intros
simp [infi_subtype, infi_and, trim_eq_infi]
intros
refine le_antisymm (le_binfi $ Œª s hs, le_infi $ Œª h2s, Œº.mono hs) _
refine le_of_forall_lt' (Œª r hr, _)
simpa only [infi_lt_iff, exists_prop] using A.exists_is_open_lt_of_lt r hr
intros
obtain ‚ü®u, hmu, hu‚ÇÅ, hu‚ÇÇ‚ü© := h
refine ‚ü®u, hmu, Œª s hs, _, hu‚ÇÇ‚ü©
rw [neg_apply v s, neg_eq_zero]
exact hu‚ÇÅ s hs
intros
{ ext i hi, simp }
ext i hi
simp
intros
have hi‚ÇÅ : measurable_set i := measurable_of_not_restrict_le_zero _ hi
rw [restrict_le_restrict_iff _ _ hi‚ÇÅ] at hi
push_neg at hi
obtain ‚ü®j, hj‚ÇÅ, hj‚ÇÇ, hj‚ü© := hi
exact ‚ü®j, hj‚ÇÅ, hj‚ÇÇ, hj‚ü©
intros
ext1 b
simp only [ennreal.coe_eq_coe.symm, coe_bind_apply, ennreal.tsum_mul_left.symm, ennreal.tsum_mul_right.symm]
rw [ennreal.tsum_comm]
simp [mul_assoc, mul_left_comm, mul_comm]
intros
let e := fintype.equiv_fin Œπ
obtain ‚ü®i‚ÇÄ, i‚ÇÅ, ne, h‚ü© := h.exists_approx_aux (fintype.card Œπ) hŒµ hb (Œª x y, A x (e.symm y))
refine ‚ü®i‚ÇÄ, i‚ÇÅ, ne, Œª k, _‚ü©
convert h (e k); simp only [e.symm_apply_apply]
convert h (e k)
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
intros
ext
simp only [exists_prop, mem_divisors_antidiagonal, finset.mem_map, function.embedding.coe_fn_mk, ne.def, prod.swap_prod_mk, prod.exists]
split
rintros ‚ü®x, y, ‚ü®‚ü®rfl, h‚ü©, rfl‚ü©‚ü©
{ rintros ‚ü®x, y, ‚ü®‚ü®rfl, h‚ü©, rfl‚ü©‚ü©, simp [mul_comm, h], }
simp [mul_comm, h]
rintros ‚ü®rfl, h‚ü©
{ rintros ‚ü®rfl, h‚ü©, use [a.snd, a.fst], rw mul_comm, simp [h] }
use [a.snd, a.fst]
rw mul_comm
simp [h]
intros
{ ext; simp, }
ext
ext; simp
simp
simp
intros
simp [norm_def]
intros
simp [padic_val_nat_def (fact.out p.prime).ne_zero]
intros
change fin 4 at z
fin_cases z; norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
fin_cases z
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
intros
cases n; simp *
cases n
simp *
simp *
intros
refine sdiff_le.lt_of_ne (Œª h, hy _)
rw [sdiff_eq_self_iff_disjoint', disjoint_iff] at h
rw [‚Üêh, inf_eq_right.mpr hx]
intros
rw [closure_sup_closure_left, closure_sup_closure_right]
intros
simpa only [inf_comm] using supr_inf_eq f a
intros
obtain ‚ü®c, hct‚ü© : ‚àÉ c, c ‚àà t := ht
obtain ‚ü®B, hB‚ü© : ‚àÉ B, B ‚àà upper_bounds t := h_bdd
refine hs.out c.2 B.2 ‚ü®_, _‚ü©
{ exact (subtype.mono_coe s).le_cSup_image hct ‚ü®B, hB‚ü© }
exact (subtype.mono_coe s).le_cSup_image hct ‚ü®B, hB‚ü©
{ exact (subtype.mono_coe s).cSup_image_le ‚ü®c, hct‚ü© hB }
exact (subtype.mono_coe s).cSup_image_le ‚ü®c, hct‚ü© hB
intros
rw [supr, gc.l_cSup (range_nonempty _) hf, supr_range']
intros
rw [at_bot_Iic_eq, tendsto_comap_iff]
intros
refine tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono $ Œª x hx, _) tendsto_id
simpa only [pow_one] using pow_le_pow hx hn
intros
simp [filter.frequently]
intros
split
split ; intro h
intro h
rcases h with ‚ü®t, t_in, ht‚ü©
{ rcases h with ‚ü®t, t_in, ht‚ü©, apply mem_of_superset t_in, rintro y y_in _ rfl, apply ht y_in }
apply mem_of_superset t_in
rintro y y_in _ rfl
apply ht y_in
intro h
{ exact ‚ü®_, h, Œª _ x_in, x_in _ rfl‚ü© }
exact ‚ü®_, h, Œª _ x_in, x_in _ rfl‚ü©
intros
rw tendsto_iff_comap at hfg ‚ä¢
calc a ‚â§ comap (g ‚àò f) c : hfg ... ‚â§ comap f b : by simpa [comap_comap] using comap_mono hg
intros
simp only [ne_bot_iff, ne, prod_eq_bot, not_or_distrib]
intros
simp only [imp_iff_not_or, eventually_or_distrib_left]
intros
simp [tendsto_def, function.graph, rtendsto'_def, rel.preimage_def, set.preimage]
{ simp [tendsto_def, function.graph, rtendsto'_def, rel.preimage_def, set.preimage] }
intros
apply lt_of_le_of_ne le_sup_left
intro h
simp at h
exact hx h
intros
apply le_antisymm; simp
apply le_antisymm
simp
simp
intros
rw [disjoint, ‚Üê h.eq_bot, sup_comm]
apply le_inf inf_le_left
apply (inf_le_inf_right (c ‚äî b) le_sup_right).trans
rw [sup_comm, is_modular_lattice.sup_inf_sup_assoc, hsup.eq_bot, bot_sup_eq]
intros
simp_rw [‚Üêsupr_partial_sups_eq f, ‚Üêsupr_partial_sups_eq g, h]
intros
rw [‚Üê e.map_rel_iff, e.apply_symm_apply]
intros
rw [is_wf]
convert h.well_founded_on
ext x y
rw lt_iff_le_and_ne
intros
{ rw add_comm, exact h.add_mul_right_left z }
rw add_comm
exact h.add_mul_right_left z
intros
suffices : span R (of R M '' f.support) ‚â§ (adjoin R (of R M '' f.support)).to_submodule
{ exact this (mem_span_support f) }
exact this (mem_span_support f)
rw submodule.span_le
exact subset_adjoin
intros
ext g
by_cases hg : g ‚àà set.range f
obtain ‚ü®a, rfl‚ü© := hg
{ obtain ‚ü®a, rfl‚ü© := hg, simp }
simp
{ simp [emb_domain_notin_range, hg] }
simp [emb_domain_notin_range, hg]
intros
simp
intros
refine or_iff_not_imp_left.1 (map_eq_top_or_is_maximal_of_surjective f hf.right H) (Œª h, H.1.1 _)
refine or_iff_not_imp_left.1 (map_eq_top_or_is_maximal_of_surjective f hf.right H) (Œª h, H.1.1 _); calc I = comap f (map f I) : ((rel_iso_of_bijective f hf).right_inv I).symm ... = comap f ‚ä§ : by rw h ... = ‚ä§ : by rw comap_top
calc I = comap f (map f I) : ((rel_iso_of_bijective f hf).right_inv I).symm ... = comap f ‚ä§ : by rw h ... = ‚ä§ : by rw comap_top
intros
ext
rw mem_map_iff_of_surjective (ring_hom.snd R S) prod.snd_surjective
exact ‚ü®by { rintro ‚ü®x, ‚ü®h, rfl‚ü©‚ü©, exact h.2 }, Œª h, ‚ü®‚ü®0, x‚ü©, ‚ü®‚ü®ideal.zero_mem _, h‚ü©, rfl‚ü©‚ü©‚ü©
intros
simp [integer_normalization, coeff_monomial, coeff_integer_normalization_of_not_mem_support] {contextual := tt}
intros
simp_rw [algebra.smul_def, mul_comm _ a]
{ simp_rw [algebra.smul_def, mul_comm _ a], apply exists_integer_multiple' }
apply exists_integer_multiple'
intros
simp [inv_fun, add_tmul, finset.sum_add_distrib]
intros
apply dvd_antisymm_of_normalize_eq normalize_content finset.normalize_gcd
rw finset.dvd_gcd_iff
{ rw finset.dvd_gcd_iff, intros i hi, apply content_dvd_coeff _ }
intros i hi
apply content_dvd_coeff _
apply finset.gcd_mono
{ apply finset.gcd_mono, intro i, simp only [nat.lt_succ_iff, mem_support_iff, ne.def, finset.mem_range], contrapose!, intro h1, apply coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le h h1), }
intro i
simp only [nat.lt_succ_iff, mem_support_iff, ne.def, finset.mem_range]
contrapose!
intro h1
apply coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le h h1)
intros
simp only [cyclotomic, h, dif_neg, not_false_iff]
ext i
simp only [coeff_map, int.cast_id, ring_hom.eq_int_cast]
intros
rw [pochhammer_succ_right, polynomial.eval_mul, polynomial.eval_add, polynomial.eval_X, polynomial.eval_nat_cast]
intros
ext x
obtain ‚ü®f, rfl‚ü© := pb.exists_eq_aeval' x
rw [‚Üê polynomial.aeval_alg_hom_apply, ‚Üê polynomial.aeval_alg_hom_apply, h]
intros
simp
intros
simpa using order_monomial_of_ne_zero 0 (1:R) one_ne_zero
intros
ext
{ ext, simp [sin, apply_ite f] }
simp [sin, apply_ite f]
intros
rw [bilin_form.to_matrix_apply, trace_form_apply]
intros
{ dunfold count, split_ifs, refl }
dunfold count
split_ifs
refl
intros
ext
ext; apply commutes_symm'
apply commutes_symm'
intros
unfreezingI { obtain ‚ü®œÜ, hf‚ü© := hf, obtain ‚ü®œà, hg‚ü© := hg }
obtain ‚ü®œÜ, hf‚ü© := hf
obtain ‚ü®œà, hg‚ü© := hg
use (Œª n, bind‚ÇÅ œÜ (œà n))
intros
simp only [peval, aeval_bind‚ÇÅ, function.comp, hg, hf]
intros
simp only [ghost_component_apply, aeval_witt_polynomial]
rw [finset.sum_range_succ', verschiebung_fun_coeff, if_pos rfl, zero_pow (pow_pos hp.1.pos _), mul_zero, add_zero, finset.mul_sum, finset.sum_congr rfl]
rintro i -
simp only [pow_succ, mul_assoc, verschiebung_fun_coeff, if_neg (nat.succ_ne_zero i), nat.succ_sub_succ, nat.sub_zero]
norm_cast
intros
intro hf
apply not_injective_of_ordinal (equiv_shrink Œ± ‚àò f)
exact (equiv_shrink _).injective.comp hf
intros
simpa only [add_zero] using add_sub_cancel a 0
intros
simpa only [mul_one] using mul_div_cancel 1 h
intros
{ cases y, rw mk_lt_mk, tauto }
cases y
rw mk_lt_mk
tauto
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
simp [h]
intros
rw ‚Üê h
rw ‚Üê h; simp
simp
intros
simp only [update, if_pos rfl]
intros
simp [h.symm, horner, pow_add, mul_assoc]
intros
cc
intros
unfold_wf; assumption
unfold_wf
assumption
intros
rw [is_open_iff_of_mem, ‚Üê preimage_compl, compl_compl, preimage_image_eq _ coe_injective]
exact infty_not_mem_image_coe
intros
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_right' n)
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_right' n); [exact (sub_self _).symm, apply_instance, apply_instance]
exact (sub_self _).symm
apply_instance
apply_instance
intros
let W : G ‚Üí set G := Œª x, (Œª y, x * y) ‚Åª¬π' U
have h1W : ‚àÄ x, is_open (W x) := Œª x, hU.preimage (continuous_mul_left x)
have h2W : ‚àÄ x ‚àà K, (1 : G) ‚àà W x := Œª x hx, by simp only [mem_preimage, mul_one, hKU hx]
choose V hV using Œª x : K, exists_open_nhds_one_mul_subset ((h1W x).mem_nhds (h2W x.1 x.2))
let X : K ‚Üí set G := Œª x, (Œª y, (x : G)‚Åª¬π * y) ‚Åª¬π' (V x)
obtain ‚ü®t, ht‚ü© : ‚àÉ t : finset ‚Ü•K, K ‚äÜ ‚ãÉ i ‚àà t, X i
refine hK.elim_finite_subcover X (Œª x, (hV x).1.preimage (continuous_mul_left x‚Åª¬π)) _
{ refine hK.elim_finite_subcover X (Œª x, (hV x).1.preimage (continuous_mul_left x‚Åª¬π)) _, intros x hx, rw [mem_Union], use ‚ü®x, hx‚ü©, rw [mem_preimage], convert (hV _).2.1, simp only [mul_left_inv, subtype.coe_mk] }
intros x hx
rw [mem_Union]
use ‚ü®x, hx‚ü©
rw [mem_preimage]
convert (hV _).2.1
simp only [mul_left_inv, subtype.coe_mk]
refine ‚ü®‚ãÇ x ‚àà t, V x, is_open_bInter (finite_mem_finset _) (Œª x hx, (hV x).1), _, _‚ü©
{ simp only [mem_Inter], intros x hx, exact (hV x).2.1 }
simp only [mem_Inter]
intros x hx
exact (hV x).2.1
rintro _ ‚ü®x, y, hx, hy, rfl‚ü©
simp only [mem_Inter] at hy
have := ht hx
simp only [mem_Union, mem_preimage] at this
rcases this with ‚ü®z, h1z, h2z‚ü©
have : (z : G)‚Åª¬π * x * y ‚àà W z := (hV z).2.2 (mul_mem_mul h2z (hy z h1z))
rw [mem_preimage] at this
convert this using 1
simp only [mul_assoc, mul_inv_cancel_left]
intros
{ rw ‚Üê tsum_zero, exact tsum_lt_tsum hg hi summable_zero hsum }
rw ‚Üê tsum_zero
exact tsum_lt_tsum hg hi summable_zero hsum
intros
simp only [continuous_iff_continuous_at, continuous_at_const_smul_iff]
intros
simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi, mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt _ _ _ _ a, set_of_and]
refine ‚ü®_, _, _‚ü©
intros Œµ Œµ0
{ intros Œµ Œµ0, exact inter_mem_inf (mem_infi_of_mem (a - Œµ) $ mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _)) (mem_infi_of_mem (Œµ + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _)) }
exact inter_mem_inf (mem_infi_of_mem (a - Œµ) $ mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _)) (mem_infi_of_mem (Œµ + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _))
intros b hb
{ intros b hb, exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi])) }
exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi]))
intros b hb
{ intros b hb, exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio])) }
exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio]))
intros
haveI := ha.nhds_within_ne_bot hs
exact ‚ü®ha.mem_upper_bounds_of_tendsto hf hb, Œª b' hb', le_of_tendsto hb (mem_of_superset self_mem_nhds_within $ Œª x hx, hb' $ mem_image_of_mem _ hx)‚ü©
intros
rw [‚Üê comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]
intros
rw continuous_on_iff_continuous_restrict at hf hg
obtain ‚ü®b, h‚ü© := @intermediate_value_univ‚ÇÇ_eventually‚ÇÅ _ _ _ _ _ _ (subtype.preconnected_space hs) ‚ü®a, ha‚ü© _ (comap_coe_ne_bot_of_le_principal hl) _ _ hf hg ha' (eventually_comap' he)
exact ‚ü®b, b.prop, h‚ü©
intros
simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]
intros
rw [‚Üê is_open_compl_iff] at *
{ rw [‚Üê is_open_compl_iff] at *, rw compl_inter, exact is_open.union h‚ÇÅ h‚ÇÇ }
rw compl_inter
exact is_open.union h‚ÇÅ h‚ÇÇ
intros
simp [nhds_def]
intros
{ convert continuous_curry' ‚ü®_, h‚ü©, ext, refl }
convert continuous_curry' ‚ü®_, h‚ü©
ext
refl
intros
rw totally_disconnected_space_iff_connected_component_subsingleton
apply forall_congr (Œª x, _)
rw set.subsingleton_iff_singleton
exact mem_connected_component
intros
letI := topological_space.coinduced (Œª x : t, œÄ x) subtype.topological_space
rcases mem_nhds_iff.mp hs with ‚ü®V, hVs, V_op, mem_V‚ü©
refine mem_nhds_within_iff_exists_mem_nhds_inter.mpr ‚ü®œÄ ‚Åª¬π' V, mem_nhds_iff.mpr ‚ü®t ‚à© œÄ ‚Åª¬π' V, inter_subset_right t (œÄ ‚Åª¬π' V), _, mem_sep h mem_V‚ü©, subset.trans (inter_subset_left _ _) (preimage_mono hVs)‚ü©
obtain ‚ü®u, hu1, hu2‚ü© := is_open_induced_iff.mp (is_open_coinduced.1 V_op)
rw [preimage_comp] at hu2
rw [set.inter_comm, ‚Üê(subtype.preimage_coe_eq_preimage_coe_iff.mp hu2)]
exact hu1.inter ht
intros
simp only [dense_iff_closure_eq, closure_pi_set, pi_congr rfl (Œª i hi, (hs i hi).closure_eq), pi_univ]
intros
rw [continuous_within_at, hx, tendsto_congr' h, continuous_within_at]
intros
ext
{ ext, exact quotient.sound' (B.refl _) }
exact quotient.sound' (B.refl _)
intros
rcases le_or_lt b a with h|h
{ simp [h] }
simp [h]
rw [real.ediam_eq (bounded_Ioo _ _), cSup_Ioo h, cInf_Ioo h]
{ rw [real.ediam_eq (bounded_Ioo _ _), cSup_Ioo h, cInf_Ioo h] }
intros
rw ennreal.Ico_eq_Iio
{ rw ennreal.Ico_eq_Iio, exact is_open_Iio}
exact is_open_Iio
intros
simp only [nhds_bot', mem_Iio, tendsto_infi, tendsto_principal]
intros
rw [nhds_cons, tendsto, map_prod]; exact le_refl _
rw [nhds_cons, tendsto, map_prod]
exact le_refl _
intros
simp_rw [continuous_within_at, ‚Üê @tendsto_map'_iff _ _ _ _ e, e.map_nhds_within_preimage_eq (e.map_target h), (‚àò), e.right_inv h]
intros
rw sUnion_eq_bUnion at hU; exact dense_bUnion_interior_of_closed hc hS hU
rw sUnion_eq_bUnion at hU
exact dense_bUnion_interior_of_closed hc hS hU
intros
simpa using h.holder_on_with.dimH_image_le zero_lt_one
intros
refine le_antisymm _ _
calc _ ‚â§ Hausdorff_edist (closure s) s + Hausdorff_edist s t : Hausdorff_edist_triangle ... = Hausdorff_edist s t : by simp [Hausdorff_edist_comm]
{ calc _ ‚â§ Hausdorff_edist (closure s) s + Hausdorff_edist s t : Hausdorff_edist_triangle ... = Hausdorff_edist s t : by simp [Hausdorff_edist_comm] }
calc _ ‚â§ Hausdorff_edist s (closure s) + Hausdorff_edist (closure s) t : Hausdorff_edist_triangle ... = Hausdorff_edist (closure s) t : by simp
{ calc _ ‚â§ Hausdorff_edist s (closure s) + Hausdorff_edist (closure s) t : Hausdorff_edist_triangle ... = Hausdorff_edist (closure s) t : by simp }
intros
simp [Hausdorff_dist]
intros
apply emetric.diam_le
rintros _ ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©
calc edist (f x) (f y) ‚â§ ‚ÜëK * edist x y : hf.edist_le_mul x y ... ‚â§ ‚ÜëK * emetric.diam s : ennreal.mul_left_mono (emetric.edist_le_diam_of_mem hx hy)
intros
ext
{ ext, simp only [supr, opens.Sup_s, sUnion_image, bUnion_range], refl }
simp only [supr, opens.Sup_s, sUnion_image, bUnion_range]
refl
intros
simp only [mem_closure_iff_frequently, nhds_induced, frequently_comap, mem_image, and_comm]
intros
{ ext t, refl }
ext t
refl
intros
constructor
intro x
apply (h x).to_has_basis
intros i pi
{ intros i pi, exact ‚ü®s x i, ‚ü®(h x).mem_of_mem pi, h' x i pi‚ü©, by refl‚ü© }
exact ‚ü®s x i, ‚ü®(h x).mem_of_mem pi, h' x i pi‚ü©, by refl‚ü©
rintros U ‚ü®U_in, hU‚ü©
{ rintros U ‚ü®U_in, hU‚ü©, rcases (h x).mem_iff.mp U_in with ‚ü®i, pi, hi‚ü©, tauto }
rcases (h x).mem_iff.mp U_in with ‚ü®i, pi, hi‚ü©
tauto
intros
ext u ; dsimp [uniform_space.comap] ; rw [prod.id_prod, filter.comap_id]
ext u ; dsimp [uniform_space.comap]
ext u
dsimp [uniform_space.comap]
rw [prod.id_prod, filter.comap_id]
intros
unfold unfolds
rw [corec_eq]
intros
cases a; cases b; congr; exact funext h
cases a; cases b; congr
cases a; cases b
cases a
cases b
congr
exact funext h
intros
cases b; simp
cases b
simp
simp
intros
have h := int.add_lt_add_right h (-b)
rwa int.add_right_neg at h
intros
rw int.add_comm
exact int.sub_left_lt_of_lt_add h
intros
induction l; intros
{induction l; intros, refl, contradiction}
induction l
refl
contradiction
intros
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'; apply bit_cases_on n; intros b n'; rw bitwise_bit h
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'; apply bit_cases_on n; intros b n'
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'; apply bit_cases_on n
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'
revert m n; induction k with k IH; intros m n; apply bit_cases_on m
revert m n; induction k with k IH; intros m n
revert m n; induction k with k IH
revert m n
induction k with k IH
intros m n
apply bit_cases_on m
intros a m'
apply bit_cases_on n
intros b n'
rw bitwise_bit h
{ simp [test_bit_zero] }
simp [test_bit_zero]
intros m n
apply bit_cases_on m
intros a m'
apply bit_cases_on n
intros b n'
rw bitwise_bit h
{ simp [test_bit_succ, IH] }
simp [test_bit_succ, IH]
intros
rw [div_eq_sub_div H (nat.le_add_left _ _), nat.add_sub_cancel]
intros
by_cases hba : b ‚â§ a
simp [le_antisymm hba h‚ÇÅ]
{ simp [le_antisymm hba h‚ÇÅ] }
by_cases hc0 : c ‚â§ 0
simp [le_antisymm hc0 c.zero_le, nat.mul_zero]
{ simp [le_antisymm hc0 c.zero_le, nat.mul_zero] }
exact (le_not_le_of_lt (nat.mul_lt_mul_of_pos_right (lt_of_le_not_le h‚ÇÅ hba) (lt_of_le_not_le c.zero_le hc0))).left
intros
rw [nat.mul_comm, nat.mul_sub_right_distrib, nat.mul_comm m n, nat.mul_comm n k]
intros
tactic.mk_inj_eq
intros
rw [vadd_eq_vadd_iff_neg_add_eq_vsub, neg_add_eq_sub]
intros
simp [bit1, bit0, add_smul, smul_add]
intros
subst hT; exact set.Union_lift_of_mem x hx
subst hT
exact set.Union_lift_of_mem x hx
intros
haveI := classical.dec_eq Œ±; let s' := ({a, b} : finset Œ±)
haveI := classical.dec_eq Œ±
let s' := ({a, b} : finset Œ±)
have hu : s' ‚äÜ s
refine insert_subset.mpr _
{ refine insert_subset.mpr _, apply and.intro ha, apply singleton_subset_iff.mpr hb }
apply and.intro ha
apply singleton_subset_iff.mpr hb
have hf : ‚àÄ c ‚àà s, c ‚àâ s' ‚Üí f c = 1
intros c hc hcs
{ intros c hc hcs, apply h‚ÇÄ c hc, apply not_or_distrib.mp, intro hab, apply hcs, apply mem_insert.mpr, rw mem_singleton, exact hab }
apply h‚ÇÄ c hc
apply not_or_distrib.mp
intro hab
apply hcs
apply mem_insert.mpr
rw mem_singleton
exact hab
rw ‚Üêprod_subset hu hf
exact finset.prod_pair hn
intros
simp
intros
rw abelian.exact_iff' f g (kernel_is_limit _) (cokernel_is_colimit _)
exact ‚ü®Œª h, le_antisymm (range_le_ker_iff.2 h.1) (ker_le_range_iff.2 h.2), Œª h, ‚ü®range_le_ker_iff.1 $ le_of_eq h, ker_le_range_iff.1 $ le_of_eq h.symm‚ü©‚ü©
intros
rcases (exists_rat_eq_nth_numerator v n) with ‚ü®A‚Çô, nth_num_eq‚ü©
rcases (exists_rat_eq_nth_denominator v n) with ‚ü®B‚Çô, nth_denom_eq‚ü©
use (A‚Çô / B‚Çô)
simp [nth_num_eq, nth_denom_eq, convergent_eq_num_div_denom]
intros
cases s_succ_nth_eq : s.nth (n + 1)
rw (squash_seq_eq_self_of_terminated s_succ_nth_eq)
case option.none { rw (squash_seq_eq_self_of_terminated s_succ_nth_eq) }
case option.some { obtain ‚ü®gp_n, s_nth_eq‚ü© : ‚àÉ gp_n, s.nth n = some gp_n, from s.ge_stable n.le_succ s_succ_nth_eq, obtain ‚ü®gp_m, s_mth_eq‚ü© : ‚àÉ gp_m, s.nth m = some gp_m, from s.ge_stable (le_of_lt m_lt_n) s_nth_eq, simp [*, squash_seq, (seq.zip_with_nth_some (seq.nats_nth m) s_mth_eq _), (ne_of_lt m_lt_n)] }
obtain ‚ü®gp_n, s_nth_eq‚ü© : ‚àÉ gp_n, s.nth n = some gp_n
from s.ge_stable n.le_succ s_succ_nth_eq
obtain ‚ü®gp_m, s_mth_eq‚ü© : ‚àÉ gp_m, s.nth m = some gp_m
from s.ge_stable (le_of_lt m_lt_n) s_nth_eq
simp [*, squash_seq, (seq.zip_with_nth_some (seq.nats_nth m) s_mth_eq _), (ne_of_lt m_lt_n)]
intros
simp [partial_denominators, s_nth_eq]
intros
{ unfold gcd_a, rw [xgcd, xgcd_zero_left] }
unfold gcd_a
rw [xgcd, xgcd_zero_left]
intros
simp only [sub_eq_add_neg]
rw [neg_eq_neg_one_mul, ‚Üê mul_div_assoc, div_add_div _ _ hb hd, ‚Üê mul_assoc, mul_comm b, mul_assoc, ‚Üê neg_eq_neg_one_mul]
intros
{ subst hs, exact finset.fold_congr hfg }
subst hs
exact finset.fold_congr hfg
intros
simp [h.symm]
intros
simp [‚Üê h]
intros
rw [eq_sub_iff_add_eq, add_comm]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
congr'
congr'; injection h
injection h
injection h
injection h
intros
cases ha with a ha; rw [‚Üêha, units.mul_right_inj]
cases ha with a ha
rw [‚Üêha, units.mul_right_inj]
intros
rw [div_eq_mul_inv, zero_mul]
intros
refine ‚ü®by simp, _‚ü©
apply @is_iso.epi_of_iso _ _ _ _ _ _
exact ‚ü®‚ü®factor_thru_image_subobject _, by { ext, simp, }, by { ext, simp, }‚ü©‚ü©
intros
change ite (1 = 0 + 1) (d‚ÇÄ ‚â´ ùüô X‚ÇÅ) 0 = d‚ÇÄ
{ change ite (1 = 0 + 1) (d‚ÇÄ ‚â´ ùüô X‚ÇÅ) 0 = d‚ÇÄ, rw [if_pos rfl, category.comp_id] }
rw [if_pos rfl, category.comp_id]
intros
funext
simp only [mul_indicator]
split_ifs; simp [*]
split_ifs
simp [*]
simp [*]
intros
rw is_semisimple_iff_no_abelian_ideals at h
{ rw is_semisimple_iff_no_abelian_ideals at h, apply h, apply_instance, }
apply h
apply_instance
intros
let s := {k | derived_series_of_ideal R L k I = ‚ä•}
change Inf s = 0 ‚Üî _
have hne : s ‚â† ‚àÖ
rw set.ne_empty_iff_nonempty
{ rw set.ne_empty_iff_nonempty, tactic.unfreeze_local_instances, obtain ‚ü®k, hk‚ü© := hI, use k, rw [derived_series_def, lie_ideal.derived_series_eq_bot_iff] at hk, exact hk, }
obtain ‚ü®k, hk‚ü© := hI
tactic.unfreeze_local_instances
use k
rw [derived_series_def, lie_ideal.derived_series_eq_bot_iff] at hk
exact hk
simp [hne]
intros
{ rw submodule.span_le, apply subset_lie_span, }
rw submodule.span_le
apply subset_lie_span
intros
{ rw submodule.span_le, apply subset_lie_span, }
rw submodule.span_le
apply subset_lie_span
intros
suffices : lie_ideal.map f (I ‚äî f.ker) ‚â§ lie_ideal.map f I
exact le_antisymm this (lie_ideal.map_mono le_sup_left)
{ exact le_antisymm this (lie_ideal.map_mono le_sup_left), }
apply lie_submodule.lie_span_mono
rintros x ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©
rw ‚Üê hy‚ÇÇ
erw lie_submodule.mem_sup at hy‚ÇÅ
obtain ‚ü®z‚ÇÅ, hz‚ÇÅ, z‚ÇÇ, hz‚ÇÇ, hy‚ü© := hy‚ÇÅ
rw ‚Üê hy
rw [f.coe_to_linear_map, f.map_add, f.mem_ker.mp hz‚ÇÇ, add_zero]
exact ‚ü®z‚ÇÅ, hz‚ÇÅ, rfl‚ü©
intros
rw [nsmul_eq_smul_cast ‚Ñï n x, nat.cast_id]
intros
rw [‚Üê set_like.mem_coe, infi_coe, set.mem_Inter]
rw [‚Üê set_like.mem_coe, infi_coe, set.mem_Inter]; refl
refl
intros
simp
intros
{ ext, refl, }
ext
refl
intros
rw [‚Üê one_div, div_le_iff ha, ‚Üê div_eq_inv_mul, le_div_iff hb, one_mul]
intros
simpa using lt_inv_of_neg ha hb
intros
refine (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn)
refine (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn); exact pow_pos (zero_lt_one.trans_le a1) _
exact pow_pos (zero_lt_one.trans_le a1) _
exact pow_pos (zero_lt_one.trans_le a1) _
intros
{ rw ‚Üê mul_le_mul_iff_left a, simp }
rw ‚Üê mul_le_mul_iff_left a
simp
intros
rw [‚Üê mul_lt_mul_iff_right b, one_mul, inv_mul_cancel_right]
intros
rw [div_eq_mul_inv, lt_mul_inv_iff_mul_lt, inv_mul_lt_iff_lt_mul]
intros
norm_cast
intros
haveI := @linear_order.decidable_le Œ± _; exact lt_of_not_ge (Œª ha, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
haveI := @linear_order.decidable_le Œ± _
exact lt_of_not_ge (Œª ha, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
intros
simpa only [sub_eq_add_neg, antiperiodic] using h.sub_eq
intros
induction n with n ih
rw pow_zero
{ rw pow_zero, exact set.mem_singleton 1 }
exact set.mem_singleton 1
rw pow_succ
{ rw pow_succ, exact set.mul_mem_mul ha ih }
exact set.mul_mem_mul ha ih
intros
{ simp only [finset.mem_mul], exact ‚ü®x, y, hx, hy, rfl‚ü© }
simp only [finset.mem_mul]
exact ‚ü®x, y, hx, hy, rfl‚ü©
intros
refine Œª x y xy, ab (_ : x * (b * a) = y * (b * a))
rw [‚Üê mul_assoc, ‚Üê mul_assoc]
exact congr_fun (congr_arg has_mul.mul xy) a
intros
split_ifs; refl
split_ifs
refl
refl
intros
simp
intros
rw [mul_support_comp_eq_preimage f g, image_inter_preimage]
intros
intros s t h_eq
obtain ‚ü®a, ‚ü®b, hb‚ü©, rfl‚ü© := is_localization.mk'_surjective (submonoid.powers f) s
obtain ‚ü®c, ‚ü®d, hd‚ü©, rfl‚ü© := is_localization.mk'_surjective (submonoid.powers f) t
simp only [to_basic_open_mk'] at h_eq
rw is_localization.eq
let I : ideal R := { carrier := {r : R | a * d * r = c * b * r}, zero_mem' := by simp only [set.mem_set_of_eq, mul_zero], add_mem' := Œª r‚ÇÅ r‚ÇÇ hr‚ÇÅ hr‚ÇÇ, by { dsimp at hr‚ÇÅ hr‚ÇÇ ‚ä¢, simp only [mul_add, hr‚ÇÅ, hr‚ÇÇ] }, smul_mem' := Œª r‚ÇÅ r‚ÇÇ hr‚ÇÇ, by { dsimp at hr‚ÇÇ ‚ä¢, simp only [mul_comm r‚ÇÅ r‚ÇÇ, ‚Üê mul_assoc, hr‚ÇÇ] }}
suffices : f ‚àà I.radical
cases this with n hn
{ cases this with n hn, exact ‚ü®‚ü®f ^ n, n, rfl‚ü©, hn‚ü© }
exact ‚ü®‚ü®f ^ n, n, rfl‚ü©, hn‚ü©
rw [‚Üê vanishing_ideal_zero_locus_eq_radical, mem_vanishing_ideal]
intros p hfp
contrapose hfp
rw [mem_zero_locus, set.not_subset]
have := congr_fun (congr_arg subtype.val h_eq) ‚ü®p,hfp‚ü©
rw [const_apply, const_apply, is_localization.eq] at this
cases this with r hr
exact ‚ü®r.1, hr, r.2‚ü©
intros
ext j
rcases i with ‚ü®i, _‚ü©
rcases j with ‚ü®j, _‚ü©
dsimp [Œ¥, œÉ, fin.succ_above, fin.pred_above]
simp [fin.pred_above] with push_cast
split_ifs; { simp at *; linarith, }
split_ifs
{ simp at *; linarith, }
{ simp at *; linarith, }
{ simp at *; linarith, }
simp at *
simp at *; linarith
{ simp at *; linarith, }
linarith
intros
simp only [change_origin_series_term, linear_isometry_equiv.nnnorm_map]
intros
ext1 n
by_cases hn : n = 0
rw [hn, h]
{ rw [hn, h], ext v, rw [comp_coeff_zero', id_apply_ne_one _ _ zero_ne_one], refl }
ext v
rw [comp_coeff_zero', id_apply_ne_one _ _ zero_ne_one]
refl
dsimp [formal_multilinear_series.comp]
{ dsimp [formal_multilinear_series.comp], have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn, rw finset.sum_eq_single (composition.single n n_pos), show comp_along_composition (id ùïú F) p (composition.single n n_pos) = p n, { ext v, rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)], dsimp [apply_composition], refine p.congr rfl (Œª i him hin, congr_arg v $ _), ext, simp }, show ‚àÄ (b : composition n), b ‚àà finset.univ ‚Üí b ‚â† composition.single n n_pos ‚Üí comp_along_composition (id ùïú F) p b = 0, { assume b _ hb, have A : b.length ‚â† 1, by simpa [composition.eq_single_iff_length] using hb, ext v, rw [comp_along_composition_apply, id_apply_ne_one _ _ A], refl }, { simp } }
have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn
rw finset.sum_eq_single (composition.single n n_pos)
show comp_along_composition (id ùïú F) p (composition.single n n_pos) = p n
ext v
{ ext v, rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)], dsimp [apply_composition], refine p.congr rfl (Œª i him hin, congr_arg v $ _), ext, simp }
rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)]
dsimp [apply_composition]
refine p.congr rfl (Œª i him hin, congr_arg v $ _)
ext
simp
show ‚àÄ (b : composition n), b ‚àà finset.univ ‚Üí b ‚â† composition.single n n_pos ‚Üí comp_along_composition (id ùïú F) p b = 0
assume b _ hb
{ assume b _ hb, have A : b.length ‚â† 1, by simpa [composition.eq_single_iff_length] using hb, ext v, rw [comp_along_composition_apply, id_apply_ne_one _ _ A], refl }
have A : b.length ‚â† 1
simpa [composition.eq_single_iff_length] using hb
simpa [composition.eq_single_iff_length] using hb
ext v
rw [comp_along_composition_apply, id_apply_ne_one _ _ A]
refl
{ simp }
simp
intros
rw left_inv
intros
simp only [is_o, is_O_with_map]
intros
simp [div_eq_inv_mul, differentiable_on.const_mul, hc]
intros
simp [deriv_within]
intros
simp only [‚Üê deriv_within_univ, deriv_within_const_sub unique_diff_within_at_univ]
intros
simp only [add_comm c, fderiv_add_const]
intros
rw add_comm
exact (is_bounded_bilinear_map_comp.has_strict_fderiv_at (d x, c x)).comp x (hd.prod hc)
intros
{ rw ‚Üê H at h, exact h }
rw ‚Üê H at h
exact h
intros
have A : f‚ÇÅ x = f x := hL.eq_of_nhds
rw [‚Üê fderiv_within_univ, ‚Üê fderiv_within_univ]
rw ‚Üê nhds_within_univ at hL
exact hL.fderiv_within_eq unique_diff_within_at_univ A
intros
{ cases h1, congr' with ‚ü®i, hi‚ü©, exact h2 i hi hi }
cases h1
congr' with ‚ü®i, hi‚ü©
exact h2 i hi hi
intros
have A : has_deriv_within_at (f_aux n) (0 : ‚Ñù) (Iic 0) 0
apply (has_deriv_at_const (0 : ‚Ñù) (0 : ‚Ñù)).has_deriv_within_at.congr
{ apply (has_deriv_at_const (0 : ‚Ñù) (0 : ‚Ñù)).has_deriv_within_at.congr, { assume y hy, simp at hy, simp [f_aux, hy] }, { simp [f_aux, le_refl] } }
assume y hy
{ assume y hy, simp at hy, simp [f_aux, hy] }
simp at hy
simp [f_aux, hy]
{ simp [f_aux, le_refl] }
simp [f_aux, le_refl]
have B : has_deriv_within_at (f_aux n) (0 : ‚Ñù) (Ici 0) 0
have diff : differentiable_on ‚Ñù (f_aux n) (Ioi 0) := Œªx hx, (f_aux_deriv_pos n x hx).differentiable_at.differentiable_within_at
{ have diff : differentiable_on ‚Ñù (f_aux n) (Ioi 0) := Œªx hx, (f_aux_deriv_pos n x hx).differentiable_at.differentiable_within_at, apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within, { refine (f_aux_limit (n+1)).congr' _, apply mem_of_superset self_mem_nhds_within (Œªx hx, _), simp [(f_aux_deriv_pos n x hx).deriv] }, { have : f_aux n 0 = 0, by simp [f_aux, le_refl], simp only [continuous_within_at, this], refine (f_aux_limit n).congr' _, apply mem_of_superset self_mem_nhds_within (Œªx hx, _), have : ¬¨(x ‚â§ 0), by simpa using hx, simp [f_aux, this] } }
apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within
refine (f_aux_limit (n+1)).congr' _
{ refine (f_aux_limit (n+1)).congr' _, apply mem_of_superset self_mem_nhds_within (Œªx hx, _), simp [(f_aux_deriv_pos n x hx).deriv] }
apply mem_of_superset self_mem_nhds_within (Œªx hx, _)
simp [(f_aux_deriv_pos n x hx).deriv]
have : f_aux n 0 = 0
{ have : f_aux n 0 = 0, by simp [f_aux, le_refl], simp only [continuous_within_at, this], refine (f_aux_limit n).congr' _, apply mem_of_superset self_mem_nhds_within (Œªx hx, _), have : ¬¨(x ‚â§ 0), by simpa using hx, simp [f_aux, this] }
simp [f_aux, le_refl]
simp [f_aux, le_refl]
simp only [continuous_within_at, this]
refine (f_aux_limit n).congr' _
apply mem_of_superset self_mem_nhds_within (Œªx hx, _)
have : ¬¨(x ‚â§ 0)
simpa using hx
simpa using hx
simp [f_aux, this]
simpa using A.union B
intros
{ rw [subsingleton.elim f (Œª _, 0)], exact times_cont_diff_const }
rw [subsingleton.elim f (Œª _, 0)]
exact times_cont_diff_const
intros
cases le_total x y
{ rw [segment_eq_Icc h, max_eq_right h, min_eq_left h] }
rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]
rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]
{ rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h] }
intros
rintro x y ‚ü®x', ‚ü®hx', hx'f‚ü©‚ü© ‚ü®y', ‚ü®hy', hy'f‚ü©‚ü© a b ha hb hab
refine ‚ü®a ‚Ä¢ x' + b ‚Ä¢ y', ‚ü®hs hx' hy' ha hb hab, _‚ü©‚ü©
rw [convex.combo_affine_apply hab, hx'f, hy'f]
intros
rw [‚Üê convex_hull_basis_eq_std_simplex, ‚Üê linear_map.convex_hull_image, ‚Üê set.range_comp, (‚àò)]
apply congr_arg
convert subtype.range_coe.symm
ext x
simp [linear_map.sum_apply, ite_smul, finset.filter_eq]
intros
cases S; cases T; congr'
cases S; cases T
cases S
cases T
congr'
intros
ext
rw [submodule.mem_bot, submodule.mem_orthogonal]
exact ‚ü®Œª h, inner_self_eq_zero.mp (h x submodule.mem_top), by { rintro rfl, simp }‚ü©
intros
convert inner_sum l.support (Œª a, l a ‚Ä¢ v a) x
{ convert inner_sum l.support (Œª a, l a ‚Ä¢ v a) x, simp [inner_smul_right, finsupp.sum] }
simp [inner_smul_right, finsupp.sum]
intros
rw [‚Üê inner_conj_sym, hv.inner_right_finsupp]
intros
{ rw [(hf.has_fderiv_at.inner hg.has_fderiv_at).fderiv], refl }
rw [(hf.has_fderiv_at.inner hg.has_fderiv_at).fderiv]
refl
intros
nth_rewrite 0 eq_sum_orthogonal_projection_self_orthogonal_complement K v
nth_rewrite 1 eq_sum_orthogonal_projection_self_orthogonal_complement K u
rw [inner_add_left, inner_add_right, submodule.inner_right_of_mem_orthogonal (submodule.coe_mem (orthogonal_projection K u)) (submodule.coe_mem (orthogonal_projection K·óÆ v)), submodule.inner_left_of_mem_orthogonal (submodule.coe_mem (orthogonal_projection K v)) (submodule.coe_mem (orthogonal_projection K·óÆ u))]
intros
rw [midpoint_comm, dist_midpoint_left, dist_comm]
intros
simpa only [is_unit_iff_ne_zero] using punctured_nhds_ne_bot (0:Œ±)
intros
refine set.subset.antisymm _ ball_subset_interior_closed_ball
intros y hy
rcases le_iff_lt_or_eq.1 (mem_closed_ball.1 $ interior_subset hy) with hr|rfl
exact hr
{ exact hr }
set f : ‚Ñù ‚Üí E := Œª c : ‚Ñù, c ‚Ä¢ (y - x) + x
suffices : f ‚Åª¬π' closed_ball x (dist y x) ‚äÜ set.Icc (-1) 1
have hfc : continuous f := (continuous_id.smul continuous_const).add continuous_const
{ have hfc : continuous f := (continuous_id.smul continuous_const).add continuous_const, have hf1 : (1:‚Ñù) ‚àà f ‚Åª¬π' (interior (closed_ball x $ dist y x)), by simpa [f], have h1 : (1:‚Ñù) ‚àà interior (set.Icc (-1:‚Ñù) 1) := interior_mono this (preimage_interior_subset_interior_preimage hfc hf1), contrapose h1, simp }
have hf1 : (1:‚Ñù) ‚àà f ‚Åª¬π' (interior (closed_ball x $ dist y x))
simpa [f]
simpa [f]
have h1 : (1:‚Ñù) ‚àà interior (set.Icc (-1:‚Ñù) 1) := interior_mono this (preimage_interior_subset_interior_preimage hfc hf1)
contrapose h1
simp
intros c hc
rw [set.mem_Icc, ‚Üê abs_le, ‚Üê real.norm_eq_abs, ‚Üê mul_le_mul_right hr]
simpa [f, dist_eq_norm, norm_smul] using hc
intros
simp_rw ‚Üê sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l)
exact summable_norm_sum_mul_antidiagonal_of_summable_norm hf hg
intros
simp only [isometry_emetric_iff_metric, dist_eq_norm, ‚Üê f.map_sub]
refine ‚ü®Œª h x, _, Œª h x y, h _‚ü©
simpa using h x 0
intros
rw lt_iff_le_and_ne
simp only [norm_nonneg, true_and]
rw [ne_comm]
exact not_iff_not_of_iff (norm_eq_zero_iff')
intros
rw ‚Üê exp_series_apply_eq_field'
exact exp_series_has_sum_exp_of_mem_ball x hx
intros
by_cases hc : c = 0
{ simp_rw [hc, smul_zero], exact is_closed_map_const }
simp_rw [hc, smul_zero]
exact is_closed_map_const
{ exact (closed_embedding_smul_left hc).is_closed_map }
exact (closed_embedding_smul_left hc).is_closed_map
intros
refine norm_id_of_nontrivial_seminorm V _
obtain ‚ü®x, hx‚ü© := exists_ne (0 : V)
exact ‚ü®x, ne_of_gt (norm_pos_iff.2 hx)‚ü©
intros
ext x
rw [normed_group_hom.coe_comp, normed_group_hom.completion_def, normed_group_hom.completion_coe_to_fun, normed_group_hom.completion_coe_to_fun, completion.map_comp (normed_group_hom.uniform_continuous _) (normed_group_hom.uniform_continuous _)]
refl
intros
rw hquot.norm
apply cInf_le
use 0
{ use 0, rintros _ ‚ü®m', hm', rfl‚ü©, apply norm_nonneg }
rintros _ ‚ü®m', hm', rfl‚ü©
apply norm_nonneg
{ exact ‚ü®0, f.ker.zero_mem, by simp‚ü© }
exact ‚ü®0, f.ker.zero_mem, by simp‚ü©
intros
simpa only [log, arg_eq_pi_iff.2 ‚ü®hre, him‚ü©] using (continuous_within_at_log_of_re_neg_of_im_zero hre him).tendsto
rw [‚Üê map_exp_at_bot, comap_map exp_injective]
intros
field_simp [integral_cos_pow, add_sub_assoc]
intros
rw ‚Üê has_deriv_within_at_univ at *
exact hf.rpow_const hx
intros
simp_rw ennreal.of_real
rw [coe_rpow_of_ne_zero, coe_eq_coe, real.to_nnreal_rpow_of_nonneg hx_pos.le]
simp [hx_pos]
intros
convert rpow_le_rpow_of_exponent_le hx hz
{ convert rpow_le_rpow_of_exponent_le hx hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
intros
induction n with n ihn generalizing p
exact times_cont_diff_zero.2 (continuous_id.rpow_const (Œª x, or.inr h))
{ exact times_cont_diff_zero.2 (continuous_id.rpow_const (Œª x, or.inr h)) }
have h1 : 1 ‚â§ p
{ have h1 : 1 ‚â§ p, from le_trans (by simp) h, rw [nat.cast_succ, ‚Üê le_sub_iff_add_le] at h, simpa [times_cont_diff_succ_iff_deriv, differentiable_rpow_const, h1, deriv_rpow_const'] using times_cont_diff_const.mul (ihn h) }
from le_trans (by simp) h
rw [nat.cast_succ, ‚Üê le_sub_iff_add_le] at h
simpa [times_cont_diff_succ_iff_deriv, differentiable_rpow_const, h1, deriv_rpow_const'] using times_cont_diff_const.mul (ihn h)
simp [cos_add]
intros
cases le_or_gt x 1 with h' h'
have hx : abs x = x := abs_of_nonneg (le_of_lt h)
{ have hx : abs x = x := abs_of_nonneg (le_of_lt h), have : abs x ‚â§ 1, rwa [hx], have := sin_bound this, rw [abs_le] at this, have := this.2, rw [sub_le_iff_le_add', hx] at this, apply lt_of_le_of_lt this, rw [sub_add], apply lt_of_lt_of_le _ (le_of_eq (sub_zero x)), apply sub_lt_sub_left, rw [sub_pos, div_eq_mul_inv (x ^ 3)], apply mul_lt_mul', { rw [pow_succ x 3], refine le_trans _ (le_of_eq (one_mul _)), rw mul_le_mul_right, exact h', apply pow_pos h }, norm_num, norm_num, apply pow_pos h }
have : abs x ‚â§ 1
rwa [hx]
have := sin_bound this
rw [abs_le] at this
have := this.2
rw [sub_le_iff_le_add', hx] at this
apply lt_of_le_of_lt this
rw [sub_add]
apply lt_of_lt_of_le _ (le_of_eq (sub_zero x))
apply sub_lt_sub_left
rw [sub_pos, div_eq_mul_inv (x ^ 3)]
apply mul_lt_mul'
rw [pow_succ x 3]
{ rw [pow_succ x 3], refine le_trans _ (le_of_eq (one_mul _)), rw mul_le_mul_right, exact h', apply pow_pos h }
refine le_trans _ (le_of_eq (one_mul _))
rw mul_le_mul_right
exact h'
apply pow_pos h
apply pow_pos h
norm_num
norm_num
apply pow_pos h
apply pow_pos h
exact lt_of_le_of_lt (sin_le_one x) h'
intros
rw tan_eq_sin_div_cos; exact div_pos (sin_pos_of_pos_of_lt_pi h0x (by linarith)) (cos_pos_of_mem_Ioo ‚ü®by linarith, hxp‚ü©)
rw tan_eq_sin_div_cos
exact div_pos (sin_pos_of_pos_of_lt_pi h0x (by linarith)) (cos_pos_of_mem_Ioo ‚ü®by linarith, hxp‚ü©)
intros
rw [‚Üê not_exists, not_iff_not, sin_eq_zero_iff]
intros
rw [arccos, sub_eq_iff_eq_add, ‚Üê sub_eq_iff_eq_add', div_two_sub_self, neg_pi_div_two_eq_arcsin]
intros
have : ‚àÄ i, 0 ‚â§ (1 / (2 : ‚Ñù)) ^ i
{ intro i, apply pow_nonneg, norm_num }
intro i
apply pow_nonneg
norm_num
convert sum_le_tsum (range n) (Œª i _, this i) summable_geometric_two
exact tsum_geometric_two.symm
intros
rw [‚Üêcategory.assoc, is_iso.hom_inv_id]
intros
{ rw [pseudo_zero_def, pseudo_apply_mk], simp }
rw [pseudo_zero_def, pseudo_apply_mk]
simp
intros
simp only [‚Üêmk_hom f, lift.fac_left]
intros
split
intros Z a b w
apply (cancel_epi g).1
apply (cancel_epi f).1
simpa using w
intros
erw [nat_iso.naturality_1]
refl
intros
ext
{ ext, simp, }
simp
intros
{ dsimp [cocone_of_cone_left_op], simp }
dsimp [cocone_of_cone_left_op]
simp
intros
dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim]
simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_inv_œÄ, iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_œÄ_œÄ, eq_to_iso_refl, category.assoc]
erw [nat_trans.id_app]
dsimp
simp
intros
simp
intros
simp
intros
simp [is_iso.inv_comp_eq]
intros
tidy
intros
letI := is_coreflexive_pair.mk' r fr gr
apply_instance
intros
haveI := t.split_mono_from f; apply_instance
haveI := t.split_mono_from f
apply_instance
intros
apply (colimit_equiv_quot F).symm.injective
simp
intros
{ rw ‚Üêtensor_comp, simp }
rw ‚Üêtensor_comp
simp
intros
rw [‚Üêtensor_comp, f.inv_hom_id]
intros
simp only [‚Üêcategory.assoc, cancel_mono]
intros
{ rw [‚Üê app_hom_apply, add_monoid_hom.map_sum], refl }
rw [‚Üê app_hom_apply, add_monoid_hom.map_sum]
refl
intros
classical
by_contradiction h
haveI := is_iso_of_mono_of_nonzero h
exact w (eq_zero_of_epi_kernel f)
intros
refine @is_glb.of_image _ _ _ _ sieves _ _ _ _
{ intros, refl }
intros
refl
{ exact is_glb_Inf _ }
exact is_glb_Inf _
intros
intros x hx
refine ‚ü®x _ (presieve.singleton_self _), _, _‚ü©
rintro _ _ ‚ü®rfl, rfl‚ü©
{ rintro _ _ ‚ü®rfl, rfl‚ü©, simp }
simp
intros t ht
{ intros t ht, simpa using ht _ (presieve.singleton_self _) }
simpa using ht _ (presieve.singleton_self _)
intros
ext Z g
split
rintro ‚ü®_, h, k, hk, rfl‚ü©
{ rintro ‚ü®_, h, k, hk, rfl‚ü©, cases hk with W g hg, change (sieve.generate R).pullback f (h ‚â´ pullback.snd), rw [sieve.pullback_apply, assoc, ‚Üê pullback.condition, ‚Üê assoc], exact sieve.downward_closed _ (sieve.le_generate R W hg) (h ‚â´ pullback.fst)}
cases hk with W g hg
change (sieve.generate R).pullback f (h ‚â´ pullback.snd)
rw [sieve.pullback_apply, assoc, ‚Üê pullback.condition, ‚Üê assoc]
exact sieve.downward_closed _ (sieve.le_generate R W hg) (h ‚â´ pullback.fst)
rintro ‚ü®W, h, k, hk, comm‚ü©
{ rintro ‚ü®W, h, k, hk, comm‚ü©, exact ‚ü®_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm‚ü© }
exact ‚ü®_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm‚ü©
intros
{ apply (cancel_mono f).mp, simp }
apply (cancel_mono f).mp
simp
intros
{ ext, simp, }
ext
simp
intros
have n_pos : 0 < n := lt_of_le_of_lt (zero_le j) h
have : 0 < c.blocks.sum
rwa [‚Üê c.blocks_sum] at n_pos
rwa [‚Üê c.blocks_sum] at n_pos
have length_pos : 0 < c.blocks.length := length_pos_of_sum_pos (blocks c) this
refine ‚ü®c.length.pred, _, nat.pred_lt (ne_of_gt length_pos)‚ü©
have : c.length.pred.succ = c.length := nat.succ_pred_eq_of_pos length_pos
simp [this, h]
intros
{ funext i, cases i; refl }
funext i
cases i
cases i; refl
refl
refl
intros
simp [incidence_set]
intros
haveI h : decidable_eq V
classical
{ classical, apply_instance }
apply_instance
simp only [‚Üêcard_univ, ‚Üêdart_fst_fiber_card_eq_degree]
exact card_eq_sum_card_fiberwise (by simp)
intros
refl
intros
induction k generalizing v
case halt : { simp only [mem_eval, cont.eval, map_pure], exact part.eq_some_iff.2 (mem_eval.2 ‚ü®refl_trans_gen.refl, rfl‚ü©) }
simp only [mem_eval, cont.eval, map_pure]
exact part.eq_some_iff.2 (mem_eval.2 ‚ü®refl_trans_gen.refl, rfl‚ü©)
case cons‚ÇÅ : fs as k IH { rw [cont.eval, step_ret, code_is_ok], simp only [‚Üê bind_pure_comp_eq_map, bind_assoc], congr, funext v', rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [step_ret, IH, bind_pure_comp_eq_map] }
case cons‚ÇÇ : ns k IH { rw [cont.eval, step_ret], exact IH }
case comp : f k IH { rw [cont.eval, step_ret, code_is_ok], simp only [‚Üê bind_pure_comp_eq_map, bind_assoc], congr, funext v', rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [IH, bind_pure_comp_eq_map] }
case fix : f k IH { rw [cont.eval, step_ret], simp only [bind_pure_comp_eq_map], split_ifs, { exact IH }, simp only [‚Üê bind_pure_comp_eq_map, bind_assoc, cont_eval_fix (code_is_ok _)], congr, funext, rw [bind_pure_comp_eq_map, ‚Üê IH], exact reaches_eval (refl_trans_gen.single rfl) }
intros
cases l; [exact (pointed_map.map_pt f).symm, refl]
cases l
exact (pointed_map.map_pt f).symm
refl
intros
simp only [mjoin, (‚àò), id.def, map_bind, (bind_pure_comp_eq_map _ _).symm, bind_assoc, pure_bind, bind_pure]
intros
simpa [equiv_functor.map_equiv]
intros
ext
ext;rw traverse_eq_map_id
rw traverse_eq_map_id
intros
rw [list.foldr_reverse, flip]; refl
rw [list.foldr_reverse, flip]
refl
intros
rw [‚Üêto_buffer_to_list b, to_list_to_buffer, size_to_buffer]
intros
cases h : p cb n; simp [decorate_errors, h]
cases h : p cb n
simp [decorate_errors, h]
simp [decorate_errors, h]
intros
simp [‚Üêbind_pure_comp_eq_map, pure_eq_done]
intros
simp [many_char, list.as_string_eq, string.to_list_nonempty h, many_eq_done]
intros
simp
intros
simp [inv_def, division_def]
intros
rw [‚Üê of_real_int_cast, abs_of_real, int.cast_abs]
intros
rw [‚Üê tan_mul_cos hx.ne', ‚Üê inv_sqrt_one_add_tan_sq hx, div_eq_mul_inv]
intros
rw [‚Üê mul_right_inj' (exp_ne_zero x), ‚Üê exp_add]
rw [‚Üê mul_right_inj' (exp_ne_zero x), ‚Üê exp_add]; simp [mul_inv_cancel (exp_ne_zero x)]
simp [mul_inv_cancel (exp_ne_zero x)]
intros
rw ‚Üê cosh_sq_sub_sinh_sq x
ring
intros
rw [tan_eq_sin_div_cos, div_mul_cancel _ hx]
intros
simp only [mul_re, of_real_im, zero_mul, of_real_re, sub_zero]
intros
rw [inv_def, ‚Üêmul_assoc, mul_conj, ‚Üêof_real_mul, ‚Üênorm_sq_eq_def', mul_inv_cancel (mt norm_sq_eq_zero.1 h), of_real_one]
intros
ext ‚ü®x, y‚ü©
simp only [mk_eq_add_mul_I, alg_hom.map_add, alg_hom.map_coe_real_complex, alg_hom.map_mul, h]
intros
simp only [filter_apply, if_pos h]
intros
refine ‚ü®Œª h, (equiv.refl _).injective _, Œª h, h ‚ñ∏ (swap_self _)‚ü©
rw [‚Üêh, swap_apply_left, h, refl_apply]
intros
cases e
{ cases e, refl }
refl
intros
by_cases h : p a; simp [perm.subtype_congr, h]
{ by_cases h : p a; simp [perm.subtype_congr, h] }
by_cases h : p a
simp [perm.subtype_congr, h]
simp [perm.subtype_congr, h]
intros
intro eq
by_cases H : i.cast_succ < p
simpa [lt_irrefl, ‚Üêsucc_above_below _ _ H, eq] using H
{ simpa [lt_irrefl, ‚Üêsucc_above_below _ _ H, eq] using H }
simpa [‚Üêsucc_above_above _ _ (le_of_not_lt H), eq] using cast_succ_lt_succ i
{ simpa [‚Üêsucc_above_above _ _ (le_of_not_lt H), eq] using cast_succ_lt_succ i }
intros
ext j
by_cases h : j = i
{ rw h, simp [tail] }
rw h
simp [tail]
{ simp [tail, (fin.succ_injective n).ne h, h] }
simp [tail, (fin.succ_injective n).ne h, h]
intros
cases j; simp [fin.succ]
cases j
simp [fin.succ]
intros
ext j
rcases em (j = i) with (rfl|hj); by_cases hs : j ‚àà s; simp *
rcases em (j = i) with (rfl|hj); by_cases hs : j ‚àà s
rcases em (j = i) with (rfl|hj)
by_cases hs : j ‚àà s
simp *
simp *
by_cases hs : j ‚àà s
simp *
simp *
intros
classical
{ classical, simp_rw [product_eq_bUnion, bUnion_bUnion, image_bUnion] }
simp_rw [product_eq_bUnion, bUnion_bUnion, image_bUnion]
intros
rw finset.disjoint_iff_ne
split
intro h
{ intro h, intros a ha1 ha2, rw ‚Üê multiset.mem_to_finset at ha1 ha2, exact h _ ha1 _ ha2 rfl }
intros a ha1 ha2
rw ‚Üê multiset.mem_to_finset at ha1 ha2
exact h _ ha1 _ ha2 rfl
rintros h a ha b hb rfl
{ rintros h a ha b hb rfl, rw multiset.mem_to_finset at ha hb, exact h ha hb }
rw multiset.mem_to_finset at ha hb
exact h ha hb
intros
show _ > _ ‚Üî _
apply fold_op_rel_iff_or
intros x y z
show _ < _ ‚Üî _
exact min_lt_iff
intros
simp [supr_or, supr_sup_eq]
intros
rw [antidiagonal, mem_def, multiset.nat.mem_antidiagonal]
intros
simp [pimage]
intros
simp only [set.subset_def, mem_coe, mem_support_iff]
simp only [set.subset_def, mem_coe, mem_support_iff]; exact forall_congr (assume a, not_imp_comm)
exact forall_congr (assume a, not_imp_comm)
intros
rw [finsupp.curry]
transitivity
exact sum_sum_index (assume a, sum_zero_index) (assume a b‚ÇÄ b‚ÇÅ, sum_add_index (assume a, hg‚ÇÄ _ _) (assume c d‚ÇÄ d‚ÇÅ, hg‚ÇÅ _ _ _ _))
{ exact sum_sum_index (assume a, sum_zero_index) (assume a b‚ÇÄ b‚ÇÅ, sum_add_index (assume a, hg‚ÇÄ _ _) (assume c d‚ÇÄ d‚ÇÅ, hg‚ÇÅ _ _ _ _)) }
congr
funext p c
transitivity
{ exact sum_single_index sum_zero_index }
exact sum_single_index sum_zero_index
exact sum_single_index (hg‚ÇÄ _ _)
intros
{ ext, simp [finsupp.single_apply, dfinsupp.single_apply] }
ext
simp [finsupp.single_apply, dfinsupp.single_apply]
intros
ext ‚ü®b, h‚ü©
apply hf
simp [hf.left_inv_of_inv_of_mem_range, @inv_fun_eq _ _ _ f b (set.mem_range.mp h)]
intros
simp
intros
have hk' := int.coe_nat_ne_zero.mpr (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk))
have key := congr_arg (Œª m, int.nat_mod m k) (gcd_eq_gcd_ab n k)
simp_rw int.nat_mod at key
rw [int.add_mul_mod_self_left, ‚Üêint.coe_nat_mod, int.to_nat_coe_nat, mod_eq_of_lt hk] at key
refine ‚ü®(n.gcd_a k % k).to_nat, eq.trans (int.coe_nat_inj _) key.symm‚ü©
rw [int.coe_nat_mod, int.coe_nat_mul, int.to_nat_of_nonneg (int.mod_nonneg _ hk'), int.to_nat_of_nonneg (int.mod_nonneg _ hk'), int.mul_mod, int.mod_mod, ‚Üêint.mul_mod]
intros
rw [modeq, eq_comm]; simp [mod_eq_mod_iff_mod_sub_eq_zero, dvd_iff_mod_eq_zero, -euclidean_domain.mod_eq_zero]
rw [modeq, eq_comm]
simp [mod_eq_mod_iff_mod_sub_eq_zero, dvd_iff_mod_eq_zero, -euclidean_domain.mod_eq_zero]
intros
{ cases L, cases h, simp, }
cases L
cases h
simp
intros
rw [‚Üê option.some_inj, ‚Üê nth_le_nth, nth_update_nth_eq, nth_le_nth]
rw [‚Üê option.some_inj, ‚Üê nth_le_nth, nth_update_nth_eq, nth_le_nth]; simp * at *
simp * at *
simp * at *
intros
rw ‚Üê h; apply take_left
rw ‚Üê h
apply take_left
intros
rw [update_nth_eq_modify_nth, modify_nth_eq_take_cons_drop _ h]
intros
apply monotone_nat_of_le_succ (Œª n, _)
by_cases h : n < L.length
rw sum_take_succ _ _ h
{ rw sum_take_succ _ _ h, exact le_self_add }
exact le_self_add
push_neg at h
{ push_neg at h, simp [take_all_of_le h, take_all_of_le (le_trans h (nat.le_succ _))] }
simp [take_all_of_le h, take_all_of_le (le_trans h (nat.le_succ _))]
intros
rw [nth_le_take L.join (sum_take_map_length_lt2 L hi hj) (sum_take_map_length_lt1 L hi hj), nth_le_drop, nth_le_of_eq (drop_take_succ_join_eq_nth_le L hi)]
intros
simp only [filter_map, h]; split; refl
simp only [filter_map, h]; split
simp only [filter_map, h]
split
refl
refl
intros
rw [‚Üê filter_map_eq_map, filter_filter_map, filter_map_filter]
rw [‚Üê filter_map_eq_map, filter_filter_map, filter_map_filter]; refl
refl
intros
cases a; simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and, false_and, exists_false, false_or, or_false, exists_and_distrib_left, exists_eq_left']
cases a
simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and, false_and, exists_false, false_or, or_false, exists_and_distrib_left, exists_eq_left']
simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and, false_and, exists_false, false_or, or_false, exists_and_distrib_left, exists_eq_left']
intros
rcases exists_of_erasep al pa with ‚ü®_, l‚ÇÅ, l‚ÇÇ, _, _, e‚ÇÅ, e‚ÇÇ‚ü©
rcases exists_of_erasep al pa with ‚ü®_, l‚ÇÅ, l‚ÇÇ, _, _, e‚ÇÅ, e‚ÇÇ‚ü©; rw e‚ÇÇ; simp [-add_comm, e‚ÇÅ]; refl
rcases exists_of_erasep al pa with ‚ü®_, l‚ÇÅ, l‚ÇÇ, _, _, e‚ÇÅ, e‚ÇÇ‚ü©; rw e‚ÇÇ; simp [-add_comm, e‚ÇÅ]
rcases exists_of_erasep al pa with ‚ü®_, l‚ÇÅ, l‚ÇÇ, _, _, e‚ÇÅ, e‚ÇÇ‚ü©; rw e‚ÇÇ
rw e‚ÇÇ
simp [-add_comm, e‚ÇÅ]
refl
intros
simp only [enum, enum_from_nth, zero_add]; intros; refl
simp only [enum, enum_from_nth, zero_add]; intros
simp only [enum, enum_from_nth, zero_add]
intros
cases bs; refl
cases bs
refl
refl
intros
induction l‚ÇÅ generalizing l‚ÇÇ; [refl, simp only [*, reverse_core, reverse_cons, append_assoc]]; refl
induction l‚ÇÅ generalizing l‚ÇÇ; [refl, simp only [*, reverse_core, reverse_cons, append_assoc]]
induction l‚ÇÅ generalizing l‚ÇÇ
refl
simp only [*, reverse_core, reverse_cons, append_assoc]
refl
intros
simp [Ico, nat.sub_eq_zero_of_le h]
intros
simp only [nodup_append, not_or_distrib, and.left_comm, and_assoc, nodup_cons, mem_append, disjoint_cons_right]
intros
{ apply of_reverse_eq, rw [reverse_append, reverse_reverse] }
apply of_reverse_eq
rw [reverse_append, reverse_reverse]
intros
induction l generalizing n
{ cases n, refl, cases h }
cases n
refl
cases h
cases n
{ simp [insert_nth] }
simp [insert_nth]
simp only [insert_nth, modify_nth_tail]
{ simp only [insert_nth, modify_nth_tail], transitivity, { apply perm.cons, apply l_ih, apply nat.le_of_succ_le_succ h }, { apply perm.swap } }
transitivity
apply perm.cons
{ apply perm.cons, apply l_ih, apply nat.le_of_succ_le_succ h }
apply l_ih
apply nat.le_of_succ_le_succ h
{ apply perm.swap }
apply perm.swap
intros
rw [‚Üê length_eq_zero, length_fin_range]
intros
rw lookup_all_eq_lookup a h; apply option.to_list_nodup
rw lookup_all_eq_lookup a h
apply option.to_list_nodup
intros
induction l‚ÇÅ generalizing l‚ÇÇ
simp
case list.nil { simp }
case list.cons : s _ ih { cases s with a', by_cases h‚ÇÅ : a = a', { subst h‚ÇÅ, simp }, { let h‚ÇÇ := @ih (kerase a' l‚ÇÇ), simp [h‚ÇÅ] at h‚ÇÇ, simp [h‚ÇÅ, h‚ÇÇ] } }
intros
rw [‚Üê reverse_sublist_iff, ‚Üê mem_sublists', sublists'_reverse, mem_map_of_injective reverse_injective]
intros
rw unzip; cases unzip l; refl
rw unzip; cases unzip l
rw unzip
cases unzip l
refl
intros
ext i j; simp [mul_comm]
ext i j
simp [mul_comm]
intros
simp only [matrix.dot_product, f.map_sum, f.map_mul]
intros
simp [sub_eq_add_neg]
intros
simp only [dot_product, vec_mul, mul_vec, finset.mul_sum, finset.sum_mul, mul_assoc]
simp only [dot_product, vec_mul, mul_vec, finset.mul_sum, finset.sum_mul, mul_assoc]; exact finset.sum_comm
exact finset.sum_comm
intros
ext
simp only [transpose_apply, block_diagonal_apply, eq_comm]
split_ifs with h
{ rw h }
rw h
{ refl }
refl
intros
{ ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©, refl }
ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©
refl
intros
simpa using add_union_distrib (a ::‚Çò 0) s t
intros
simp [subset_iff, or_imp_distrib, forall_and_distrib]
intros
simp [le_erase_dup, hno]
intros
rw [‚Üê inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]
rw [‚Üê inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]; simp
simp
intros
haveI := classical.dec_eq Œ±
simp [Œª l:list Œ±, revzip_powerset_aux_lemma l revzip_powerset_aux, coe_eq_coe.2 p]
exact (powerset_aux_perm p).map _
intros
funext i
transitivity (aeval x (aeval (Œª i, g (X i)) (f (X i))))
apply eval‚ÇÇ_hom_congr rfl rfl
{ apply eval‚ÇÇ_hom_congr rfl rfl, rw alg_hom.comp_apply, suffices : g = aeval (Œª i, g (X i)), { rw ‚Üê this, }, exact aeval_unique g }
rw alg_hom.comp_apply
suffices : g = aeval (Œª i, g (X i))
rw ‚Üê this
{ rw ‚Üê this, }
exact aeval_unique g
simp only [comap, aeval_eq_eval‚ÇÇ_hom, map_eval‚ÇÇ_hom, alg_hom.comp_apply]
{ simp only [comap, aeval_eq_eval‚ÇÇ_hom, map_eval‚ÇÇ_hom, alg_hom.comp_apply], refine eval‚ÇÇ_hom_congr _ rfl rfl, ext r, apply aeval_C }
refine eval‚ÇÇ_hom_congr _ rfl rfl
ext r
apply aeval_C
intros
{ ext1 i, simp }
ext1 i
simp
intros
by_cases n0 : n = 0
{ rw [n0, nat.div_zero, nat.div_zero] }
rw [n0, nat.div_zero, nat.div_zero]
rw [‚Üê mod_add_div m n] { occs := occurrences.pos [2] }
{ rw [‚Üê mod_add_div m n] { occs := occurrences.pos [2] }, rw [nat.add_sub_cancel_left, mul_div_right _ (nat.pos_of_ne_zero n0)] }
rw [nat.add_sub_cancel_left, mul_div_right _ (nat.pos_of_ne_zero n0)]
{ ext n, cases n; simp }
ext n
cases n
cases n; simp
simp
simp
intros
bitwise_assoc_tac
intros
rw [dist_comm]
apply dist_eq_sub_of_le h
intros
{ conv_rhs { rw [‚Üê enat.add_lt_add_iff_left hx] }, rw [add_zero] }
conv_rhs { rw [‚Üê enat.add_lt_add_iff_left hx] }
rw [add_zero]
intros
rw [mul_comm n k, H.gcd_mul_left_cancel_right n]
intros
rw factors
norm_num
simp [totient]
intros
cases n; apply nat.succ_pos
cases n
apply nat.succ_pos
apply nat.succ_pos
apply nat.succ_pos
intros
cases x; simp only [map_none', map_some']
{ cases x; simp only [map_none', map_some'] }
cases x
simp only [map_none', map_some']
simp only [map_none', map_some']
intros
cases a; refl
cases a
refl
refl
intros
rw balance'
split_ifs
{ exact hl.node' hr (or.inl h) }
exact hl.node' hr (or.inl h)
{ exact hl.rotate_l hr h h_1 H‚ÇÅ }
exact hl.rotate_l hr h h_1 H‚ÇÅ
{ exact hl.rotate_r hr h h_2 H‚ÇÇ }
exact hl.rotate_r hr h h_2 H‚ÇÇ
exact hl.node' hr (or.inr ‚ü®not_lt.1 h_2, not_lt.1 h_1‚ü©)
{ exact hl.node' hr (or.inr ‚ü®not_lt.1 h_2, not_lt.1 h_1‚ü©) }
intros
simp [node', add_comm]
intros
ext
ext; dsimp [pequiv.trans]; simp
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
simp
intros
ext x
ext x; simp [core_def]
simp [core_def]
intros
{ cases x, refl }
cases x
refl
intros
rw ‚Üê coprime_coe at *
simp only [pow_coe]
apply nat.coprime.pow
apply h
intros
{ rcases p, rcases q, simp [coeff, finsupp.ext_iff] }
rcases p
rcases q
simp [coeff, finsupp.ext_iff]
intros
by_cases hp : p = 0
{ rw hp, exact bot_le }
rw hp
exact bot_le
rw degree_eq_nat_degree hp
{ rw degree_eq_nat_degree hp, exact le_degree_of_ne_zero h }
exact le_degree_of_ne_zero h
intros
apply nat_degree_le_of_degree_le
apply le_trans (degree_mul_le p q)
rw with_bot.coe_add
refine add_le_add _ _; apply degree_le_nat_degree
refine add_le_add _ _
apply degree_le_nat_degree
apply degree_le_nat_degree
intros
rw next_coeff_up
{ rw next_coeff_up, simp }
simp
intros
induction k with k ih
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
rw eval‚ÇÇ_mul f x
exact mul_eq_zero_of_left hp (q.eval‚ÇÇ f x)
intros
intros x
simp only [mem_support_iff]
contrapose!
rw coeff_map
intro hx
rw hx
exact ring_hom.map_zero f
intros
rw [‚Üêone_mul (X ^ n : polynomial R), ‚ÜêC_1, root_set_C_mul_X_pow hn]
{ rw [‚Üêone_mul (X ^ n : polynomial R), ‚ÜêC_1, root_set_C_mul_X_pow hn], exact one_ne_zero }
exact one_ne_zero
intros
ext m
rw [coeff_iterated_deriv_as_prod_range, coeff_zero, coeff_eq_zero_of_nat_degree_lt, zero_mul]
linarith
intros
rw [‚Üêp.mirror_mirror, mirror_trailing_coeff, p.mirror_mirror]
intros
apply hf
rw [‚Üê leading_coeff_of_injective hf, hp.leading_coeff, f.map_one]
intros
rw [coeff_reverse, rev_at_le (zero_le f.nat_degree), nat.sub_zero, leading_coeff]
intros
rw [supp]
dsimp
split
intros h a f haf
{ intros h a f haf, have : liftp (Œª i u, u ‚àà f i '' univ) x, { rw liftp_iff, refine ‚ü®a, f, haf.symm, _‚ü©, intros i u, exact mem_image_of_mem _ (mem_univ _) }, exact h this }
have : liftp (Œª i u, u ‚àà f i '' univ) x
rw liftp_iff
{ rw liftp_iff, refine ‚ü®a, f, haf.symm, _‚ü©, intros i u, exact mem_image_of_mem _ (mem_univ _) }
refine ‚ü®a, f, haf.symm, _‚ü©
intros i u
exact mem_image_of_mem _ (mem_univ _)
exact h this
intros h p
rw liftp_iff
rintros ‚ü®a, f, xeq, h'‚ü©
rcases h a f xeq.symm with ‚ü®i, _, hi‚ü©
rw ‚Üêhi
apply h'
intros
rw [Wrepr, recF_eq', q.P.W_dest'_W_mk]; refl
rw [Wrepr, recF_eq', q.P.W_dest'_W_mk]
intros
simp only [mk_eq_div, cast_div, cast_coe_int]
intros
show rat.nonneg _ ‚Üî _
rw ‚Üê sub_nonneg
simp [sub_eq_add_neg, ne_of_gt b0, ne_of_gt d0, mul_pos d0 b0]
simpa only [div_eq_mul_inv, one_mul] using sub_half one_ne_top
intros
simp [ennreal.to_real]
intros
simp [ennreal.of_real]
intros
induction y using ereal.rec
{ exact (lt_irrefl _ (bot_le.trans_lt h1)).elim }
exact (lt_irrefl _ (bot_le.trans_lt h1)).elim
calc x + z ‚â§ y + z : add_le_add h1.le (le_refl _) ... < y + t : add_lt_add_left_coe h2 _
{ calc x + z ‚â§ y + z : add_le_add h1.le (le_refl _) ... < y + t : add_lt_add_left_coe h2 _ }
simp [lt_top_iff_ne_top, with_top.add_eq_top, h1.ne, (h2.trans_le le_top).ne]
{ simp [lt_top_iff_ne_top, with_top.add_eq_top, h1.ne, (h2.trans_le le_top).ne] }
rw [inv_eq_iff, ‚Üê neg_inv, neg_eq_iff_neg_eq]
exact inv_gold.symm
intros
rw [‚Üê nnreal.coe_zero, nnreal.coe_eq]
intros
simp only [div_eq_mul_inv, finset.sum_mul]
pi_lower_bound [ 11482/8119, 5401/2923, 2348/1197, 11367/5711, 25705/12868, 23235/11621]
simp [sqrt]
intros
haveI := h1.terminates; haveI := h2.terminates; rw [‚Üêh1.length, h2.length]
haveI := h1.terminates; haveI := h2.terminates
haveI := h1.terminates
haveI := h2.terminates
rw [‚Üêh1.length, h2.length]
intros
cases x with x hx; exact hf _ _ _ _ _
cases x with x hx
exact hf _ _ _ _ _
intros
ext
{ ext, simp }
simp
intros
{ ext, simp [image, range] }
ext
simp [image, range]
intros
rw [‚Üê nonempty_image_iff, hf.image_preimage]
intros
rw [‚Üê mk_preimage_prod_left_eq_if, prod_preimage_left, preimage_preimage]
intros
ext
{ ext, simp_rw [mem_univ_pi], apply forall_congr, intro i, split_ifs; simp [h] }
simp_rw [mem_univ_pi]
apply forall_congr
intro i
split_ifs
split_ifs; simp [h]
simp [h]
simp [h]
intros
simp [subset_def]
intros
contrapose! ht
exact infinite_of_inj_on_maps_to (Œª x hx y hy, not_imp_not.1 (ht x hx y hy)) hf hs
intros
simp
intros
refine h.inv_on_inv_fun_on.bij_on _ (maps_to_image _ _)
rintros _ ‚ü®y, hy, rfl‚ü©
rwa [h.right_inv_on_inv_fun_on hy]
intros
simp [‚Üê Ioi_inter_Iio]
intros
ext1 x
simp_rw [mem_union, mem_Iic, mem_Icc, le_max_iff]
by_cases hc : c ‚â§ x
{ tauto }
tauto
have hxb : x ‚â§ b := (le_of_not_ge hc).trans h‚ÇÅ
{ have hxb : x ‚â§ b := (le_of_not_ge hc).trans h‚ÇÅ, tauto }
tauto
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (Œª x, a + x) (Œª x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Icc_of_neg a b h
intros
simp only [interval, min_le_iff, le_max_iff, nonempty_Icc]
{ simp only [interval, min_le_iff, le_max_iff, nonempty_Icc], left, left, refl }
left
left
refl
intros
ext y
{ ext y, split; simp only [mem_Union]; rintro ‚ü®a, b, c, d, e‚ü©, exact ‚ü®c, a, d, b, e‚ü©, exact ‚ü®b, d, a, c, e‚ü© }
split
split; simp only [mem_Union]; rintro ‚ü®a, b, c, d, e‚ü©
split; simp only [mem_Union]
simp only [mem_Union]
rintro ‚ü®a, b, c, d, e‚ü©
exact ‚ü®c, a, d, b, e‚ü©
simp only [mem_Union]
rintro ‚ü®a, b, c, d, e‚ü©
exact ‚ü®b, d, a, c, e‚ü©
intros
ext x
refine ‚ü®Œª hx, Union_inter_subset hx, _‚ü©
rintro ‚ü®‚ü®_, ‚ü®i, rfl‚ü©, xs‚ü©, _, ‚ü®j, rfl‚ü©, xt‚ü©
exact ‚ü®_, ‚ü®i ‚äî j, rfl‚ü©, hs le_sup_left xs, ht le_sup_right xt‚ü©
intros
rw [‚Üêcompl_compl (‚ãÉ‚ÇÄ S), compl_sUnion]
intros
refl
intros
simpa only [scanl, to_list_cons]
intros
change (a : zmod b) = ((0 : ‚Ñ§) : zmod b) ‚Üî (b : ‚Ñ§) ‚à£ a
rw [zmod.int_coe_eq_int_coe_iff, int.modeq_zero_iff_dvd]
intros
rw [val_nat_cast, nat.mod_eq_of_lt h]
intros
simp [sub_eq_add_neg, hf.map_add, hf.map_neg]
intros
rw set.ext_iff; simp [ker]; exact ‚ü®Œª h x hx, (h x).1 hx, Œª h x, ‚ü®h x, Œª hx, by rw [hx, hf.map_one]‚ü©‚ü©
rw set.ext_iff; simp [ker]
rw set.ext_iff
simp [ker]
exact ‚ü®Œª h x hx, (h x).1 hx, Œª h x, ‚ü®h x, Œª hx, by rw [hx, hf.map_one]‚ü©‚ü©
intros
simp only [‚Üê units_coe, ‚Üê mul_apply, f.mul_inv, coe_one, id]
intros
simp_rw [is_invariant, maps_to']
intros
{ rw [is_periodic_pt, iterate_add], exact hn.comp hm }
rw [is_periodic_pt, iterate_add]
exact hn.comp hm
intros
apply adjoin_eq_algebra_adjoin
intros x hx
by_cases x = 0
rw [h, inv_zero]
{ rw [h, inv_zero], exact subalgebra.zero_mem (algebra.adjoin F {Œ±}) }
exact subalgebra.zero_mem (algebra.adjoin F {Œ±})
let œï := alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly F Œ±
haveI := minpoly.irreducible hŒ±
suffices : œï ‚ü®x, hx‚ü© * (œï ‚ü®x, hx‚ü©)‚Åª¬π = 1
convert subtype.mem (œï.symm (œï ‚ü®x, hx‚ü©)‚Åª¬π)
{ convert subtype.mem (œï.symm (œï ‚ü®x, hx‚ü©)‚Åª¬π), refine (eq_inv_of_mul_right_eq_one _).symm, apply_fun œï.symm at this, rw [alg_equiv.map_one, alg_equiv.map_mul, alg_equiv.symm_apply_apply] at this, rw [‚Üêsubsemiring.coe_one, ‚Üêthis, subsemiring.coe_mul, subtype.coe_mk] }
refine (eq_inv_of_mul_right_eq_one _).symm
apply_fun œï.symm at this
rw [alg_equiv.map_one, alg_equiv.map_mul, alg_equiv.symm_apply_apply] at this
rw [‚Üêsubsemiring.coe_one, ‚Üêthis, subsemiring.coe_mul, subtype.coe_mk]
rw mul_inv_cancel (mt (Œª key, _) h)
rw ‚Üê œï.map_zero at key
change ‚Üë(‚ü®x, hx‚ü© : algebra.adjoin F {Œ±}) = _
rw [œï.injective key, subalgebra.coe_zero]
intros
rw [‚Üê cardinal.nat_cast_le, finrank_eq_dim]
apply dim_le_card
intros
haveI : fintype E := fintype_of_fintype F E
exact exists_primitive_element_of_fintype_top F E
intros
rw [‚Üêfinset.card_range n, ‚Üêfinset.prod_const]
exact splits_prod i (Œª j hj, hf)
intros
rw ‚Üê sq_eq_sq (norm_nonneg (x + y)) (add_nonneg (norm_nonneg x) (norm_nonneg y))
rw [norm_add_pow_two_real, inner_eq_mul_norm_of_angle_eq_zero h]
ring
intros
split
{ exact Œª h, h ‚ñ∏ orthogonal_projection_mem p }
exact Œª h, h ‚ñ∏ orthogonal_projection_mem p
intro h
{ intro h, have hp : p ‚àà ((s : set P) ‚à© mk' p s.direction·óÆ) := ‚ü®h, self_mem_mk' p _‚ü©, rw [inter_eq_singleton_orthogonal_projection p] at hp, symmetry, exact hp }
have hp : p ‚àà ((s : set P) ‚à© mk' p s.direction·óÆ) := ‚ü®h, self_mem_mk' p _‚ü©
rw [inter_eq_singleton_orthogonal_projection p] at hp
symmetry
exact hp
intros
rcases exists_circumcenter_eq_of_cospherical_subset h hd hc with ‚ü®r, hr‚ü©
rw [hr sx‚ÇÅ hsx‚ÇÅ, hr sx‚ÇÇ hsx‚ÇÇ]
intros
rcases ho with ‚ü®t‚ÇÄ, ht‚ÇÄo, ht‚ÇÄs‚ü©
rw ht‚ÇÄs at ht
rcases exists_of_range_subset_orthocentric_system ht‚ÇÄo ht t.independent.injective with ‚ü®i‚ÇÅ, i‚ÇÇ, i‚ÇÉ, j‚ÇÇ, j‚ÇÉ, h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÉ, h‚ÇÇ‚ÇÉ, h‚ÇÅ‚ÇÇ‚ÇÉ, h‚ÇÅ, hj‚ÇÇ‚ÇÉ, h‚ÇÇ, h‚ÇÉ‚ü© | hs
obtain ‚ü®j‚ÇÅ, hj‚ÇÅ‚ÇÇ, hj‚ÇÅ‚ÇÉ, hj‚ÇÅ‚ÇÇ‚ÇÉ‚ü© : ‚àÉ j‚ÇÅ : fin 3, j‚ÇÅ ‚â† j‚ÇÇ ‚àß j‚ÇÅ ‚â† j‚ÇÉ ‚àß ‚àÄ j : fin 3, j = j‚ÇÅ ‚à® j = j‚ÇÇ ‚à® j = j‚ÇÉ
{ obtain ‚ü®j‚ÇÅ, hj‚ÇÅ‚ÇÇ, hj‚ÇÅ‚ÇÉ, hj‚ÇÅ‚ÇÇ‚ÇÉ‚ü© : ‚àÉ j‚ÇÅ : fin 3, j‚ÇÅ ‚â† j‚ÇÇ ‚àß j‚ÇÅ ‚â† j‚ÇÉ ‚àß ‚àÄ j : fin 3, j = j‚ÇÅ ‚à® j = j‚ÇÇ ‚à® j = j‚ÇÉ, { clear h‚ÇÇ h‚ÇÉ, dec_trivial! }, suffices h : t‚ÇÄ.points j‚ÇÅ = t.orthocenter, { have hui : (set.univ : set (fin 3)) = {i‚ÇÅ, i‚ÇÇ, i‚ÇÉ}, { ext x, simpa using h‚ÇÅ‚ÇÇ‚ÇÉ x }, have huj : (set.univ : set (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}, { ext x, simpa using hj‚ÇÅ‚ÇÇ‚ÇÉ x }, rw [‚Üêh, ht‚ÇÄs, ‚Üêset.image_univ, huj, ‚Üêset.image_univ, hui], simp_rw [set.image_insert_eq, set.image_singleton, h‚ÇÅ, ‚Üêh‚ÇÇ, ‚Üêh‚ÇÉ], rw set.insert_comm }, exact (triangle.orthocenter_replace_orthocenter_eq_point hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÉ h‚ÇÅ h‚ÇÇ.symm h‚ÇÉ.symm).symm }
{ clear h‚ÇÇ h‚ÇÉ, dec_trivial! }
clear h‚ÇÇ h‚ÇÉ
dec_trivial!
suffices h : t‚ÇÄ.points j‚ÇÅ = t.orthocenter
have hui : (set.univ : set (fin 3)) = {i‚ÇÅ, i‚ÇÇ, i‚ÇÉ}
{ have hui : (set.univ : set (fin 3)) = {i‚ÇÅ, i‚ÇÇ, i‚ÇÉ}, { ext x, simpa using h‚ÇÅ‚ÇÇ‚ÇÉ x }, have huj : (set.univ : set (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}, { ext x, simpa using hj‚ÇÅ‚ÇÇ‚ÇÉ x }, rw [‚Üêh, ht‚ÇÄs, ‚Üêset.image_univ, huj, ‚Üêset.image_univ, hui], simp_rw [set.image_insert_eq, set.image_singleton, h‚ÇÅ, ‚Üêh‚ÇÇ, ‚Üêh‚ÇÉ], rw set.insert_comm }
ext x
{ ext x, simpa using h‚ÇÅ‚ÇÇ‚ÇÉ x }
simpa using h‚ÇÅ‚ÇÇ‚ÇÉ x
have huj : (set.univ : set (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}
ext x
{ ext x, simpa using hj‚ÇÅ‚ÇÇ‚ÇÉ x }
simpa using hj‚ÇÅ‚ÇÇ‚ÇÉ x
rw [‚Üêh, ht‚ÇÄs, ‚Üêset.image_univ, huj, ‚Üêset.image_univ, hui]
simp_rw [set.image_insert_eq, set.image_singleton, h‚ÇÅ, ‚Üêh‚ÇÇ, ‚Üêh‚ÇÉ]
rw set.insert_comm
exact (triangle.orthocenter_replace_orthocenter_eq_point hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÉ h‚ÇÅ h‚ÇÇ.symm h‚ÇÉ.symm).symm
rw hs
{ rw hs, convert ht‚ÇÄs using 2, exact triangle.orthocenter_eq_of_range_eq hs }
convert ht‚ÇÄs using 2
exact triangle.orthocenter_eq_of_range_eq hs
intros
rw ‚Üê he'.1
exact PG.congr e.open_source he'.eq_on.symm he
intros
convert hs.unique_mdiff_on_preimage (h.to_local_homeomorph_mdifferentiable hn)
simp [h.image_eq_preimage]
intros
have : s = univ ‚à© s
rw univ_inter
rw univ_inter
rwa [this, hG.lift_prop_within_at_inter hs] at h
intros
rw [unique_mdiff_within_at, ext_chart_preimage_inter_eq]
exact unique_diff_within_at.inter hs (ext_chart_preimage_mem_nhds I x ht)
intros
have A : f‚ÇÅ x = f x := (mem_of_mem_nhds hL : _)
rw [‚Üê mfderiv_within_univ, ‚Üê mfderiv_within_univ]
rw ‚Üê nhds_within_univ at hL
exact hL.mfderiv_within_eq (unique_mdiff_within_at_univ I) A
intros
rw [‚Üê I.map_nhds_eq, map_map, I.symm_comp_self, map_id]
intros
rw [‚Üê times_cont_mdiff_on_univ, times_cont_mdiff_on_iff_target]
simp [continuous_iff_continuous_on_univ]
intros
rw [‚Üê fintype.card_prod, fintype.card_congr (orbit_prod_stabilizer_equiv_group Œ± b)]
intros
rw ‚Üê neg_one_smul R
{ rw ‚Üê neg_one_smul R, exact p.smul_mem _ hx }
exact p.smul_mem _ hx
intros
rw mul_comm; convert units.inv_mul_eq_iff_eq_mul _; exact (is_unit.coe_lift_right (f.mrestrict S) h _).symm
rw mul_comm; convert units.inv_mul_eq_iff_eq_mul _
rw mul_comm
convert units.inv_mul_eq_iff_eq_mul _
exact (is_unit.coe_lift_right (f.mrestrict S) h _).symm
intros
rw [‚Üêf.lift_of_comp j, ‚Üêf.lift_of_comp k]
congr' 1 with x
exact h x
intros
induction n with d hd
{ simp }
simp
rintros _ ‚ü®x, hx : x ‚àà upper_central_series G d.succ, rfl‚ü© y'
{ rintros _ ‚ü®x, hx : x ‚àà upper_central_series G d.succ, rfl‚ü© y', rcases (h y') with ‚ü®y, rfl‚ü©, simpa using hd (mem_map_of_mem f (hx y)) }
rcases (h y') with ‚ü®y, rfl‚ü©
simpa using hd (mem_map_of_mem f (hx y))
intros
refine (H ‚äì K).eq_bot_iff_forall.mpr (Œª x hx, _)
rw [‚Üêorder_of_eq_one_iff, ‚Üênat.dvd_one, ‚Üêh.gcd_eq_one, nat.dvd_gcd_iff]
exact ‚ü®(congr_arg (‚à£ fintype.card H) (order_of_subgroup ‚ü®x, hx.1‚ü©)).mpr order_of_dvd_card_univ, (congr_arg (‚à£ fintype.card K) (order_of_subgroup ‚ü®x, hx.2‚ü©)).mpr order_of_dvd_card_univ‚ü©
intros
rw disjoint_iff_disjoint_support at h
intros x hx
simp only [mem_cycle_factors_finset_iff, inf_eq_inter, mem_inter, mem_support] at hx
obtain ‚ü®‚ü®‚ü®a, ha, -‚ü©, hf‚ü©, -, hg‚ü© := hx
refine h (_ : a ‚àà f.support ‚à© g.support)
simp [ha, ‚Üêhf a ha, ‚Üêhg a ha]
intros
obtain ‚ü®x, y, hxy, rfl‚ü© := hf
exact is_cycle_swap hxy
intros
cases n
{ rcases j with ‚ü®_, ‚ü®‚ü©‚ü© }
rcases j with ‚ü®_, ‚ü®‚ü©‚ü©
rcases lt_trichotomy j i with hlt | heq | hgt
have : (j + 1).cast_succ = j.succ
{ have : (j + 1).cast_succ = j.succ, { ext, rw [coe_cast_succ, coe_succ, fin.coe_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)] }, rw [fin.cycle_range_of_lt hlt, fin.succ_above_below, this, swap_apply_of_ne_of_ne], { apply fin.succ_ne_zero }, { exact (fin.succ_injective _).ne hlt.ne }, { rw fin.lt_iff_coe_lt_coe, simpa [this] using hlt } }
ext
{ ext, rw [coe_cast_succ, coe_succ, fin.coe_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)] }
rw [coe_cast_succ, coe_succ, fin.coe_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)]
rw [fin.cycle_range_of_lt hlt, fin.succ_above_below, this, swap_apply_of_ne_of_ne]
{ apply fin.succ_ne_zero }
apply fin.succ_ne_zero
{ exact (fin.succ_injective _).ne hlt.ne }
exact (fin.succ_injective _).ne hlt.ne
rw fin.lt_iff_coe_lt_coe
{ rw fin.lt_iff_coe_lt_coe, simpa [this] using hlt }
simpa [this] using hlt
rw [heq, fin.cycle_range_self, fin.succ_above_below, swap_apply_right, fin.cast_succ_zero]
{ rw [heq, fin.cycle_range_self, fin.succ_above_below, swap_apply_right, fin.cast_succ_zero], { rw fin.cast_succ_zero, apply fin.succ_pos } }
{ rw fin.cast_succ_zero, apply fin.succ_pos }
rw fin.cast_succ_zero
apply fin.succ_pos
rw [fin.cycle_range_of_gt hgt, fin.succ_above_above, swap_apply_of_ne_of_ne]
{ rw [fin.cycle_range_of_gt hgt, fin.succ_above_above, swap_apply_of_ne_of_ne], { apply fin.succ_ne_zero }, { apply (fin.succ_injective _).ne hgt.ne.symm }, { simpa [fin.le_iff_coe_le_coe] using hgt } }
{ apply fin.succ_ne_zero }
apply fin.succ_ne_zero
{ apply (fin.succ_injective _).ne hgt.ne.symm }
apply (fin.succ_injective _).ne hgt.ne.symm
{ simpa [fin.le_iff_coe_le_coe] using hgt }
simpa [fin.le_iff_coe_le_coe] using hgt
intros
cases l with hd tl
{ simp }
simp
rw ‚Üêform_perm_apply_mem_eq_self_iff _ hl hd (mem_cons_self _ _)
{ rw ‚Üêform_perm_apply_mem_eq_self_iff _ hl hd (mem_cons_self _ _), split, { simp {contextual := tt} }, { intro h, simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h, simp [h] } }
split
{ simp {contextual := tt} }
simp {contextual := tt}
intro h
{ intro h, simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h, simp [h] }
simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h
simp [h]
intros
rw [le_iff_lt_or_eq, nat.lt_succ_iff, nat.le_zero_iff, card_support_eq_zero, or_iff_not_imp_right, imp_iff_right f.card_support_ne_one]
intros
ext
ext; simp [right_hom]
simp [right_hom]
intros
rw [‚Üêcomap_bot, ‚Üêcomap_bot, ‚Üêcomap_bot, ‚Üêprod_map_comap_prod, bot_prod_bot]
intros
simp only [infi, coe_Inf, set.bInter_range]
intros
simp [line_map_apply]
intros
simp_rw [weighted_vsub_of_point_apply]
exact finset.sum_map _ _ _
intros
cases s1
cases s2
congr' with i
exact h i
intros
rw [map_le_line_map_iff_slope_le_slope_left (mul_pos h‚ÇÄ (sub_pos.2 hab)), ‚Üê line_map_slope_line_map_slope_line_map f a b r, right_le_line_map_iff_le h‚ÇÅ]
apply_instance
apply_instance
apply_instance
apply_instance
intros
rw [range_le_iff_comap]; exact ker_eq_top
rw [range_le_iff_comap]
exact ker_eq_top
intros
conv_rhs { rw ‚Üê b.total_repr u }
simp [finsupp.total_apply, finsupp.sum_fintype, b.equiv_fun_apply]
intros
erw mem_pair_self_adjoint_matrices_submodule
simp [matrix.is_skew_adjoint, matrix.is_adjoint_pair]
intros
{ ext, refl }
ext
refl
intros
dsimp [module.rank]
apply cardinal.lift_sup_le
rintro ‚ü®s, li‚ü©
apply le_trans
swap 2
apply cardinal.lift_le.mpr
refine (cardinal.le_sup _ ‚ü®range_splitting f '' s, _‚ü©)
apply linear_independent.of_comp f.range_restrict
{ apply linear_independent.of_comp f.range_restrict, convert li.comp (equiv.set.range_splitting_image_equiv f s) (equiv.injective _) using 1, }
convert li.comp (equiv.set.range_splitting_image_equiv f s) (equiv.injective _) using 1
exact (cardinal.lift_mk_eq'.mpr ‚ü®equiv.set.range_splitting_image_equiv f s‚ü©).ge
{ exact (cardinal.lift_mk_eq'.mpr ‚ü®equiv.set.range_splitting_image_equiv f s‚ü©).ge, }
intros
rw [basis.equiv_fun_apply, dual_basis_repr]
intros
rw polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)
simp only [aeval_def, eval‚ÇÇ_C]
apply ker_algebra_map_End
apply coeff_coe_units_zero_ne_zero c
intros
rw [‚Üêalg_hom.map_mul, Œπ_sq_zero, alg_hom.map_zero]
intros
rw [set.range_unique, basis_singleton_apply]
intros
{ ext i, apply fin_zero_elim i }
ext i
apply fin_zero_elim i
intros
rw [linear_map.submodule_image, linear_map.range_comp, range_of_le]
intros
rw [disjoint, ‚Üê set.image_univ, finsupp.span_image_eq_map_total, map_inf_eq_map_inf_comap, map_le_iff_le_comap, comap_bot, finsupp.supported_univ, top_inf_eq] at hf_inj
unfold linear_independent at hv ‚ä¢
rw [hv, le_bot_iff] at hf_inj
haveI : inhabited M := ‚ü®0‚ü©
rw [finsupp.total_comp, @finsupp.lmap_domain_total _ _ R _ _ _ _ _ _ _ _ _ _ f, linear_map.ker_comp, hf_inj]
exact Œª _, rfl
intros
rw [basis_to_matrix_mul_linear_map_to_matrix, linear_map_to_matrix_mul_basis_to_matrix]
intros
rw [polynomial.eval, ‚Üê coe_eval‚ÇÇ_ring_hom, ring_hom.map_det]
apply congr_arg det
ext
symmetry
convert mat_poly_equiv_eval _ _ _ _
intros
ext j
ext j; simp [mul_vec_diagonal]
simp [mul_vec_diagonal]
intros
{ ext, simp [matrix.one_apply, std_basis_apply] }
ext
simp [matrix.one_apply, std_basis_apply]
intros
rw [left_mul_matrix_apply, to_matrix_lmul' b x i j]
intros
obtain ‚ü®i, _‚ü© : ‚àÉi:Œπ, i ‚àà set.univ := set.exists_mem_of_nonempty Œπ
exact map_coord_zero f i rfl
intros
have : z = z ‚Ä¢ (1 : R) := by simp only [mul_one, algebra.id.smul_eq_mul]
conv_lhs { rw this }
rw ‚Üêsmul_tprod_coeff'
refl
intros
simp [disjoint_def, @eq_comm M 0, @eq_comm M‚ÇÇ 0] {contextual := tt}
simp [disjoint_def, @eq_comm M 0, @eq_comm M‚ÇÇ 0] {contextual := tt}; intros; refl
simp [disjoint_def, @eq_comm M 0, @eq_comm M‚ÇÇ 0] {contextual := tt}; intros
intros
simp [tailings]
intros
rw [‚Üêneg_one_smul R x, polar_smul_left, neg_one_mul]
intros
{ rw g.det_coe, norm_num }
rw g.det_coe
norm_num
intros
simp [xor]
intros
simp [@eq_comm _ a']
intros
{ rw [‚Üê and_forall_ne a, update_same], simp { contextual := tt } }
rw [‚Üê and_forall_ne a, update_same]
simp { contextual := tt }
intros
refine is_compact.induction_on h _ _ _ _
{ use ‚àÖ, simp [superset] }
use ‚àÖ
simp [superset]
rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
{ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©, exact ‚ü®U, hst.trans htU, hUo, hU‚ü© }
exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
{ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©, refine ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo, (measure_union_le _ _).trans_lt $ ennreal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü© }
refine ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo, (measure_union_le _ _).trans_lt $ ennreal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
intros x hx
{ intros x hx, rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©, exact ‚ü®U, nhds_within_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hU‚ü© }
rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
exact ‚ü®U, nhds_within_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hU‚ü©
intros
{ rw [real_smul_def, ‚Üê smul_neg_part, dif_pos hr] }
rw [real_smul_def, ‚Üê smul_neg_part, dif_pos hr]
intros
let s := dense_seq E
have hs : dense_range s := dense_range_dense_seq E
have hf' : ‚àÄ·µê x ‚àÇŒº, ‚àÄ n : ‚Ñï, inner (s n) (f x) = (0 : ùïú)
from ae_all_iff.mpr (Œª n, hf (s n))
refine hf'.mono (Œª x hx, _)
rw [pi.zero_apply, ‚Üê inner_self_eq_zero]
have h_closed : is_closed {c : E | inner c (f x) = (0 : ùïú)}
from is_closed_eq (continuous_id.inner continuous_const) continuous_const
exact @is_closed_property ‚Ñï E _ s (Œª c, inner c (f x) = (0 : ùïú)) hs h_closed (Œª n, hx n) _
intros
haveI : normed_space ‚Ñù E := restrict_scalars.normed_space ‚Ñù ùïú E
rw dense_range_iff_closure_range
suffices : (to_Lp p Œº ùïú : _ ‚ÜíL[ùïú] Lp E p Œº).range.to_add_subgroup.topological_closure = ‚ä§
{ exact congr_arg coe this }
exact congr_arg coe this
simp [range_to_Lp p Œº, measure_theory.Lp.bounded_continuous_function_dense E hp]
intros
simp [integrable, hg, hg.comp_measurable hf, has_finite_integral, lintegral_map' hg.ennnorm hf]
intros
have : ‚àÄ x, ‚à•is_R_or_C.re (f x)‚à• ‚â§ 1 * ‚à•f x‚à•
intro x
intro x
{ intro x, rw one_mul, exact is_R_or_C.norm_re_le_norm (f x), }
{ intro x, rw one_mul, exact is_R_or_C.norm_re_le_norm (f x), }
rw one_mul
rw one_mul
exact is_R_or_C.norm_re_le_norm (f x)
exact is_R_or_C.norm_re_le_norm (f x)
exact hf.of_le_mul hf.1.re (eventually_of_forall this)
intros
rw neg_part
filter_upwards [coe_fn_pos_part (-f), coe_fn_neg f]
assume a h‚ÇÅ h‚ÇÇ
rw [h‚ÇÅ, h‚ÇÇ, pi.neg_apply]
intros
simp [snorm', hq_neg]
intros
rw [snorm'_congr_ae hf_zero, snorm'_zero hq0_lt]
intros
by_cases hf : integrable (Œª a, (f a : ‚Ñù)) Œº
{ exact (lintegral_coe_le_coe_iff_integral_le hf).1 h }
exact (lintegral_coe_le_coe_iff_integral_le hf).1 h
{ rw integral_undef hf, exact b.2 }
rw integral_undef hf
exact b.2
intros
{ ext1 x, rw [weighted_smul_apply], simp, }
ext1 x
rw [weighted_smul_apply]
simp
intros
simpa only [‚Üê integral_symm] using (integral_has_strict_deriv_at_right hf.symm hmeas ha).neg
intros
rw [count, lintegral_sum_measure]
congr
exact funext (Œª a, lintegral_dirac' a hf)
intros
rw f.support_eq
{ rw f.support_eq, exact finset.measurable_set_bUnion _ (Œª y hy, measurable_set_fiber _ _), }
exact finset.measurable_set_bUnion _ (Œª y hy, measurable_set_fiber _ _)
intros
refine integral_eq_zero_of_ae _
rw [eventually_eq, ae_restrict_iff (measurable_set_eq_fun hf measurable_zero)]
refine eventually_of_forall (Œª x hx, _)
rw pi.zero_apply
exact ht_eq x hx
intros
rw [content.outer_measure, induced_outer_measure_eq_infi]
exact le_infi (Œª U, le_infi $ Œª hU, le_infi $ Œº.le_inner_content K ‚ü®U, hU‚ü©)
{ exact le_infi (Œª U, le_infi $ Œª hU, le_infi $ Œº.le_inner_content K ‚ü®U, hU‚ü©) }
{ exact Œº.inner_content_Union_nat }
exact Œº.inner_content_Union_nat
{ exact Œº.inner_content_mono }
exact Œº.inner_content_mono
intros
simp only [lintegral_eq_supr_eapprox_lintegral, hf, simple_func.lintegral]
refine measurable_supr (Œª n, finset.measurable_sum _ (Œª i _, _))
refine measurable.const_mul _ _
exact measurable_coe ((simple_func.eapprox f n).measurable_set_preimage _)
intros
apply ennreal.zero_lt_one.trans_le
rw [content.outer_measure_eq_infi]
refine le_binfi _
intros U hU
refine le_infi _
intros h2U
refine le_trans (le_of_eq _) (le_bsupr ‚ü®K‚ÇÄ.1, K‚ÇÄ.2.1‚ü© h2U)
exact haar_content_self.symm
intros
rw [‚Üê e.image_symm, e.symm.hausdorff_measure_image]
intros
simpa using (map_eq_sum Œº id measurable_id).symm
intros
rw [‚Üê measure_univ_eq_zero, restrict_apply_univ]
intros
split
{ rintro rfl _ _, refl }
rintro rfl _ _
refl
rw ext_iff'
{ rw ext_iff', intros h i, by_cases hi : measurable_set i, { exact h i hi }, { simp_rw [not_measurable _ hi] } }
intros h i
by_cases hi : measurable_set i
{ exact h i hi }
exact h i hi
{ simp_rw [not_measurable _ hi] }
simp_rw [not_measurable _ hi]
intros
refine measure_theory.vector_measure.ext (Œª i hi, _)
rw [to_ennreal_vector_measure_apply_measurable hi, add_apply, vector_measure.add_apply, to_ennreal_vector_measure_apply_measurable hi, to_ennreal_vector_measure_apply_measurable hi]
intros
intros s hs
by_cases hmeas : measurable_set s
{ exact h hmeas hs }
exact h hmeas hs
{ exact not_measurable v hmeas }
exact not_measurable v hmeas
intros
ext1 b
simp only [ennreal.coe_eq_coe.symm, coe_bind_apply, ennreal.tsum_mul_left.symm, ennreal.tsum_mul_right.symm]
rw [ennreal.tsum_comm]
simp [mul_assoc, mul_left_comm, mul_comm]
intros
split
split; intro h
intro h
contrapose! h
{ contrapose! h, simp [h] }
simp [h]
intro h
{ simp [h, pow_ne_zero] }
simp [h, pow_ne_zero]
intros
let e := fintype.equiv_fin Œπ
obtain ‚ü®t, ht‚ü© := h.exists_partition' (fintype.card Œπ) hŒµ hb (A ‚àò e.symm)
refine ‚ü®t ‚àò e, Œª i‚ÇÄ i‚ÇÅ h, _‚ü©
convert ht (e i‚ÇÄ) (e i‚ÇÅ) h; simp only [e.symm_apply_apply]
convert ht (e i‚ÇÄ) (e i‚ÇÅ) h
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
intros
cases n
{ simp }
simp
rw [divisors_eq_proper_divisors_insert_self_of_pos (nat.succ_pos _), finset.sum_insert (proper_divisors.not_self_mem), add_comm]
{ rw [divisors_eq_proper_divisors_insert_self_of_pos (nat.succ_pos _), finset.sum_insert (proper_divisors.not_self_mem), add_comm] }
intros
simp [norm_def]
intros
simp only [padic.cast_eq_of_rat]
change ‚àÉ N, ‚àÄ i ‚â• N, (f - const _ (f i)).norm < Œµ
by_contradiction h
cases cauchy‚ÇÇ f hŒµ with N hN
have : ‚àÄ N, ‚àÉ i ‚â• N, Œµ ‚â§ (f - const _ (f i)).norm
simpa only [not_forall, not_exists, not_lt] using h
simpa only [not_forall, not_exists, not_lt] using h
rcases this N with ‚ü®i, hi, hge‚ü©
have hne : ¬¨ (f - const (padic_norm p) (f i)) ‚âà 0
intro h
{ intro h, unfold padic_seq.norm at hge; split_ifs at hge, exact not_lt_of_ge hge hŒµ }
unfold padic_seq.norm at hge
unfold padic_seq.norm at hge; split_ifs at hge
split_ifs at hge
exact not_lt_of_ge hge hŒµ
unfold padic_seq.norm at hge; split_ifs at hge
unfold padic_seq.norm at hge
split_ifs at hge
apply not_le_of_gt _ hge
cases decidable.em (N ‚â§ stationary_point hne) with hgen hngen
apply hN; assumption
{ apply hN; assumption }
apply hN
assumption
assumption
have := stationary_point_spec hne (le_refl _) (le_of_not_le hngen)
{ have := stationary_point_spec hne (le_refl _) (le_of_not_le hngen), rw ‚Üêthis, apply hN, apply le_refl, assumption }
rw ‚Üêthis
apply hN
apply le_refl
assumption
intros
rw [ideal.mem_span_singleton] at ha hb
rw [‚Üê sub_eq_zero, ‚Üê int.cast_sub, zmod.int_coe_zmod_eq_zero_iff_dvd, int.coe_nat_pow]
rw [‚Üê dvd_neg, neg_sub] at ha
have := dvd_add ha hb
rwa [sub_eq_add_neg, sub_eq_add_neg, add_assoc, neg_add_cancel_left, ‚Üê sub_eq_add_neg, ‚Üê int.cast_sub, pow_p_dvd_int_iff] at this
intros
simp [ext]
intros
rw [sdiff_eq, top_inf_eq]
intros
{ cases x, simpa using h, refl, }
cases x
simpa using h
refl
intros
rw [supr, subtype.range_coe]
intros
obtain ‚ü®c, hct‚ü© : ‚àÉ c, c ‚àà t := ht
obtain ‚ü®B, hB‚ü© : ‚àÉ B, B ‚àà lower_bounds t := h_bdd
refine hs.out B.2 c.2 ‚ü®_, _‚ü©
{ exact (subtype.mono_coe s).le_cInf_image ‚ü®c, hct‚ü© hB }
exact (subtype.mono_coe s).le_cInf_image ‚ü®c, hct‚ü© hB
{ exact (subtype.mono_coe s).cInf_image_le hct ‚ü®B, hB‚ü© }
exact (subtype.mono_coe s).cInf_image_le hct ‚ü®B, hB‚ü©
intros
haveI := hne.to_subtype
{ haveI := hne.to_subtype, rw image_eq_range at hf, exact gc.l_csupr hf }
rw image_eq_range at hf
exact gc.l_csupr hf
intros
rw [‚Üê map_coe_Ioi_at_top a, tendsto_map'_iff]
intros
refine not_iff_not.1 ((inf_principal_ne_bot_iff.trans _).symm.trans ne_bot_iff)
exact ‚ü®Œª h hs, by simpa [empty_not_nonempty] using h s hs, Œª hs t ht, inter_compl_nonempty_iff.2 $ Œª hts, hs $ mem_of_superset ht hts‚ü©
intros
simp only [filter.frequently, not_not]
intros
classical
erw [‚Üê not_iff_not, not_not, not_not, filter.eventually_comap]
simp only [not_exists, not_and]
intros
simp [comap_eval_ne_bot_iff', *]
intros
refine ((comap_mono $ map_le_iff_le_comap.1 hœà).trans _).antisymm (map_le_iff_le_comap.1 hœÜ)
rw [comap_comap, eq, comap_id]
exact le_rfl
intros
simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self]
intros
rw [‚Üê infi_sets_eq_finite, ‚Üê equiv.plift.surjective.infi_comp]
{ rw [‚Üê infi_sets_eq_finite, ‚Üê equiv.plift.surjective.infi_comp], refl }
refl
ext s
simp only [mem_cofinite, mem_at_top_sets]
split
assume hs
{ assume hs, use (hs.to_finset.sup id) + 1, assume b hb, by_contradiction hbs, have := hs.to_finset.subset_range_sup_succ (hs.mem_to_finset.2 hbs), exact not_lt_of_le hb (finset.mem_range.1 this) }
use (hs.to_finset.sup id) + 1
assume b hb
by_contradiction hbs
have := hs.to_finset.subset_range_sup_succ (hs.mem_to_finset.2 hbs)
exact not_lt_of_le hb (finset.mem_range.1 this)
rintros ‚ü®N, hN‚ü©
{ rintros ‚ü®N, hN‚ü©, apply (finite_lt_nat N).subset, assume n hn, change n < N, exact lt_of_not_ge (Œª hn', hn $ hN n hn') }
apply (finite_lt_nat N).subset
assume n hn
change n < N
exact lt_of_not_ge (Œª hn', hn $ hN n hn')
intros
ext t
simp only [pfun.core_res, mem_pmap, mem_map, mem_inf_principal, imp_iff_not_or]
refl
intros
apply le_antisymm; simp
apply le_antisymm
simp
simp
intros
rw [disjoint.comm, sup_comm]
apply disjoint.disjoint_sup_right_of_disjoint_sup_left h.symm
rwa [sup_comm, disjoint.comm] at hsup
intros
rw [forall_swap,forall_forall_merge]
intros
induction n with n ih
{ cases h, apply le_refl, }
cases h
apply le_refl
cases h with h h
{ cases h with h h, { exact le_sup_right, }, { exact (ih h).trans le_sup_left, } }
{ exact le_sup_right, }
exact le_sup_right
{ exact (ih h).trans le_sup_left, }
exact (ih h).trans le_sup_left
intros
rw [‚Üê e.map_rel_iff, e.apply_symm_apply]
intros
rw symm_diff_eq_sup_sdiff_inf
exact (ha.sup_left hb).disjoint_sdiff_left
intros
{ rw add_comm, exact h.add_mul_left_right z }
rw add_comm
exact h.add_mul_left_right z
intros
simp_rw [irreducible_iff_uniformizer]
{simp_rw [irreducible_iff_uniformizer], exact (is_principal_ideal_ring.principal $ maximal_ideal R).principal}
exact (is_principal_ideal_ring.principal $ maximal_ideal R).principal
intros
{ rw div_nonzero h, exact submodule.mem_div_iff_forall_mul_mem }
rw div_nonzero h
exact submodule.mem_div_iff_forall_mul_mem
intros
ext g
simp only [hsum_coeff, add_coeff, add_apply]
exact finsum_add_distrib (s.finite_co_support _) (t.finite_co_support _)
intros
refine trans (ideal_prod_eq _) _
simp [map_map]
intros
suffices : is_integral R (show S, from ‚ü®x, hx‚ü©)
{ rcases this with ‚ü®p, hpm, hpx‚ü©, replace hpx := congr_arg S.val hpx, refine ‚ü®p, hpm, eq.trans _ hpx‚ü©, simp only [aeval_def, eval‚ÇÇ, sum_def], rw S.val.map_sum, refine finset.sum_congr rfl (Œª n hn, _), rw [S.val.map_mul, S.val.map_pow, S.val.commutes, S.val_apply, subtype.coe_mk], }
rcases this with ‚ü®p, hpm, hpx‚ü©
replace hpx := congr_arg S.val hpx
refine ‚ü®p, hpm, eq.trans _ hpx‚ü©
simp only [aeval_def, eval‚ÇÇ, sum_def]
rw S.val.map_sum
refine finset.sum_congr rfl (Œª n hn, _)
rw [S.val.map_mul, S.val.map_pow, S.val.commutes, S.val_apply, subtype.coe_mk]
refine is_integral_of_noetherian H ‚ü®x, hx‚ü©
intros
let leval : (polynomial R ‚Üí‚Çó[R] A) := (aeval x).to_linear_map
let D : ‚Ñï ‚Üí submodule R A := Œª n, (degree_le R n).map leval
let M := well_founded.min (is_noetherian_iff_well_founded.1 H) (set.range D) ‚ü®_, ‚ü®0, rfl‚ü©‚ü©
have HM : M ‚àà set.range D := well_founded.min_mem _ _ _
cases HM with N HN
have HM : ¬¨M < D (N+1) := well_founded.not_lt_min (is_noetherian_iff_well_founded.1 H) (set.range D) _ ‚ü®N+1, rfl‚ü©
rw ‚Üê HN at HM
have HN2 : D (N+1) ‚â§ D N := classical.by_contradiction (Œª H, HM (lt_of_le_not_le (map_mono (degree_le_mono (with_bot.coe_le_coe.2 (nat.le_succ N)))) H))
have HN3 : leval (X^(N+1)) ‚àà D N
exact HN2 (mem_map_of_mem (mem_degree_le.2 (degree_X_pow_le _)))
{ exact HN2 (mem_map_of_mem (mem_degree_le.2 (degree_X_pow_le _))) }
rcases HN3 with ‚ü®p, hdp, hpe‚ü©
refine ‚ü®X^(N+1) - p, monic_X_pow_sub (mem_degree_le.1 hdp), _‚ü©
show leval (X ^ (N + 1) - p) = 0
rw [linear_map.map_sub, hpe, sub_self]
intros
cases mem_jacobson_iff.1 h 1 with s hs
use s
simpa [sub_mul] using hs
intros
intro x
by_cases triv : (1 : R) = 0
have : (1 : R‚Çò) = 0 := by convert congr_arg (algebra_map R R‚Çò) triv; simp
{ have : (1 : R‚Çò) = 0 := by convert congr_arg (algebra_map R R‚Çò) triv; simp, exact ‚ü®0, ‚ü®trans leading_coeff_zero this.symm, eval‚ÇÇ_zero _ _‚ü©‚ü© }
exact ‚ü®0, ‚ü®trans leading_coeff_zero this.symm, eval‚ÇÇ_zero _ _‚ü©‚ü©
haveI : nontrivial R := nontrivial_of_ne 1 0 triv
{ haveI : nontrivial R := nontrivial_of_ne 1 0 triv, obtain ‚ü®‚ü®s, ‚ü®u, hu‚ü©‚ü©, hx‚ü© := surj (algebra.algebra_map_submonoid S M) x, obtain ‚ü®v, hv‚ü© := hu, obtain ‚ü®v', hv'‚ü© := is_unit_iff_exists_inv'.1 (map_units R‚Çò ‚ü®v, hv.1‚ü©), refine @is_integral_of_is_integral_mul_unit R‚Çò _ _ _ (localization_algebra M S) x (algebra_map S S‚Çò u) v' _ _, { replace hv' := congr_arg (@algebra_map R‚Çò S‚Çò _ _ (localization_algebra M S)) hv', rw [ring_hom.map_mul, ring_hom.map_one, ‚Üê ring_hom.comp_apply _ (algebra_map R R‚Çò)] at hv', erw is_localization.map_comp at hv', exact hv.2 ‚ñ∏ hv' }, { obtain ‚ü®p, hp‚ü© := H s, exact hx.symm ‚ñ∏ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ‚ñ∏ M.one_mem) } }
obtain ‚ü®‚ü®s, ‚ü®u, hu‚ü©‚ü©, hx‚ü© := surj (algebra.algebra_map_submonoid S M) x
obtain ‚ü®v, hv‚ü© := hu
obtain ‚ü®v', hv'‚ü© := is_unit_iff_exists_inv'.1 (map_units R‚Çò ‚ü®v, hv.1‚ü©)
refine @is_integral_of_is_integral_mul_unit R‚Çò _ _ _ (localization_algebra M S) x (algebra_map S S‚Çò u) v' _ _
replace hv' := congr_arg (@algebra_map R‚Çò S‚Çò _ _ (localization_algebra M S)) hv'
{ replace hv' := congr_arg (@algebra_map R‚Çò S‚Çò _ _ (localization_algebra M S)) hv', rw [ring_hom.map_mul, ring_hom.map_one, ‚Üê ring_hom.comp_apply _ (algebra_map R R‚Çò)] at hv', erw is_localization.map_comp at hv', exact hv.2 ‚ñ∏ hv' }
rw [ring_hom.map_mul, ring_hom.map_one, ‚Üê ring_hom.comp_apply _ (algebra_map R R‚Çò)] at hv'
erw is_localization.map_comp at hv'
exact hv.2 ‚ñ∏ hv'
obtain ‚ü®p, hp‚ü© := H s
{ obtain ‚ü®p, hp‚ü© := H s, exact hx.symm ‚ñ∏ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ‚ñ∏ M.one_mem) }
exact hx.symm ‚ñ∏ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ‚ñ∏ M.one_mem)
intros
simp [inv_fun,finset.mul_sum]
intros
rw fg_def
split
rintros ‚ü®S, Sfin, hS‚ü©
{ rintros ‚ü®S, Sfin, hS‚ü©, obtain ‚ü®n, f, rfl‚ü© := Sfin.fin_embedding, exact ‚ü®n, f, hS‚ü©, }
obtain ‚ü®n, f, rfl‚ü© := Sfin.fin_embedding
exact ‚ü®n, f, hS‚ü©
rintros ‚ü®n, s, hs‚ü©
{ rintros ‚ü®n, s, hs‚ü©, refine ‚ü®range s, finite_range s, hs‚ü© }
refine ‚ü®range s, finite_range s, hs‚ü©
intros
conv { congr, congr, skip, funext, dsimp [bernstein_polynomial], rw [mul_assoc, mul_comm], }
rw ‚Üêadd_pow
simp
intros
by_cases h : p = 0
{ simp [h] }
simp [h]
rw [‚Üê leading_coeff_eq_zero, leading_coeff, ‚Üê ne.def, ‚Üê mem_support_iff] at h
rw [content, ‚Üê finset.insert_erase h, finset.gcd_insert, leading_coeff, content, erase_lead_support]
refine congr rfl (finset.gcd_congr rfl (Œª i hi, _))
rw finset.mem_erase at hi
rw [erase_lead_coeff, if_neg hi.1]
intros
rw [‚Üê dickson_one_one_mul, mul_comm, dickson_one_one_mul]
intros
induction n with n ih
simp only [nat.nat_zero_eq_zero, pochhammer_zero, eval_one]
{ simp only [nat.nat_zero_eq_zero, pochhammer_zero, eval_one], exact zero_lt_one, }
exact zero_lt_one
rw [pochhammer_succ_right, mul_add, eval_add, ‚Üênat.cast_comm, eval_nat_cast_mul, eval_mul_X, nat.cast_comm, ‚Üêmul_add]
{ rw [pochhammer_succ_right, mul_add, eval_add, ‚Üênat.cast_comm, eval_nat_cast_mul, eval_mul_X, nat.cast_comm, ‚Üêmul_add], exact mul_pos ih (lt_of_lt_of_le h ((le_add_iff_nonneg_right _).mpr (nat.cast_nonneg n))), }
exact mul_pos ih (lt_of_lt_of_le h ((le_add_iff_nonneg_right _).mpr (nat.cast_nonneg n)))
intros
{ intro, rw rename_esymm }
intro
rw rename_esymm
intros
unfold minpoly_gen
rw degree_sub_eq_left_of_degree_lt; rw degree_X_pow
rw degree_sub_eq_left_of_degree_lt
rw degree_X_pow
rw degree_X_pow
apply degree_sum_fin_lt
intros
ext
{ ext, simp only [ring_hom.id_apply, rescale, one_pow, coeff_mk, one_mul, ring_hom.coe_mk], }
simp only [ring_hom.id_apply, rescale, one_pow, coeff_mk, one_mul, ring_hom.coe_mk]
intros
simpa only [nat.cast_one] using order_monomial_of_ne_zero 1 (1:R) one_ne_zero
intros
change (mv_power_series.map œÉ (algebra_map R A)).comp (C œÉ R) r = _
simp
intros
ext
{ ext, simp [cos, apply_ite f] }
simp [cos, apply_ite f]
intros
apply tensor_product.induction_on x; simp {contextual := tt}
apply tensor_product.induction_on x
simp {contextual := tt}
simp {contextual := tt}
simp {contextual := tt}
intros
ext
{ ext, rw [trace_form_to_matrix, pow_add, h.basis_eq_pow, h.basis_eq_pow] }
rw [trace_form_to_matrix, pow_add, h.basis_eq_pow, h.basis_eq_pow]
intros
{ dunfold count, split_ifs, refl }
dunfold count
split_ifs
refl
intros
simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)
intros
rw [frobenius_poly, ring_hom.map_add, ring_hom.map_pow, ring_hom.map_mul, map_X, map_C]
simp only [int.cast_coe_nat, add_zero, ring_hom.eq_int_cast, zmod.nat_cast_self, zero_mul, C_0]
intros
obtain ‚ü®œÜ, hf‚ü© := hf
unfreezingI {obtain ‚ü®œÜ, hf‚ü© := hf}
refine ‚ü®‚ü®Œª n, bind‚ÇÅ (uncurry ![X, X]) (œÜ n), _‚ü©‚ü©
intros
funext n
simp only [hf, peval, uncurry, aeval_bind‚ÇÅ]
apply eval‚ÇÇ_hom_congr rfl _ rfl
ext ‚ü®i, k‚ü©
fin_cases i
fin_cases i; simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]
simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]
simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]
intros
cases n
simp only [verschiebung_poly, verschiebung_fun_coeff_zero, if_pos rfl, alg_hom.map_zero]
{ simp only [verschiebung_poly, verschiebung_fun_coeff_zero, if_pos rfl, alg_hom.map_zero] }
rw [verschiebung_poly, verschiebung_fun_coeff_succ, if_neg (n.succ_ne_zero), aeval_X, nat.succ_eq_add_one, nat.add_sub_cancel]
{ rw [verschiebung_poly, verschiebung_fun_coeff_succ, if_neg (n.succ_ne_zero), aeval_X, nat.succ_eq_add_one, nat.add_sub_cancel] }
intros
cases min_eq _ _ with s e; rw [succ, e]; exact s.2
cases min_eq _ _ with s e; rw [succ, e]
cases min_eq _ _ with s e
rw [succ, e]
exact s.2
intros
refine lt_succ.1 (lt_of_not_ge $ Œª hn, _)
rw [‚Üê cardinal.nat_succ, ‚Üê cardinal.lift_mk_fin n.succ] at hn
cases hn with f
refine not_lt_of_le (H $ finset.univ.map f) _
rw [finset.card_map, ‚Üê fintype.card, fintype.card_ulift, fintype.card_fin]
exact n.lt_succ_self
intros
induction s with _ a a' l l' e m s IH
cases h
{cases h}
simp at h
rcases h with rfl|h
exacts [‚ü®_, m, e‚ü©, IH h]
intros
cases e : split' o with a n
rw split_eq_scale_split' e at h
injection h
subst o'
cases NF_repr_split' e
resetI
simp
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
rw ‚Üê h
rw ‚Üê h; simp
simp
intros
simp [h.symm, horner]; cc
simp [h.symm, horner]
cc
intros
cases xs; unfold_wf; linarith
cases xs; unfold_wf
cases xs
unfold_wf
unfold_wf
linarith
intros
rw [‚Üê is_open_compl_iff, is_open_compl_image_coe]
intros
simpa only using h.map (-add_monoid_hom.id Œ±) continuous_neg
intros
{ ext, simp }
ext
simp
intros
{ ext m, refl }
ext m
refl
intros
refine ‚ü®eq_of_nhds_eq_nhds $ Œª a, _‚ü©
rw [h_nhds]
letI := preorder.topology Œ±
letI : order_topology Œ± := ‚ü®rfl‚ü©
exact (nhds_eq_infi_abs_sub a).symm
intros
rw [‚Üê comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]
intros
simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]
intros
rw nhds_def; exact infi_le_of_le s (infi_le_of_le ‚ü®h, o‚ü© sf)
rw nhds_def
exact infi_le_of_le s (infi_le_of_le ‚ü®h, o‚ü© sf)
intros
apply continuous_of_continuous_uncurry
apply continuous_of_continuous_uncurry
rw ‚Üêhomeomorph.comp_continuous_iff' (homeomorph.prod_assoc _ _ _).symm
convert continuous_ev; tidy
convert continuous_ev
tidy
intros
fsplit
intros s‚ÇÅ s‚ÇÇ
by_cases n : nonempty Œ±
obtain ‚ü®x‚ü© := n
{ obtain ‚ü®x‚ü© := n, ext f, have h : f = algebra_map R C(Œ±, R) (f x), { ext x', simp only [mul_one, algebra.id.smul_eq_mul, algebra_map_apply], congr, }, rw h, simp only [subalgebra.algebra_map_mem], }
ext f
have h : f = algebra_map R C(Œ±, R) (f x)
ext x'
{ ext x', simp only [mul_one, algebra.id.smul_eq_mul, algebra_map_apply], congr, }
simp only [mul_one, algebra.id.smul_eq_mul, algebra_map_apply]
congr
rw h
simp only [subalgebra.algebra_map_mem]
ext f
{ ext f, have h : f = 0, { ext x', exact false.elim (n ‚ü®x'‚ü©), }, subst h, simp only [subalgebra.zero_mem], }
have h : f = 0
{ ext x', exact false.elim (n ‚ü®x'‚ü©), }
ext x'
exact false.elim (n ‚ü®x'‚ü©)
subst h
simp only [subalgebra.zero_mem]
intros
simp
intros
classical
simp only [is_open_iff_continuous_mem, set.ite] at *
convert continuous_piecewise (Œª x hx, propext (ht x hx)) hs.continuous_on hs'.continuous_on
ext x
by_cases hx : x ‚àà t
by_cases hx : x ‚àà t; simp [hx]
simp [hx]
simp [hx]
intros
rw [nhds_within, nhds_subtype, principal_subtype, ‚Üêcomap_inf, ‚Üênhds_within]
intros
rw continuous_on_iff'
split
assume h t ht
{ assume h t ht, rcases h t ht with ‚ü®u, u_open, hu‚ü©, rw [inter_comm, hu], apply is_open.inter u_open hs }
rcases h t ht with ‚ü®u, u_open, hu‚ü©
rw [inter_comm, hu]
apply is_open.inter u_open hs
assume h t ht
{ assume h t ht, refine ‚ü®s ‚à© f ‚Åª¬π' t, h t ht, _‚ü©, rw [@inter_comm _ s (f ‚Åª¬π' t), inter_assoc, inter_self] }
refine ‚ü®s ‚à© f ‚Åª¬π' t, h t ht, _‚ü©
rw [@inter_comm _ s (f ‚Åª¬π' t), inter_assoc, inter_self]
intros
change (of_le h ‚àò A.proj) x = _
{ change (of_le h ‚àò A.proj) x = _, simp }
simp
intros
rw continuous_iff_continuous_at
assume x
rcases h (proj x) with ‚ü®e, ex‚ü©
apply e.continuous_at_proj
rwa e.source_eq
intros
rw ‚Üê image_symm; exact h.symm.compact_image
rw ‚Üê image_symm
exact h.symm.compact_image
intros
rcases le_or_lt a b with h|h
rw [real.ediam_eq (bounded_Icc _ _), cSup_Icc h, cInf_Icc h]
{ rw [real.ediam_eq (bounded_Icc _ _), cSup_Icc h, cInf_Icc h] }
{ simp [h, h.le] }
simp [h, h.le]
intros
simp only [continuous_at, nhds_coe_coe, ‚Üê coe_add, tendsto_map'_iff, (‚àò), tendsto_coe, tendsto_add]
intros
rw [‚Üê continuous_within_at_univ, e.continuous_within_at_iff_continuous_within_at_comp_right h, preimage_univ, continuous_within_at_univ]
intros
ext
{ ext, simp only [continuous_id, id.def, function.comp.right_id, coe_comap] }
simp only [continuous_id, id.def, function.comp.right_id, coe_comap]
intros
rw ‚Üê bUnion_univ
apply dense_bUnion_interior_of_closed
{ simp [hc] }
simp [hc]
{ apply countable_encodable }
apply countable_encodable
{ rwa ‚Üê bUnion_univ at hU }
rwa ‚Üê bUnion_univ at hU
intros
refine tendsto.mono_right _ (comap_dist_right_at_top_le_cocompact x)
{ refine tendsto.mono_right _ (comap_dist_right_at_top_le_cocompact x), rwa tendsto_comap_iff }
rwa tendsto_comap_iff
intros
rw [‚Üê not_nonempty_iff_eq_empty, nonempty_closed_ball, not_le]
intros
simp [is_open_iff, subset_singleton_iff, mem_ball]
intros
apply induction_on‚ÇÉ x y z
refine is_closed_le _ (continuous.add _ _)
{ refine is_closed_le _ (continuous.add _ _), { have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.1, p.2.2)) := continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }, { have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.1, p.2.1)) := continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }, { have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.2.1, p.2.2)) := continuous.prod_mk (continuous_fst.comp continuous_snd) (continuous.comp continuous_snd continuous_snd), exact (continuous.comp completion.uniform_continuous_dist.continuous this : _) } }
have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.1, p.2.2)) := continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd)
{ have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.1, p.2.2)) := continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }
exact (completion.uniform_continuous_dist.continuous.comp this : _)
have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.1, p.2.1)) := continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd)
{ have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.1, p.2.1)) := continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }
exact (completion.uniform_continuous_dist.continuous.comp this : _)
have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.2.1, p.2.2)) := continuous.prod_mk (continuous_fst.comp continuous_snd) (continuous.comp continuous_snd continuous_snd)
{ have : continuous (Œªp : completion Œ± √ó completion Œ± √ó completion Œ±, (p.2.1, p.2.2)) := continuous.prod_mk (continuous_fst.comp continuous_snd) (continuous.comp continuous_snd continuous_snd), exact (continuous.comp completion.uniform_continuous_dist.continuous this : _) }
exact (continuous.comp completion.uniform_continuous_dist.continuous this : _)
assume a b c
{ assume a b c, rw [completion.dist_eq, completion.dist_eq, completion.dist_eq], exact dist_triangle a b c }
rw [completion.dist_eq, completion.dist_eq, completion.dist_eq]
exact dist_triangle a b c
intros
simp [edist_comm]
intros
simp [@Hausdorff_edist_comm _ _ s _]
intros
simp [Hausdorff_dist]
intros
refine emetric.uniform_continuous_iff.2 (ŒªŒµ Œµpos, _)
use [Œµ / K, ennreal.div_pos_iff.2 ‚ü®ne_of_gt Œµpos, ennreal.coe_ne_top‚ü©]
assume x y Dxy
apply lt_of_le_of_lt (hf.edist_le_mul x y)
rw [mul_comm]
exact ennreal.mul_lt_of_lt_div Dxy
intros
{ rw supr_def, simp }
rw supr_def
simp
intros
refine ha.elim (Œª x, _)
have : is_open ((finset.univ : finset Œ±) : set Œ±)
simp
{ simp }
rcases exists_open_singleton_of_open_finset _ ‚ü®x, finset.mem_univ x‚ü© this with ‚ü®x, _, hx‚ü©
exact ‚ü®x, hx‚ü©
intros
dsimp [presheaf.germ, stalk_to_fiber]
cases x
simp
refl
intros
rw filter.has_basis_cocompact.tendsto_iff filter.has_basis_cocompact
intros K hK
refine ‚ü®f ‚Åª¬π' (K ‚à© (set.range f)), _, Œª x hx, by simpa using hx‚ü©
apply hf.to_embedding.is_compact_iff_is_compact_image.mpr
rw set.image_preimage_eq_of_subset (set.inter_subset_right _ _)
exact hK.inter_right hf.closed_range
intros
ext
ext ; dsimp [uniform_space.comap] ; rw filter.comap_comap
ext ; dsimp [uniform_space.comap]
dsimp [uniform_space.comap]
rw filter.comap_comap
intros
simp [symmetric_rel, symmetrize_rel, preimage_inter, inter_comm, ‚Üê preimage_comp]
intros
rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift']
intro s
{ intro s, exact monotone_prod monotone_const monotone_preimage }
exact monotone_prod monotone_const monotone_preimage
intro t
{ intro t, exact monotone_prod monotone_preimage monotone_const }
exact monotone_prod monotone_preimage monotone_const
intros
cases x
{ cases x, refl }
refl
intros
cases a
cases b
congr
funext i
cases i
apply h
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
rw [‚Üê h‚ÇÇ]
apply int.nat_abs_bit1_nonneg h‚ÇÅ
intros
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
rw int.add_comm at h
exact int.lt_add_of_sub_right_lt h
intros
induction l; intros; contradiction
induction l; intros
induction l
contradiction
contradiction
intros
unfold bodd bodd_div2; cases bodd_div2 n; cases fst; refl
unfold bodd bodd_div2; cases bodd_div2 n; cases fst
unfold bodd bodd_div2; cases bodd_div2 n
unfold bodd bodd_div2
cases bodd_div2 n
cases fst
refl
refl
intros
rw [nat.add_comm, add_div_right x H]
intros
{cases n, exact or.inl rfl, exact or.inr (succ_pos _)}
cases n
exact or.inl rfl
exact or.inr (succ_pos _)
intros
rw [nat.mul_sub_left_distrib, nat.right_distrib, nat.right_distrib, nat.mul_comm b a, nat.add_comm (a*a) (a*b), nat.add_sub_add_left]
intros
tactic.mk_inj_eq
intros
simp [bit1, add_smul, smul_add]
intros
cases exists_nat_gt (y - x)‚Åª¬π with n nh
cases exists_floor (x * n) with z zh
refine ‚ü®(z + 1 : ‚Ñ§) / n, _‚ü©
have n0' := (inv_pos.2 (sub_pos.2 h)).trans nh
have n0 := nat.cast_pos.1 n0'
rw [rat.cast_div_of_ne_zero, rat.cast_coe_nat, rat.cast_coe_int, div_lt_iff n0']
refine ‚ü®(lt_div_iff n0').2 $ (lt_iff_lt_of_le_iff_le (zh _)).1 (lt_add_one _), _‚ü©
rw [int.cast_add, int.cast_one]
refine lt_of_le_of_lt (add_le_add_right ((zh _).1 (le_refl _)) _) _
rwa [‚Üê lt_sub_iff_add_lt', ‚Üê sub_mul, ‚Üê div_lt_iff' (sub_pos.2 h), one_div]
rw [rat.coe_int_denom, nat.cast_one]
{ rw [rat.coe_int_denom, nat.cast_one], exact one_ne_zero }
exact one_ne_zero
exact one_ne_zero
intro H
{ intro H, rw [rat.coe_nat_num, ‚Üê coe_coe, nat.cast_eq_zero] at H, subst H, cases n0 }
rw [rat.coe_nat_num, ‚Üê coe_coe, nat.cast_eq_zero] at H
subst H
cases n0
rw [rat.coe_nat_denom, nat.cast_one]
{ rw [rat.coe_nat_denom, nat.cast_one], exact one_ne_zero }
exact one_ne_zero
exact one_ne_zero
intros
simpa only [‚Üê div_eq_mul_inv] using @sum_range_sub (additive M) _ f n
intros
simp
intros
casesI hq with q hq_one hq_prime
{ refl }
refl
exact false.elim (lt_irrefl _ ((hp.eq R hq_hchar).symm ‚ñ∏ hq_prime : (0 : ‚Ñï).prime).pos)
{ exact false.elim (lt_irrefl _ ((hp.eq R hq_hchar).symm ‚ñ∏ hq_prime : (0 : ‚Ñï).prime).pos) }
intros
cases s_succ_succ_nth_eq : s.nth (n + 2) with gp_succ_succ_n
case option.none { have : squash_seq s (n + 1) = s, from squash_seq_eq_self_of_terminated s_succ_succ_nth_eq, cases s_succ_nth_eq : (s.nth (n + 1)); simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq] }
have : squash_seq s (n + 1) = s
from squash_seq_eq_self_of_terminated s_succ_succ_nth_eq
cases s_succ_nth_eq : (s.nth (n + 1)); simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]
cases s_succ_nth_eq : (s.nth (n + 1))
simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]
simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]
case option.some { obtain ‚ü®gp_succ_n, s_succ_nth_eq‚ü© : ‚àÉ gp_succ_n, s.nth (n + 1) = some gp_succ_n, from s.ge_stable (n + 1).le_succ s_succ_succ_nth_eq, ext m, cases decidable.em (m = n) with m_eq_n m_ne_n, { have : s.tail.nth n = some gp_succ_n, from (s.nth_tail n).trans s_succ_nth_eq, simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth n) this), (seq.zip_with_nth_some (seq.nats_nth (n + 1)) s_succ_nth_eq)] }, { have : s.tail.nth m = s.nth (m + 1), from s.nth_tail m, cases s_succ_mth_eq : s.nth (m + 1), all_goals { have s_tail_mth_eq, from this.trans s_succ_mth_eq }, { simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)] }, { simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)] } } }
obtain ‚ü®gp_succ_n, s_succ_nth_eq‚ü© : ‚àÉ gp_succ_n, s.nth (n + 1) = some gp_succ_n
from s.ge_stable (n + 1).le_succ s_succ_succ_nth_eq
ext m
cases decidable.em (m = n) with m_eq_n m_ne_n
have : s.tail.nth n = some gp_succ_n
{ have : s.tail.nth n = some gp_succ_n, from (s.nth_tail n).trans s_succ_nth_eq, simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth n) this), (seq.zip_with_nth_some (seq.nats_nth (n + 1)) s_succ_nth_eq)] }
from (s.nth_tail n).trans s_succ_nth_eq
simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth n) this), (seq.zip_with_nth_some (seq.nats_nth (n + 1)) s_succ_nth_eq)]
have : s.tail.nth m = s.nth (m + 1)
{ have : s.tail.nth m = s.nth (m + 1), from s.nth_tail m, cases s_succ_mth_eq : s.nth (m + 1), all_goals { have s_tail_mth_eq, from this.trans s_succ_mth_eq }, { simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)] }, { simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)] } }
from s.nth_tail m
cases s_succ_mth_eq : s.nth (m + 1)
have s_tail_mth_eq
all_goals { have s_tail_mth_eq, from this.trans s_succ_mth_eq }
from this.trans s_succ_mth_eq
simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)]
{ simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)] }
have s_tail_mth_eq
from this.trans s_succ_mth_eq
simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)]
{ simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)] }
intros
simpa [partial_numerators, seq.map_nth] using nth_part_num_eq
intros
{congr, ext, simp [to_add_monoid, of]}
congr
ext
simp [to_add_monoid, of]
intros
{ unfold gcd_b, rw [xgcd, xgcd_zero_left] }
unfold gcd_b
rw [xgcd, xgcd_zero_left]
intros
rw [inv_eq_one_div, inv_eq_one_div, one_div_add_one_div ha hb]
intros
rw [gcd_def, multiset.gcd_eq_zero_iff]
split
split; intro h
intro h
intros b bs
{ intros b bs, apply h (f b), simp only [multiset.mem_map, mem_def.1 bs], use b, simp [mem_def.1 bs] }
apply h (f b)
simp only [multiset.mem_map, mem_def.1 bs]
use b
simp [mem_def.1 bs]
intro h
intros a as
{ intros a as, rw multiset.mem_map at as, rcases as with ‚ü®b, ‚ü®bs, rfl‚ü©‚ü©, apply h b (mem_def.1 bs) }
rw multiset.mem_map at as
rcases as with ‚ü®b, ‚ü®bs, rfl‚ü©‚ü©
apply h b (mem_def.1 bs)
intros
simp [h.symm]
intros
simp [h]
intros
rw [sub_eq_iff_eq_add, add_comm]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
congr'
congr'; injection h
injection h
injection h
injection h
intros
ext
{ ext, simp only [function.comp_app, inv_apply, map_inv, coe_comp] }
simp only [function.comp_app, inv_apply, map_inv, coe_comp]
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
cases ha with a ha; rw [‚Üêha, units.mul_left_inj]
cases ha with a ha
rw [‚Üêha, units.mul_left_inj]
intros
rw [‚Üê multiples_hom_symm_apply, ‚Üê multiples_hom_apply, equiv.apply_symm_apply]
intros
rw [div_eq_mul_inv, inv_zero, mul_zero]
intros
rw [mul_comm c, mul_comm c, mul_div_mul_right _ _ hc]
intros
rw [‚Üêkernel_subobject_arrow', exact_iso_comp]
{ rw [‚Üêkernel_subobject_arrow', exact_iso_comp], exact exact_kernel_subobject_arrow }
exact exact_kernel_subobject_arrow
intros
change ite (1 = 0 + 1) (d‚ÇÄ ‚â´ ùüô X‚ÇÅ) 0 = d‚ÇÄ
{ change ite (1 = 0 + 1) (d‚ÇÄ ‚â´ ùüô X‚ÇÅ) 0 = d‚ÇÄ, rw [if_pos rfl, category.comp_id] }
rw [if_pos rfl, category.comp_id]
intros
simp [mul_indicator_preimage, pi.one_def, set.preimage_const_of_not_mem ht]
intros
{ rw [‚Üêsub_eq_zero, sub_neg_eq_add, ‚Üêadd_lie], simp, }
rw [‚Üêsub_eq_zero, sub_neg_eq_add, ‚Üêadd_lie]
simp
intros
dunfold derived_abelian_of_ideal
cases h : derived_length_of_ideal R L I with k
{ rw derived_length_zero at h, rw h, refl, }
rw derived_length_zero at h
rw h
refl
obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := (derived_series_of_derived_length_succ R L I k).mp h
{ obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := (derived_series_of_derived_length_succ R L I k).mp h, have h‚ÇÉ : I ‚â† ‚ä•, { intros contra, apply h‚ÇÇ, rw contra, apply derived_series_of_bot_eq_bot, }, change derived_series_of_ideal R L k I = ‚ä• ‚Üî I = ‚ä•, split; contradiction, }
have h‚ÇÉ : I ‚â† ‚ä•
intros contra
{ intros contra, apply h‚ÇÇ, rw contra, apply derived_series_of_bot_eq_bot, }
apply h‚ÇÇ
rw contra
apply derived_series_of_bot_eq_bot
change derived_series_of_ideal R L k I = ‚ä• ‚Üî I = ‚ä•
split; contradiction
split
contradiction
contradiction
intros
split
{ exact set.subset.trans subset_lie_span, }
exact set.subset.trans subset_lie_span
{ intros hs m hm, rw mem_lie_span at hm, exact hm _ hs, }
intros hs m hm
rw mem_lie_span at hm
exact hm _ hs
intros
split
{ exact subset.trans subset_lie_span, }
exact subset.trans subset_lie_span
{ intros hs m hm, rw mem_lie_span at hm, exact hm _ hs, }
intros hs m hm
rw mem_lie_span at hm
exact hm _ hs
intros
refine is_linear_map.mk (smul_add c) _
intros _ _
simp only [smul_smul, mul_comm]
intros
simp
intros
refine ‚ü®h, Œª ho, _‚ü©
cases lt_trichotomy a b with hab hab
change compares ordering.lt a b at hab
{ change compares ordering.lt a b at hab, rwa [ho.inj (h hab)] }
rwa [ho.inj (h hab)]
cases hab with hab hab
{ cases hab with hab hab, { change compares ordering.eq a b at hab, rwa [ho.inj (h hab)] }, { change compares ordering.gt a b at hab, rwa [ho.inj (h hab)] } }
change compares ordering.eq a b at hab
{ change compares ordering.eq a b at hab, rwa [ho.inj (h hab)] }
rwa [ho.inj (h hab)]
change compares ordering.gt a b at hab
{ change compares ordering.gt a b at hab, rwa [ho.inj (h hab)] }
rwa [ho.inj (h hab)]
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, one_lt_div_of_neg] }
simp [hb, hb.not_lt, one_lt_div_of_neg]
{ simp [lt_irrefl, zero_le_one] }
simp [lt_irrefl, zero_le_one]
{ simp [hb, hb.not_lt, one_lt_div] }
simp [hb, hb.not_lt, one_lt_div]
intros
refine (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn)
refine (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn); exact pow_pos (trans zero_lt_one a1) _
exact pow_pos (trans zero_lt_one a1) _
exact pow_pos (trans zero_lt_one a1) _
intros
simpa only [div_eq_mul_inv] using mul_inv_lt_mul_inv_iff'
intros
norm_cast
intros
haveI := @linear_order.decidable_le Œ± _; exact lt_of_not_ge (Œª hb, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
haveI := @linear_order.decidable_le Œ± _
exact lt_of_not_ge (Œª hb, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
intros
nontriviality
calc 1 = 1 * 1 : by rw one_mul ... < a * b : decidable.mul_lt_mul' ha hb zero_le_one (zero_lt_one.trans_le ha)
intros
simpa only [zero_add] using h.neg 0
intros
rw [‚Üênat.sub_add_cancel (nat.pos_of_ne_zero hn), pow_succ, empty_mul]
intros
convert finset.card_image_le
{ convert finset.card_image_le, rw [finset.card_product, mul_comm] }
rw [finset.card_product, mul_comm]
intros
simpa using nat_degree_multiset_sum_le (s.val.map f)
intros
simp only [is_left_regular, ‚Üê mul_left_iterate, rla.iterate n]
intros
split_ifs; refl
split_ifs
refl
refl
intros
simp
intros
obtain ‚ü®V, (hxV : x.1 ‚àà V.1), iVU, f, g, (hVDg : V ‚äÜ basic_open g), s_eq‚ü© := exists_const R U s x.1 x.2
obtain ‚ü®_, ‚ü®h, rfl‚ü©, hxDh, (hDhV : basic_open h ‚äÜ V)‚ü© := is_topological_basis_basic_opens.exists_subset_of_mem_open hxV V.2
cases (basic_open_le_basic_open_iff h g).mp (set.subset.trans hDhV hVDg) with n hn
replace hn := ideal.mul_mem_left (ideal.span {g}) h hn
rw [‚Üê pow_succ, ideal.mem_span_singleton'] at hn
cases hn with c hc
have basic_opens_eq := basic_open_pow h (n+1) (by linarith)
have i_basic_open := eq_to_hom basic_opens_eq ‚â´ hom_of_le hDhV
use [f * c, h ^ (n+1), i_basic_open ‚â´ iVU, (basic_opens_eq.symm.le : _) hxDh]
rw [op_comp, functor.map_comp, comp_apply, ‚Üê s_eq, res_const]
swap
intros y hy
{ intros y hy, rw basic_opens_eq at hy, exact (set.subset.trans hDhV hVDg : _) hy }
rw basic_opens_eq at hy
exact (set.subset.trans hDhV hVDg : _) hy
apply const_ext
rw [mul_assoc f c g, hc]
intros
rcases ((tfae_exists_lt_is_o_pow (Œª n, ‚à•p n‚à• * r ^ n) 1).out 1 5).mp (p.is_o_of_lt_radius h) with ‚ü®a, ha, C, hC, H‚ü©
exact ‚ü®a, ha, C, hC, Œª n, (le_abs_self _).trans (H n)‚ü©
intros
rw [‚Üê p.nnnorm_change_origin_series_term k l s hs, ‚Üê fin.prod_const, ‚Üê fin.prod_const]
apply continuous_multilinear_map.le_of_op_nnnorm_le
apply continuous_multilinear_map.le_op_nnnorm
intros
ext1 n
induction n using nat.strong_rec' with n IH
cases n
simp
{ simp }
cases n
simp
{ simp }
simp only [left_inv, neg_inj]
refine finset.sum_congr rfl (Œª c cuniv, _)
rcases c with ‚ü®c, hc‚ü©
ext v
dsimp
simp [IH _ hc]
intros
unfold is_O_with at *
filter_upwards [hfg, hgk]
assume x hx hx'
calc ‚à•f x‚à• ‚â§ c * ‚à•g x‚à• : hx ... ‚â§ c * (c' * ‚à•k x‚à•) : mul_le_mul_of_nonneg_left hx' hc ... = c * c' * ‚à•k x‚à• : (mul_assoc _ _ _).symm
intros
rw is_O_with; refl
rw is_O_with
refl
intros
simp [div_eq_inv_mul, differentiable.const_mul, hc]
intros
{ unfold deriv_within deriv, rw h.fderiv_within hxs }
unfold deriv_within deriv
rw h.fderiv_within hxs
intros
rw add_comm
exact (is_bounded_bilinear_map_comp.has_fderiv_at (d x, c x)).comp_has_fderiv_within_at x (hd.prod hc)
intros
{ rw ‚Üê H at h, exact h }
rw ‚Üê H at h
exact h
intros
simp [iterated_deriv_within_eq_equiv_comp, continuous_linear_equiv.comp_continuous_on_iff, -coe_fn_coe_base]
exact h.continuous_on_iterated_fderiv_within hmn hs
intros
refine is_o_iff.mpr (Œª c hc, metric.eventually_nhds_iff_ball.mpr _)
rcases metric.mem_nhds_iff.mp (inter_mem hder (hcont $ ball_mem_nhds _ hc)) with ‚ü®Œµ, Œµ0, hŒµ‚ü©
refine ‚ü®Œµ, Œµ0, _‚ü©
rintros ‚ü®a, b‚ü© h
rw [‚Üê ball_prod_same, prod_mk_mem_set_prod_eq] at h
have hf' : ‚àÄ x' ‚àà ball x Œµ, ‚à•f' x' - f' x‚à• ‚â§ c
intros x' H'
{ intros x' H', rw ‚Üê dist_eq_norm, exact le_of_lt (hŒµ H').2 }
rw ‚Üê dist_eq_norm
exact le_of_lt (hŒµ H').2
letI : normed_space ‚Ñù G := restrict_scalars.normed_space ‚Ñù ùïú G
letI : is_scalar_tower ‚Ñù ùïú G := restrict_scalars.is_scalar_tower _ _ _
refine (convex_ball _ _).norm_image_sub_le_of_norm_has_fderiv_within_le' _ hf' h.2 h.1
exact Œª y hy, (hŒµ hy).1.has_fderiv_within_at
intros
rcases lt_trichotomy x 0 with hx|hx|hx
have : f_aux (n+1) x = 0
{ have : f_aux (n+1) x = 0, by simp [f_aux, le_of_lt hx], rw this, apply (has_deriv_at_const x (0 : ‚Ñù)).congr_of_eventually_eq, filter_upwards [gt_mem_nhds hx], assume y hy, simp [f_aux, hy.le] }
simp [f_aux, le_of_lt hx]
simp [f_aux, le_of_lt hx]
rw this
apply (has_deriv_at_const x (0 : ‚Ñù)).congr_of_eventually_eq
filter_upwards [gt_mem_nhds hx]
assume y hy
simp [f_aux, hy.le]
have : f_aux (n + 1) 0 = 0
{ have : f_aux (n + 1) 0 = 0, by simp [f_aux, le_refl], rw [hx, this], exact f_aux_deriv_zero n }
simp [f_aux, le_refl]
simp [f_aux, le_refl]
rw [hx, this]
exact f_aux_deriv_zero n
have : f_aux (n+1) x = (P_aux (n+1)).eval x * exp (-x‚Åª¬π) / x^(2 * (n+1))
{ have : f_aux (n+1) x = (P_aux (n+1)).eval x * exp (-x‚Åª¬π) / x^(2 * (n+1)), by simp [f_aux, not_le_of_gt hx], rw this, exact f_aux_deriv_pos n x hx }
simp [f_aux, not_le_of_gt hx]
simp [f_aux, not_le_of_gt hx]
rw this
exact f_aux_deriv_pos n x hx
intros
rw times_cont_diff_on_top_iff_fderiv_within hs.unique_diff_on
congr' 2
rw ‚Üê iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact fderiv_within_of_open hs hx
intros
rw [subsingleton.elim f (Œª _, 0)]
{ rw [subsingleton.elim f (Œª _, 0)], exact times_cont_diff_within_at_const }
exact times_cont_diff_within_at_const
intros
rw [‚Üê times_cont_diff_within_at_univ] at *; exact times_cont_diff_within_at.sum h
rw [‚Üê times_cont_diff_within_at_univ] at *
exact times_cont_diff_within_at.sum h
intros
rw [norm_int, _root_.abs_of_nonneg]; exact int.cast_nonneg.2 hn
rw [norm_int, _root_.abs_of_nonneg]
exact int.cast_nonneg.2 hn
intros
rw [smul_aux', complex.div_im]
set NsqBot := (denom g z).norm_sq
have : NsqBot ‚â† 0
simp only [denom_ne_zero g z, monoid_with_zero_hom.map_eq_zero, ne.def, not_false_iff]
{ simp only [denom_ne_zero g z, monoid_with_zero_hom.map_eq_zero, ne.def, not_false_iff], }
field_simp [smul_aux']
convert congr_arg (Œª x, x * z.im * NsqBot ^ 2) g.det_coe using 1
rw det_fin_two ‚Üëg
{ rw det_fin_two ‚Üëg, ring }
ring
{ ring }
ring
intros
cases hxy.lt_or_lt
rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]
{ rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le] }
rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]
{ rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le] }
intros
simp only [center_mass, sum_empty, smul_zero]
intros
obtain hB | hB := B.eq_empty_or_nonempty
refine ‚ü®0, 1, _‚ü©
{ refine ‚ü®0, 1, _‚ü©, rw [hB, eq_comm, eq_empty_iff_forall_not_mem], rintro x ‚ü®-, h‚ü©, rw continuous_linear_map.zero_apply at h, linarith }
rw [hB, eq_comm, eq_empty_iff_forall_not_mem]
rintro x ‚ü®-, h‚ü©
rw continuous_linear_map.zero_apply at h
linarith
obtain ‚ü®l, rfl‚ü© := hAB hB
obtain ‚ü®w, hw‚ü© := hB
exact ‚ü®l, l w, subset.antisymm (Œª x hx, ‚ü®hx.1, hx.2 w hw.1‚ü©) (Œª x hx, ‚ü®hx.1, Œª y hy, (hw.2 y hy).trans hx.2‚ü©)‚ü©
intros
rw [‚Üê submodule.top_orthogonal_eq_bot, eq_top_iff]
exact submodule.le_orthogonal_orthogonal ‚ä§
intros
simp only [inner_zero_left, add_monoid_hom.map_zero]
intros
simp only [sq, ‚Üê inner_self_eq_norm_sq]
exact (re_clm : ùïú ‚ÜíL[‚Ñù] ‚Ñù).times_cont_diff.comp (times_cont_diff_id.inner times_cont_diff_id)
intros
rw ‚Üê@ennreal.le_rpow_one_div_iff _ _ (1/p) (by simp [lt_of_lt_of_le zero_lt_one hp1])
rw one_div_one_div
exact add_rpow_le_rpow_add _ _ hp1
intros
rw [dist_comm, dist_midpoint_right]
intros
haveI : complete_space G := complete_space_coe_iff_is_complete.2 hG.is_complete
let g := coprod_subtypeL_equiv_of_is_compl f h hker
rw congr_arg coe (range_eq_map_coprod_subtypeL_equiv_of_is_compl f h hker )
apply g.to_homeomorph.is_closed_image.2
exact is_closed_univ.prod is_closed_singleton
intros
simp only [dist_eq_norm, neg_sub_neg, norm_sub_rev]
intros
rw [frontier, closure_closed_ball, interior_closed_ball x hr, closed_ball_diff_ball]
intros
simp_rw ‚Üê sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l)
exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm hf hg
intros
by_cases h : (exp_series ùïÇ ùî∏).radius = 0
{ rw h at hx, exact (ennreal.not_lt_zero hx).elim }
rw h at hx
exact (ennreal.not_lt_zero hx).elim
have h := pos_iff_ne_zero.mpr h
{ have h := pos_iff_ne_zero.mpr h, exact (has_fpower_series_on_ball_exp_of_radius_pos h).analytic_at_of_mem hx }
exact (has_fpower_series_on_ball_exp_of_radius_pos h).analytic_at_of_mem hx
intros
refine ‚ü®summable_of_summable_norm, Œª hf, _‚ü©
suffices : ‚àÄ {N : ‚Ñï} {g : Œ± ‚Üí fin N ‚Üí ‚Ñù}, summable g ‚Üí summable (Œª x, ‚à•g x‚à•)
obtain v := fin_basis ‚Ñù E
{ obtain v := fin_basis ‚Ñù E, set e := v.equiv_funL, have : summable (Œª x, ‚à•e (f x)‚à•) := this (e.summable.2 hf), refine summable_of_norm_bounded _ (this.mul_left ‚Üë(nnnorm (e.symm : (fin (finrank ‚Ñù E) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E))) (Œª i, _), simpa using (e.symm : (fin (finrank ‚Ñù E) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E).le_op_norm (e $ f i) }
set e := v.equiv_funL
have : summable (Œª x, ‚à•e (f x)‚à•) := this (e.summable.2 hf)
refine summable_of_norm_bounded _ (this.mul_left ‚Üë(nnnorm (e.symm : (fin (finrank ‚Ñù E) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E))) (Œª i, _)
simpa using (e.symm : (fin (finrank ‚Ñù E) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E).le_op_norm (e $ f i)
clear_dependent E
unfreezingI { clear_dependent E }
intros N g hg
have : ‚àÄ i, summable (Œª x, ‚à•g x i‚à•) := Œª i, (pi.summable.1 hg i).abs
refine summable_of_norm_bounded _ (summable_sum (Œª i (hi : i ‚àà finset.univ), this i)) (Œª x, _)
rw [norm_norm, pi_norm_le_iff]
refine Œª i, finset.single_le_sum (Œª i hi, _) (finset.mem_univ i)
{ refine Œª i, finset.single_le_sum (Œª i hi, _) (finset.mem_univ i), exact norm_nonneg (g x i) }
exact norm_nonneg (g x i)
{ exact finset.sum_nonneg (Œª _ _, norm_nonneg _) }
exact finset.sum_nonneg (Œª _ _, norm_nonneg _)
intros
ext m x
simp only [snoc_last, continuous_multilinear_map.curry_right_apply, continuous_multilinear_map.uncurry_right_apply]
rw init_snoc
intros
rw div_eq_inv_mul
{ rw div_eq_inv_mul, exact (has_strict_deriv_at_log h‚ÇÇ).comp x h‚ÇÅ }
exact (has_strict_deriv_at_log h‚ÇÇ).comp x h‚ÇÅ
intros
rw [‚Üê map_exp_at_bot, tendsto_map'_iff]
intros
rw tendsto_at_top_at_top
intro b
use (max b 0) ^ (1/y)
intros x hx
exact le_of_max_le_left (by { convert rpow_le_rpow (rpow_nonneg_of_nonneg (le_max_right b 0) (1/y)) hx (le_of_lt hy), rw [‚Üê rpow_mul (le_max_right b 0), (eq_div_iff (ne_of_gt hy)).mp rfl, rpow_one] })
intros
by_cases hp0 : p = 0
{ simp [hp0], }
simp [hp0]
by_cases hx0 : x = 0
rw ‚Üê ne.def at hp0
{ rw ‚Üê ne.def at hp0, have hp_pos : 0 < p := lt_of_le_of_ne hp_nonneg hp0.symm, simp [hx0, hp_pos, hp_pos.ne.symm], }
have hp_pos : 0 < p := lt_of_le_of_ne hp_nonneg hp0.symm
simp [hx0, hp_pos, hp_pos.ne.symm]
rw ‚Üê ne.def at hx0
exact of_real_rpow_of_pos (hx_nonneg.lt_of_ne hx0.symm)
intros
simp [real.rpow_def_of_nonneg hx, complex.cpow_def]
simp [real.rpow_def_of_nonneg hx, complex.cpow_def]; split_ifs; simp [complex.of_real_log hx]
simp [real.rpow_def_of_nonneg hx, complex.cpow_def]; split_ifs
split_ifs
simp [complex.of_real_log hx]
simp [complex.of_real_log hx]
simp [complex.of_real_log hx]
intros
{ rw ‚Üê one_rpow z, exact rpow_lt_rpow zero_le_one hx hz }
rw ‚Üê one_rpow z
exact rpow_lt_rpow zero_le_one hx hz
intros
simpa only [cos_zero] using (cos_periodic.nat_mul n).add_antiperiod_eq cos_antiperiodic
intros
have hx : abs x = x := abs_of_nonneg (le_of_lt h)
have : abs x ‚â§ 1
rwa [hx]
have := sin_bound this
rw [abs_le] at this
have := this.1
rw [le_sub_iff_add_le, hx] at this
refine lt_of_lt_of_le _ this
rw [add_comm, sub_add, sub_neg_eq_add]
apply sub_lt_sub_left
apply add_lt_of_lt_sub_left
rw (show x ^ 3 / 4 - x ^ 3 / 6 = x ^ 3 * 12‚Åª¬π, by simp [div_eq_mul_inv, ‚Üê mul_sub]; norm_num)
apply mul_lt_mul'
rw [pow_succ x 3]
{ rw [pow_succ x 3], refine le_trans _ (le_of_eq (one_mul _)), rw mul_le_mul_right, exact h', apply pow_pos h }
refine le_trans _ (le_of_eq (one_mul _))
rw mul_le_mul_right
exact h'
apply pow_pos h
apply pow_pos h
norm_num
norm_num
apply pow_pos h
apply pow_pos h
intros
have h := (sin_two_mul Œ∏).symm
rw mul_assoc at h
rw [tan, div_eq_zero_iff, ‚Üê mul_eq_zero, ‚Üê zero_mul ((1/2):‚ÑÇ), mul_one_div, cancel_factors.cancel_factors_eq_div h two_ne_zero', mul_comm]
simpa only [zero_div, zero_mul, ne.def, not_false_iff] with field_simps using sin_eq_zero_iff
intros
convert has_sum.mul_left (a / 2) (has_sum_geometric_of_lt_1 (le_of_lt one_half_pos) one_half_lt_one)
{ funext n, simp, refl, }
funext n
simp
refl
{ norm_num }
norm_num
intros
have key : ‚àÄ·∂† n in at_top, ‚à•f n‚à• ‚â† 0
filter_upwards [eventually_ge_of_tendsto_gt hl h]
{ filter_upwards [eventually_ge_of_tendsto_gt hl h], intros n hn hc, rw [hc, div_zero] at hn, linarith }
intros n hn hc
rw [hc, div_zero] at hn
linarith
rcases exists_between hl with ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü©
refine not_summable_of_ratio_norm_eventually_ge hr‚ÇÄ key.frequently _
filter_upwards [eventually_ge_of_tendsto_gt hr‚ÇÅ h, key]
intros n h‚ÇÄ h‚ÇÅ
rwa ‚Üê le_div_iff (lt_of_le_of_ne (norm_nonneg _) h‚ÇÅ.symm)
intros
apply mono_inl_of_is_colimit _ _ (pushout_cocone.is_colimit_of_factors _ _ _ _ _ hf hg t ht)
intros
simp
intros
simp only [‚Üêarrow.mk_hom f, lift.fac_left, arrow.hom_mk'_left]
intros
split
intros Z a b w
apply (cancel_mono f).1
apply (cancel_mono g).1
simpa using w
intros
{ cases p, cases q, simp, }
cases p
cases q
simp
intros
ext
{ ext, simp, }
simp
intros
dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
{ dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso], tidy, }
tidy
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, coprod_comparison_natural]
intros
rw [‚Üêcolimit.w _ f, ‚Üêcolimit.w _ f']
rw [types_comp_apply, types_comp_apply, w]
intros
{ rw ‚Üêtensor_comp, simp }
rw ‚Üêtensor_comp
simp
intros
have pent := pentagon W X Y Z
rw ‚Üêiso.comp_inv_eq at pent
rw [iso.eq_inv_comp, ‚Üêpent]
simp only [tensor_hom_inv_id, iso.inv_hom_id_assoc, tensor_id, category.comp_id, category.assoc]
intros
rw [naturality, ‚Üêcategory.assoc, ‚Üênat_trans.comp_app, Œ±.inv_hom_id, id_app, category.id_comp]
intros
classical
by_contradiction h
apply w
exact is_iso_of_mono_of_nonzero h
intros
rw [is_iso_iff_mk_eq_top, mk_arrow]
intros
rw [le_iff_le_iff_lt_iff_lt, hom_lt_iff h‚ÇÅ]
intros
by_contradiction H
set i := c.index j with hi
push_neg at H
have i_pos : (0 : ‚Ñï) < i
by_contradiction i_pos
{ by_contradiction i_pos, push_neg at i_pos, revert H, simp [nonpos_iff_eq_zero.1 i_pos, c.size_up_to_zero] }
push_neg at i_pos
revert H
simp [nonpos_iff_eq_zero.1 i_pos, c.size_up_to_zero]
let i‚ÇÅ := (i : ‚Ñï).pred
have i‚ÇÅ_lt_i : i‚ÇÅ < i := nat.pred_lt (ne_of_gt i_pos)
have i‚ÇÅ_succ : i‚ÇÅ.succ = i := nat.succ_pred_eq_of_pos i_pos
have := nat.find_min (c.index_exists j.2) i‚ÇÅ_lt_i
simp [lt_trans i‚ÇÅ_lt_i (c.index j).2, i‚ÇÅ_succ] at this
exact nat.lt_le_antisymm H this
intros
have : fintype.card (finset (fin (n-1))) = 2 ^ (n - 1)
simp
simp
rw ‚Üê this
exact fintype.card_congr (composition_as_set_equiv n)
intros
{ funext i, cases i; refl }
funext i
cases i
cases i; refl
refl
refl
intros
simp only [mem_incidence_set, mem_neighbor_set]
intros
refine quotient.ind (Œª p h, _) e h
cases p with v w
let d : G.dart := ‚ü®v, w, h‚ü©
convert congr_arg card d.edge_fiber
rw [card_insert_of_not_mem, card_singleton]
rw [mem_singleton]
exact d.rev_ne.symm
intros
simp [add_def]
intros
cases q; apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
cases q
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
intros
simp [guard]
intros
cases x
cases x; cases x'; congr; apply h
cases x; cases x'; congr
cases x; cases x'
cases x'
congr
apply h
intros
ext
ext; simp [traverse_map]
simp [traverse_map]
intros
cases F
cases F; refl
refl
intros
suffices : v.to_nat + 1 ‚â§ 2 ^ n
simpa
{ simpa }
rw to_nat_eq_foldr_reverse
cases v with xs h
dsimp [bitvec.to_nat,bits_to_nat]
rw ‚Üê list.length_reverse at h
generalize_hyp : xs.reverse = ys at ‚ä¢ h
clear xs
induction ys generalizing n
{ simp [‚Üê h] }
simp [‚Üê h]
simp only [‚Üêh, pow_add, flip, list.length, list.foldr, pow_one]
{ simp only [‚Üêh, pow_add, flip, list.length, list.foldr, pow_one], rw [add_lsb_eq_twice_add_one], transitivity 2 * list.foldr (Œª (x : bool) (y : ‚Ñï), add_lsb y x) 0 ys_tl + 2 * 1, { ac_mono, rw two_mul, mono, cases ys_hd; simp }, { rw ‚Üê left_distrib, ac_mono, norm_num, apply ys_ih, refl } }
rw [add_lsb_eq_twice_add_one]
transitivity 2 * list.foldr (Œª (x : bool) (y : ‚Ñï), add_lsb y x) 0 ys_tl + 2 * 1
{ ac_mono, rw two_mul, mono, cases ys_hd; simp }
ac_mono
rw two_mul
mono
cases ys_hd
cases ys_hd; simp
simp
simp
rw ‚Üê left_distrib
{ rw ‚Üê left_distrib, ac_mono, norm_num, apply ys_ih, refl }
ac_mono
norm_num
apply ys_ih
refl
intros
induction l with hd tl hl generalizing b
{ refl }
refl
have hb : i < ((b.push_back hd).append_list tl).size := by convert h using 1
{ have hb : i < ((b.push_back hd).append_list tl).size := by convert h using 1, have hb' : i < (b.push_back hd).size := by { convert nat.lt_succ_of_lt h', simp }, have : (append_list b (hd :: tl)).read ‚ü®i, h‚ü© = read ((push_back b hd).append_list tl) ‚ü®i, hb‚ü© := rfl, simp [this, hl _ hb hb', read_push_back_left _ _ h'] }
have hb' : i < (b.push_back hd).size := by { convert nat.lt_succ_of_lt h', simp }
have : (append_list b (hd :: tl)).read ‚ü®i, h‚ü© = read ((push_back b hd).append_list tl) ‚ü®i, hb‚ü© := rfl
simp [this, hl _ hb hb', read_push_back_left _ _ h']
intros
cases p cb n; simp
cases p cb n
simp
simp
apply not_step_of_static_done
simp only [eof_eq_done, exists_eq_left', exists_const]
use [buffer.nil, 0]
simp
intros
simp [many_char, list.as_string_eq]
intros
rw ‚Üê of_real_inj; simp [cos_three_mul]
rw ‚Üê of_real_inj
simp [cos_three_mul]
intros
simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]
intros
rw ‚Üê cosh_sq_sub_sinh_sq x
ring
intros
simp only [add_zero, of_real_im, zero_mul, of_real_re, mul_im]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]
intros
rw [map_range_def]
refine (finset.prod_subset support_mk_subset _).trans _
intros i h1 h2
{ intros i h1 h2, dsimp, simp [h1] at h2, dsimp at h2, simp [h1, h2, h0] }
dsimp
simp [h1] at h2
dsimp at h2
simp [h1, h2, h0]
refine finset.prod_congr rfl _
{ refine finset.prod_congr rfl _, intros i h1, simp [h1] }
intros i h1
simp [h1]
intros
simp only [filter_apply, if_neg h]
intros
{ cases œÄ, refl }
cases œÄ
refl
intros
simp [perm.subtype_congr.apply, h]
intros
simp_rw [set.range, set.mem_set_of_eq, ne.def, option.eq_none_iff_forall_not_mem, encodable.mem_decode‚ÇÇ, not_forall, not_not]
intros
{ ext j, simp [tail] }
ext j
simp [tail]
intros
simp [lt_iff_coe_lt_coe]
intros
cases i; refl
cases i
refl
intros
cases s‚ÇÅ; cases s‚ÇÇ; simp [alist.to_finmap]
cases s‚ÇÅ; cases s‚ÇÇ
cases s‚ÇÅ
cases s‚ÇÇ
simp [alist.to_finmap]
intros
rw update_piecewise
refine s.piecewise_congr (Œª _ _, rfl) (Œª j hj, update_noteq _ _ _)
exact Œª h, hj (h.symm ‚ñ∏ hi)
intros
ext
ext; simp
simp
intros
classical
calc card s = card (s.image f) : by rw [card_image_of_inj_on f_inj] ... ‚â§ card t : card_le_of_subset $ image_subset_iff.2 hf
intros
simp only [insert_eq, union_assoc]
intros
show _ ‚â• _ ‚Üî _
apply fold_op_rel_iff_and
intros x y z
show _ ‚â§ _ ‚Üî _
exact max_le_iff
intros
simp [antidiagonal]
intros
{ ext, simp [eq_comm] }
ext
simp [eq_comm]
intros
ext x
ext x; refl
refl
intros
simp [single_apply_eq_zero, not_or_distrib]
intros
{ ext, simp, }
ext
simp
intros
simp
intros
simp
intros
rw [(coe_nat_le_coe_nat_iff _ _).symm, to_nat_eq_max, max_le_iff]
rw [(coe_nat_le_coe_nat_iff _ _).symm, to_nat_eq_max, max_le_iff]; exact and_iff_left (coe_zero_le _)
exact and_iff_left (coe_zero_le _)
intros
{ rw [sub_eq_add_neg, ‚Üê int.nat_abs_neg b], apply nat_abs_add_le }
rw [sub_eq_add_neg, ‚Üê int.nat_abs_neg b]
apply nat_abs_add_le
intros
rw [mul_comm, add_mul_mod_self]
intros
cases r; [exact absurd h (lt_irrefl _), {simp only [xgcd_aux], refl}]
cases r
exact absurd h (lt_irrefl _)
simp only [xgcd_aux]
refl
intros
rw [even_iff, mod_two_ne_zero]
intros
rw [‚Üê option.some_inj, ‚Üê list.nth_le_nth, list.nth_update_nth_ne _ _ h, list.nth_le_nth]
intros
induction xs generalizing n; simp only [reverse_cons, drop, reverse_nil, nat.zero_sub, length, take_nil]
induction xs generalizing n
simp only [reverse_cons, drop, reverse_nil, nat.zero_sub, length, take_nil]
simp only [reverse_cons, drop, reverse_nil, nat.zero_sub, length, take_nil]
cases h.lt_or_eq_dec with h' h'
replace h' := le_of_succ_le_succ h'
{ replace h' := le_of_succ_le_succ h', rwa [take_append_of_le_length, xs_ih _ h'], rw [show xs_tl.length + 1 - n = succ (xs_tl.length - n), from _, drop], { rwa [succ_eq_add_one, nat.sub_add_comm] }, { rwa length_reverse } }
rwa [take_append_of_le_length, xs_ih _ h']
rw [show xs_tl.length + 1 - n = succ (xs_tl.length - n), from _, drop]
{ rwa [succ_eq_add_one, nat.sub_add_comm] }
rwa [succ_eq_add_one, nat.sub_add_comm]
{ rwa length_reverse }
rwa length_reverse
subst h'
{ subst h', rw [length, nat.sub_self, drop], suffices : xs_tl.length + 1 = (xs_tl.reverse ++ [xs_hd]).length, by rw [this, take_length, reverse_cons], rw [length_append, length_reverse], refl }
rw [length, nat.sub_self, drop]
suffices : xs_tl.length + 1 = (xs_tl.reverse ++ [xs_hd]).length
rw [this, take_length, reverse_cons]
rw [this, take_length, reverse_cons]
rw [length_append, length_reverse]
refl
intros
induction l with hd tl ih
{ simp }
simp
rw prod_cons
exact one_le_mul (hl‚ÇÅ hd (mem_cons_self hd tl)) (ih (Œª x h, hl‚ÇÅ x (mem_cons_of_mem hd h)))
intros
refine ‚ü®Œª H, by simp [H], _‚ü©
rintros ‚ü®join_eq, length_eq‚ü©
apply ext_le
have : length (map length L) = length (map length L')
{ have : length (map length L) = length (map length L'), by rw length_eq, simpa using this }
rw length_eq
rw length_eq
simpa using this
assume n h‚ÇÅ h‚ÇÇ
{ assume n h‚ÇÅ h‚ÇÇ, rw [‚Üê drop_take_succ_join_eq_nth_le, ‚Üê drop_take_succ_join_eq_nth_le, join_eq, length_eq] }
rw [‚Üê drop_take_succ_join_eq_nth_le, ‚Üê drop_take_succ_join_eq_nth_le, join_eq, length_eq]
intros
refine ‚ü®_, map_subset f‚ü©
intros h2 x hx
rcases mem_map.1 (h2 (mem_map_of_mem f hx)) with ‚ü®x', hx', hxx'‚ü©
cases h hxx'
exact hx'
intros
induction ys generalizing f; simp *
induction ys generalizing f
simp *
simp *
intros
simp only [reverse_cons, concat_eq_append]
intros
have h' := mem_cons_self l.head l.tail
rwa cons_head_tail h at h'
intros
rw [next, next_or, if_pos hx]
intros
induction bs generalizing start a
{ refl }
refl
simp [foldl_with_index_aux, foldl_with_index_aux_spec_cons, *]
{ simp [foldl_with_index_aux, foldl_with_index_aux_spec_cons, *] }
intros
rw [Ico, Ico, map_add_range', nat.add_sub_add_right, add_comm n k]
intros
rw [range_succ, map_append, map_singleton, prod_append, prod_cons, prod_nil, mul_one]
intros
induction n with n hn generalizing l k
have hk' : k < l.length := by simpa using hk
{ have hk' : k < l.length := by simpa using hk, simp [nat.mod_eq_of_lt hk'] }
simp [nat.mod_eq_of_lt hk']
simp [nat.succ_eq_add_one, ‚Üêrotate_rotate, nth_le_rotate_one, hn l, add_comm, add_left_comm]
{ simp [nat.succ_eq_add_one, ‚Üêrotate_rotate, nth_le_rotate_one, hn l, add_comm, add_left_comm] }
intros
cases l with x l
{ simp }
simp
rw mem_iff_nth_le
{ rw mem_iff_nth_le, refine ‚ü®0, by simp, _‚ü©, simp }
refine ‚ü®0, by simp, _‚ü©
simp
intros
simp [lookup_all_eq_lookup, nd‚ÇÅ, nd‚ÇÇ, perm_lookup a nd‚ÇÅ nd‚ÇÇ p]
intros
simp [keys, nodupkeys]
intros
simp only [sublists_eq_sublists', length_map, length_sublists', length_reverse]
intros
ext i j
ext i j; simp [mul_apply]
simp [mul_apply]
intros
simp only [matrix.vec_mul, matrix.map_apply, ring_hom.map_dot_product]
intros
simp [dot_product, finset.smul_sum, smul_mul_assoc]
intros
{ ext, simp [mul_vec] }
ext
simp [mul_vec]
intros
simp only [conj_transpose, block_diagonal_transpose]
rw block_diagonal_map _ star (star_zero Œ±)
intros
simp [vec_cons]
intros
{ ext i, refine fin.cases _ _ i; simp }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp
simp
simp
intros
rw [add_comm, inter_add_distrib, add_comm s, add_comm s]
intros
rw [‚Üê inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]
rw [‚Üê inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]; simp
simp
intros
rw [powerset_len_aux, sublists_len_aux_eq, append_nil]
intros
rw [‚Üê zero_add (single s n), monomial_add_single, C_apply]
intros
{ funext x, exact comap_comp_apply _ _ _ }
funext x
exact comap_comp_apply _ _ _
intros
rw [aeval_eq_bind‚ÇÅ, bind‚ÇÅ_X_left]
intros
cases nat.eq_zero_or_pos n with n0 h
{ rw [n0, zero_mul], exact m.zero_le }
rw [n0, zero_mul]
exact m.zero_le
{ rw [mul_comm, ‚Üê nat.le_div_iff_mul_le' h] }
rw [mul_comm, ‚Üê nat.le_div_iff_mul_le' h]
intros
rw [‚Üê image_singleton, range_comp, ‚Üê image_union, zero_union_range_succ, image_univ]
intros
rw add_comm; apply dist_tri_left
rw add_comm
apply dist_tri_left
intros
rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), nat.div_self H]
intros
split
intro H
{ intro H, rw [eq_Ici_of_nonempty_of_upward_closed (nonempty_of_Inf_eq_succ H) hs, H, mem_Ici, mem_Ici], exact ‚ü®le_refl _, k.not_succ_le_self‚ü©, }
rw [eq_Ici_of_nonempty_of_upward_closed (nonempty_of_Inf_eq_succ H) hs, H, mem_Ici, mem_Ici]
exact ‚ü®le_refl _, k.not_succ_le_self‚ü©
rintro ‚ü®H, H'‚ü©
{ rintro ‚ü®H, H'‚ü©, rw [Inf_def (‚ü®_, H‚ü© : s.nonempty), find_eq_iff], exact ‚ü®H, Œª n hnk hns, H' $ hs n k (lt_succ_iff.mp hnk) hns‚ü©, }
rw [Inf_def (‚ü®_, H‚ü© : s.nonempty), find_eq_iff]
exact ‚ü®H, Œª n hnk hns, H' $ hs n k (lt_succ_iff.mp hnk) hns‚ü©
intros
simp
intros
cases n; refl
cases n
refl
refl
intros
rw [‚Üê to_nat_to_int, int.cast_coe_nat, cast_to_nat]
intros
rw [‚Üê num.succ'_to_nat, n.succ'_pred']
intros
cases o; refl
cases o
refl
refl
intros
suffices : @size Œ± r ‚â§ 3 * (size l + 1)
cases nat.eq_zero_or_pos (size l) with l0 l0
{ cases nat.eq_zero_or_pos (size l) with l0 l0, { apply or.inr, rwa l0 at this }, change 1 ‚â§ _ at l0, apply or.inl, linarith }
{ apply or.inr, rwa l0 at this }
apply or.inr
rwa l0 at this
change 1 ‚â§ _ at l0
apply or.inl
linarith
rcases H2 with ‚ü®hl, rfl‚ü© | ‚ü®hr, rfl‚ü©; rcases H1 with h | ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
rcases H2 with ‚ü®hl, rfl‚ü© | ‚ü®hr, rfl‚ü©
rcases H1 with h | ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
exact le_trans (nat.le_add_left _ _) (le_trans h (nat.le_add_left _ _))
{ exact le_trans (nat.le_add_left _ _) (le_trans h (nat.le_add_left _ _)) }
exact le_trans h‚ÇÇ (nat.mul_le_mul_left _ $ le_trans (nat.dist_tri_right _ _) (nat.add_le_add_left hl _))
{ exact le_trans h‚ÇÇ (nat.mul_le_mul_left _ $ le_trans (nat.dist_tri_right _ _) (nat.add_le_add_left hl _)) }
rcases H1 with h | ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
exact le_trans (nat.dist_tri_left' _ _) (le_trans (add_le_add hr (le_trans (nat.le_add_left _ _) h)) dec_trivial)
{ exact le_trans (nat.dist_tri_left' _ _) (le_trans (add_le_add hr (le_trans (nat.le_add_left _ _) h)) dec_trivial) }
rw nat.mul_succ
{ rw nat.mul_succ, exact le_trans (nat.dist_tri_right' _ _) (add_le_add h‚ÇÇ (le_trans hr dec_trivial)) }
exact le_trans (nat.dist_tri_right' _ _) (add_le_add h‚ÇÇ (le_trans hr dec_trivial))
intros
simp [node3_l, node3_r, dual_node']
intros
{ cases t, { contradiction }, { simp [h.1] } }
cases t
contradiction
{ contradiction }
simp [h.1]
{ simp [h.1] }
intros
rw ‚Üê mem_iff_mem at *; cases h : f.symm b; simp * at *
rw ‚Üê mem_iff_mem at *; cases h : f.symm b
rw ‚Üê mem_iff_mem at *
cases h : f.symm b
simp * at *
simp * at *
intros
rw [preimage_eq, set.union_distrib_right, set.union_comm (dom f), set.compl_union_self, set.inter_univ, set.union_eq_self_of_subset_right (f.compl_dom_subset_core s)]
intros
refl
intros
cases x; refl
cases x
refl
intros
let h‚ÇÄ := nat.mod_add_div (m : ‚Ñï) (k : ‚Ñï)
have : ¬¨ ((m : ‚Ñï) % (k : ‚Ñï) = 0 ‚àß (m : ‚Ñï) / (k : ‚Ñï) = 0)
rintro ‚ü®hr, hq‚ü©
rintro ‚ü®hr, hq‚ü©
{ rintro ‚ü®hr, hq‚ü©, rw [hr, hq, mul_zero, zero_add] at h‚ÇÄ, exact (m.ne_zero h‚ÇÄ.symm).elim }
{ rintro ‚ü®hr, hq‚ü©, rw [hr, hq, mul_zero, zero_add] at h‚ÇÄ, exact (m.ne_zero h‚ÇÄ.symm).elim }
rw [hr, hq, mul_zero, zero_add] at h‚ÇÄ
rw [hr, hq, mul_zero, zero_add] at h‚ÇÄ
exact (m.ne_zero h‚ÇÄ.symm).elim
exact (m.ne_zero h‚ÇÄ.symm).elim
have := mod_div_aux_spec k ((m : ‚Ñï) % (k : ‚Ñï)) ((m : ‚Ñï) / (k : ‚Ñï)) this
exact (this.trans h‚ÇÄ)
intros
let h := @pnat.factor_multiset_le_iff' u.prod v
{ let h := @pnat.factor_multiset_le_iff' u.prod v, rw [u.factor_multiset_prod] at h, exact h.symm }
rw [u.factor_multiset_prod] at h
exact h.symm
intros
simp only [monomial, monomial_fun, linear_map.coe_mk, mul_to_finsupp, add_monoid_algebra.single_mul_single]
intros
set f' : add_monoid_algebra R ‚Ñï ‚Üí+ M := f.comp (to_finsupp_iso R).symm with hf'
set g' : add_monoid_algebra R ‚Ñï ‚Üí+ M := g.comp (to_finsupp_iso R).symm with hg'
have : ‚àÄ n a, f' (single n a) = g' (single n a) := Œª n, by simp [hf', hg', h n]
have A : f' = g' := finsupp.add_hom_ext this
have B : f = f'.comp (to_finsupp_iso R)
rw [hf', add_monoid_hom.comp_assoc]
rw [hf', add_monoid_hom.comp_assoc]
{ rw [hf', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
{ rw [hf', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
ext x
ext x
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
have C : g = g'.comp (to_finsupp_iso R)
rw [hg', add_monoid_hom.comp_assoc]
rw [hg', add_monoid_hom.comp_assoc]
{ rw [hg', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
{ rw [hg', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
ext x
ext x
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
rw [B, C, A]
intros
simp
intros
rw [monic.def, leading_coeff_zero] at h; exact ‚ü®Œª p q, by rw [‚Üê mul_one p, ‚Üê mul_one q, ‚Üê C_1, ‚Üê h, C_0, mul_zero, mul_zero], Œª a b, by rw [‚Üê mul_one a, ‚Üê mul_one b, ‚Üê h, mul_zero, mul_zero]‚ü©
rw [monic.def, leading_coeff_zero] at h
exact ‚ü®Œª p q, by rw [‚Üê mul_one p, ‚Üê mul_one q, ‚Üê C_1, ‚Üê h, C_0, mul_zero, mul_zero], Œª a b, by rw [‚Üê mul_one a, ‚Üê mul_one b, ‚Üê h, mul_zero, mul_zero]‚ü©
intros
simp only [coeff_nat_degree, coeff_mul_degree_add_degree]
intros
rw [derivative_apply, sum_monomial_index, C_mul_X_pow_eq_monomial]
{ rw [derivative_apply, sum_monomial_index, C_mul_X_pow_eq_monomial], simp }
simp
intros
rw eval‚ÇÇ_mul f x
exact mul_eq_zero_of_right (p.eval‚ÇÇ f x) hq
intros
rw [bit1, eval‚ÇÇ_add, eval‚ÇÇ_bit0, eval‚ÇÇ_one, bit1]
intros
simpa only [monic, leading_coeff_zero] using (zero_ne_one : (0 : R) ‚â† 1)
intros
simp [reverse]
intros
rw [‚Üê with_bot.coe_eq_coe, ‚Üê degree_eq_nat_degree (mul_ne_zero hp hq), with_bot.coe_add, ‚Üê degree_eq_nat_degree hp, ‚Üê degree_eq_nat_degree hq, degree_mul]
intros
ext
ext; apply mem_supp
apply mem_supp
intros
by_cases d0 : d = 0
simp [d0, div_zero]
{simp [d0, div_zero]}
simp [division_def, coe_int_eq_mk, mul_def one_ne_zero d0]
intros
by_cases h : a = 0
{ rw [h, zero_mul, zero_to_nnreal] }
rw [h, zero_mul, zero_to_nnreal]
{ rw [mul_top, if_neg h, top_to_nnreal] }
rw [mul_top, if_neg h, top_to_nnreal]
intros
simp [bit1]
intros
unfold bit1; simp
unfold bit1
simp
intros
induction x using ereal.rec; induction y using ereal.rec; simp [‚Üê ereal.coe_add]
induction x using ereal.rec; induction y using ereal.rec
induction x using ereal.rec
induction y using ereal.rec
simp [‚Üê ereal.coe_add]
simp [‚Üê ereal.coe_add]
simp [‚Üê ereal.coe_add]
induction y using ereal.rec
simp [‚Üê ereal.coe_add]
simp [‚Üê ereal.coe_add]
simp [‚Üê ereal.coe_add]
induction y using ereal.rec
simp [‚Üê ereal.coe_add]
simp [‚Üê ereal.coe_add]
simp [‚Üê ereal.coe_add]
{field_simp, rw ‚Üê sq_sub_sq, norm_num}
field_simp
rw ‚Üê sq_sub_sq
norm_num
intros
rw [‚Üêinfinite_pos_iff_infinite_of_nonneg (abs_nonneg _), infinite_iff_infinite_pos_abs]
intros
rw [‚Üê nnreal.coe_one, nnreal.coe_eq]
intros
simp [pos_iff_ne_zero]
pi_upper_bound [ 4756/3363, 101211/54775, 505534/257719, 83289/41846, 411278/205887, 438142/219137, 451504/225769, 265603/132804, 849938/424971]
intros
rw [sqrt, sqrt, nnreal.coe_le_coe, nnreal.sqrt_le_sqrt_iff, real.to_nnreal_le_to_nnreal_iff hy]
intros
simp [core]
intros
haveI := terminates_of_mem h; exact ‚ü®_, results_of_terminates' s h‚ü©
haveI := terminates_of_mem h
exact ‚ü®_, results_of_terminates' s h‚ü©
intros
refine eq_of_bisim (Œª s1 s2, ‚àÉ s, s1 = f s ‚àß s2 = g s) _ ‚ü®s, rfl, rfl‚ü©
intros s1 s2 h
rcases h with ‚ü®s, h1, h2‚ü©
rw [h1, h2]
apply H
intros
apply coinduction2 s; intro s; apply cases_on s; simp [ret]
apply coinduction2 s; intro s; apply cases_on s
apply coinduction2 s; intro s
apply coinduction2 s
intro s
apply cases_on s
simp [ret]
simp [ret]
intros
rw ‚Üê image_univ; exact image_subset _ (subset_univ _)
rw ‚Üê image_univ
exact image_subset _ (subset_univ _)
intros
intros s t h
{ intros s t h, rw [‚Üêpreimage_image_eq s hf, ‚Üêpreimage_image_eq t hf, h] }
rw [‚Üêpreimage_image_eq s hf, ‚Üêpreimage_image_eq t hf, h]
intros
rw [‚Üê mk_preimage_prod_right_eq_if, prod_preimage_right, preimage_preimage]
intros
{ cases x, refl }
cases x
refl
intros
simp [diagonal]
intros
rw [‚Üêimage_univ, infinite_image_iff (inj_on_of_injective hi _)]
{ rw [‚Üêimage_univ, infinite_image_iff (inj_on_of_injective hi _)], exact infinite_univ }
exact infinite_univ
intros
split
intros h x
{ intros h x, rw [‚Üêfinite.mem_to_finset hs, ‚Üêfinite.mem_to_finset ht], exact Œª hx, h hx }
rw [‚Üêfinite.mem_to_finset hs, ‚Üêfinite.mem_to_finset ht]
exact Œª hx, h hx
intros h x
{ intros h x, rw [finite.mem_to_finset hs, finite.mem_to_finset ht], exact Œª hx, h hx }
rw [finite.mem_to_finset hs, finite.mem_to_finset ht]
exact Œª hx, h hx
intros
split
rcases eq_empty_or_nonempty t with rfl|ht
{ rcases eq_empty_or_nonempty t with rfl|ht, { exact Œª _, ‚ü®‚àÖ, empty_subset _, bij_on_empty f‚ü© }, { assume h, haveI : nonempty Œ± := ‚ü®classical.some (h.comap_nonempty ht)‚ü©, exact ‚ü®_, h.maps_to_inv_fun_on.image_subset, h.bij_on_subset‚ü© }}
{ exact Œª _, ‚ü®‚àÖ, empty_subset _, bij_on_empty f‚ü© }
exact Œª _, ‚ü®‚àÖ, empty_subset _, bij_on_empty f‚ü©
assume h
{ assume h, haveI : nonempty Œ± := ‚ü®classical.some (h.comap_nonempty ht)‚ü©, exact ‚ü®_, h.maps_to_inv_fun_on.image_subset, h.bij_on_subset‚ü© }
haveI : nonempty Œ± := ‚ü®classical.some (h.comap_nonempty ht)‚ü©
exact ‚ü®_, h.maps_to_inv_fun_on.image_subset, h.bij_on_subset‚ü©
rintros ‚ü®s', hs', hfs'‚ü©
{ rintros ‚ü®s', hs', hfs'‚ü©, exact hfs'.surj_on.mono hs' (subset.refl _) }
exact hfs'.surj_on.mono hs' (subset.refl _)
intros
ext1 x
simp_rw [mem_union, mem_Icc, min_le_iff, le_max_iff]
by_cases hc : c ‚â§ x; by_cases hd : x ‚â§ d
by_cases hc : c ‚â§ x
by_cases hd : x ‚â§ d
{ tauto }
tauto
have hax : a ‚â§ x := h‚ÇÇ.trans (le_of_not_ge hd)
{ have hax : a ‚â§ x := h‚ÇÇ.trans (le_of_not_ge hd), tauto }
tauto
by_cases hd : x ‚â§ d
have hxb : x ‚â§ b := (le_of_not_ge hc).trans h‚ÇÅ
{ have hxb : x ‚â§ b := (le_of_not_ge hc).trans h‚ÇÅ, tauto }
tauto
{ tauto }
tauto
intros
rw [e.image_eq_preimage, e.symm.preimage_Iic, e.symm_symm]
intros
simp [‚Üê Ici_inter_Iic]
intros
simp [lt_irrefl]
intros
simp [‚Üê Ici_inter_Iic, inter_comm]
intros
simp [sub_eq_neg_add]
intros
intros p hp
rw [mem_Ici, le_iff_lt_or_eq] at hp
rcases hp with hp'|hp'
cases (surj_on_Ioi_of_monotone_surjective h_mono h_surj a hp') with x hx
{ cases (surj_on_Ioi_of_monotone_surjective h_mono h_surj a hp') with x hx, exact ‚ü®x, Ioi_subset_Ici_self hx.1, hx.2‚ü© }
exact ‚ü®x, Ioi_subset_Ici_self hx.1, hx.2‚ü©
rw ‚Üê hp'
{ rw ‚Üê hp', refine ‚ü®a, left_mem_Ici, rfl‚ü© }
refine ‚ü®a, left_mem_Ici, rfl‚ü©
intros
simp only [‚Üê image_prod, Union_prod_const, image_Union]
intros
rintro x ‚ü®_, ‚ü®i, rfl‚ü©, hx‚ü© _ ‚ü®j, rfl‚ü©
{ rintro x ‚ü®_, ‚ü®i, rfl‚ü©, hx‚ü© _ ‚ü®j, rfl‚ü©, exact ‚ü®_, ‚ü®i, rfl‚ü©, hx _ ‚ü®j, rfl‚ü©‚ü© }
exact ‚ü®_, ‚ü®i, rfl‚ü©, hx _ ‚ü®j, rfl‚ü©‚ü©
intros
rw [sUnion_eq_compl_sInter_compl, compl_compl_image]
intros
refl
intros
rw [‚Üêcons_head_tail v]
simp only [scanl_cons, scanl_nil, cons_head, singleton_tail]
intros
dsimp only [vector.zip_with, vector.nth]
cases x
cases y
simp only [list.nth_le_zip_with, subtype.coe_mk]
congr
intros
change (a : zmod b) = ((0 : ‚Ñï) : zmod b) ‚Üî b ‚à£ a
rw [zmod.nat_coe_eq_nat_coe_iff, nat.modeq_zero_iff_dvd]
intros
refine {..}
refine {..}; intros; refl
refine {..}; intros
intros
refl
intros
refl
intros
refl
intros
simp only [omega_limit, image2_image_right]
intros
rw [is_periodic_pt, iterate_add] at hn
{ rw [is_periodic_pt, iterate_add] at hn, exact hn.left_of_comp hm }
exact hn.left_of_comp hm
intros
{ rw [eq_bot_iff, adjoin_le_iff], refl, }
rw [eq_bot_iff, adjoin_le_iff]
refl
intros
letI := classical.dec_eq R; exact suffices ¬¨ disjoint (univ.image (Œª x : R, eval x f)) (univ.image (Œª x : R, eval x (-g))), begin simp only [disjoint_left, mem_image] at this, push_neg at this, rcases this with ‚ü®x, ‚ü®a, _, ha‚ü©, ‚ü®b, _, hb‚ü©‚ü©, exact ‚ü®a, b, by rw [ha, ‚Üê hb, eval_neg, neg_add_self]‚ü© end, assume hd : disjoint _ _, lt_irrefl (2 * ((univ.image (Œª x : R, eval x f)) ‚à™ (univ.image (Œª x : R, eval x (-g)))).card) $ calc 2 * ((univ.image (Œª x : R, eval x f)) ‚à™ (univ.image (Œª x : R, eval x (-g)))).card ‚â§ 2 * fintype.card R : nat.mul_le_mul_left _ (finset.card_le_univ _) ... = fintype.card R + fintype.card R : two_mul _ ... < nat_degree f * (univ.image (Œª x : R, eval x f)).card + nat_degree (-g) * (univ.image (Œª x : R, eval x (-g))).card : add_lt_add_of_lt_of_le (lt_of_le_of_ne (card_image_polynomial_eval (by rw hf2; exact dec_trivial)) (mt (congr_arg (%2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR]))) (card_image_polynomial_eval (by rw [degree_neg, hg2]; exact dec_trivial)) ... = 2 * (univ.image (Œª x : R, eval x f) ‚à™ univ.image (Œª x : R, eval x (-g))).card : by rw [card_disjoint_union hd]; simp [nat_degree_eq_of_degree_eq_some hf2, nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]
letI := classical.dec_eq R
exact suffices ¬¨ disjoint (univ.image (Œª x : R, eval x f)) (univ.image (Œª x : R, eval x (-g))), begin simp only [disjoint_left, mem_image] at this, push_neg at this, rcases this with ‚ü®x, ‚ü®a, _, ha‚ü©, ‚ü®b, _, hb‚ü©‚ü©, exact ‚ü®a, b, by rw [ha, ‚Üê hb, eval_neg, neg_add_self]‚ü© end, assume hd : disjoint _ _, lt_irrefl (2 * ((univ.image (Œª x : R, eval x f)) ‚à™ (univ.image (Œª x : R, eval x (-g)))).card) $ calc 2 * ((univ.image (Œª x : R, eval x f)) ‚à™ (univ.image (Œª x : R, eval x (-g)))).card ‚â§ 2 * fintype.card R : nat.mul_le_mul_left _ (finset.card_le_univ _) ... = fintype.card R + fintype.card R : two_mul _ ... < nat_degree f * (univ.image (Œª x : R, eval x f)).card + nat_degree (-g) * (univ.image (Œª x : R, eval x (-g))).card : add_lt_add_of_lt_of_le (lt_of_le_of_ne (card_image_polynomial_eval (by rw hf2; exact dec_trivial)) (mt (congr_arg (%2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR]))) (card_image_polynomial_eval (by rw [degree_neg, hg2]; exact dec_trivial)) ... = 2 * (univ.image (Œª x : R, eval x f) ‚à™ univ.image (Œª x : R, eval x (-g))).card : by rw [card_disjoint_union hd]; simp [nat_degree_eq_of_degree_eq_some hf2, nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]
intros
rw fintype.bijective_iff_injective_and_card
split
{ exact mul_semiring_action.to_alg_hom_injective _ F }
exact mul_semiring_action.to_alg_hom_injective _ F
apply le_antisymm
{ apply le_antisymm, { exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F) }, { rw ‚Üê finrank_eq_card G F, exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _) } }
exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F)
{ exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F) }
rw ‚Üê finrank_eq_card G F
{ rw ‚Üê finrank_eq_card G F, exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _) }
exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _)
intros
{ contrapose! h, simpa only [hx, coeff_zero_eq_zero] using h }
contrapose! h
simpa only [hx, coeff_zero_eq_zero] using h
intros
conv_lhs { rw ‚Üêreflection_reflection s p‚ÇÅ }
exact (reflection s).dist_map _ _
intros
rw [‚Üê sq_eq_sq (norm_nonneg (x - y)) (abs_nonneg (‚à•x‚à• - ‚à•y‚à•)), norm_sub_pow_two_real, inner_eq_mul_norm_of_angle_eq_zero h, sq_abs (‚à•x‚à• - ‚à•y‚à•)]
ring
intros
haveI : nonempty (‚ä§ : affine_subspace ‚Ñù P) := set.univ.nonempty
rw [‚Üêfinrank_top, ‚Üêdirection_top ‚Ñù V P] at hd
refine exists_circumcenter_eq_of_cospherical_subset _ hd hc
exact set.subset_univ _
intros
simp only [‚Üê unique_mdiff_on_iff_unique_diff_on, unique_mdiff_on_image, hn]
intros
have : s = univ ‚à© s
rw univ_inter
rw univ_inter
rwa [this, hG.lift_prop_within_at_inter hs]
intros
refine and_congr iff.rfl (exists_congr $ Œª f', _)
rw [inter_comm]
simp only [has_fderiv_within_at, nhds_within_inter, nhds_within_ext_chart_target_eq]
intros
apply @filter.mem_of_superset _ _ ((f ‚àò (ext_chart_at I x).symm)‚Åª¬π' (ext_chart_at I' (f x)).source) _ (ext_chart_preimage_mem_nhds_within I x (h.preimage_mem_nhds_within (ext_chart_at_source_mem_nhds _ _)))
mfld_set_tac
intros
rw inter_comm
{ rw inter_comm, exact I.unique_diff.inter (hs.preimage I.continuous_inv_fun) }
exact I.unique_diff.inter (hs.preimage I.continuous_inv_fun)
intros
rw [‚Üê times_cont_mdiff_within_at_univ, times_cont_mdiff_within_at_iff_times_cont_diff_within_at, times_cont_diff_within_at_univ]
intros
suffices h : mdifferentiable_within_at I I' f (s ‚à© (f ‚Åª¬π' (ext_chart_at I' (f x)).source)) x
rwa mdifferentiable_within_at_inter' at h
{ rwa mdifferentiable_within_at_inter' at h, apply (hf.1).preimage_mem_nhds_within, exact is_open.mem_nhds (ext_chart_at_open_source I' (f x)) (mem_ext_chart_source I' (f x)) }
apply (hf.1).preimage_mem_nhds_within
exact is_open.mem_nhds (ext_chart_at_open_source I' (f x)) (mem_ext_chart_source I' (f x))
rw mdifferentiable_within_at_iff
exact ‚ü®hf.1.mono (inter_subset_left _ _), (hf.2.differentiable_within_at hn).mono (by mfld_set_tac)‚ü©
intros
simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]
intros
{ ext, simp [quotient_group.eq] }
ext
simp [quotient_group.eq]
intros
rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]
intros
ext
rw [lift_spec, ‚Üêhj, ‚Üêhj, ‚Üêj.map_mul]
apply congr_arg
rw ‚Üêsec_spec'
intros
rw [lower_central_series_succ, closure_eq_bot_iff, set.subset_singleton_iff]
rintro x ‚ü®y, hy1, z, ‚ü®‚ü©, rfl‚ü©
symmetry
rw [eq_mul_inv_iff_mul_eq, eq_mul_inv_iff_mul_eq, one_mul]
exact mem_center_iff.mp (h hy1) z
intros
obtain ‚ü®c, g', rfl, hd, hc, rfl‚ü© := mem_cycle_type_iff.1 hng
by_cases g'1 : g' = 1
rw [hd.cycle_type, hc.cycle_type, multiset.singleton_eq_cons, multiset.singleton_coe, g'1, cycle_type_one, add_zero]
{ rw [hd.cycle_type, hc.cycle_type, multiset.singleton_eq_cons, multiset.singleton_coe, g'1, cycle_type_one, add_zero] }
contrapose! hn2
apply le_trans _ (c * g').support.card_le_univ
rw [hd.card_support_mul]
exact add_le_add_left (two_le_card_support_of_ne_one g'1) _
intros
rw cycle_factors_finset_eq_finset
split
simp only [mem_cycle_factors_finset_iff, mem_union]
{ simp only [mem_cycle_factors_finset_iff, mem_union], rintro _ (‚ü®h, -‚ü© | ‚ü®h, -‚ü©); exact h }
rintro _ (‚ü®h, -‚ü© | ‚ü®h, -‚ü©); exact h
rintro _ (‚ü®h, -‚ü© | ‚ü®h, -‚ü©)
exact h
exact h
exact h
exact h
refine ‚ü®_, _‚ü©
{ refine ‚ü®_, _‚ü©, { simp_rw mem_union, rintros x (hx | hx) y (hy | hy) hxy, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }, { exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy } }, { rw noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset, rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod] } }
simp_rw mem_union
{ simp_rw mem_union, rintros x (hx | hx) y (hy | hy) hxy, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }, { exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy } }
rintros x (hx | hx) y (hy | hy) hxy
{ exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }
exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy
exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)
{ exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }
exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)
{ exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }
{ exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }
exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy
rw noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset
{ rw noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset, rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod] }
rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod]
intros
rcases l with (_ | ‚ü®x, _ | ‚ü®y, l‚ü©‚ü©)
suffices : l'.length ‚â§ 1 ‚Üî l' = nil ‚à® l'.length ‚â§ 1
{ suffices : l'.length ‚â§ 1 ‚Üî l' = nil ‚à® l'.length ‚â§ 1, { simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero] }, refine ‚ü®Œª h, or.inr h, _‚ü©, rintro (rfl | h), { simp }, { exact h } }
{ simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero] }
simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero]
refine ‚ü®Œª h, or.inr h, _‚ü©
rintro (rfl | h)
{ simp }
simp
{ exact h }
exact h
suffices : l'.length ‚â§ 1 ‚Üî [x] ~r l' ‚à® l'.length ‚â§ 1
{ suffices : l'.length ‚â§ 1 ‚Üî [x] ~r l' ‚à® l'.length ‚â§ 1, { simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl] }, refine ‚ü®Œª h, or.inr h, _‚ü©, rintro (h | h), { simp [‚Üêh.perm.length_eq] }, { exact h } }
{ simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl] }
simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl]
refine ‚ü®Œª h, or.inr h, _‚ü©
rintro (h | h)
{ simp [‚Üêh.perm.length_eq] }
simp [‚Üêh.perm.length_eq]
{ exact h }
exact h
rcases l' with (_ | ‚ü®x', _ | ‚ü®y', l'‚ü©‚ü©)
{ rcases l' with (_ | ‚ü®x', _ | ‚ü®y', l'‚ü©‚ü©), { simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }, { suffices : ¬¨ (x :: y :: l) ~r [x'], { simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }, intro h, simpa using h.perm.length_eq }, { simp [-form_perm_cons_cons, form_perm_ext_iff hl hl'] } }
{ simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }
simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]
suffices : ¬¨ (x :: y :: l) ~r [x']
{ suffices : ¬¨ (x :: y :: l) ~r [x'], { simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }, intro h, simpa using h.perm.length_eq }
{ simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }
simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]
intro h
simpa using h.perm.length_eq
{ simp [-form_perm_cons_cons, form_perm_ext_iff hl hl'] }
simp [-form_perm_cons_cons, form_perm_ext_iff hl hl']
intros
ext
ext; simp [right_hom]
simp [right_hom]
intros
simp [line_map_apply]
intros
tidy
intros
simp [weighted_vsub, linear_map.sum_apply]
intros
{ ext, simp [face_points] }
ext
simp [face_points]
intros
rw [slope, sub_self, inv_zero, zero_smul]
intros
rw [‚Üê range_le_bot_iff, le_bot_iff]
intros
rw [finsupp.sum_smul_index', finsupp.smul_sum]
{ simp only [linear_map.map_smul], }
simp only [linear_map.map_smul]
{ intro i, exact (h i).map_zero }
intro i
exact (h i).map_zero
intros
split
split; intros h
intros h
ext
{ ext, cases h‚Çó x with x' hx, subst hx, cases h·µ£ y with y' hy, subst hy, rw [‚Üêcomp_apply, ‚Üêcomp_apply, h], }
cases h‚Çó x with x' hx
subst hx
cases h·µ£ y with y' hy
subst hy
rw [‚Üêcomp_apply, ‚Üêcomp_apply, h]
intros h
{ subst h, }
subst h
intros
{ rw [‚Üê@zero_smul R _ _ _ _ (0 : M), smul_left, zero_mul] }
rw [‚Üê@zero_smul R _ _ _ _ (0 : M), smul_left, zero_mul]
intros
simp [e.det_apply]
intros
simpa using lift_dim_range_le f
intros
refine b.ext (Œª i, b.dual_basis.ext (Œª j, _))
rw [linear_map.comp_apply, to_dual_apply_left, coe_to_dual_self, ‚Üê coe_dual_basis, dual.eval_apply, basis.repr_self, finsupp.single_apply, dual_basis_apply_self]
intros
apply p.induction_on
{ intro a, simp [module.algebra_map_End_apply] }
intro a
simp [module.algebra_map_End_apply]
{ intros p q hp hq, simp [hp, hq, add_smul] }
intros p q hp hq
simp [hp, hq, add_smul]
intros n a hna
{ intros n a hna, rw [mul_comm, pow_succ, mul_assoc, alg_hom.map_mul, linear_map.mul_apply, mul_comm, hna], simp [algebra_map_End_apply, mem_eigenspace_iff.1 h.1, smul_smul, mul_comm] }
rw [mul_comm, pow_succ, mul_assoc, alg_hom.map_mul, linear_map.mul_apply, mul_comm, hna]
simp [algebra_map_End_apply, mem_eigenspace_iff.1 h.1, smul_smul, mul_comm]
intros
refine supr_le (assume a‚ÇÅ, supr_le $ assume h‚ÇÅ, range_le_iff_comap.2 _)
simp only [(ker_comp _ _).symm, eq_top_iff, set_like.le_def, mem_ker, comap_infi, mem_infi]
assume b hb a‚ÇÇ h‚ÇÇ
have : a‚ÇÅ ‚â† a‚ÇÇ := assume eq, h ‚ü®h‚ÇÅ, eq.symm ‚ñ∏ h‚ÇÇ‚ü©
exact single_eq_of_ne this
intros
rw [finsupp.total_on, linear_map.range_eq_map, linear_map.map_cod_restrict, ‚Üê linear_map.range_le_iff_comap, range_subtype, map_top, linear_map.range_comp, range_subtype]
exact (span_image_eq_map_total _ _).le
intros
rw submodule.eq_bot_iff
intros x hx
refine congr_arg coe (show (‚ü®x, hNO hx‚ü© : O) = 0, from b.ext_elem (Œª i, _))
rw (eq_bot_iff_generator_eq_zero _).mpr hgen at hœï
rw [linear_equiv.map_zero, finsupp.zero_apply]
refine (submodule.eq_bot_iff _).mp (hœï ((finsupp.lapply i) ‚àò‚Çó ‚Üëb.repr) bot_le) _ _
exact (linear_map.mem_submodule_image_of_le hNO).mpr ‚ü®x, hx, rfl‚ü©
intros
haveI := classical.dec_eq Œπ'
{ haveI := classical.dec_eq Œπ', rw [‚Üê@basis_to_matrix_mul_linear_map_to_matrix _ _ Œπ, to_matrix_id, matrix.mul_one] }
rw [‚Üê@basis_to_matrix_mul_linear_map_to_matrix _ _ Œπ, to_matrix_id, matrix.mul_one]
intros
rw [coeff_zero_eq_eval_zero, charpoly, eval_det, mat_poly_equiv_charmatrix, ‚Üê det_smul]
simp
intros
rw [det_apply', det_apply']
apply fintype.sum_equiv (equiv.perm_congr e)
intro œÉ
rw equiv.perm.sign_perm_congr e œÉ
congr' 1
apply fintype.prod_equiv e
intro i
rw [equiv.perm_congr_apply, equiv.symm_apply_apply, minor_apply]
intros
ext j
simp_rw [linear_map.comp_apply, to_lin'_apply, mul_vec_diagonal, linear_map.smul_apply, pi.smul_apply, algebra.id.smul_eq_mul]
by_cases i = j
{ subst h }
subst h
rw [std_basis_ne R (Œª_:n, R) _ _ (ne.symm h), _root_.mul_zero, _root_.mul_zero]
{ rw [std_basis_ne R (Œª_:n, R) _ _ (ne.symm h), _root_.mul_zero, _root_.mul_zero] }
intros
simp only [one_div, inv_pow']
intros
ext i j
simp [subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i]
intros
refine inv_eq_left_inv _
rw [smul_mul, mul_adjugate, units.smul_def, smul_smul, h.coe_inv_mul, one_smul]
intros
ext
{ ext, rw [matrix.one_apply, linear_map.to_matrix_alg_equiv'_apply, id_apply] }
rw [matrix.one_apply, linear_map.to_matrix_alg_equiv'_apply, id_apply]
intros
simp_rw ‚Üêtprod_coeff_eq_smul_tprod at C1
exact pi_tensor_product.induction_on' z @C1 @Cp
intros
refine le_antisymm _ (sup_le (map_le_iff_le_comap.2 _) (map_le_iff_le_comap.2 _))
rw set_like.le_def
{ rw set_like.le_def, rintro _ ‚ü®x, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, rfl‚ü©, exact mem_sup.2 ‚ü®_, ‚ü®_, h‚ÇÅ, rfl‚ü©, _, ‚ü®_, h‚ÇÇ, rfl‚ü©, rfl‚ü© }
rintro _ ‚ü®x, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, rfl‚ü©
exact mem_sup.2 ‚ü®_, ‚ü®_, h‚ÇÅ, rfl‚ü©, _, ‚ü®_, h‚ÇÇ, rfl‚ü©, rfl‚ü©
{ exact Œª x hx, ‚ü®(x, 0), by simp [hx]‚ü© }
exact Œª x hx, ‚ü®(x, 0), by simp [hx]‚ü©
{ exact Œª x hx, ‚ü®(0, x), by simp [hx]‚ü© }
exact Œª x hx, ‚ü®(0, x), by simp [hx]‚ü©
intros
simp [tailings]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_left, polar_neg_left]
intros
simpa only [range_eq_map] using map_liftq _ _ _ _
intros
simp only [and.left_comm, and.comm]
intros
simp only [‚Üê @forall_eq _ p a, ‚Üê forall_and_distrib, ‚Üê or_imp_distrib, classical.em, forall_const]
intros
by_cases h : j = i
{ subst j, simp }
subst j
simp
{ simp [h] }
simp [h]
intros
rcases exists_pair_ne Œ± with ‚ü®x‚ÇÅ, x‚ÇÇ, hx‚ü©
by_cases h : f x‚ÇÇ = y
{ exact ‚ü®x‚ÇÅ, (hf.ne_iff' h).2 hx‚ü© }
exact ‚ü®x‚ÇÅ, (hf.ne_iff' h).2 hx‚ü©
{ exact ‚ü®x‚ÇÇ, h‚ü© }
exact ‚ü®x‚ÇÇ, h‚ü©
intros
by_cases hxy : x = y
{ exact hxy ‚ñ∏ h x }
exact hxy ‚ñ∏ h x
{ exact hr hxy }
exact hr hxy
intros
haveI : encodable s := hs.to_encodable
{ haveI : encodable s := hs.to_encodable, simp only [supr_subtype'], exact measurable_supr (Œª i, hf i) }
simp only [supr_subtype']
exact measurable_supr (Œª i, hf i)
intros
rw [prod_dirac, map_dirac measurable_prod_mk_right]
intros
rw [real_smul_def, ‚Üê smul_neg_part, dif_neg (not_le.2 hr), neg_pos_part]
{ rw [real_smul_def, ‚Üê smul_neg_part, dif_neg (not_le.2 hr), neg_pos_part] }
intros
apply (ae_measurable.ae_eq_mk _).symm.trans
exact @quotient.mk_out' _ (Œº.ae_eq_setoid Œ≤) (‚ü®f, hf‚ü© : {f // ae_measurable f Œº})
intros
have h_ss : ae_seq_set hf p ‚äÜ {a : Œ± | ‚àÄ i, ae_seq hf p i a = (hf i).mk (f i) a}
from Œª x hx i, by simp only [ae_seq, hx, if_true]
exact le_antisymm (le_trans (measure_mono (set.compl_subset_compl.mpr h_ss)) (le_of_eq (measure_compl_ae_seq_set_eq_zero hf hp))) (zero_le _)
intros
refine eventually_eq.trans _ (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hŒºs x)
simp [condexp_ind, condexp_ind_L1, hs, hŒºs]
intros
haveI : normed_space ‚Ñù E := restrict_scalars.normed_space ‚Ñù ùïú E
rw dense_range_iff_closure_range
suffices : (to_Lp p Œº ùïú : _ ‚ÜíL[ùïú] Lp E p Œº).range.to_add_subgroup.topological_closure = ‚ä§
{ exact congr_arg coe this }
exact congr_arg coe this
simp [range_to_Lp p Œº, measure_theory.Lp.bounded_continuous_function_dense E hp]
intros
simp only [integrable, ae_measurable_map_equiv_iff, has_finite_integral, lintegral_map_equiv]
intros
simp [Lp.dist_def, snorm, snorm']
{ simp [Lp.dist_def, snorm, snorm'], simp [edist_eq_coe_nnnorm_sub] }
simp [edist_eq_coe_nnnorm_sub]
intros
have : ‚àÄ x, ‚à•is_R_or_C.im (f x)‚à• ‚â§ 1 * ‚à•f x‚à•
intro x
intro x
{ intro x, rw one_mul, exact is_R_or_C.norm_im_le_norm (f x), }
{ intro x, rw one_mul, exact is_R_or_C.norm_im_le_norm (f x), }
rw one_mul
rw one_mul
exact is_R_or_C.norm_im_le_norm (f x)
exact is_R_or_C.norm_im_le_norm (f x)
exact hf.of_le_mul hf.1.im (eventually_of_forall this)
intros
refine ess_sup_mono_ae (eventually_of_forall (Œª x, _))
rw [ennreal.coe_le_coe, nnnorm_indicator_eq_indicator_nnnorm]
exact set.indicator_le_self s _ x
intros
rw [snorm'_congr_ae hf_zero, snorm'_zero' hq0_ne hŒº]
intros
simp [Lp.tendsto_Lp_iff_tendsto_‚Ñíp'', tendsto_approx_on_univ_Lp_snorm hp_ne_top fmeas hf.2]
intros
ext1 x
push_cast
simp_rw [pi.add_apply, weighted_smul_apply]
push_cast
rw [pi.add_apply, ennreal.to_real_add hŒºs hŒΩs, add_smul]
intros
simp_rw [‚Üê of_real_norm_eq_coe_nnnorm]
{ simp_rw [‚Üê of_real_norm_eq_coe_nnnorm], apply ennreal.of_real_le_of_le_to_real, exact norm_integral_le_lintegral_norm f }
apply ennreal.of_real_le_of_le_to_real
exact norm_integral_le_lintegral_norm f
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [f.sum_measure_preimage_singleton, coe_range, preimage_range]
intros
rw [count, lintegral_sum_measure]
congr
exact funext (Œª a, lintegral_dirac a f)
intros
by_cases h : integrable œÜ Œº
{ exact integral_comp_comm L h }
exact integral_comp_comm L h
have : ¬¨ (integrable (L ‚àò œÜ) Œº)
rwa lipschitz_with.integrable_comp_iff_of_antilipschitz L.lipschitz hL (L.map_zero)
rwa lipschitz_with.integrable_comp_iff_of_antilipschitz L.lipschitz hL (L.map_zero)
simp [integral_undef, h, this]
intros
rw [set_to_fun_eq hT (L1.integrable_coe_fn f), integrable.to_L1_coe_fn]
intros
letI : fintype s := finite.fintype hs
exact measurable_of_measurable_union_cover s s·∂ú hs.measurable_set hs.measurable_set.compl (by simp only [union_compl_self]) (measurable_of_fintype _) hf
intros
rw ‚Üê encodable.Union_decode‚ÇÇ
exact ‚Äπmeasurable_space Œ±‚Ä∫.measurable_set_Union _ (measurable_set.bUnion_decode‚ÇÇ h)
intros
rw [Œº.outer_measure_opens] at hU ‚ä¢
rcases Œº.inner_content_exists_compact hU hŒµ with ‚ü®K, h1K, h2K‚ü©
exact ‚ü®K, h1K, le_trans h2K $ add_le_add_right (Œº.le_outer_measure_compacts K) _‚ü©
intros
change (((haar_content K‚ÇÄ).outer_measure) K‚ÇÄ.val)‚Åª¬π * (haar_content K‚ÇÄ).measure s = _
simp only [hs, div_eq_mul_inv, mul_comm, content.measure_apply]
intros
rw measure_Inter_eq_infi hs (directed_of_sup hm) hf
exact tendsto_at_top_infi (assume n m hnm, measure_mono $ hm hnm)
intros
simp only [measure.restrict_eq_zero, h]
intros
haveI := hs.to_encodable
rw [bUnion_eq_Union]
apply measure_Union_le
intros
apply of_function_caratheodory
intro t
cases t.eq_empty_or_nonempty with h h
{ simp [h, empty_not_nonempty] }
simp [h, empty_not_nonempty]
convert le_trans _ (hs t)
{ convert le_trans _ (hs t), { simp [h] }, exact add_le_add supr_const_le supr_const_le }
simp [h]
{ simp [h] }
exact add_le_add supr_const_le supr_const_le
intros
refine ‚ü®Œª A hA r hr, _‚ü©
rw [map_apply f.measurable hA, ‚Üê f.image_symm] at hr
rcases set.exists_is_open_lt_of_lt _ r hr with ‚ü®U, hAU, hUo, hU‚ü©
have : is_open (f.symm ‚Åª¬π' U)
from hUo.preimage f.symm.continuous
refine ‚ü®f.symm ‚Åª¬π' U, image_subset_iff.1 hAU, this, _‚ü©
rwa [map_apply f.measurable this.measurable_set, f.preimage_symm, f.preimage_image]
intros
rw [vector_measure.sub_apply, to_signed_measure_apply_measurable hi, measure.to_signed_measure_apply_measurable hi, sub_eq_add_neg]
intros
refine nnreal.summable_of_le (assume a, _) p.summable_coe
split_ifs
{ refine (mul_zero (p a)).symm ‚ñ∏ le_of_eq h.symm }
refine (mul_zero (p a)).symm ‚ñ∏ le_of_eq h.symm
suffices : p a * f a h b ‚â§ p a * 1
{ suffices : p a * f a h b ‚â§ p a * 1, { simpa }, exact mul_le_mul_of_nonneg_left ((f a h).coe_le_one _) (p a).2 }
simpa
{ simpa }
exact mul_le_mul_of_nonneg_left ((f a h).coe_le_one _) (p a).2
intros
haveI : fact (1 < (q:‚Ñï)) := ‚ü®w‚ü©
convert card_units_lt (X q)
rw X_card
intros
rw maximal_ideal_eq_span_p at hm hn
have := zmod_congr_of_sub_mem_span_aux 1 x m n
simp only [pow_one] at this
specialize this hm hn
apply_fun zmod.cast_hom (show p ‚à£ p ^ 1, by rw pow_one) (zmod p) at this
simpa only [ring_hom.map_int_cast]
intros
rw [two_mul, add_assoc, xn_add, add_assoc, ‚Üêzero_add 0]
refine (dvd_mul_right (xn a1 n) (xn a1 (n + j))).modeq_zero_nat.add _
rw [yn_add, left_distrib, add_assoc, ‚Üêzero_add 0]
exact ((dvd_mul_right _ _).mul_left _).modeq_zero_nat.add (xn_modeq_x2n_add_lem _ _ _).modeq_zero_nat
intros
simp [ext, of_int_re, of_int_im]
intros
rw [norm_sq_apply, norm_sq_apply, ‚Üê _root_.abs_mul_self, _root_.abs_mul, ‚Üê _root_.abs_mul_self y.re, _root_.abs_mul y.re, ‚Üê _root_.abs_mul_self x.im, _root_.abs_mul x.im, ‚Üê _root_.abs_mul_self y.im, _root_.abs_mul y.im]
rw [norm_sq_apply, norm_sq_apply, ‚Üê _root_.abs_mul_self, _root_.abs_mul, ‚Üê _root_.abs_mul_self y.re, _root_.abs_mul y.re, ‚Üê _root_.abs_mul_self x.im, _root_.abs_mul x.im, ‚Üê _root_.abs_mul_self y.im, _root_.abs_mul y.im]; exact (add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him))
exact (add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him))
intros
intros A B h
cases A
cases B
injection h
obtain rfl : A_le = B_le := ‚Äπ_‚Ä∫
obtain rfl : A_lt = B_lt := ‚Äπ_‚Ä∫
obtain rfl : A_decidable_le = B_decidable_le := subsingleton.elim _ _
obtain rfl : A_max = B_max := A_max_def.trans B_max_def.symm
obtain rfl : A_min = B_min := A_min_def.trans B_min_def.symm
congr
intros
rw [sdiff_eq, compl_top, inf_bot_eq]
intros
simp [(<)]
intros
rw [Sup_eq_supr]; exact hf.le_map_supr2 _
rw [Sup_eq_supr]
exact hf.le_map_supr2 _
intros
apply le_antisymm
refine (finset.sup'_le _ _ $ Œª a ha, _)
{ refine (finset.sup'_le _ _ $ Œª a ha, _), refine le_cSup ‚ü®s.sup' H f, _‚ü© ‚ü®a, ha, rfl‚ü©, rintros i ‚ü®j, hj, rfl‚ü©, exact finset.le_sup' _ hj }
refine le_cSup ‚ü®s.sup' H f, _‚ü© ‚ü®a, ha, rfl‚ü©
rintros i ‚ü®j, hj, rfl‚ü©
exact finset.le_sup' _ hj
apply cSup_le ((coe_nonempty.mpr H).image _)
{ apply cSup_le ((coe_nonempty.mpr H).image _), rintros _ ‚ü®a, ha, rfl‚ü©, exact finset.le_sup' _ ha, }
rintros _ ‚ü®a, ha, rfl‚ü©
exact finset.le_sup' _ ha
intros
rw [‚Üê map_coe_Ici_at_top a, tendsto_map'_iff]
intros
simpa only [inf_ne_bot_iff, frequently_iff, exists_prop, and_comm]
intros
simp [filter.frequently, -not_eventually, eventually_false_iff_eq_bot, ne_bot_iff]
intros
refine ‚ü®compl_compl s ‚ñ∏ mt mem_of_eq_bot _‚ü©
rintro ‚ü®t, ht, hts‚ü©
rcases hf.nonempty_of_mem (inter_mem hs ht) with ‚ü®_, ‚ü®x, hxs, rfl‚ü©, hxt‚ü©
exact absurd hxs (hts hxt)
intros
simp [filter.coprod]
intros
simp only [‚Üê nat.cofinite_eq_at_top, frequently_cofinite_iff_infinite]
intros
simp only [lt_iff_le_not_le, eventually_and, coe_le, eventually_not, eventually_le]
intros
simp only [filter.lift', tendsto_lift, tendsto_principal]
intros
simp only [tendsto, ptendsto, pmap_res]
intros
obtain ‚ü®a, ha‚ü© : ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I := ideal_Inter_nonempty.exists_all_mem
exact ‚ü®a, by simp [ha]‚ü©
intros
rw [sup_comm, @sup_comm _ _ a, sup_assoc]
intros
simp [is_cobounded]
intros
induction n with n ih
{ apply w 0 le_rfl, }
apply w 0 le_rfl
exact sup_le (ih (Œª m p, w m (nat.le_succ_of_le p))) (w (n + 1) le_rfl)
{ exact sup_le (ih (Œª m p, w m (nat.le_succ_of_le p))) (w (n + 1) le_rfl) }
intros
simp [symm_diff_eq]
intros
suffices : set.range (algebra_map D E) = set.range (algebra_map ((‚ä§ : subalgebra C D).map (is_scalar_tower.to_alg_hom C D E)) E)
ext x
{ ext x, change x ‚àà subsemiring.closure (_ ‚à™ S) ‚Üî x ‚àà subsemiring.closure (_ ‚à™ S), rw this }
change x ‚àà subsemiring.closure (_ ‚à™ S) ‚Üî x ‚àà subsemiring.closure (_ ‚à™ S)
rw this
ext x
split
rintros ‚ü®y, hy‚ü©
{ rintros ‚ü®y, hy‚ü©, exact ‚ü®‚ü®algebra_map D E y, ‚ü®y, ‚ü®algebra.mem_top, rfl‚ü©‚ü©‚ü©, hy‚ü© }
exact ‚ü®‚ü®algebra_map D E y, ‚ü®y, ‚ü®algebra.mem_top, rfl‚ü©‚ü©‚ü©, hy‚ü©
rintros ‚ü®‚ü®y, ‚ü®z, ‚ü®h0, h1‚ü©‚ü©‚ü©, h2‚ü©
{ rintros ‚ü®‚ü®y, ‚ü®z, ‚ü®h0, h1‚ü©‚ü©‚ü©, h2‚ü©, exact ‚ü®z, eq.trans h1 h2‚ü© }
exact ‚ü®z, eq.trans h1 h2‚ü©
intros
{ rw add_comm, exact h.add_mul_right_right z }
rw add_comm
exact h.add_mul_right_right z
intros
cases exists_mul_sub_mem_of_sub_one_mem_jacobson r h with s hs
rw [mem_bot, sub_eq_zero] at hs
exact is_unit_of_mul_eq_one _ _ hs
intros
dsimp [inv_fun]
simp only [algebra.algebra_map_eq_smul_one, smul_tmul, ‚Üêtmul_sum, mul_boole]
congr
conv_rhs {rw matrix_eq_sum_std_basis M}
convert finset.sum_product
simp
intros
rw [eq_coe_iff]
{ rw [eq_coe_iff], use dvd_rfl, rw [pow_dvd_pow_iff h0 hu], apply nat.not_succ_le_self }
use dvd_rfl
rw [pow_dvd_pow_iff h0 hu]
apply nat.not_succ_le_self
intros
rw C_dvd_iff_dvd_coeff
split
intros h i
{ intros h i, apply h.trans (content_dvd_coeff _) }
apply h.trans (content_dvd_coeff _)
intro h
{ intro h, rw [content, finset.dvd_gcd_iff], intros i hi, apply h i }
rw [content, finset.dvd_gcd_iff]
intros i hi
apply h i
intros
rw_mod_cast [pochhammer_nat_eq_asc_factorial, nat.zero_asc_factorial]
intros
apply monic_sub_of_left (monic_pow (monic_X) _)
rw degree_X_pow
exact degree_sum_fin_lt _
intros
{ rw [X_pow_eq, order_monomial_of_ne_zero], exact one_ne_zero }
rw [X_pow_eq, order_monomial_of_ne_zero]
exact one_ne_zero
intros
{ refine ‚ü®_, Œª h, inv h‚ü©, intro h, rw [‚Üê inv_inv Œ∂], exact inv h }
refine ‚ü®_, Œª h, inv h‚ü©
intro h
rw [‚Üê inv_inv Œ∂]
exact inv h
intros
simp only [‚Üê nsmul_one, nsmul_mem, one_mem]
intros
apply tensor_product.induction_on x; simp {contextual := tt}
apply tensor_product.induction_on x
simp {contextual := tt}
simp {contextual := tt}
simp {contextual := tt}
intros
have d_pos : 0 < pb.dim := power_basis.dim_pos pb
have d_pos' : 0 < (minpoly K pb.gen).nat_degree
simpa
{ simpa }
haveI : nonempty (fin pb.dim) := ‚ü®‚ü®0, d_pos‚ü©‚ü©
rw [trace_eq_matrix_trace pb.basis, trace_eq_neg_charpoly_coeff, charpoly_left_mul_matrix, ring_hom.map_neg, ‚Üê pb.nat_degree_minpoly, fintype.card_fin, ‚Üê next_coeff_of_pos_nat_degree _ d_pos', ‚Üê next_coeff_map (algebra_map K F).injective]
conv_lhs { rw eq_prod_roots_of_splits hf }
rw [monic.next_coeff_mul, next_coeff_C_eq_zero, zero_add, monic.next_coeff_multiset_prod]
simp_rw [next_coeff_X_sub_C, multiset.sum_map_neg, neg_neg]
{ intros, apply monic_X_sub_C }
intros
intros
apply monic_X_sub_C
apply monic_X_sub_C
convert monic_one
{ convert monic_one, simp [(minpoly.monic pb.is_integral_gen).leading_coeff] }
simp [(minpoly.monic pb.is_integral_gen).leading_coeff]
apply monic_multiset_prod_of_monic
{ apply monic_multiset_prod_of_monic, intros, apply monic_X_sub_C }
{ intros, apply monic_X_sub_C }
intros
intros
apply monic_X_sub_C
apply monic_X_sub_C
intros
dunfold has_mem.mem
dunfold factor_set_mem
split_ifs
exact trivial
intros
have : v‚ÇÅ r ‚â† v‚ÇÅ 0 ‚Üî v‚ÇÇ r ‚â† v‚ÇÇ 0 := not_iff_not_of_iff h.val_eq
rwa [v‚ÇÅ.map_zero, v‚ÇÇ.map_zero] at this
intros
rw [‚Üê ring_hom.comp_assoc, commutes, ring_hom.comp_assoc, padic_int.zmod_cast_comp_to_zmod_pow]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective
simp only [map_bind‚ÇÅ, map_frobenius_poly, bind‚ÇÅ_frobenius_poly_rat_witt_polynomial, map_witt_polynomial]
intros
use verschiebung_poly
simp only [aeval_verschiebung_poly', eq_self_iff_true, forall_3_true_iff]
intros
rw [‚Üê succ_le, (by norm_cast : succ 1 = 2)] at hb
rw [‚Üê succ_le, (by norm_cast : succ 1 = 2)] at hb; exact lt_of_lt_of_le (cantor _) (power_le_power_right hb)
exact lt_of_lt_of_le (cantor _) (power_le_power_right hb)
intros
dsimp [cof, strict_order.cof, order.cof, type, quotient.mk, quot.lift_on]
dsimp [cof, strict_order.cof, order.cof, type, quotient.mk, quot.lift_on]; rw [cardinal.le_min, subtype.forall]; refl
dsimp [cof, strict_order.cof, order.cof, type, quotient.mk, quot.lift_on]; rw [cardinal.le_min, subtype.forall]
rw [cardinal.le_min, subtype.forall]
refl
intros
have b0 : b ‚â† 0 := ne_of_gt (lt_trans zero_lt_one b1)
apply lt_imp_lt_of_le_imp_le (power_le_power_left $ power_ne_zero a b0)
rw [‚Üê power_mul, mul_eq_self ha]
exact lt_power_cof (le_trans ha $ le_of_lt $ cantor' _ b1)
intros
simp [of_list, of']
intros
rw [‚Üêcard_type c.ord.out.r, type_out, card_ord]
intros
induction x with xl xr xL xR IHxl IHxr generalizing y
induction y with yl yr yL yR IHyl IHyr
classical
simp only [mk_le_mk, mk_lt_mk, not_and_distrib, not_or_distrib, not_forall, not_exists, and_comm, or_comm, IHxl, IHxr, IHyl, IHyr, iff_self, and_self]
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
delta choice
rw [map_fval yx, Class.mem_hom_left, Class.mem_hom_right]
exact choice_mem_aux x h y yx
intros
rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, int.nat_cast_eq_coe_nat]
rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, int.nat_cast_eq_coe_nat]; refl
refl
intros
simp [h.symm, horner, add_assoc]
intros
cc
intros
rw [‚Üê compl_range_coe, is_closed_compl_iff]
{ rw [‚Üê compl_range_coe, is_closed_compl_iff], exact is_open_range_coe }
exact is_open_range_coe
intros
{ ext, refl }
ext
refl
intros
refine le_of_tendsto (tendsto_const_nhds.dist ha) (eventually_at_top.2 ‚ü®n, Œª m hnm, _‚ü©)
refine le_trans (dist_le_Ico_sum_of_dist_le hnm (Œª k _ _, hf k)) _
rw [sum_Ico_eq_sum_range]
refine sum_le_tsum (range _) (Œª _ _, le_trans dist_nonneg (hf _)) _
exact hd.comp_injective (add_right_injective n)
intros
simpa only [neg_neg] using hf.neg
intros
rw [ne.def, tsum_eq_zero_iff hf, not_forall]
intros
simp [nhds_eq_infi_abs_sub, abs_sub_comm a]
intros
cases s.eq_empty_or_nonempty with h h
{ simp [h, fbot] }
simp [h, fbot]
{ exact map_Sup_of_continuous_at_of_monotone' Cf Mf h }
exact map_Sup_of_continuous_at_of_monotone' Cf Mf h
intros
revert hf
refine degree_pos_induction_on p hd _ _ _
refine degree_pos_induction_on p hd _ _ _; clear hd p
clear hd p
rintros c - hc
{ rintros c - hc, rw [leading_coeff_mul_X, leading_coeff_C] at hc, simpa [abv_mul abv] using hz.const_mul_at_top ((abv_pos abv).2 hc) }
rw [leading_coeff_mul_X, leading_coeff_C] at hc
simpa [abv_mul abv] using hz.const_mul_at_top ((abv_pos abv).2 hc)
clear hd p
intros p hpd ihp hf
{ intros p hpd ihp hf, rw [leading_coeff_mul_X] at hf, simpa [abv_mul abv] using (ihp hf).at_top_mul_at_top hz }
rw [leading_coeff_mul_X] at hf
simpa [abv_mul abv] using (ihp hf).at_top_mul_at_top hz
clear hd p
{ intros p a hd ihp hf, rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf, refine tendsto_at_top_of_add_const_right (abv (-f a)) _, refine tendsto_at_top_mono (Œª _, abv_add abv _ _) _, simpa using ihp hf }
intros p a hd ihp hf
rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf
refine tendsto_at_top_of_add_const_right (abv (-f a)) _
refine tendsto_at_top_mono (Œª _, abv_add abv _ _) _
simpa using ihp hf
intros
let S := f.discrete_quotient
let ff : S ‚Üí Œ± := f.lift
casesI is_empty_or_nonempty S
suffices : ‚àÉ j, is_empty (F.obj j)
{ suffices : ‚àÉ j, is_empty (F.obj j), { refine this.imp (Œª j hj, _), refine ‚ü®‚ü®hj.elim, Œª A, _‚ü©, _‚ü©, { convert is_open_empty, exact @set.eq_empty_of_is_empty _ hj _ }, { ext x, exact hj.elim' (C.œÄ.app j x) } }, simp only [‚Üê not_nonempty_iff, ‚Üê not_forall], intros h, haveI : ‚àÄ j : J, nonempty ((F ‚ãô Profinite.to_Top).obj j) := h, haveI : ‚àÄ j : J, t2_space ((F ‚ãô Profinite.to_Top).obj j) := Œª j, (infer_instance : t2_space (F.obj j)), haveI : ‚àÄ j : J, compact_space ((F ‚ãô Profinite.to_Top).obj j) := Œª j, (infer_instance : compact_space (F.obj j)), have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system (F ‚ãô Profinite.to_Top), suffices : nonempty C.X, from is_empty.false (S.proj this.some), let D := Profinite.to_Top.map_cone C, have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC, have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit _)).inv, exact cond.map CD }
refine this.imp (Œª j hj, _)
{ refine this.imp (Œª j hj, _), refine ‚ü®‚ü®hj.elim, Œª A, _‚ü©, _‚ü©, { convert is_open_empty, exact @set.eq_empty_of_is_empty _ hj _ }, { ext x, exact hj.elim' (C.œÄ.app j x) } }
refine ‚ü®‚ü®hj.elim, Œª A, _‚ü©, _‚ü©
convert is_open_empty
{ convert is_open_empty, exact @set.eq_empty_of_is_empty _ hj _ }
exact @set.eq_empty_of_is_empty _ hj _
ext x
{ ext x, exact hj.elim' (C.œÄ.app j x) }
exact hj.elim' (C.œÄ.app j x)
simp only [‚Üê not_nonempty_iff, ‚Üê not_forall]
intros h
haveI : ‚àÄ j : J, nonempty ((F ‚ãô Profinite.to_Top).obj j) := h
haveI : ‚àÄ j : J, t2_space ((F ‚ãô Profinite.to_Top).obj j) := Œª j, (infer_instance : t2_space (F.obj j))
haveI : ‚àÄ j : J, compact_space ((F ‚ãô Profinite.to_Top).obj j) := Œª j, (infer_instance : compact_space (F.obj j))
have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system (F ‚ãô Profinite.to_Top)
suffices : nonempty C.X
from is_empty.false (S.proj this.some)
let D := Profinite.to_Top.map_cone C
have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC
have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit _)).inv
exact cond.map CD
let f' : locally_constant C.X S := ‚ü®S.proj, S.proj_is_locally_constant‚ü©
{ let f' : locally_constant C.X S := ‚ü®S.proj, S.proj_is_locally_constant‚ü©, obtain ‚ü®j, g', hj‚ü© := exists_locally_constant_fintype_nonempty _ hC f', refine ‚ü®j, ‚ü®ff ‚àò g', g'.is_locally_constant.comp _‚ü©,_‚ü©, ext1 t, apply_fun (Œª e, e t) at hj, rw locally_constant.coe_comap _ _ (C.œÄ.app j).continuous at hj ‚ä¢, dsimp at hj ‚ä¢, rw ‚Üê hj, refl }
obtain ‚ü®j, g', hj‚ü© := exists_locally_constant_fintype_nonempty _ hC f'
refine ‚ü®j, ‚ü®ff ‚àò g', g'.is_locally_constant.comp _‚ü©,_‚ü©
ext1 t
apply_fun (Œª e, e t) at hj
rw locally_constant.coe_comap _ _ (C.œÄ.app j).continuous at hj ‚ä¢
dsimp at hj ‚ä¢
rw ‚Üê hj
refl
intros
simp [norm_def, bounded_continuous_function.dist_eq]
intros
simpa only [subtype.range_coe] using (embedding_subtype_coe.map_nhds_eq ‚ü®a, h‚ü©).symm
intros
convert (continuous_on_open_iff hs).mp h t ht
rw [inter_comm, inter_eq_self_of_subset_left hp]
intros
refine is_open_map_iff_nhds_le.2 (Œª x, _)
rcases h (proj x) with ‚ü®e, ex‚ü©
refine (e.map_proj_nhds _).ge
rwa e.source_eq
intros
rw [add_comm, supr_add]; simp [add_comm]
rw [add_comm, supr_add]
simp [add_comm]
intros
simp only [‚Üê e.symm_image_eq_source_inter_preimage h, continuous_on, ball_image_iff]
refine forall_congr (Œª x, forall_congr $ Œª hx, _)
rw [e.continuous_within_at_iff_continuous_within_at_comp_right (h hx), e.symm_image_eq_source_inter_preimage h, inter_comm, continuous_within_at_inter]
exact is_open.mem_nhds e.open_source (e.map_target (h hx))
intros
{ ext, simp only [hf, hg, hg.comp hf, coe_comap] }
ext
simp only [hf, hg, hg.comp hf, coe_comap]
intros
by_contradiction h
simp only [not_exists, not_nonempty_iff_eq_empty] at h
have := calc ‚àÖ = closure (‚ãÉs, interior (f s)) : by simp [h] ... = univ : (dense_Union_interior_of_closed hc hU).closure_eq
exact univ_nonempty.ne_empty this.symm
intros
apply hs.elim_finite_subcover_image
{ simp [is_open_ball] }
simp [is_open_ball]
intros x xs
{ intros x xs, simp, exact ‚ü®x, ‚ü®xs, by simpa‚ü©‚ü© }
simp
exact ‚ü®x, ‚ü®xs, by simpa‚ü©‚ü©
intros
rw disjoint_left
assume a ax ay
apply lt_irrefl (dist x y)
calc dist x y ‚â§ dist x a + dist a y : dist_triangle _ _ _ ... < rx + ry : add_lt_add (mem_ball'.1 ax) (mem_ball.1 ay) ... ‚â§ dist x y : h
intros
convert hf.apriori_edist_iterate_efixed_point_le hx 0
{ convert hf.apriori_edist_iterate_efixed_point_le hx 0, simp only [pow_zero, mul_one] }
simp only [pow_zero, mul_one]
intros
simp
intros
simp [Hausdorff_dist]
intros
simp [supr_def]
intros
rw [is_connected_iff_connected_space, is_path_connected_iff_path_connected_space]
haveI := loc_path_connected_of_is_open U_op
exact path_connected_space_iff_connected_space
intros
rw [continuous_on, ‚Üê and_forall_ne x, and_comm]
refine and_congr ‚ü®Œª H z hz, _, Œª H z hzx hzs, _‚ü© (forall_congr $ Œª hxs, _)
specialize H z hz.2 hz.1
{ specialize H z hz.2 hz.1, rw continuous_within_at_update_of_ne hz.2 at H, exact H.mono (diff_subset _ _) }
rw continuous_within_at_update_of_ne hz.2 at H
exact H.mono (diff_subset _ _)
rw continuous_within_at_update_of_ne hzx
{ rw continuous_within_at_update_of_ne hzx, refine (H z ‚ü®hzs, hzx‚ü©).mono_of_mem (inter_mem_nhds_within _ _), exact is_open_ne.mem_nhds hzx }
refine (H z ‚ü®hzs, hzx‚ü©).mono_of_mem (inter_mem_nhds_within _ _)
exact is_open_ne.mem_nhds hzx
{ exact continuous_within_at_update_same }
exact continuous_within_at_update_same
intros
simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at ‚ä¢ hst
simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at ‚ä¢ hst; exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst
exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst
intros
intros x y h
have : {x} ‚àà (pure x : ultrafilter Œ±) := singleton_mem_pure
have : {x} ‚àà (pure x : ultrafilter Œ±) := singleton_mem_pure
have : {x} ‚àà (pure x : ultrafilter Œ±) := singleton_mem_pure
have : {x} ‚àà (pure x : ultrafilter Œ±) := singleton_mem_pure
rw h at this
exact (mem_singleton_iff.mp (mem_pure.mp this)).symm
intros
split
all_goals { intros h t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ, specialize h t‚ÇÅ·∂ú t‚ÇÇ·∂ú, simp only [is_open_compl_iff, is_closed_compl_iff] at h, specialize h ht‚ÇÅ ht‚ÇÇ }
intros h t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
specialize h t‚ÇÅ·∂ú t‚ÇÇ·∂ú
simp only [is_open_compl_iff, is_closed_compl_iff] at h
specialize h ht‚ÇÅ ht‚ÇÇ
contrapose!
{ contrapose!, simp only [not_subset], rintro ‚ü®‚ü®x, hx, hx'‚ü©, ‚ü®y, hy, hy'‚ü©‚ü©, rcases h ‚ü®x, hx, hx'‚ü© ‚ü®y, hy, hy'‚ü© with ‚ü®z, hz, hz'‚ü©, rw ‚Üê compl_union at hz', exact ‚ü®z, hz, hz'‚ü© }
simp only [not_subset]
rintro ‚ü®‚ü®x, hx, hx'‚ü©, ‚ü®y, hy, hy'‚ü©‚ü©
rcases h ‚ü®x, hx, hx'‚ü© ‚ü®y, hy, hy'‚ü© with ‚ü®z, hz, hz'‚ü©
rw ‚Üê compl_union at hz'
exact ‚ü®z, hz, hz'‚ü©
intros h t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
specialize h t‚ÇÅ·∂ú t‚ÇÇ·∂ú
simp only [is_open_compl_iff, is_closed_compl_iff] at h
specialize h ht‚ÇÅ ht‚ÇÇ
rintro ‚ü®x, hx, hx'‚ü© ‚ü®y, hy, hy'‚ü©
{ rintro ‚ü®x, hx, hx'‚ü© ‚ü®y, hy, hy'‚ü©, rw ‚Üê compl_inter at h, delta set.nonempty, rw imp_iff_not_or at h, contrapose! h, split, { intros z hz hz', exact h z ‚ü®hz, hz'‚ü© }, { split; intro H; refine H _ ‚Äπ_‚Ä∫; assumption } }
rw ‚Üê compl_inter at h
delta set.nonempty
rw imp_iff_not_or at h
contrapose! h
split
{ intros z hz hz', exact h z ‚ü®hz, hz'‚ü© }
intros z hz hz'
exact h z ‚ü®hz, hz'‚ü©
split; intro H; refine H _ ‚Äπ_‚Ä∫; assumption
split; intro H; refine H _ ‚Äπ_‚Ä∫
split; intro H
{ split; intro H; refine H _ ‚Äπ_‚Ä∫; assumption }
split
intro H
refine H _ ‚Äπ_‚Ä∫
assumption
intro H
refine H _ ‚Äπ_‚Ä∫
assumption
intros
rw [compact_iff_compact_in_subtype, image_univ, subtype.range_coe]
rw [compact_iff_compact_in_subtype, image_univ, subtype.range_coe]; refl
intros
rw [@nhds_eq_uniformity Œ± u‚ÇÅ a, @nhds_eq_uniformity Œ± u‚ÇÇ a]
rw [@nhds_eq_uniformity Œ± u‚ÇÅ a, @nhds_eq_uniformity Œ± u‚ÇÇ a]; exact (lift'_mono h le_rfl)
exact (lift'_mono h le_rfl)
intros
intros V V_in
rcases h _ (symmetrize_mem_uniformity V_in) (symmetric_symmetrize_rel V) with ‚ü®t, tfin, h‚ü©
refine ‚ü®t, tfin, subset.trans h _‚ü©
mono
intros x x_in z z_in
exact z_in.right
intros
unfold interleave corec_on
rw corec_eq
dsimp
rw corec_eq
refl
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
have h := int.add_le_add_left h a
rwa int.add_neg_cancel_left at h
intros
rw int.add_comm at h
exact int.neg_add_lt_left_of_lt_add h
intros
induction n with n IH
{ simp, cases bodd m; refl }
simp
cases bodd m
cases bodd m; refl
refl
refl
{ simp [add_succ, IH], cases bodd m; cases bodd n; refl }
simp [add_succ, IH]
cases bodd m
cases bodd m; cases bodd n; refl
cases bodd m; cases bodd n
cases bodd n
refl
refl
cases bodd n
refl
refl
intros
induction n; simp [*, mul_succ, nat.mul_zero]
{induction n; simp [*, mul_succ, nat.mul_zero] }
induction n
simp [*, mul_succ, nat.mul_zero]
simp [*, mul_succ, nat.mul_zero]
intros
rw [‚Üê add_one, ‚Üê add_one]
simp [nat.right_distrib, nat.left_distrib, nat.add_left_comm, nat.mul_one, nat.one_mul, nat.add_assoc]
intros
tactic.mk_inj_eq
intros
{ simp only [bit0, bit1, add_smul, smul_add, one_smul], abel }
simp only [bit0, bit1, add_smul, smul_add, one_smul]
abel
intros
{ ext c, exact (mul_assoc a c b).symm, }
ext c
exact (mul_assoc a c b).symm
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
cases exists_nat_gt (1/Œµ) with n hn
use n
rw [div_lt_iff, ‚Üê div_lt_iff' hŒµ]
apply hn.trans
{ apply hn.trans, simp [zero_lt_one] }
simp [zero_lt_one]
{ exact n.cast_add_one_pos }
exact n.cast_add_one_pos
intros
rw [piecewise, prod_ite, filter_mem_eq_inter, ‚Üê sdiff_eq_filter]
{ rw [piecewise, prod_ite, filter_mem_eq_inter, ‚Üê sdiff_eq_filter], }
intros
conv_lhs { erw ‚Üêprod_map (s.subtype p) (function.embedding.subtype _) f }
exact prod_congr (subtype_map _) (Œª x hx, rfl)
intros
simpa only [‚Üê div_eq_mul_inv] using @sum_range_sub' (additive M) _ f n
intros
simp only [finset.coe_image, set.mem_image, finset.mem_coe, function.support_subset_iff]
intros b h
suffices : (s.filter (Œª (a : Œ±), g a = b)).nonempty
simpa only [s.fiber_nonempty_iff_mem_image g b, finset.mem_image, exists_prop]
{ simpa only [s.fiber_nonempty_iff_mem_image g b, finset.mem_image, exists_prop], }
exact finset.nonempty_of_prod_ne_one h
intros
simp only [div_eq_mul_inv, sum_mul]
intros
cases s_succ_nth_eq : (s.nth $ n + 1) with gp_succ_n
case option.none { rw [(squash_seq_eq_self_of_terminated s_succ_nth_eq), (convergents'_aux_stable_step_of_terminated s_succ_nth_eq)] }
rw [(squash_seq_eq_self_of_terminated s_succ_nth_eq), (convergents'_aux_stable_step_of_terminated s_succ_nth_eq)]
case option.some { induction n with m IH generalizing s gp_succ_n, case nat.zero { obtain ‚ü®gp_head, s_head_eq‚ü© : ‚àÉ gp_head, s.head = some gp_head, from s.ge_stable zero_le_one s_succ_nth_eq, have : (squash_seq s 0).head = some ‚ü®gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b‚ü©, from squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq, simp [*, convergents'_aux, seq.head, seq.nth_tail] }, case nat.succ { obtain ‚ü®gp_head, s_head_eq‚ü© : ‚àÉ gp_head, s.head = some gp_head, from s.ge_stable (m + 2).zero_le s_succ_nth_eq, suffices : gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2), by simpa only [convergents'_aux, s_head_eq], have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1), by { refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }, have : (squash_seq s (m + 1)).head = some gp_head, from (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq, simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n] } }
induction n with m IH generalizing s gp_succ_n
case nat.zero { obtain ‚ü®gp_head, s_head_eq‚ü© : ‚àÉ gp_head, s.head = some gp_head, from s.ge_stable zero_le_one s_succ_nth_eq, have : (squash_seq s 0).head = some ‚ü®gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b‚ü©, from squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq, simp [*, convergents'_aux, seq.head, seq.nth_tail] }
obtain ‚ü®gp_head, s_head_eq‚ü© : ‚àÉ gp_head, s.head = some gp_head
from s.ge_stable zero_le_one s_succ_nth_eq
have : (squash_seq s 0).head = some ‚ü®gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b‚ü©
from squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq
simp [*, convergents'_aux, seq.head, seq.nth_tail]
case nat.succ { obtain ‚ü®gp_head, s_head_eq‚ü© : ‚àÉ gp_head, s.head = some gp_head, from s.ge_stable (m + 2).zero_le s_succ_nth_eq, suffices : gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2), by simpa only [convergents'_aux, s_head_eq], have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1), by { refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }, have : (squash_seq s (m + 1)).head = some gp_head, from (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq, simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n] }
obtain ‚ü®gp_head, s_head_eq‚ü© : ‚àÉ gp_head, s.head = some gp_head
from s.ge_stable (m + 2).zero_le s_succ_nth_eq
suffices : gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2)
simpa only [convergents'_aux, s_head_eq]
simpa only [convergents'_aux, s_head_eq]
have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1)
refine (IH gp_succ_n _)
refine (IH gp_succ_n _)
{ refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }
{ refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }
simpa [seq.nth_tail] using s_succ_nth_eq
simpa [seq.nth_tail] using s_succ_nth_eq
have : (squash_seq s (m + 1)).head = some gp_head
from (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq
simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n]
intros
simpa [partial_denominators, seq.map_nth] using nth_part_denom_eq
intros
{ rw [from_add_monoid, to_add_monoid_of], refl }
rw [from_add_monoid, to_add_monoid_of]
refl
intros
rw [inv_eq_one_div, inv_eq_one_div, div_sub_div _ _ ha hb, one_mul, mul_one]
intros
simp [norm_unit, h0]
intros
simp [h]
intros
simp [‚Üê h]
intros
rw [sub_eq_neg_add, neg_add_cancel_left]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
congr'
congr'; injection h
injection h
injection h
injection h
intros
convert units.mul_inv _
simp [h.unit_spec]
intros
rw [div_mul_eq_mul_div, ‚Üê one_mul c, ‚Üê div_mul_div, div_one, one_mul]
intros
dsimp [d_to, X_prev_iso]
rw c.prev_eq_some r
refl
intros
simp [image_to_kernel]
intros
simp [mul_indicator, ite_eq_iff, exists_or_distrib, eq_univ_iff_forall, and_comm, or_comm, @eq_comm _ r 1]
intros
{ rw [‚Üêsub_eq_zero, sub_neg_eq_add, ‚Üêlie_add], simp, }
rw [‚Üêsub_eq_zero, sub_neg_eq_add, ‚Üêlie_add]
simp
intros
ext m
simp only [module.End.mem_maximal_generalized_eigenspace, submodule.mem_top, sub_zero, iff_true, zero_smul, submodule.mem_infi]
intros x
obtain ‚ü®k, hk‚ü© := nilpotent_endo_of_nilpotent_module R L M
use k
rw hk
exact linear_map.zero_apply m
intros
{ rw is_semisimple.semisimple, exact is_lie_abelian_bot R L, }
rw is_semisimple.semisimple
exact is_lie_abelian_bot R L
intros
induction k with k ih
{ rw [zero_add, derived_series_of_ideal_zero], }
rw [zero_add, derived_series_of_ideal_zero]
rw [nat.succ_add k l, derived_series_of_ideal_succ, derived_series_of_ideal_succ, ih]
{ rw [nat.succ_add k l, derived_series_of_ideal_succ, derived_series_of_ideal_succ, ih], }
intros
{ rw lie_span_le, exact set.subset.trans h subset_lie_span, }
rw lie_span_le
exact set.subset.trans h subset_lie_span
intros
{ rw lie_span_le, exact subset.trans h subset_lie_span, }
rw lie_span_le
exact subset.trans h subset_lie_span
intros
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, comap_coe_submodule, I.map_coe_submodule f h, lie_submodule.sup_coe_to_submodule, f.ker_coe_submodule, submodule.comap_map_eq]
intros
simp only [root_space_product_def, coe_root_space_weight_space_product_tmul]
intros
{ intros f g h, ext, exact linear_map.congr_fun h x }
intros f g h
ext
exact linear_map.congr_fun h x
intros
have h := (set_like.lt_iff_le_and_exists.1 bot_lt).2
tidy
intros
cases o‚ÇÅ; try {refl}; cases o‚ÇÇ; refl
cases o‚ÇÅ; try {refl}; cases o‚ÇÇ
cases o‚ÇÅ; try {refl}
cases o‚ÇÅ
try {refl}
try {refl}
try {refl}
refl
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, one_le_div_of_neg] }
simp [hb, hb.not_lt, one_le_div_of_neg]
{ simp [lt_irrefl, zero_lt_one.not_le, zero_lt_one] }
simp [lt_irrefl, zero_lt_one.not_le, zero_lt_one]
{ simp [hb, hb.not_lt, one_le_div] }
simp [hb, hb.not_lt, one_le_div]
intros
simp [division_def, mul_pos_iff]
intros
{ rw [‚Üê mul_le_mul_iff_left a, ‚Üê mul_le_mul_iff_right b], simp }
rw [‚Üê mul_le_mul_iff_left a, ‚Üê mul_le_mul_iff_right b]
simp
intros
rw [lt_div_iff_mul_lt, mul_comm]
intros
cases a
cases a; refl
refl
refl
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Iio]
split
rintro ‚ü®a_w, a_h_left, rfl‚ü©
{ rintro ‚ü®a_w, a_h_left, rfl‚ü©, exact (mul_lt_mul_left hr).mpr a_h_left, }
exact (mul_lt_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (div_lt_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (div_lt_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
rw [add_eq_zero_iff', mul_self_eq_zero, mul_self_eq_zero]
rw [add_eq_zero_iff', mul_self_eq_zero, mul_self_eq_zero]; apply mul_self_nonneg
apply mul_self_nonneg
apply mul_self_nonneg
intros
simpa only [mul_one] using decidable.mul_le_mul h‚ÇÇ h‚ÇÑ h‚ÇÉ h‚ÇÅ
intros
by_cases H‚ÇÅ : c = 0
{ simp [H‚ÇÅ, zero_smul] }
simp [H‚ÇÅ, zero_smul]
by_cases H‚ÇÇ : a = b
{ by_cases H‚ÇÇ : a = b, { rw H‚ÇÇ }, { exact le_of_lt (smul_lt_smul_of_pos (lt_of_le_of_ne h‚ÇÅ H‚ÇÇ) (lt_of_le_of_ne h‚ÇÇ (ne.symm H‚ÇÅ))), } }
{ rw H‚ÇÇ }
rw H‚ÇÇ
exact le_of_lt (smul_lt_smul_of_pos (lt_of_le_of_ne h‚ÇÅ H‚ÇÇ) (lt_of_le_of_ne h‚ÇÇ (ne.symm H‚ÇÅ)))
{ exact le_of_lt (smul_lt_smul_of_pos (lt_of_le_of_ne h‚ÇÅ H‚ÇÇ) (lt_of_le_of_ne h‚ÇÇ (ne.symm H‚ÇÅ))), }
intros
simpa only [mul_zero, mul_one] using mul_le_mul_left' (@zero_le_one' Œ± _) a
intros
by_cases h : l.sum = 0
{ simp [h] }
simp [h]
rw degree_eq_nat_degree h
{ rw degree_eq_nat_degree h, suffices : (l.map nat_degree).maximum = ((l.map nat_degree).foldr max 0 : ‚Ñï), { rw this, simpa [this] using nat_degree_list_sum_le l }, rw list.maximum_eq_coe_foldr_max_of_ne_nil, { congr }, contrapose! h, rw [list.map_eq_nil] at h, simp [h] }
suffices : (l.map nat_degree).maximum = ((l.map nat_degree).foldr max 0 : ‚Ñï)
rw this
{ rw this, simpa [this] using nat_degree_list_sum_le l }
simpa [this] using nat_degree_list_sum_le l
rw list.maximum_eq_coe_foldr_max_of_ne_nil
{ congr }
congr
contrapose! h
rw [list.map_eq_nil] at h
simp [h]
intros
simp only [norm_sq_def, sq, ‚Üê neg_mul_eq_mul_neg, sub_neg_eq_add, mul_re, conj_re, conj_im_i, conj_im_j, conj_im_k]
intros
rw [is_right_regular, ‚Üê mul_right_iterate]
{ rw [is_right_regular, ‚Üê mul_right_iterate], exact rra.iterate n }
exact rra.iterate n
intros
simp
intros
simp [mk_ring_hom, quot.sound (rel.of w)]
intros
ext
simp only [mem_singleton_iff, ne.def, function.mem_support]
split
contrapose!
{ contrapose!, exact Œª h', single_eq_of_ne h' b }
exact Œª h', single_eq_of_ne h' b
rintro rfl
{ rintro rfl, rw single_eq_same, exact h }
rw single_eq_same
exact h
intros
rw [‚Üê zero_locus_span {f}, ‚Üê zero_locus_span {g}, zero_locus_subset_zero_locus_iff, ideal.span_le, set.singleton_subset_iff, set_like.mem_coe]
intros
rw [nnreal.tsum_mul_right, ‚Üê fin.prod_const]
exact (p.change_origin_series k l).le_of_op_nnnorm_le _ (p.nnnorm_change_origin_series_le_tsum _ _)
intros
refine le_radius_of_bound_nnreal _ (‚àë' i : (Œ£ n, composition n), nnnorm (comp_along_composition q p i.snd) * r ^ i.fst) (Œª n, _)
calc nnnorm (formal_multilinear_series.comp q p n) * r ^ n ‚â§ ‚àë' (c : composition n), nnnorm (comp_along_composition q p c) * r ^ n : begin rw [tsum_fintype, ‚Üê finset.sum_mul], exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl end ... ‚â§ ‚àë' (i : Œ£ (n : ‚Ñï), composition n), nnnorm (comp_along_composition q p i.snd) * r ^ i.fst : nnreal.tsum_comp_le_tsum_of_inj hr sigma_mk_injective
intros
unfold is_o at *
intros c' c'pos
have : 0 < c' / c
from div_pos c'pos hc
exact ((hfg this).trans hgk (le_of_lt this)).congr_const (div_mul_cancel _ (ne_of_gt hc))
intros
rw is_O_iff; refl
rw is_O_iff
refl
intros
simp [div_eq_inv_mul, deriv_within_const_mul, hc, hxs]
intros
{ ext, unfold deriv_within deriv, rw fderiv_within_univ }
ext
unfold deriv_within deriv
rw fderiv_within_univ
intros
rw add_comm
exact (is_bounded_bilinear_map_comp.has_fderiv_at (d x, c x)).comp x (hd.prod hc)
intros
split
rintros ‚ü®g', hg'‚ü©
{ rintros ‚ü®g', hg'‚ü©, exact ‚ü®g', hs.eq (hg'.restrict_scalars ùïú) hf.has_fderiv_within_at‚ü©, }
exact ‚ü®g', hs.eq (hg'.restrict_scalars ùïú) hf.has_fderiv_within_at‚ü©
rintros ‚ü®f', hf'‚ü©
{ rintros ‚ü®f', hf'‚ü©, exact ‚ü®f', has_fderiv_within_at_of_restrict_scalars ùïú hf.has_fderiv_within_at hf'‚ü©, }
exact ‚ü®f', has_fderiv_within_at_of_restrict_scalars ùïú hf.has_fderiv_within_at hf'‚ü©
intros
have := œÜ.has_strict_fderiv_at.to_local_inverse
simp only [prod_fun] at this
convert this.comp (œÜ.right_fun œÜ.pt) ((has_strict_fderiv_at_const _ _).prod (has_strict_fderiv_at_id _))
simp only [continuous_linear_map.ext_iff, continuous_linear_map.coe_comp', function.comp_app] at hg'inv hg'invf ‚ä¢
simp [continuous_linear_equiv.eq_symm_apply, *]
intros
apply @lhopital_zero_nhds' _ _ _ f' _ g'
apply @lhopital_zero_nhds' _ _ _ f' _ g'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds; assumption
apply @lhopital_zero_nhds' _ _ _ f' _ g'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
intros
induction n with n IH
{ simp }
simp
simp [iterated_deriv_succ, IH]
{ simp [iterated_deriv_succ, IH], ext x, exact (f_aux_has_deriv_at n x).deriv }
ext x
exact (f_aux_has_deriv_at n x).deriv
intros
simp [‚Üê times_cont_diff_on_univ] at *; exact times_cont_diff_on.sum h
simp [‚Üê times_cont_diff_on_univ] at *
exact times_cont_diff_on.sum h
intros
rcases h 0 bot_le with ‚ü®u, hu, p, H‚ü©
rw [mem_nhds_within_insert] at hu
exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2
intros
rintro ‚ü®w, hwB, hwC‚ü©
obtain ‚ü®l‚ÇÅ, rfl‚ü© := hB ‚ü®w, hwB‚ü©
obtain ‚ü®l‚ÇÇ, rfl‚ü© := hC ‚ü®w, hwC‚ü©
refine ‚ü®l‚ÇÅ + l‚ÇÇ, subset.antisymm _ _‚ü©
rintro x ‚ü®‚ü®hxA, hxB‚ü©, ‚ü®-, hxC‚ü©‚ü©
{ rintro x ‚ü®‚ü®hxA, hxB‚ü©, ‚ü®-, hxC‚ü©‚ü©, exact ‚ü®hxA, Œª z hz, add_le_add (hxB z hz) (hxC z hz)‚ü© }
exact ‚ü®hxA, Œª z hz, add_le_add (hxB z hz) (hxC z hz)‚ü©
rintro x ‚ü®hxA, hx‚ü©
refine ‚ü®‚ü®hxA, Œª y hy, _‚ü©, hxA, Œª y hy, _‚ü©
exact (add_le_add_iff_right (l‚ÇÇ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))
{ exact (add_le_add_iff_right (l‚ÇÇ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1)) }
exact (add_le_add_iff_left (l‚ÇÅ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))
{ exact (add_le_add_iff_left (l‚ÇÅ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1)) }
intros
obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := hz
exact hf.le_right_of_left_le' hx hy ha.le hb hab hxz
intros
apply convex_on_of_deriv2_nonneg (convex_Ici _) (continuous_pow n).continuous_on differentiable_on_pow
simp only [deriv_pow']
{ simp only [deriv_pow'], exact (@differentiable_on_pow ‚Ñù _ _ _).const_mul (n : ‚Ñù) }
exact (@differentiable_on_pow ‚Ñù _ _ _).const_mul (n : ‚Ñù)
intros x hx
{ intros x hx, rw [iter_deriv_pow, finset.prod_range_cast_nat_sub], exact mul_nonneg (nat.cast_nonneg _) (pow_nonneg (interior_subset hx) _) }
rw [iter_deriv_pow, finset.prod_range_cast_nat_sub]
exact mul_nonneg (nat.cast_nonneg _) (pow_nonneg (interior_subset hx) _)
intros
refine ‚ü®_, by { rintro rfl, exact submodule.bot_orthogonal_eq_top }‚ü©
intro h
have : K ‚äì K·óÆ = ‚ä• := K.orthogonal_disjoint.eq_bot
rwa [h, inf_comm, top_inf_eq] at this
intros
rw [‚Üêinner_conj_sym, inner_zero_left, ring_hom.map_zero]
intros
rw ‚Üê add_right_inj (finrank ùïú K‚ÇÅ)
{ rw ‚Üê add_right_inj (finrank ùïú K‚ÇÅ), simp [submodule.finrank_add_inf_finrank_orthogonal h, h_dim] }
simp [submodule.finrank_add_inf_finrank_orthogonal h, h_dim]
intros
simpa using dist_midpoint_midpoint_le' p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ
intros
simp only [‚Üê dist_zero_right, dist_pi_le_iff hr, pi.zero_apply]
intros
simpa only [sub_eq_add_neg, dist_neg_neg] using dist_add_add_le g‚ÇÅ (-g‚ÇÇ) h‚ÇÅ (-h‚ÇÇ)
intros
convert (has_fpower_series_at_exp_zero_of_radius_pos h).has_strict_fderiv_at
ext x
change x = exp_series ùïÇ ùî∏ 1 (Œª _, x)
simp [exp_series_apply_eq]
intros
{ ext m, simp }
ext m
simp
intros
simp only [norm_def, coe_neg, norm_neg, pi.neg_apply]
intros
ext x
change f.completion x = _
simpa
intros
nontriviality R
rw [eventually_iff, metric.mem_nhds_iff]
have hinv : 0 < ‚à•(‚Üëx‚Åª¬π : R)‚à•‚Åª¬π
cancel_denoms
cancel_denoms
use [‚à•(‚Üëx‚Åª¬π : R)‚à•‚Åª¬π, hinv]
intros t ht
simp only [mem_ball, dist_zero_right] at ht
have ht' : ‚à•-‚Üëx‚Åª¬π * t‚à• < 1
refine lt_of_le_of_lt (norm_mul_le _ _) _
{ refine lt_of_le_of_lt (norm_mul_le _ _) _, rw norm_neg, refine lt_of_lt_of_le (mul_lt_mul_of_pos_left ht x‚Åª¬π.norm_pos) _, cancel_denoms }
rw norm_neg
refine lt_of_lt_of_le (mul_lt_mul_of_pos_left ht x‚Åª¬π.norm_pos) _
cancel_denoms
have hright := inverse_one_sub (-‚Üëx‚Åª¬π * t) ht'
have hleft := inverse_unit (x.add t ht)
simp only [‚Üê neg_mul_eq_neg_mul, sub_neg_eq_add] at hright
simp only [units.coe_add] at hleft
simp [hleft, hright, units.add]
intros
simp only [norm_eq_sqrt_real_inner, inner_self, norm_sq.map_mul]
exact real.sqrt_mul norm_sq_nonneg _
intros
dsimp [bernstein, polynomial.to_continuous_map_on, polynomial.to_continuous_map, bernstein_polynomial]
simp
intros
rw div_eq_inv_mul
{ rw div_eq_inv_mul, exact (has_strict_deriv_at_log h‚ÇÇ).has_deriv_at.comp x h‚ÇÅ }
exact (has_strict_deriv_at_log h‚ÇÇ).has_deriv_at.comp x h‚ÇÅ
intros
{ rw [log_of_ne_zero hx.ne'], congr, exact abs_of_pos hx }
rw [log_of_ne_zero hx.ne']
congr
exact abs_of_pos hx
intros
simpa using integral_sin_pow_mul_cos_pow_odd 1 0
intros
refine tendsto.congr' _ ((tendsto_exp_nhds_0_nhds_1.comp (by simpa only [mul_zero, pow_one] using ((@tendsto_const_nhds _ _ _ a _).mul (tendsto_div_pow_mul_exp_add_at_top b c 1 hb (by norm_num))))).comp (tendsto_log_at_top))
apply eventually_eq_of_mem (Ioi_mem_at_top (0:‚Ñù))
intros x hx
simp only [set.mem_Ioi, function.comp_app] at hx ‚ä¢
rw [exp_log hx, ‚Üê exp_log (rpow_pos_of_pos hx (a / (b * x + c))), log_rpow hx (a / (b * x + c))]
field_simp
intros
cases x
rcases lt_trichotomy y 0 with H|H|H; simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
rcases lt_trichotomy y 0 with H|H|H
{ rcases lt_trichotomy y 0 with H|H|H; simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr] }
simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
by_cases h : x = 0
{ by_cases h : x = 0, { rcases lt_trichotomy y 0 with H|H|H; simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr] }, { have A : x ^ y ‚â† 0, by simp [h], simp [coe_rpow_of_ne_zero h, ‚Üê coe_inv A, nnreal.rpow_neg] } }
rcases lt_trichotomy y 0 with H|H|H; simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
rcases lt_trichotomy y 0 with H|H|H
{ rcases lt_trichotomy y 0 with H|H|H; simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr] }
simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
have A : x ^ y ‚â† 0
{ have A : x ^ y ‚â† 0, by simp [h], simp [coe_rpow_of_ne_zero h, ‚Üê coe_inv A, nnreal.rpow_neg] }
simp [h]
simp [h]
simp [coe_rpow_of_ne_zero h, ‚Üê coe_inv A, nnreal.rpow_neg]
intros
{ rw ‚Üê one_rpow z, exact rpow_le_rpow zero_le_one hx hz }
rw ‚Üê one_rpow z
exact rpow_le_rpow zero_le_one hx hz
intros
simpa only [cos_zero] using (cos_periodic.int_mul n).add_antiperiod_eq cos_antiperiodic
intros
simp
intros
simp only [cos, div_eq_mul_inv]
convert ((((has_strict_deriv_at_id x).neg.mul_const I).cexp.sub ((has_strict_deriv_at_id x).mul_const I).cexp).mul_const I).mul_const (2:‚ÑÇ)‚Åª¬π
simp only [function.comp, id]
rw [sub_mul, mul_assoc, mul_assoc, I_mul_I, neg_one_mul, neg_neg, mul_one, one_mul, mul_assoc, I_mul_I, mul_neg_one, sub_neg_eq_add, add_comm]
intros
rw [‚Üê not_exists, not_iff_not, tan_eq_zero_iff]
intros
rw [arccos_eq_pi_div_two_sub_arcsin, sin_pi_div_two_sub, cos_arcsin hx‚ÇÅ hx‚ÇÇ]
intros
apply nnreal.has_sum_coe.1
push_cast
rw [nnreal.coe_sub (le_of_lt hr)]
exact has_sum_geometric_of_lt_1 r.coe_nonneg hr
intros
simp only [‚Üêarrow.mk_hom g, lift.fac_right, arrow.hom_mk'_right]
intros
split
intros Z a b w
replace w := congr_arg (Œª k, k ‚â´ g) w
dsimp at w
rw [category.assoc, category.assoc] at w
exact (cancel_mono _).1 w
intros
{ cases p, simp, }
cases p
simp
intros
injection (constant_of_preserves_morphisms (Œª k, ulift.up (k ‚àà p)) (Œª j‚ÇÅ j‚ÇÇ f, _) j j‚ÇÄ) with i
rwa i
dsimp
exact congr_arg ulift.up (propext (h1 f))
intros
apply (cancel_epi (inv f)).1
erw [inv_hom_id, p, inv_hom_id]
intros
ext1
rw [‚Üêcategory.assoc]
simp
intros
simp
intros
rw ‚Üêis_image.e_iso_ext_hom F.to_mono_is_image hF'
{ rw ‚Üêis_image.e_iso_ext_hom F.to_mono_is_image hF', apply strong_epi_comp }
apply strong_epi_comp
intros
apply quot.eq.1
simpa using congr_arg (colimit_equiv_quot F) w
intros
{ rw [‚Üêtensor_comp], simp }
rw [‚Üêtensor_comp]
simp
intros
have pent := pentagon W X Y Z
rw ‚Üêiso.inv_comp_eq at pent
rw [‚Üêpent]
simp only [tensor_id, assoc, id_comp, comp_id, hom_inv_id, tensor_hom_inv_id_assoc]
intros
rw [naturality, ‚Üêcategory.assoc, ‚Üênat_trans.comp_app, Œ±.hom_inv_id, id_app, category.id_comp]
intros
rw [covers_iff, bot_covering, ‚Üê sieve.pullback_eq_top_iff_mem]
intros
rw ‚Üê is_separated_for_and_exists_is_amalgamation_iff_sheaf_for
split
intros x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
{ intros x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ, exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x t‚ÇÅ ht‚ÇÅ) (is_amalgamation_restrict h x t‚ÇÇ ht‚ÇÇ) }
exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x t‚ÇÅ ht‚ÇÅ) (is_amalgamation_restrict h x t‚ÇÇ ht‚ÇÇ)
intros x hx
{ intros x hx, use hS.amalgamate _ (hx.restrict h), intros W j hj, apply (trans hj).ext, intros Y f hf, rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict, ‚Üêhx (ùüô _) f _ _ (id_comp _)], simp }
use hS.amalgamate _ (hx.restrict h)
intros W j hj
apply (trans hj).ext
intros Y f hf
rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict, ‚Üêhx (ùüô _) f _ _ (id_comp _)]
simp
intros
apply quotient.induction_on' x
intro f
apply quotient.sound
exact ‚ü®mono_over.pullback_id.app f‚ü©
intros
simp [types_comp]
intros
{ rw c.card_boundaries_eq_succ_length, exact lt_add_one _ }
rw c.card_boundaries_eq_succ_length
exact lt_add_one _
intros
{ funext i, cases i; refl }
funext i
cases i
cases i; refl
refl
refl
intros
rw ‚Üêcard_univ
rw @card_eq_sum_card_fiberwise _ _ _ dart.edge _ G.edge_finset (Œª d h, by { rw mem_edge_finset, apply dart.edge_mem })
rw [‚Üêmul_comm, sum_const_nat]
intros e h
apply G.dart_edge_fiber_card e
rwa ‚Üêmem_edge_finset
intros
simp [mul_def]
intros
conv {to_lhs, rw [‚Üê list_blank.cons_head_tail l]}
exact quotient.induction_on' l (Œª a, rfl)
intros
simp [guard]
intros
ext
ext; simp [map_traverse]
simp [map_traverse]
intros
cases F; subst f; simp
cases F; subst f
cases F
subst f
simp
intros
cases b; simp only [nat.add_mul_div_left, add_lsb, ‚Üêtwo_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]; norm_num
cases b; simp only [nat.add_mul_div_left, add_lsb, ‚Üêtwo_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]
cases b
simp only [nat.add_mul_div_left, add_lsb, ‚Üêtwo_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]
simp only [nat.add_mul_div_left, add_lsb, ‚Üêtwo_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]
norm_num
intros
introI
have : (pure a : parser Œ±) buffer.nil 0 = done 0 a := by simp [pure_eq_done]
exact absurd (bounded.of_done this) (lt_irrefl _)
intros
obtain ‚ü®np, a, hp‚ü© := p.exists_done cb n
simpa [hp] using h
intros
simp [map_const_eq]
intros
by_cases hn : n = n'
{ simp [hn, pure_eq_done] }
simp [hn, pure_eq_done]
{ simp [orelse_eq_fail_of_mono_ne, hn] }
simp [orelse_eq_fail_of_mono_ne, hn]
intros
simp only [many', eps_eq_done, many, foldr, and_then_eq_bind, exists_and_distrib_right, bind_eq_done, exists_eq_right]
split
rintro ‚ü®_ | ‚ü®hd, tl‚ü©, hl‚ü©
{ rintro ‚ü®_ | ‚ü®hd, tl‚ü©, hl‚ü©, { exact or.inl hl }, { have hl2 := hl, simp only [foldr_core_eq_done, or_false, exists_and_distrib_left, and_false, false_and, exists_eq_right_right] at hl, obtain ‚ü®np, hp, h‚ü© := hl, refine or.inr ‚ü®np, _, _, hl2, hp, h‚ü© } }
{ exact or.inl hl }
exact or.inl hl
have hl2 := hl
{ have hl2 := hl, simp only [foldr_core_eq_done, or_false, exists_and_distrib_left, and_false, false_and, exists_eq_right_right] at hl, obtain ‚ü®np, hp, h‚ü© := hl, refine or.inr ‚ü®np, _, _, hl2, hp, h‚ü© }
simp only [foldr_core_eq_done, or_false, exists_and_distrib_left, and_false, false_and, exists_eq_right_right] at hl
obtain ‚ü®np, hp, h‚ü© := hl
refine or.inr ‚ü®np, _, _, hl2, hp, h‚ü©
rintro (h | ‚ü®np, a, l, hp, h‚ü©)
{ rintro (h | ‚ü®np, a, l, hp, h‚ü©), { exact ‚ü®[], h‚ü© }, { refine ‚ü®a :: l, hp‚ü© } }
{ exact ‚ü®[], h‚ü© }
exact ‚ü®[], h‚ü©
{ refine ‚ü®a :: l, hp‚ü© }
refine ‚ü®a :: l, hp‚ü©
rw [‚Üê of_real_zero, ‚Üê of_real_inv, inv_zero]
intros
rw ‚Üê of_real_inj; simp [sin_three_mul]
rw ‚Üê of_real_inj
simp [sin_three_mul]
intros
rw [two_mul, cosh_add, sq, sq]
intros
rw algebra.smul_def
{ rw algebra.smul_def, apply of_real_mul_re }
apply of_real_mul_re
intros
by_cases h : r = 0
{ simp [h, of_real_zero] }
simp [h, of_real_zero]
change r ‚â† 0 at h
{ change r ‚â† 0 at h, rw [div_eq_mul_inv, ‚Üêof_real_inv, div_eq_mul_inv], simp [norm_sq, div_mul_eq_div_mul_one_div, div_self h] }
rw [div_eq_mul_inv, ‚Üêof_real_inv, div_eq_mul_inv]
simp [norm_sq, div_mul_eq_div_mul_one_div, div_self h]
intros
by_cases h : b ‚â† 0
{ simp [dfinsupp.prod, support_single_ne_zero h] }
simp [dfinsupp.prod, support_single_ne_zero h]
rw [not_not] at h
{ rw [not_not] at h, simp [h, prod_zero_index, h_zero], refl }
simp [h, prod_zero_index, h_zero]
refl
intros
refine quotient.induction_on f (Œª x, _)
cases x with f s H
revert f H
apply multiset.induction_on s
intros f H
{ intros f H, convert h0, ext i, exact (H i).resolve_left id }
convert h0
ext i
exact (H i).resolve_left id
intros i s ih f H
by_cases H1 : i ‚àà s
have H2 : ‚àÄ j, j ‚àà s ‚à® f j = 0
{ have H2 : ‚àÄ j, j ‚àà s ‚à® f j = 0, { intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { left, rw H3, exact H1 }, { left, exact H3 } }, right, exact H2 }, have H3 : (‚ü¶{to_fun := f, pre_support := i ::‚Çò s, zero := H}‚üß : Œ†‚ÇÄ i, Œ≤ i) = ‚ü¶{to_fun := f, pre_support := s, zero := H2}‚üß, { exact quotient.sound (Œª i, rfl) }, rw H3, apply ih }
intro j
{ intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { left, rw H3, exact H1 }, { left, exact H3 } }, right, exact H2 }
cases H j with H2 H2
cases multiset.mem_cons.1 H2 with H3 H3
{ cases multiset.mem_cons.1 H2 with H3 H3, { left, rw H3, exact H1 }, { left, exact H3 } }
left
{ left, rw H3, exact H1 }
rw H3
exact H1
left
{ left, exact H3 }
exact H3
right
exact H2
have H3 : (‚ü¶{to_fun := f, pre_support := i ::‚Çò s, zero := H}‚üß : Œ†‚ÇÄ i, Œ≤ i) = ‚ü¶{to_fun := f, pre_support := s, zero := H2}‚üß
{ exact quotient.sound (Œª i, rfl) }
exact quotient.sound (Œª i, rfl)
rw H3
apply ih
have H2 : p (erase i ‚ü¶{to_fun := f, pre_support := i ::‚Çò s, zero := H}‚üß)
dsimp only [erase, quotient.map_mk]
{ dsimp only [erase, quotient.map_mk], have H2 : ‚àÄ j, j ‚àà s ‚à® ite (j = i) 0 (f j) = 0, { intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { right, exact if_pos H3 }, { left, exact H3 } }, right, split_ifs; [refl, exact H2] }, have H3 : (‚ü¶{to_fun := Œª (j : Œπ), ite (j = i) 0 (f j), pre_support := i ::‚Çò s, zero := _}‚üß : Œ†‚ÇÄ i, Œ≤ i) = ‚ü¶{to_fun := Œª (j : Œπ), ite (j = i) 0 (f j), pre_support := s, zero := H2}‚üß := quotient.sound (Œª i, rfl), rw H3, apply ih }
have H2 : ‚àÄ j, j ‚àà s ‚à® ite (j = i) 0 (f j) = 0
intro j
{ intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { right, exact if_pos H3 }, { left, exact H3 } }, right, split_ifs; [refl, exact H2] }
cases H j with H2 H2
cases multiset.mem_cons.1 H2 with H3 H3
{ cases multiset.mem_cons.1 H2 with H3 H3, { right, exact if_pos H3 }, { left, exact H3 } }
right
{ right, exact if_pos H3 }
exact if_pos H3
left
{ left, exact H3 }
exact H3
right
split_ifs
split_ifs; [refl, exact H2]
refl
exact H2
have H3 : (‚ü¶{to_fun := Œª (j : Œπ), ite (j = i) 0 (f j), pre_support := i ::‚Çò s, zero := _}‚üß : Œ†‚ÇÄ i, Œ≤ i) = ‚ü¶{to_fun := Œª (j : Œπ), ite (j = i) 0 (f j), pre_support := s, zero := H2}‚üß := quotient.sound (Œª i, rfl)
rw H3
apply ih
have H3 : single i _ + _ = (‚ü¶{to_fun := f, pre_support := i ::‚Çò s, zero := H}‚üß : Œ†‚ÇÄ i, Œ≤ i) := single_add_erase _ _
rw ‚Üê H3
change p (single i (f i) + _)
cases classical.em (f i = 0) with h h
{ rw [h, single_zero, zero_add], exact H2 }
rw [h, single_zero, zero_add]
exact H2
refine ha _ _ _ _ h H2
rw erase_same
intros
{ ext1 x, cases x, refl }
ext1 x
cases x
refl
intros
{ convert perm.subtype_congr.left_apply _ _ a.property, simp }
convert perm.subtype_congr.left_apply _ _ a.property
simp
intros
{ rw [succ_above_below, cast_succ_cast_lt], exact h }
rw [succ_above_below, cast_succ_cast_lt]
exact h
intros
rw [‚Üê not_exists, ‚Üê is_some_find_iff]; cases (find p); simp
rw [‚Üê not_exists, ‚Üê is_some_find_iff]; cases (find p)
rw [‚Üê not_exists, ‚Üê is_some_find_iff]
cases (find p)
simp
simp
intros
{ rw [lt_iff_coe_lt_coe, coe_zero], exact nat.succ_pos i }
rw [lt_iff_coe_lt_coe, coe_zero]
exact nat.succ_pos i
intros
cases i; refl
cases i
refl
refl
intros
rw update_piecewise
refine s.piecewise_congr (Œª j hj, update_noteq _ _ _) (Œª _ _, rfl)
exact Œª h, hi (h ‚ñ∏ hj)
intros
simp only [finset.subset_iff, multiset.subset_iff, multiset.mem_to_finset]
intros
classical
by_contra hz
push_neg at hz
refine hc.not_le (card_le_card_of_inj_on f hf _)
intros x hx y hy
contrapose
exact hz x hx y hy
intros
{ rw nonempty_iff_ne_empty, exact not_not, }
rw nonempty_iff_ne_empty
exact not_not
intros
simp only [insert_eq, union_left_comm]
intros
show _ > _ ‚Üî _
apply fold_op_rel_iff_and
intros x y z
show _ < _ ‚Üî _
exact max_lt_iff
intros
rw [‚Üê supr_coe, coe_image, supr_image, supr_coe]
intros
apply iff.trans multiset.sup_le
simp only [multiset.mem_map, and_imp, exists_imp_distrib]
exact ‚ü®Œª k b hb, k _ _ hb rfl, Œª k a' b hb h, h ‚ñ∏ k _ hb‚ü©
intros
apply eq_of_veq
rw [insert_val_of_not_mem, map_val]
{apply multiset.nat.antidiagonal_succ}
apply multiset.nat.antidiagonal_succ
intro con
{ intro con, rcases mem_map.1 con with ‚ü®‚ü®a,b‚ü©, ‚ü®h1, h2‚ü©‚ü©, simp only [prod.mk.inj_iff, function.embedding.coe_prod_map, prod.map_mk] at h2, apply nat.succ_ne_zero a h2.1, }
rcases mem_map.1 con with ‚ü®‚ü®a,b‚ü©, ‚ü®h1, h2‚ü©‚ü©
simp only [prod.mk.inj_iff, function.embedding.coe_prod_map, prod.map_mk] at h2
apply nat.succ_ne_zero a h2.1
intros
{ subst s, ext y, simp [h‚ÇÇ] { contextual := tt } }
subst s
ext y
simp [h‚ÇÇ] { contextual := tt }
intros
simp [order_emb_of_fin, set.range_comp coe (s.order_iso_of_fin h)]
intros
ext x
ext x; refl
refl
intros
{ ext, simp }
ext
simp
intros
ext ‚ü®b, h‚ü©
apply f.injective
simp [f.left_inv_of_inv_of_mem_range, @inv_fun_eq _ _ _ f b (set.mem_range.mp h)]
intros
simp
intros
rw to_nat_le; exact le_trans h (le_to_nat b)
rw to_nat_le
exact le_trans h (le_to_nat b)
intros
cases a; cases b; simp only [‚Üê int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
cases a; cases b
cases a
cases b
simp only [‚Üê int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
simp only [‚Üê int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
cases b
simp only [‚Üê int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
simp only [‚Üê int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
intros
rw [add_comm, add_mod_self]
intros
rw [abs_eq_nat_abs]; refl
rw [abs_eq_nat_abs]
refl
intros
cases (nat.eq_zero_or_pos (nat_abs b))
rw eq_zero_of_nat_abs_eq_zero h
{rw eq_zero_of_nat_abs_eq_zero h, simp [int.div_zero]}
simp [int.div_zero]
calc nat_abs (a / b) = nat_abs (a / b) * 1 : by rw mul_one ... = nat_abs (a / b) * (nat_abs b / nat_abs b) : by rw nat.div_self h ... = nat_abs (a / b) * nat_abs b / nat_abs b : by rw (nat.mul_div_assoc _ dvd_rfl) ... = nat_abs (a / b * b) / nat_abs b : by rw (nat_abs_mul (a / b) b) ... = nat_abs a / nat_abs b : by rw int.div_mul_cancel H
intros
rwa [‚Üê hx, ‚Üê hy, int.coe_nat_gcd]
intros
rw [mul_comm a, mul_comm b, mul_comm n]; exact h.mul_left' hc
rw [mul_comm a, mul_comm b, mul_comm n]
exact h.mul_left' hc
intros
rw [odd_iff, mod_two_ne_one]
intros
ext : 1; simp only [alist.insert_entries, list.kerase_cons_eq]; constructor_matching* [_ ‚àß _]; refl
ext : 1; simp only [alist.insert_entries, list.kerase_cons_eq]; constructor_matching* [_ ‚àß _]
ext : 1; simp only [alist.insert_entries, list.kerase_cons_eq]
ext : 1
simp only [alist.insert_entries, list.kerase_cons_eq]
constructor_matching* [_ ‚àß _]
refl
refl
refl
intros
rw [remove_nth_eq_nth_tail, insert_nth, modify_nth_tail_modify_nth_tail_same]
rw [remove_nth_eq_nth_tail, insert_nth, modify_nth_tail_modify_nth_tail_same]; from modify_nth_tail_id _ _
from modify_nth_tail_id _ _
intros
cases l; cases n; simp only [update_nth]
cases l; cases n
cases l
cases n
simp only [update_nth]
simp only [update_nth]
cases n
simp only [update_nth]
simp only [update_nth]
intros
rw [insert_neg, singleton_eq]
{ rw [insert_neg, singleton_eq], rwa [singleton_eq, mem_singleton] }
rwa [singleton_eq, mem_singleton]
intros
funext l
induction l with a l IH
refl
{refl}
simp only [filter_map_cons_some (some ‚àò f) _ _ rfl, IH, map_cons]
split
split; refl
refl
refl
intros
induction ys generalizing f
{ simp }
simp
{ simp [ys_ih (Œª xs, f (ys_hd :: xs))] }
simp [ys_ih (Œª xs, f (ys_hd :: xs))]
intros
simp only [map‚ÇÇ_right, map‚ÇÇ_right', map‚ÇÇ_left_eq_map‚ÇÇ_left']
intros
induction s; [rw [nil_append, reverse_nil, append_nil], simp only [*, cons_append, reverse_cons, append_assoc]]
induction s
rw [nil_append, reverse_nil, append_nil]
simp only [*, cons_append, reverse_cons, append_assoc]
intros
cases l
cases l; refl
refl
refl
intros
rw [next, next_or_concat]
{ refl }
refl
{ simp [hy, hx] }
simp [hy, hx]
intros
induction s using quot.induction_on
exact next_mem _ _ _
intros
simp only [foldl_with_index, foldl_with_index_aux_spec, foldl_with_index_aux_eq_foldl_with_index_aux_spec, enum]
intros
obtain ‚ü®xs, hp, h‚ü© := h
exact ‚ü®_, hp.filter p, h.filter p‚ü©
intros
induction l; simp [*, perm.insert]
induction l
simp [*, perm.insert]
simp [*, perm.insert]
intros
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem h
simp
intros
cases nd.eq_of_fst_eq h h' rfl; refl
cases nd.eq_of_fst_eq h h' rfl
refl
intros
simp only [unzip_eq_map]
intros
{ ext, apply dot_product_add }
ext
apply dot_product_add
intros
ext i j
ext i j; simp
simp
intros
simp only [matrix.mul_vec, matrix.map_apply, ring_hom.map_dot_product]
intros
simp [dot_product, finset.smul_sum, mul_smul_comm]
intros
{ ext, simp [vec_mul] }
ext
simp [vec_mul]
intros
{ ext, simp [block_diagonal_apply] }
ext
simp [block_diagonal_apply]
intros
simp only [vec_cons, fin.cons, fin.cases_succ']
intros
{ ext i, refine fin.cases _ _ i; simp }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp
simp
simp
intros
simp
intros
ext
ext; simp
simp
intros
rw [‚Üê inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_cons]
rw [‚Üê inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_cons]; simp
simp
intros
simp [powerset_len_aux_eq_map_coe]; refl
simp [powerset_len_aux_eq_map_coe]
refl
intros
{ convert comap_id_apply x, ext1 œÜ, rw [hf, alg_hom.id_apply] }
convert comap_id_apply x
ext1 œÜ
rw [hf, alg_hom.id_apply]
intros
rw [aeval_eq_bind‚ÇÅ, bind‚ÇÅ_X_left, alg_hom.id_apply]
intros
dsimp only [degrees]
apply multiset.subset_of_le
apply finset.sup_mono
apply mv_polynomial.support_map_subset
intros
rw [mul_comm, ‚Üê nat.div_lt_iff_lt_mul' n0]
exact lt_succ_self _
intros
convert (range_of_succ _).symm
ext n
induction n with n ihn
{ refl }
refl
dsimp at ihn ‚ä¢
{ dsimp at ihn ‚ä¢, rw ihn }
rw ihn
intros
rw [lxor_comm n m, lxor_comm n' m] at h
{ rw [lxor_comm n m, lxor_comm n' m] at h, exact lxor_right_inj h }
exact lxor_right_inj h
intros
have A : ‚àÄn:‚Ñï, P n := Œª n, nat.rec_on n h0 hsuc
cases a
{ exact htop A }
exact htop A
{ exact A a }
exact A a
intros
induction l with hd tl IH
{ simp [of_digits], }
simp [of_digits]
rw [of_digits, list.length_cons, pow_succ]
{ rw [of_digits, list.length_cons, pow_succ], have : (of_digits (b + 2) tl + 1) * (b+2) ‚â§ (b + 2) ^ tl.length * (b+2) := mul_le_mul (IH (Œª x hx, hl _ (list.mem_cons_of_mem _ hx))) (by refl) dec_trivial (nat.zero_le _), suffices : ‚Üëhd < b + 2, { linarith }, norm_cast, exact hl hd (list.mem_cons_self _ _) }
have : (of_digits (b + 2) tl + 1) * (b+2) ‚â§ (b + 2) ^ tl.length * (b+2) := mul_le_mul (IH (Œª x hx, hl _ (list.mem_cons_of_mem _ hx))) (by refl) dec_trivial (nat.zero_le _)
suffices : ‚Üëhd < b + 2
{ linarith }
linarith
norm_cast
exact hl hd (list.mem_cons_self _ _)
intros
rw dist_comm; apply dist_tri_left
rw dist_comm
apply dist_tri_left
intros
cases le_or_lt b 1 with hb hb
{ rw log_of_left_le_one hb, exact zero_le _ }
rw log_of_left_le_one hb
exact zero_le _
{ cases nat.eq_zero_or_pos n with hn hn, { rw [hn, log_zero_right], exact zero_le _ }, { rw ‚Üêpow_le_iff_le_log hb (hn.trans_le h), exact (pow_log_le_self hb hn).trans h } }
cases nat.eq_zero_or_pos n with hn hn
{ rw [hn, log_zero_right], exact zero_le _ }
rw [hn, log_zero_right]
exact zero_le _
rw ‚Üêpow_le_iff_le_log hb (hn.trans_le h)
{ rw ‚Üêpow_le_iff_le_log hb (hn.trans_le h), exact (pow_log_le_self hb hn).trans h }
exact (pow_log_le_self hb hn).trans h
intros
rw [‚Üê add_mod_add_ite, if_neg (not_le_of_lt hc), add_zero]
intros
rw [‚Üê one_shiftl]
have : ‚àÄ {n}, n = 0 ‚Üí n < shiftl 1 (size n)
simp
{ simp }
apply binary_rec _ _ n
apply this rfl
{apply this rfl}
intros b n IH
by_cases bit b n = 0
apply this h
{apply this h}
rw [size_bit h, shiftl_succ]
exact bit_lt_bit0 _ IH
intros
apply iff.intro
intro h
{ intro h, exact ‚ü®min_fac (gcd m n), min_fac_prime h, ((min_fac_dvd (gcd m n)).trans (gcd_dvd_left m n)), ((min_fac_dvd (gcd m n)).trans (gcd_dvd_right m n))‚ü© }
exact ‚ü®min_fac (gcd m n), min_fac_prime h, ((min_fac_dvd (gcd m n)).trans (gcd_dvd_left m n)), ((min_fac_dvd (gcd m n)).trans (gcd_dvd_right m n))‚ü©
intro h
{ intro h, cases h with p hp, apply nat.not_coprime_of_dvd_of_dvd (prime.one_lt hp.1) hp.2.1 hp.2.2 }
cases h with p hp
apply nat.not_coprime_of_dvd_of_dvd (prime.one_lt hp.1) hp.2.1 hp.2.2
intros
rw [‚Üê n.to_nat_to_int, to_nat_eq_succ_pred]; refl
rw [‚Üê n.to_nat_to_int, to_nat_eq_succ_pred]
refl
intros
cases x; simp
{ cases x; simp }
cases x
simp
simp
intros
cases o; refl
cases o
refl
refl
intros
cases m; simp [node4_l, node4_r, dual_node3_l, dual_node']
cases m
simp [node4_l, node4_r, dual_node3_l, dual_node']
simp [node4_l, node4_r, dual_node3_l, dual_node']
intros
rw [‚Üê find_min'_dual, dual_dual]
intros
split
rw [ne, eq_none_iff', not_not]
{ rw [ne, eq_none_iff', not_not], exact Œª h, ‚ü®o.get h, eq_some_iff.2 (get_mem h)‚ü© }
exact Œª h, ‚ü®o.get h, eq_some_iff.2 (get_mem h)‚ü©
{ rintro ‚ü®x, rfl‚ü©, apply some_ne_none }
rintro ‚ü®x, rfl‚ü©
apply some_ne_none
intros
{ cases x, dsimp [const.get,const.mk], congr' with _ ‚ü® ‚ü© }
cases x
dsimp [const.get,const.mk]
congr' with _ ‚ü® ‚ü©
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
let h := @prod_dvd_iff u n.factor_multiset
{ let h := @prod_dvd_iff u n.factor_multiset, rw [n.prod_factor_multiset] at h, exact h }
rw [n.prod_factor_multiset] at h
exact h
intros
induction k with k ih
{ simp [pow_zero, monomial_zero_one], }
simp [pow_zero, monomial_zero_one]
simp [pow_succ, ih, monomial_mul_monomial, nat.succ_eq_add_one, mul_add, add_comm]
{ simp [pow_succ, ih, monomial_mul_monomial, nat.succ_eq_add_one, mul_add, add_comm] }
intros
rw [‚Üêone_smul R p, ‚Üêh, zero_smul]
intros
rw [degree, ‚Üê monomial_zero_left, support_monomial 0 _ ha, sup_singleton]
{ rw [degree, ‚Üê monomial_zero_left, support_monomial 0 _ ha, sup_singleton], refl }
refl
intros
by_cases hp : p = 0
simp [hp]
{ simp [hp], rw bot_lt_iff_ne_bot, intro hq, simpa [hp, degree_eq_bot.mp hq, lt_irrefl] using h }
rw bot_lt_iff_ne_bot
intro hq
simpa [hp, degree_eq_bot.mp hq, lt_irrefl] using h
rw [degree_eq_nat_degree hp, degree_eq_nat_degree $ ne_zero_of_nat_degree_gt h]
{ rw [degree_eq_nat_degree hp, degree_eq_nat_degree $ ne_zero_of_nat_degree_gt h], exact_mod_cast h }
exact_mod_cast h
intros
rw [C_mul_X_pow_eq_monomial, C_mul_X_pow_eq_monomial, derivative_monomial]
intros
simp [eval‚ÇÇ_eq_sum]
intros
simp only [‚ÜêC_eq_int_cast, eval_C]
intros
rw [ne.def, ‚Üê leading_coeff_eq_zero, ‚Üê ne.def, ‚Üê is_unit_iff_ne_zero] at hp0
rw [monic, leading_coeff_normalize, normalize_eq_one]
apply hp0
intros
rw [iterated_deriv, iterated_deriv, function.iterate_succ']
intros
rw [‚ÜêC_mul', ‚ÜêC_mul', mirror_mul_of_domain, mirror_C]
intros
by_cases h : p = 1
{ simpa [h] }
simpa [h]
rw [ne.def, ‚Üêdegree_eq_bot, hp.degree_mul, with_bot.add_eq_bot, not_or_distrib, degree_eq_bot]
refine ‚ü®hq, _‚ü©
rw [‚Üêhp.degree_le_zero_iff_eq_one, not_le] at h
refine (lt_trans _ h).ne'
simp
intros
rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero]
intros n hn
rw with_bot.coe_lt_coe at hn
rw [coeff_reverse, rev_at, function.embedding.coe_fn_mk, if_neg (not_le_of_gt hn), coeff_eq_zero_of_nat_degree_lt hn]
intros
have dz := degree_eq_zero_of_is_unit H
rw degree_map_eq_of_leading_coeff_ne_zero at dz
rw eq_C_of_degree_eq_zero dz
{ rw eq_C_of_degree_eq_zero dz, refine is_unit.map (C.to_monoid_hom : R ‚Üí* polynomial R) _, convert hf, rw (degree_eq_iff_nat_degree_eq _).1 dz, rintro rfl, simpa using H, }
refine is_unit.map (C.to_monoid_hom : R ‚Üí* polynomial R) _
convert hf
rw (degree_eq_iff_nat_degree_eq _).1 dz
rintro rfl
simpa using H
intro h
{ intro h, have u : is_unit (œÜ f.leading_coeff) := is_unit.map œÜ.to_monoid_hom hf, rw h at u, simpa using u, }
have u : is_unit (œÜ f.leading_coeff) := is_unit.map œÜ.to_monoid_hom hf
rw h at u
simpa using u
intros
split
intros h
{ intros h, have : liftp (supp x) x, by { rw h, introv, exact id, }, rw liftp_iff at this, rcases this with ‚ü®a, f, xeq, h'‚ü©, refine ‚ü®a, f, xeq.symm, _‚ü©, intros a' f' h'', rintros hu u ‚ü®j, h‚ÇÇ, hfi‚ü©, have hh : u ‚àà supp x a', by rw ‚Üêhfi; apply h', refine (mem_supp x _ u).mp hh _ _ hu, }
have : liftp (supp x) x
rw h
rw h
{ rw h, introv, exact id, }
{ rw h, introv, exact id, }
introv
introv
exact id
exact id
rw liftp_iff at this
rcases this with ‚ü®a, f, xeq, h'‚ü©
refine ‚ü®a, f, xeq.symm, _‚ü©
intros a' f' h''
rintros hu u ‚ü®j, h‚ÇÇ, hfi‚ü©
have hh : u ‚àà supp x a'
rw ‚Üêhfi
rw ‚Üêhfi
rw ‚Üêhfi; apply h'
rw ‚Üêhfi; apply h'
apply h'
apply h'
refine (mem_supp x _ u).mp hh _ _ hu
rintros ‚ü®a, f, xeq, h‚ü© p
rw liftp_iff
split
rintros ‚ü®a', f', xeq', h'‚ü© i u usuppx
{ rintros ‚ü®a', f', xeq', h'‚ü© i u usuppx, rcases (mem_supp x _ u).mp @usuppx a' f' xeq'.symm with ‚ü®i, _, f'ieq‚ü©, rw ‚Üêf'ieq, apply h' }
rcases (mem_supp x _ u).mp @usuppx a' f' xeq'.symm with ‚ü®i, _, f'ieq‚ü©
rw ‚Üêf'ieq
apply h'
intro h'
refine ‚ü®a, f, xeq.symm, _‚ü©
intros j y
apply h'
rw mem_supp
intros a' f' xeq'
apply h _ a' f' xeq'
apply mem_image_of_mem _ (mem_univ _)
intros
rw [‚Üê int.cast_coe_nat, ‚Üê mk_eq_div, num_denom]
intros
rw [‚Üê sub_nonneg, ‚Üê cast_sub, cast_nonneg, sub_nonneg]
intros
rw [sqrt, mul_self_num, mul_self_denom, int.sqrt_eq, nat.sqrt_eq, abs_def]
intros
rw [mul_comm, to_nnreal_mul_top]
norm_cast
intros
simpa only [bit1_zero] using @bit1_inj a 0
intros
simp [lt_top_iff_ne_top, not_or_distrib]
intros
norm_cast
pi_lower_bound [ 11482/8119, 7792/4217, 54055/27557, 949247/476920, 3310126/1657059, 2635492/1318143, 1580265/790192, 1221775/610899, 3612247/1806132, 849943/424972]
intros
rw [sqrt, sqrt, nnreal.coe_lt_coe, nnreal.sqrt_lt_sqrt_iff, to_nnreal_lt_to_nnreal_iff hy]
intros
ext x
simp [core, comp]
split
{ exact Œª h y rxy z, h z y rxy }
exact Œª h y rxy z, h z y rxy
{ exact Œª h z y rzy, h y rzy z }
exact Œª h z y rzy, h y rzy z
intros
refine ‚ü®swap (lift_rel R), h, Œª s t (h : lift_rel R t s), _‚ü©
rw [‚Üêlift_rel_o.swap, computation.lift_rel.swap]
apply lift_rel_destruct h
intros
revert s
induction n with n IH
induction n with n IH; intros s h
intros s h
rcases exists_of_mem_map h with ‚ü®o, h1, h2‚ü©
{ rcases exists_of_mem_map h with ‚ü®o, h1, h2‚ü©, cases o with o; injection h2 with h', cases o with a' s', exact (eq_or_mem_iff_mem h1).2 (or.inl h'.symm) }
cases o with o; injection h2 with h'
cases o with o
injection h2 with h'
injection h2 with h'
cases o with a' s'
exact (eq_or_mem_iff_mem h1).2 (or.inl h'.symm)
intros s h
have := @IH (tail s)
{ have := @IH (tail s), rw nth_tail at this, exact mem_of_mem_tail (this h) }
rw nth_tail at this
exact mem_of_mem_tail (this h)
intros
rw range_comp; apply image_subset_range
rw range_comp
apply image_subset_range
intros
apply preimage_subset_preimage_iff
{ apply preimage_subset_preimage_iff, rw [hf.range_eq], apply subset_univ }
rw [hf.range_eq]
apply subset_univ
intros
rw [image_swap_eq_preimage_swap, preimage_swap_prod]
intros
{ cases x, refl }
cases x
refl
intros
simp only [‚Üê subset_empty_iff]; exact union_subset_iff
simp only [‚Üê subset_empty_iff]
exact union_subset_iff
intros
rw ‚Üêrange_subset_iff at hf
{ rw ‚Üêrange_subset_iff at hf, exact (infinite_range_of_injective hi).mono hf }
exact (infinite_range_of_injective hi).mono hf
intros
rw [‚Üê finset.coe_subset, ht.coe_to_finset]
intros
ext x
rcases em (x ‚àà range f) with ‚ü®a, rfl‚ü©|hx
{ simp [left_inverse_inv_fun hf _, hf.mem_set_image] }
simp [left_inverse_inv_fun hf _, hf.mem_set_image]
{ simp [mem_preimage, inv_fun_neg hx, h, hx] }
simp [mem_preimage, inv_fun_neg hx, h, hx]
intros
rw [e.image_eq_preimage, e.symm.preimage_Iio, e.symm_symm]
intros
simp [‚Üê Ioi_inter_Iic]
intros
simp [‚Üê Ioi_inter_Iic, ‚Üê Ici_inter_Iio, inter_comm]
intros
simp [sub_eq_neg_add]
intros
convert image_mul_right_Icc' b c h using 1; simp only [mul_comm _ a]
convert image_mul_right_Icc' b c h using 1
{ convert image_mul_right_Icc' b c h using 1; simp only [mul_comm _ a] }
simp only [mul_comm _ a]
simp only [mul_comm _ a]
intros
classical
intros p hp
rcases h_surj p with ‚ü®x, rfl‚ü©
refine ‚ü®x, mem_Ioo.2 _, rfl‚ü©
by_contra h
cases not_and_distrib.mp h with ha hb
exact has_lt.lt.false (lt_of_lt_of_le hp.1 (h_mono (not_lt.mp ha)))
{ exact has_lt.lt.false (lt_of_lt_of_le hp.1 (h_mono (not_lt.mp ha))) }
exact has_lt.lt.false (lt_of_le_of_lt (h_mono (not_lt.mp hb)) hp.2)
{ exact has_lt.lt.false (lt_of_le_of_lt (h_mono (not_lt.mp hb)) hp.2) }
intros
simp only [‚Üê image_prod, prod_Union, image_Union]
intros
simp [‚Üê ne_empty_iff_nonempty]
intros
tidy
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
cases n
have : v = nil := by simp only [eq_iff_true_of_subsingleton]
{ have : v = nil := by simp only [eq_iff_true_of_subsingleton], simp only [this, scanl_nil, cons_head] }
simp only [this, scanl_nil, cons_head]
rw ‚Üêcons_head_tail v
{ rw ‚Üêcons_head_tail v, simp only [‚Üênth_zero, nth_eq_nth_le, to_list_scanl, to_list_cons, list.scanl, fin.val_zero', list.nth_le] }
simp only [‚Üênth_zero, nth_eq_nth_le, to_list_scanl, to_list_cons, list.scanl, fin.val_zero', list.nth_le]
intros
{ ext, simp [nth_tail], }
ext
simp [nth_tail]
intros
rw zmod.int_coe_eq_int_coe_iff
apply int.mod_modeq
intros
rw neg_val'
by_cases h : a = 0
rw [if_pos h, h, val_zero, nat.sub_zero, nat.mod_self]
{ rw [if_pos h, h, val_zero, nat.sub_zero, nat.mod_self] }
rw if_neg h
apply nat.mod_eq_of_lt
apply nat.sub_lt (fact.out (0 < n))
contrapose! h
rwa [nat.le_zero_iff, val_eq_zero] at h
intros
simp_rw [frequently_iff, omega_limit_def, mem_Inter, mem_closure_iff_nhds]
split
intros h _ hn _ hu
{ intros h _ hn _ hu, rcases h _ hu _ hn with ‚ü®_, _, _, _, ht, hx, hœïtx‚ü©, exact ‚ü®_, ht, _, hx, by rwa [mem_preimage, hœïtx]‚ü©, }
rcases h _ hu _ hn with ‚ü®_, _, _, _, ht, hx, hœïtx‚ü©
exact ‚ü®_, ht, _, hx, by rwa [mem_preimage, hœïtx]‚ü©
intros h _ hu _ hn
{ intros h _ hu _ hn, rcases h _ hn hu with ‚ü®_, ht, _, hx, hœïtx‚ü©, exact ‚ü®_, hœïtx, _, _, ht, hx, rfl‚ü© }
rcases h _ hn hu with ‚ü®_, ht, _, hx, hœïtx‚ü©
exact ‚ü®_, hœïtx, _, _, ht, hx, rfl‚ü©
intros
{ rw add_comm at hn, exact hn.left_of_add hm }
rw add_comm at hn
exact hn.left_of_add hm
intros
{ rw adjoin_eq_bot_iff, exact set.singleton_subset_iff }
rw adjoin_eq_bot_iff
exact set.singleton_subset_iff
intros
ext
{ ext, rw [mem_to_subalgebra, iff_true_right algebra.mem_top], exact mem_top }
rw [mem_to_subalgebra, iff_true_right algebra.mem_top]
exact mem_top
intros
simp only [frobenius_def]
cases x with n x
dsimp only
suffices : ‚àÄ p':‚Ñï, mk K p (n, x) ^ p' = mk K p (n, x ^ p')
{ apply this }
apply this
intro p
induction p with p ih
apply r.sound
case nat.zero { apply r.sound, rw [(frobenius _ _).iterate_map_one, pow_zero] }
rw [(frobenius _ _).iterate_map_one, pow_zero]
case nat.succ { rw [pow_succ, ih], symmetry, apply r.sound, simp only [pow_succ, (frobenius _ _).iterate_map_mul] }
rw [pow_succ, ih]
symmetry
apply r.sound
simp only [pow_succ, (frobenius _ _).iterate_map_mul]
intros
unfold angle
rw [real_inner_comm, mul_comm]
intros
refine ‚ü®Œª h, _, norm_sub_eq_add_norm_of_angle_eq_pi‚ü©
rw ‚Üê inner_eq_neg_mul_norm_iff_angle_eq_pi hx hy
obtain ‚ü®hxy‚ÇÅ, hxy‚ÇÇ‚ü© := ‚ü®norm_nonneg (x - y), add_nonneg (norm_nonneg x) (norm_nonneg y)‚ü©
rw [‚Üê sq_eq_sq hxy‚ÇÅ hxy‚ÇÇ, norm_sub_pow_two_real] at h
calc inner x y = (‚à•x‚à• ^ 2 + ‚à•y‚à• ^ 2 - (‚à•x‚à• + ‚à•y‚à•) ^ 2) / 2 : by linarith ... = -(‚à•x‚à• * ‚à•y‚à•) : by ring
intros
change orthogonal_projection_fn s p = orthogonal_projection_fn s' p
congr
exact h
intros
rcases exists_circumcenter_eq_of_cospherical hd hc with ‚ü®r, hr‚ü©
rw [hr sx‚ÇÅ hsx‚ÇÅ, hr sx‚ÇÇ hsx‚ÇÇ]
intros
rw [‚Üêto_derivation_eq_coe]; exact left_invariant'' X g
rw [‚Üêto_derivation_eq_coe]
exact left_invariant'' X g
intros
simp only [range_comp e, e.image_eq_preimage, preimage_preimage] with mfld_simps
intros
assume x hx
rcases h x hx with ‚ü®u, u_open, xu, hu‚ü©
have := hu x ‚ü®hx, xu‚ü©
rwa hG.lift_prop_within_at_inter at this
exact is_open.mem_nhds u_open xu
intros
simp only [mfderiv_within, h, dif_neg, not_false_iff]
intros
refine ‚ü®Œª h m hm, h.of_le hm, Œª h, _‚ü©
cases n
exact times_cont_mdiff_within_at_top.2 (Œª n, h n le_top)
{ exact times_cont_mdiff_within_at_top.2 (Œª n, h n le_top) }
{ exact h n (le_refl _) }
exact h n (le_refl _)
intros
simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]
intros
simp only [h, subgroup.closure_le]
intros
rw [mul_inv_right h, mul_assoc, mul_comm _ (f y‚ÇÇ), ‚Üêmul_assoc, mul_inv_left h, mul_comm x‚ÇÇ, f.map_mul, f.map_mul]
intros
rw nilpotent_iff_lower_central_series at *
rcases hH with ‚ü®n, hn‚ü©
refine ‚ü®n + 1, lower_central_series_succ_eq_bot (le_trans ((map_eq_bot_iff _).mp _) hf1)‚ü©
exact eq_bot_iff.mpr (hn ‚ñ∏ (lower_central_series.map f n))
intros
by_cases hx : x = 1
rw [‚Üêorder_of_eq_one_iff, h] at hx
{ rw [‚Üêorder_of_eq_one_iff, h] at hx, contradiction }
contradiction
rw [order_of_eq_zero_iff, is_of_fin_order_iff_pow_eq_one] at h
push_neg at h
induction n with n IH generalizing m
cases m
{ cases m, { simp }, { simpa [eq_comm] using h m.succ m.zero_lt_succ } }
{ simp }
simp
{ simpa [eq_comm] using h m.succ m.zero_lt_succ }
simpa [eq_comm] using h m.succ m.zero_lt_succ
cases m
{ cases m, { simpa using h n.succ n.zero_lt_succ }, { simp [pow_succ, IH] } }
{ simpa using h n.succ n.zero_lt_succ }
simpa using h n.succ n.zero_lt_succ
{ simp [pow_succ, IH] }
simp [pow_succ, IH]
intros
rw [nat.modeq_iff_dvd' œÉ.support·∂ú.card_le_univ, ‚Üêfinset.card_compl, compl_compl]
refine (congr_arg _ œÉ.sum_cycle_type).mp (multiset.dvd_sum (Œª k hk, _))
obtain ‚ü®m, -, hm‚ü© := (nat.dvd_prime_pow hp.out).mp (order_of_dvd_of_pow_eq_one hœÉ)
obtain ‚ü®l, -, rfl‚ü© := (nat.dvd_prime_pow hp.out).mp ((congr_arg _ hm).mp (dvd_of_mem_cycle_type hk))
exact dvd_pow_self _ (Œª h, (one_lt_of_mem_cycle_type hk).ne $ by rw [h, pow_zero])
intros
rw mem_cycle_factors_finset_iff at h
intro x
by_cases hx : f x = x
{ exact or.inr hx }
exact or.inr hx
refine or.inl _
{ refine or.inl _, rw [mul_apply, ‚Üêh.right, apply_inv_self], rwa [‚Üêsupport_inv, apply_mem_support, support_inv, mem_support] }
rw [mul_apply, ‚Üêh.right, apply_inv_self]
rwa [‚Üêsupport_inv, apply_mem_support, support_inv, mem_support]
intros
suffices : œÉ.is_cycle ‚Üí (œÉ ‚àà l ‚Üî ‚àÄ (a : Œ±) (h4 : œÉ a ‚â† a), œÉ a = l.prod a)
exact ‚ü®Œª hœÉ, ‚ü®h1 œÉ hœÉ, (this (h1 œÉ hœÉ)).mp hœÉ‚ü©, Œª hœÉ, (this hœÉ.1).mpr hœÉ.2‚ü©
{ exact ‚ü®Œª hœÉ, ‚ü®h1 œÉ hœÉ, (this (h1 œÉ hœÉ)).mp hœÉ‚ü©, Œª hœÉ, (this hœÉ.1).mpr hœÉ.2‚ü© }
intro h3
classical
split
intros h a ha
{ intros h a ha, exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha) }
exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)
intros h
{ intros h, have hœÉl : œÉ.support ‚äÜ l.prod.support, { intros x hx, rw mem_support at hx, rwa [mem_support, ‚Üêh _ hx] }, obtain ‚ü®a, ha, -‚ü© := id h3, rw ‚Üêmem_support at ha, obtain ‚ü®œÑ, hœÑ, hœÑa‚ü© := exists_mem_support_of_mem_support_prod (hœÉl ha), have hœÑl : ‚àÄ (x ‚àà œÑ.support), œÑ x = l.prod x := eq_on_support_mem_disjoint hœÑ h2, have key : ‚àÄ (x ‚àà œÉ.support ‚à© œÑ.support), œÉ x = œÑ x, { intros x hx, rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hœÑl x (mem_of_mem_inter_right hx)] }, convert hœÑ, refine h3.eq_on_support_inter_nonempty_congr (h1 _ hœÑ) key _ ha, exact key a (mem_inter_of_mem ha hœÑa) }
have hœÉl : œÉ.support ‚äÜ l.prod.support
intros x hx
{ intros x hx, rw mem_support at hx, rwa [mem_support, ‚Üêh _ hx] }
rw mem_support at hx
rwa [mem_support, ‚Üêh _ hx]
obtain ‚ü®a, ha, -‚ü© := id h3
rw ‚Üêmem_support at ha
obtain ‚ü®œÑ, hœÑ, hœÑa‚ü© := exists_mem_support_of_mem_support_prod (hœÉl ha)
have hœÑl : ‚àÄ (x ‚àà œÑ.support), œÑ x = l.prod x := eq_on_support_mem_disjoint hœÑ h2
have key : ‚àÄ (x ‚àà œÉ.support ‚à© œÑ.support), œÉ x = œÑ x
intros x hx
{ intros x hx, rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hœÑl x (mem_of_mem_inter_right hx)] }
rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hœÑl x (mem_of_mem_inter_right hx)]
convert hœÑ
refine h3.eq_on_support_inter_nonempty_congr (h1 _ hœÑ) key _ ha
exact key a (mem_inter_of_mem ha hœÑa)
intros
simp [equiv.perm.decompose_fin, equiv.perm_congr_def]
intros
simp only [swap_apply_def, mul_apply, f.injective.eq_iff] at *
by_cases h : f y = x
split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split; intro
split
{ split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at * }
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split_ifs at hy; cc
{ split_ifs at hy; cc }
split_ifs at hy
cc
cc
intros
simp [hxy]
intros
simp [right_hom]
intros
rw [general_commutator, general_commutator, monoid_hom.map_closure]
apply le_antisymm; apply closure_mono
apply le_antisymm
apply closure_mono
rintros _ ‚ü®x, ‚ü®p, hp, q, hq, rfl‚ü©, rfl‚ü©
{ rintros _ ‚ü®x, ‚ü®p, hp, q, hq, rfl‚ü©, rfl‚ü©, refine ‚ü®f p, mem_map.mpr ‚ü®p, hp, rfl‚ü©, f q, mem_map.mpr ‚ü®q, hq, rfl‚ü©, by simp *‚ü©, }
refine ‚ü®f p, mem_map.mpr ‚ü®p, hp, rfl‚ü©, f q, mem_map.mpr ‚ü®q, hq, rfl‚ü©, by simp *‚ü©
apply closure_mono
rintros x ‚ü®_, ‚ü®p, hp, rfl‚ü©, _, ‚ü®q, hq, rfl‚ü©, rfl‚ü©
{ rintros x ‚ü®_, ‚ü®p, hp, rfl‚ü©, _, ‚ü®q, hq, rfl‚ü©, rfl‚ü©, refine ‚ü®p * q * p‚Åª¬π * q‚Åª¬π, ‚ü®p, hp, q, hq, rfl‚ü©, by simp *‚ü©, }
refine ‚ü®p * q * p‚Åª¬π * q‚Åª¬π, ‚ü®p, hp, q, hq, rfl‚ü©, by simp *‚ü©
intros
split
introI h
{ introI h, exact ‚ü®is_simple_group.is_cyclic, is_simple_group.prime_card‚ü© }
exact ‚ü®is_simple_group.is_cyclic, is_simple_group.prime_card‚ü©
rintro ‚ü®hc, hp‚ü©
{ rintro ‚ü®hc, hp‚ü©, haveI : fact (fintype.card Œ±).prime := ‚ü®hp‚ü©, exact is_simple_group_of_prime_card rfl }
haveI : fact (fintype.card Œ±).prime := ‚ü®hp‚ü©
exact is_simple_group_of_prime_card rfl
intros
cases P; cases Q; congr'
cases P; cases Q
cases P
cases Q
congr'
intros
{ rw [comp_line_map], simp }
rw [comp_line_map]
simp
intros
ext p
have hq1 := set.mem_of_mem_inter_left hn.some_mem
have hq2 := set.mem_of_mem_inter_right hn.some_mem
split
intro hp
{ intro hp, rw ‚Üêvsub_vadd p hn.some, refine vadd_mem_of_mem_direction _ hq2, rw ‚Üêhd, exact vsub_mem_direction hp hq1 }
rw ‚Üêvsub_vadd p hn.some
refine vadd_mem_of_mem_direction _ hq2
rw ‚Üêhd
exact vsub_mem_direction hp hq1
intro hp
{ intro hp, rw ‚Üêvsub_vadd p hn.some, refine vadd_mem_of_mem_direction _ hq1, rw hd, exact vsub_mem_direction hp hq2 }
rw ‚Üêvsub_vadd p hn.some
refine vadd_mem_of_mem_direction _ hq1
rw hd
exact vsub_mem_direction hp hq2
intros
simp [weighted_vsub_apply]
intros
rw [face_points', set.range_comp, finset.range_order_emb_of_fin]
intros
rw [slope, smul_eq_zero, inv_eq_zero, sub_eq_zero, vsub_eq_zero_iff_eq] at h
exact h.elim (Œª h, h ‚ñ∏ rfl) eq.symm
intros
rw [f.map_span, span_le, set.image_subset_iff]
exact iff.rfl
intros
ext
ext; simp
simp
intros
{ rcases x with ‚ü®bi, ‚ü®i, rfl‚ü©‚ü©, exact b.reindex_range_self i, }
rcases x with ‚ü®bi, ‚ü®i, rfl‚ü©‚ü©
exact b.reindex_range_self i
ext1
dsimp only [alg_hom.comp_apply, subtype.coe_mk, alg_hom.id_apply]
rw [of_complex_I, to_complex_Œπ, one_smul]
intros
split
rintro ‚ü®hli, hspan‚ü©
{ rintro ‚ü®hli, hspan‚ü©, set v' := basis.mk hli hspan with v'_eq, rw e.det_apply, convert linear_equiv.is_unit_det (linear_equiv.refl _ _) v' e using 2, ext i j, simp }
set v' := basis.mk hli hspan with v'_eq
rw e.det_apply
convert linear_equiv.is_unit_det (linear_equiv.refl _ _) v' e using 2
ext i j
simp
intro h
{ intro h, rw [basis.det_apply, basis.to_matrix_eq_to_matrix_constr] at h, set v' := basis.map e (linear_equiv.of_is_unit_det h) with v'_def, have : ‚áë v' = v, { ext i, rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis] }, rw ‚Üê this, exact ‚ü®v'.linear_independent, v'.span_eq‚ü© }
rw [basis.det_apply, basis.to_matrix_eq_to_matrix_constr] at h
set v' := basis.map e (linear_equiv.of_is_unit_det h) with v'_def
have : ‚áë v' = v
ext i
{ ext i, rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis] }
rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis]
rw ‚Üê this
exact ‚ü®v'.linear_independent, v'.span_eq‚ü©
intros
have h := lift_dim_range_le (f.comp (submodule.subtype p))
rwa [linear_map.range_comp, range_subtype] at h
intros
rw ker_eq_bot'
intros m hm
simp_rw [linear_map.ext_iff, dual.eval_apply, zero_apply] at hm
exact (basis.forall_coord_eq_zero_iff _).mp (Œª i, hm (b.coord i))
intros
rcases (submodule.ne_bot_iff _).1 h with ‚ü®w, ‚ü®H, ne0‚ü©‚ü©
refine or.resolve_right (smul_eq_zero.1 _) ne0
simp [‚Üê aeval_apply_of_has_eigenvector ‚ü®H, ne0‚ü©, minpoly.aeval K f]
intros
obtain ‚ü®k, h_k_le, hk‚ü© : ‚àÉ k, k ‚â§ finrank K V ‚àß linear_map.ker (f ^ k) = linear_map.ker (f ^ k.succ) := exists_ker_pow_eq_ker_pow_succ f
calc (f ^ m).ker = (f ^ (k + (m - k))).ker : by rw nat.add_sub_of_le (h_k_le.trans hm) ... = (f ^ k).ker : by rw ker_pow_constant hk _ ... = (f ^ (k + (finrank K V - k))).ker : ker_pow_constant hk (finrank K V - k) ... = (f ^ finrank K V).ker : by rw nat.add_sub_of_le h_k_le
intros
simp only [set_like.le_def, mem_infi, mem_ker, mem_bot, lapply_apply]
exact assume a h, finsupp.ext h
intros
rw finsupp.total_apply; refl
rw finsupp.total_apply
refl
intros
rw [linear_independent.repr, linear_equiv.ker]
intros
ext
{ ext, simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.reindex_alg_equiv_apply, matrix.reindex_apply, matrix.minor_apply, function.comp_app, e.apply_symm_apply] }
simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.reindex_alg_equiv_apply, matrix.reindex_apply, matrix.minor_apply, function.comp_app, e.apply_symm_apply]
intros
ext m
rw [coeff_sub, coeff_C, mat_poly_equiv_coeff_apply, ring_hom.map_matrix_apply, matrix.map_apply, alg_hom.coe_to_ring_hom, dmatrix.sub_apply, coeff_X_pow]
by_cases hij : i = j
rw [hij, charmatrix_apply_eq, alg_hom.map_sub, expand_C, expand_X, coeff_sub, coeff_X_pow, coeff_C]
{ rw [hij, charmatrix_apply_eq, alg_hom.map_sub, expand_C, expand_X, coeff_sub, coeff_X_pow, coeff_C], split_ifs with mp m0; simp only [matrix.one_apply_eq, dmatrix.zero_apply] }
split_ifs with mp m0; simp only [matrix.one_apply_eq, dmatrix.zero_apply]
split_ifs with mp m0
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
rw [charmatrix_apply_ne _ _ _ hij, alg_hom.map_neg, expand_C, coeff_neg, coeff_C]
{ rw [charmatrix_apply_ne _ _ _ hij, alg_hom.map_neg, expand_C, coeff_neg, coeff_C], split_ifs with m0 mp; simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff] }
split_ifs with m0 mp; simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
split_ifs with m0 mp
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
intros
rw [‚Üêmatrix.mul_one (œÉ.to_pequiv.to_matrix : matrix n n R), pequiv.to_pequiv_mul_matrix, det_permute, det_one, mul_one]
intros
ext v j; simp [mul_vec_diagonal]
ext v j
simp [mul_vec_diagonal]
intros
by_cases h : is_unit A.det
{ rw [nonsing_inv_nonsing_inv _ h] }
rw [nonsing_inv_nonsing_inv _ h]
{ simp [nonsing_inv_apply_not_is_unit _ h] }
simp [nonsing_inv_apply_not_is_unit _ h]
intros
{ ext, simp }
ext
simp
intros
simp only [left_mul_matrix_apply, linear_map.to_matrix_apply, mul_comm, basis.smul_apply, basis.smul_repr, finsupp.smul_apply, algebra.lmul_apply, id.smul_eq_mul, linear_equiv.map_smul, mul_smul_comm]
intros
refine linear_map.ext _
refine Œª z, (pi_tensor_product.induction_on' z _ (Œª x y hx hy, by rw [œÜ‚ÇÅ.map_add, œÜ‚ÇÇ.map_add, hx, hy]))
intros r f
{ intros r f, rw [tprod_coeff_eq_smul_tprod, œÜ‚ÇÅ.map_smul, œÜ‚ÇÇ.map_smul], apply _root_.congr_arg, exact multilinear_map.congr_fun H f }
rw [tprod_coeff_eq_smul_tprod, œÜ‚ÇÅ.map_smul, œÜ‚ÇÇ.map_smul]
apply _root_.congr_arg
exact multilinear_map.congr_fun H f
intros
rw [‚Üê map_coprod_prod, coprod_inl_inr, map_id]
intros
induction n with n ih
simp only [tailings_zero]
{ simp only [tailings_zero], apply tailing_disjoint_tunnel_succ, }
apply tailing_disjoint_tunnel_succ
simp only [tailings_succ]
{ simp only [tailings_succ], refine disjoint.disjoint_sup_left_of_disjoint_sup_right _ _, apply tailing_disjoint_tunnel_succ, apply disjoint.mono_right _ ih, apply tailing_sup_tunnel_succ_le_tunnel, }
refine disjoint.disjoint_sup_left_of_disjoint_sup_right _ _
apply tailing_disjoint_tunnel_succ
apply disjoint.mono_right _ ih
apply tailing_sup_tunnel_succ_le_tunnel
intros
simp [polar]
intros
simp [discr, mul_left_comm, mul_comm]
intros
ext i j
refine fin.cases (by simp) (Œª i, _) i
refine fin.cases (by simp) (Œª j, _) j
simp [pow_succ]
intros
simp only [and.left_comm, and.comm]
intros
simp only [or_imp_distrib, forall_and_distrib, forall_eq]
intros
funext c
simp only [update]
by_cases h‚ÇÅ : c = b; by_cases h‚ÇÇ : c = a; try {simp [h‚ÇÅ, h‚ÇÇ]}
by_cases h‚ÇÅ : c = b; by_cases h‚ÇÇ : c = a
by_cases h‚ÇÅ : c = b
by_cases h‚ÇÇ : c = a
try {simp [h‚ÇÅ, h‚ÇÇ]}
cases h (h‚ÇÇ.symm.trans h‚ÇÅ)
try {simp [h‚ÇÅ, h‚ÇÇ]}
by_cases h‚ÇÇ : c = a
try {simp [h‚ÇÅ, h‚ÇÇ]}
try {simp [h‚ÇÅ, h‚ÇÇ]}
simp [h‚ÇÅ, h‚ÇÇ]
intros
classical; exact (function.update_injective (Œª i, classical.choice (inst i)) i').nontrivial
classical
exact (function.update_injective (Œª i, classical.choice (inst i)) i').nontrivial
intros
haveI : encodable s := hs.to_encodable
simp only [supr_subtype']
exact ae_measurable_supr (Œª i, hf i)
intros
rw [real_smul_def, ‚Üê smul_pos_part, dif_neg (not_le.2 hr), neg_neg_part]
{ rw [real_smul_def, ‚Üê smul_pos_part, dif_neg (not_le.2 hr), neg_neg_part] }
intros
refine (eq_singular_part 0 0 vector_measure.mutually_singular.zero_left _).symm
rw [zero_add, with_density·µ•_zero]
intros
rw [‚Üê comp_mk g hg f f.ae_measurable, mk_coe_fn]
intros
have h_ss : {a : Œ± | ¬¨‚àÄ (i : Œπ), ae_seq hf p i a = f i a} ‚äÜ (ae_seq_set hf p)·∂ú
from Œª x, mt (Œª hx i, (ae_seq_eq_fun_of_mem_ae_seq_set hf hx i))
exact measure_mono_null h_ss (measure_compl_ae_seq_set_eq_zero hf hp)
intros
ext1
ext1
refine (condexp_ind_ae_eq_condexp_ind_smul hm measurable_set.empty (by simp) x).trans _
rw condexp_ind_smul_empty
refine (Lp.coe_fn_zero G 2 Œº).trans _
refine eventually_eq.trans _ (Lp.coe_fn_zero G 1 Œº).symm
refl
intros
refine order_iso.limsup_apply g _ _ _ _
is_bounded_default
all_goals { is_bounded_default, }
is_bounded_default
is_bounded_default
is_bounded_default
intros
{ simp [Lp.norm_def, snorm, snorm'] }
simp [Lp.norm_def, snorm, snorm']
intros
by_cases hŒº0 : Œº = 0
rw [hŒº0, snorm_ess_sup_measure_zero, ennreal.coe_nonneg]
{ rw [hŒº0, snorm_ess_sup_measure_zero, ennreal.coe_nonneg], exact zero_le', }
exact zero_le'
exact (snorm_ess_sup_indicator_le s (Œª x, c)).trans (snorm_ess_sup_const c hŒº0).le
{ exact (snorm_ess_sup_indicator_le s (Œª x, c)).trans (snorm_ess_sup_const c hŒº0).le, }
intros
simp [snorm_ess_sup]
intros
rw [snorm', ennreal.rpow_eq_zero_iff] at h
cases h
rw lintegral_eq_zero_iff' (hf.ennnorm.pow_const q) at h
{ rw lintegral_eq_zero_iff' (hf.ennnorm.pow_const q) at h, refine h.left.mono (Œª x hx, _), rw [pi.zero_apply, ennreal.rpow_eq_zero_iff] at hx, cases hx, { cases hx with hx _, rwa [‚Üêennreal.coe_zero, ennreal.coe_eq_coe, nnnorm_eq_zero] at hx, }, { exact absurd hx.left ennreal.coe_ne_top, }, }
refine h.left.mono (Œª x hx, _)
rw [pi.zero_apply, ennreal.rpow_eq_zero_iff] at hx
cases hx
cases hx with hx _
{ cases hx with hx _, rwa [‚Üêennreal.coe_zero, ennreal.coe_eq_coe, nnnorm_eq_zero] at hx, }
rwa [‚Üêennreal.coe_zero, ennreal.coe_eq_coe, nnnorm_eq_zero] at hx
{ exact absurd hx.left ennreal.coe_ne_top, }
exact absurd hx.left ennreal.coe_ne_top
exfalso
{ exfalso, rw [one_div, inv_lt_zero] at h, exact hq0.not_lt h.right }
rw [one_div, inv_lt_zero] at h
exact hq0.not_lt h.right
intros
simpa [snorm_one_eq_lintegral_nnnorm] using tendsto_approx_on_Lp_snorm hf h‚ÇÄ one_ne_top hŒº (by simpa [snorm_one_eq_lintegral_nnnorm] using hi)
intros
simp_rw [integral_eq_lintegral_of_nonneg_ae hf hfi.1, ennreal.to_real_eq_zero_iff, lintegral_eq_zero_iff' (ennreal.measurable_of_real.comp_ae_measurable hfi.1), ‚Üê ennreal.not_lt_top, ‚Üê has_finite_integral_iff_of_real hf, hfi.2, not_true, or_false, ‚Üê hf.le_iff_eq, filter.eventually_eq, filter.eventually_le, (‚àò), pi.zero_apply, ennreal.of_real_eq_zero]
intros
{ ext1 x, simp_rw weighted_smul_apply, congr' 2, }
ext1 x
simp_rw weighted_smul_apply
congr' 2
intros
rw [tendsto_zero_iff_norm_tendsto_zero]
simp_rw [‚Üê coe_nnnorm, ‚Üê nnreal.coe_zero, nnreal.tendsto_coe, ‚Üê ennreal.tendsto_coe, ennreal.coe_zero]
exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds (tendsto_set_lintegral_zero (ne_of_lt hf) hs) (Œª i, zero_le _) (Œª i, ennnorm_integral_le_lintegral_ennnorm _)
intros
simpa only [zero_sub] using integral_comp_sub_left f 0
intros
have : ‚à´‚Åª a, f a ‚àÇŒº = ‚à´‚Åª a, hf.mk f a ‚àÇŒº := lintegral_congr_ae hf.ae_eq_mk
rw [this, lintegral_eq_zero_iff hf.measurable_mk]
exact ‚ü®Œª H, hf.ae_eq_mk.trans H, Œª H, hf.ae_eq_mk.symm.trans H‚ü©
intros
{ rw [add_eq_map‚ÇÇ], exact hf.map‚ÇÇ hg (zero_add 0) }
rw [add_eq_map‚ÇÇ]
exact hf.map‚ÇÇ hg (zero_add 0)
intros
rw set_to_fun_eq hT
simp only [integrable.to_L1_zero, continuous_linear_map.map_zero]
{ simp only [integrable.to_L1_zero, continuous_linear_map.map_zero], }
{ exact integrable_zero _ _ _, }
exact integrable_zero _ _ _
intros
rw bUnion_eq_Union
haveI := hs.to_encodable
exact measurable_set.Union (by simpa using h)
intros
rcases induced_outer_measure_exists_set _ _ Œº.inner_content_mono hA (ennreal.coe_ne_zero.2 hŒµ) with ‚ü®U, hU, h2U, h3U‚ü©
exact ‚ü®‚ü®U, hU‚ü©, h2U, h3U‚ü©
swap
exact Œº.inner_content_Union_nat
intros
simp only [prehaar, compacts.bot_val, index_empty, nat.cast_zero, zero_div]
{ simp only [prehaar, compacts.bot_val, index_empty, nat.cast_zero, zero_div] }
intros
simp [‚Üê measure_congr Iio_ae_eq_Iic]
intros
intros t ht
suffices : Œº (‚ãÉ i, t ‚à© s i) ‚â§ ‚àë' i, Œº (t ‚à© s i)
simpa [ht, inter_Union]
simpa [ht, inter_Union]
apply measure_Union_le
intros
by_cases a ‚àà s; simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
by_cases a ‚àà s
simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
intros
rw [‚Üê finset.sum_attach, finset.attach_eq_univ, ‚Üê tsum_fintype]
exact measure_bUnion_le s.countable_to_set f
intros
rcases eq_or_ne x 0 with rfl|h0
{ rw zero_smul, exact outer_regular.zero }
rw zero_smul
exact outer_regular.zero
refine ‚ü®Œª A hA r hr, _‚ü©
{ refine ‚ü®Œª A hA r hr, _‚ü©, rw [smul_apply, A.measure_eq_infi_is_open] at hr, simpa only [ennreal.mul_infi_of_ne h0 hx, gt_iff_lt, infi_lt_iff, exists_prop] using hr }
rw [smul_apply, A.measure_eq_infi_is_open] at hr
simpa only [ennreal.mul_infi_of_ne h0 hx, gt_iff_lt, infi_lt_iff, exists_prop] using hr
intros
rw [ennreal_to_measure, of_measurable_apply _ hs]
intros
have ha : 0 < a := lt_of_le_of_lt (absolute_value.nonneg _ _) hxy
by_cases hxy' : x = y
{ rwa hxy' }
rwa hxy'
by_cases hyz' : y = z
{ rwa ‚Üê hyz' }
rwa ‚Üê hyz'
by_cases hxz' : x = z
{ rwa [hxz', sub_self, absolute_value.map_zero] }
rwa [hxz', sub_self, absolute_value.map_zero]
rw [‚Üê ne.def, ‚Üê sub_ne_zero] at hxy' hyz' hxz'
refine lt_of_le_of_lt _ (max_lt hxy hyz)
rw [card_pow_degree_nonzero _ hxz', card_pow_degree_nonzero _ hxy', card_pow_degree_nonzero _ hyz']
have : (1 : ‚Ñ§) ‚â§ fintype.card Fq
exact_mod_cast (@fintype.one_lt_card Fq _ _).le
{ exact_mod_cast (@fintype.one_lt_card Fq _ _).le }
simp only [int.cast_pow, int.cast_coe_nat, le_max_iff]
refine or.imp (pow_le_pow this) (pow_le_pow this) _
rw [nat_degree_le_iff_degree_le, nat_degree_le_iff_degree_le, ‚Üê le_max_iff, ‚Üê degree_eq_nat_degree hxy', ‚Üê degree_eq_nat_degree hyz']
convert degree_add_le (x - y) (y - z) using 2
exact (sub_add_sub_cancel _ _ _).symm
intros
rw [mem_divisors, nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]
intros
simp [l_series_summable, summable_zero]
intros
dsimp [œâ, œâb]
ext
ext; simp; ring
ext; simp
simp
ring
simp
intros
simp [padic_norm]
intros
simp [ext]
intros
rcases nonneg_cases ha with ‚ü®x, y, rfl|rfl|rfl‚ü©
rcases nonneg_cases ha with ‚ü®x, y, rfl|rfl|rfl‚ü©; rcases nonneg_cases hb with ‚ü®z, w, rfl|rfl|rfl‚ü©; dsimp [add, nonneg] at ha hb ‚ä¢
rcases nonneg_cases ha with ‚ü®x, y, rfl|rfl|rfl‚ü©; rcases nonneg_cases hb with ‚ü®z, w, rfl|rfl|rfl‚ü©
rcases nonneg_cases hb with ‚ü®z, w, rfl|rfl|rfl‚ü©
dsimp [add, nonneg] at ha hb ‚ä¢
{ trivial }
trivial
dsimp [add, nonneg] at ha hb ‚ä¢
refine nonnegg_cases_right (Œªi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 hb))
{ refine nonnegg_cases_right (Œªi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 hb)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *]))) }, { apply nat.le_add_left } }
exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *])))
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *]))) }
{ apply nat.le_add_left }
apply nat.le_add_left
dsimp [add, nonneg] at ha hb ‚ä¢
refine nonnegg_cases_left (Œªi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 hb))
{ refine nonnegg_cases_left (Œªi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 hb)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *]))) }, { apply nat.le_add_left } }
exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *])))
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *]))) }
{ apply nat.le_add_left }
apply nat.le_add_left
rcases nonneg_cases hb with ‚ü®z, w, rfl|rfl|rfl‚ü©
dsimp [add, nonneg] at ha hb ‚ä¢
refine nonnegg_cases_right (Œªi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 ha))
{ refine nonnegg_cases_right (Œªi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 ha)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp *))) }, { apply nat.le_add_right } }
exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp *)))
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp *))) }
{ apply nat.le_add_right }
apply nat.le_add_right
dsimp [add, nonneg] at ha hb ‚ä¢
simpa [add_comm] using nonnegg_pos_neg.2 (sq_le_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))
{ simpa [add_comm] using nonnegg_pos_neg.2 (sq_le_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb)) }
dsimp [add, nonneg] at ha hb ‚ä¢
{ exact nonneg_add_lem ha hb }
exact nonneg_add_lem ha hb
rcases nonneg_cases hb with ‚ü®z, w, rfl|rfl|rfl‚ü©
dsimp [add, nonneg] at ha hb ‚ä¢
refine nonnegg_cases_left (Œªi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 ha))
{ refine nonnegg_cases_left (Œªi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 ha)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (int.le.intro h)) }, { apply nat.le_add_right } }
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (int.le.intro h)) }
exact int.coe_nat_le.1 (le_of_neg_le_neg (int.le.intro h))
{ apply nat.le_add_right }
apply nat.le_add_right
dsimp [add, nonneg] at ha hb ‚ä¢
rw [add_comm, add_comm ‚Üëy]
{ rw [add_comm, add_comm ‚Üëy], exact nonneg_add_lem hb ha }
exact nonneg_add_lem hb ha
dsimp [add, nonneg] at ha hb ‚ä¢
simpa [add_comm] using nonnegg_neg_pos.2 (sq_le_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))
{ simpa [add_comm] using nonnegg_neg_pos.2 (sq_le_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb)) }
intros
rw [sup_comm, sup_inf_sdiff]
intros
rw [‚Üêle_bot_iff, sdiff_le_iff, sup_bot_eq]
intros
rw [‚Üê sdiff_eq, sup_inf_sdiff _ _]
intros
simp only [Ici_inter_Iic.symm, subset_inter_iff, bdd_below_iff_subset_Ici, bdd_above_iff_subset_Iic, exists_and_distrib_left, exists_and_distrib_right]
intros
simp_rw [‚Üêset_like.mem_coe, ‚Üêset.singleton_subset_iff, ‚Üêl.le_iff_subset]
{ simp_rw [‚Üêset_like.mem_coe, ‚Üêset.singleton_subset_iff, ‚Üêl.le_iff_subset], exact ‚ü®Œª h S, h.trans, Œª h, h _ le_rfl‚ü© }
exact ‚ü®Œª h S, h.trans, Œª h, h _ le_rfl‚ü©
intros
rw [supr, bool.range_eq, Sup_pair, sup_comm]
intros
simp only [supr, hf.range_comp]
intros
{ rw ‚Üê Sup_image', exact is_lub_cSup (Hne.image _) H }
rw ‚Üê Sup_image'
exact is_lub_cSup (Hne.image _) H
intros
rw [sup'_eq_cSup_image s H, set.image_id]
intros
rw [‚Üê map_coe_Iio_at_bot a, tendsto_map'_iff]
intros
erw [h.filter_basis.mem_filter_iff]
simp only [mem_filter_basis_iff h, exists_prop]
split
rintros ‚ü®_, ‚ü®i, pi, rfl‚ü©, h‚ü©
{ rintros ‚ü®_, ‚ü®i, pi, rfl‚ü©, h‚ü©, tauto }
tauto
{ tauto }
tauto
intros
simp
intros
simp only [tendsto, le_inf_iff, iff_self]
intros
simp [filter.coprod]
intros
rcases em (‚àÉ y ‚àà s, ‚àÉ x, f y < x) with ‚ü®y, hys, x, hx‚ü©|not_all_top
have : finite {y | ¬¨x ‚â§ f y} := (filter.eventually_cofinite.mp (tendsto_at_top.1 hf x))
{ have : finite {y | ¬¨x ‚â§ f y} := (filter.eventually_cofinite.mp (tendsto_at_top.1 hf x)), simp only [not_le] at this, obtain ‚ü®a‚ÇÄ, ‚ü®ha‚ÇÄ : f a‚ÇÄ < x, ha‚ÇÄs‚ü©, others_bigger‚ü© := exists_min_image _ f (this.inter_of_left s) ‚ü®y, hx, hys‚ü©, refine ‚ü®a‚ÇÄ, ha‚ÇÄs, Œª a has, (lt_or_le (f a) x).elim _ (le_trans ha‚ÇÄ.le)‚ü©, exact Œª h, others_bigger a ‚ü®h, has‚ü© }
simp only [not_le] at this
obtain ‚ü®a‚ÇÄ, ‚ü®ha‚ÇÄ : f a‚ÇÄ < x, ha‚ÇÄs‚ü©, others_bigger‚ü© := exists_min_image _ f (this.inter_of_left s) ‚ü®y, hx, hys‚ü©
refine ‚ü®a‚ÇÄ, ha‚ÇÄs, Œª a has, (lt_or_le (f a) x).elim _ (le_trans ha‚ÇÄ.le)‚ü©
exact Œª h, others_bigger a ‚ü®h, has‚ü©
push_neg at not_all_top
{ push_neg at not_all_top, obtain ‚ü®a‚ÇÄ, ha‚ÇÄs‚ü© := hs, exact ‚ü®a‚ÇÄ, ha‚ÇÄs, Œª a ha, not_all_top a ha (f a‚ÇÄ)‚ü© }
obtain ‚ü®a‚ÇÄ, ha‚ÇÄs‚ü© := hs
exact ‚ü®a‚ÇÄ, ha‚ÇÄs, Œª a ha, not_all_top a ha (f a‚ÇÄ)‚ü©
intros
{ ext ‚ü®f‚ü© ‚ü®g‚ü©, exact coe_lt }
ext ‚ü®f‚ü© ‚ü®g‚ü©
exact coe_lt
intros
{ rw ‚Üê tendsto_iff_ptendsto, simp [principal_univ] }
rw ‚Üê tendsto_iff_ptendsto
simp [principal_univ]
intros
obtain ‚ü®a, ha‚ü© : ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I := ideal_Inter_nonempty.exists_all_mem
exact ‚ü®a, by simp [ha]‚ü©
intros
rw [sup_assoc, sup_idem]
intros
simp [is_cobounded, eq_univ_iff_forall, exists_true_iff_nonempty] {contextual := tt}
intros
ext n
induction n with n ih
{ refl }
refl
rw [partial_sups_succ, ih, sup_eq_right.2 (hf (nat.le_succ _))]
{ rw [partial_sups_succ, ih, sup_eq_right.2 (hf (nat.le_succ _))] }
intros
rw [symm_diff_comm, symm_diff_top]
intros
obtain ‚ü®a, b, h‚ü© := h
use [-a, b]
rwa neg_mul_neg
intros
rw irreducible_iff_uniformizer at ha hb
rw [‚Üêspan_singleton_eq_span_singleton, ‚Üêha, hb]
intros
suffices : of R M '' (‚ãÉ f ‚àà S, (f.support : set M)) = ‚ãÉ f ‚àà S, (of R M '' (f.support : set M))
rw this
{ rw this, exact support_gen_of_gen hS }
exact support_gen_of_gen hS
simp only [set.image_Union]
intros
rw [coe_one_eq_coe_submodule_top, coe_submodule_top]
intros
{ ext, simp }
ext
simp
intros
simp only [‚Üêideal_prod_equiv_symm_apply, ideal_prod_equiv.symm.injective.eq_iff, prod.mk.inj_iff]
intros
split_ifs with h h
{ simp [h, card_univ] }
simp [h, card_univ]
{ exact sum_hom_units_eq_zero f h }
exact sum_hom_units_eq_zero f h
intros
use Œª hI, ‚ü®{J : ideal R | I ‚â§ J ‚àß J.is_maximal}, ‚ü®Œª _ hJ, or.inl hJ.right, hI.symm‚ü©‚ü©
rintros ‚ü®M, hM, hInf‚ü©
refine le_antisymm (Œª x hx, _) le_jacobson
rw [hInf, mem_Inf]
intros I hI
cases hM I hI with is_max is_top
exact (mem_Inf.1 hx) ‚ü®le_Inf_iff.1 (le_of_eq hInf) I hI, is_max‚ü©
{ exact (mem_Inf.1 hx) ‚ü®le_Inf_iff.1 (le_of_eq hInf) I hI, is_max‚ü© }
{ exact is_top.symm ‚ñ∏ submodule.mem_top }
exact is_top.symm ‚ñ∏ submodule.mem_top
intros
rw [localization.mk_eq_mk', is_fraction_ring.mk'_eq_div]
intros
simp only [inv_fun, alg_hom.map_sum, std_basis_matrix, apply_ite ‚áë(algebra_map R A), mul_boole, to_fun_alg_hom_apply, ring_hom.map_zero, ring_hom.map_one]
convert finset.sum_product
apply matrix_eq_sum_std_basis
intros
rw [multiplicity_le_multiplicity_iff] at hle
rw [‚Üê nonpos_iff_eq_zero, ‚Üê not_lt, enat.pos_iff_one_le, ‚Üê nat.cast_one, ‚Üê pow_dvd_iff_le_multiplicity]
assume h
have := nat.dvd_gcd h (hle _ h)
rw [coprime.gcd_eq_one hab, nat.dvd_one, pow_one] at this
exact hp this
intros
rw [‚Üênormalize_content, normalize_eq_one, is_primitive]
simp_rw [‚Üêdvd_content_iff_C_dvd]
exact ‚ü®Œª h, h p.content (dvd_refl p.content), Œª h r hdvd, is_unit_of_dvd_unit hdvd h‚ü©
intros
apply map_injective (int.cast_ring_hom ‚ÑÇ) int.cast_injective
rw [h, (int_cyclotomic_spec n).1]
intros
rw_mod_cast [pochhammer_nat_eq_asc_factorial, nat.factorial_mul_asc_factorial]
intros
rw support_esymm''
congr
funext
exact finsupp.support_single_ne_zero one_ne_zero
intros
simp_rw [minpoly_gen, alg_hom.map_sub, alg_hom.map_sum, alg_hom.map_mul, alg_hom.map_pow, aeval_C, ‚Üê algebra.smul_def, aeval_X]
refine sub_eq_zero.mpr ((pb.basis.total_repr (pb.gen ^ pb.dim)).symm.trans _)
rw [finsupp.total_apply, finsupp.sum_fintype]
rw [finsupp.total_apply, finsupp.sum_fintype]; simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]
simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]
simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]
intros
ext
{ ext, simp [coeff_coe, power_series.coeff_monomial, polynomial.coeff_monomial, eq_comm] }
simp [coeff_coe, power_series.coeff_monomial, polynomial.coeff_monomial, eq_comm]
intros
rcases mul_eq_mul_prime_prod (Œª _ _, hp) (show x * y = a * (range n).prod (Œª _, p), by simpa) with ‚ü®t, u, b, c, htus, htu, rfl, rfl, rfl‚ü©
exact ‚ü®t.card, u.card, b, c, by rw [‚Üê card_disjoint_union htu, htus, card_range], by simp‚ü©
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
rw [trace_eq_zero_of_not_exists_basis, linear_map.zero_apply]
contrapose! hx
obtain ‚ü®s, ‚ü®b‚ü©‚ü© := hx
refine is_integral_of_mem_of_fg (K‚üÆx‚üØ).to_subalgebra _ x _
exact (submodule.fg_iff_finite_dimensional _).mpr (finite_dimensional.of_finset_basis b)
{ exact (submodule.fg_iff_finite_dimensional _).mpr (finite_dimensional.of_finset_basis b) }
{ exact subset_adjoin K _ (set.mem_singleton x) }
exact subset_adjoin K _ (set.mem_singleton x)
intros
dunfold has_mem.mem
dunfold factor_set_mem
split_ifs
refl
intros
rw ‚Üê padic_int.to_zmod_pow_eq_iff_ext
intro n
rw [‚Üê ring_hom.comp_assoc, to_padic_int, padic_int.lift_spec]
simp only [from_padic_int, to_zmod_pow, ring_hom.comp_id]
rw [ring_hom.comp_assoc, truncate_comp_lift, ‚Üê ring_hom.comp_assoc]
simp only [ring_equiv.symm_to_ring_hom_comp_to_ring_hom, ring_hom.id_comp]
intros
rw [frobenius_fun, coeff_mk]
intros
{ rw [‚Üêpos_iff_ne_zero, lt_succ], apply zero_le }
rw [‚Üêpos_iff_ne_zero, lt_succ]
apply zero_le
intros
rw [‚Üê succ_zero, succ_le]
intros
rw [aleph, ordinal.add_succ, aleph'_succ]; refl
rw [aleph, ordinal.add_succ, aleph'_succ]
refl
intros
rw [‚Üêord_lt_ord, h]
{ rw [‚Üêord_lt_ord, h], refine lt_of_le_of_lt (ord_card_le _) (typein_lt_type r x) }
refine lt_of_le_of_lt (ord_card_le _) (typein_lt_type r x)
intros
split
split; intro h
intro h
by_cases h' : b = 0
{ by_cases h' : b = 0, { rw [h', add_zero] at h, right, exact ‚ü®h', h‚ü© }, left, rw [‚Üêadd_sub_cancel a b], apply sub_is_limit h, suffices : a + 0 < a + b, simpa only [add_zero], rwa [add_lt_add_iff_left, ordinal.pos_iff_ne_zero] }
{ rw [h', add_zero] at h, right, exact ‚ü®h', h‚ü© }
rw [h', add_zero] at h
right
exact ‚ü®h', h‚ü©
left
rw [‚Üêadd_sub_cancel a b]
apply sub_is_limit h
suffices : a + 0 < a + b
simpa only [add_zero]
rwa [add_lt_add_iff_left, ordinal.pos_iff_ne_zero]
intro h
rcases h with h|‚ü®rfl, h‚ü©
exact add_is_limit a h
simpa only [add_zero]
intros
cases o; cases n; refl
cases o; cases n
cases o
cases n
refl
refl
cases n
refl
refl
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
cases n; refl
cases n
refl
refl
intros
apply mul_le_mul_of_nonneg_right; assumption
apply mul_le_mul_of_nonneg_right
assumption
assumption
intros
rwa zero_add
intros
simp [h‚ÇÇ.symm, h‚ÇÉ.symm, h‚ÇÅ.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]
simp [h‚ÇÇ.symm, h‚ÇÉ.symm, h‚ÇÅ.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]; cc
cc
intros
cc
intros
cc
intros
simpa only [zero_add] using dist_le_tsum_of_dist_le_of_tendsto d hf hd ha 0
intros
{ simp only [sub_eq_add_neg], exact hf.add hg.neg }
simp only [sub_eq_add_neg]
exact hf.add hg.neg
intros
ext
ext; simp [‚Üê continuous_linear_map.map_smul_of_tower]
simp [‚Üê continuous_linear_map.map_smul_of_tower]
intros
rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), ‚Üê range_comp, supr]
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Ioi _ _ _ _ (a‚Åª¬π)
intros
by_cases p; simp *
by_cases p
simp *
simp *
intros
convert nhds_basis_opens a
ext s
split
rintros ‚ü®s_in, s_op‚ü©
{ rintros ‚ü®s_in, s_op‚ü©, exact ‚ü®mem_of_mem_nhds s_in, s_op‚ü© }
exact ‚ü®mem_of_mem_nhds s_in, s_op‚ü©
rintros ‚ü®a_in, s_op‚ü©
{ rintros ‚ü®a_in, s_op‚ü©, exact ‚ü®is_open.mem_nhds s_op a_in, s_op‚ü© }
exact ‚ü®is_open.mem_nhds s_op a_in, s_op‚ü©
intros
obtain ‚ü®U, V, hU, hV, Ux, Vy, f, disj‚ü© := totally_separated_space.is_totally_separated_univ Œ± x (set.mem_univ x) y (set.mem_univ y) hxy
have clopen_U := is_clopen_inter_of_disjoint_cover_clopen (is_clopen_univ) f hU hV disj
rw set.univ_inter _ at clopen_U
rw [‚Üêset.subset_compl_iff_disjoint, set.subset_compl_comm] at disj
exact ‚ü®U, clopen_U, Ux, disj Vy‚ü©
intros
simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]
intros
constructor
erw induced_infi
congr' 1
funext
erw induced_compose
intros
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]; abel
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
cases le_total x y with h h
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
abel
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
intros
rw [closure_eq_self_union_frontier, inter_union_distrib_left, inter_union_distrib_left, ite_inter_self, ite_inter_of_inter_eq _ ht]
intros
rw [nhds_within_eq_map_subtype_coe a.coe_prop, mem_map, preimage_image_eq _ subtype.coe_injective, subtype.coe_eta]
intros
rcases continuous_on_iff_is_closed.1 hf t ht with ‚ü®u, hu‚ü©
rw [inter_comm, hu.2]
apply is_closed.inter hu.1 hs
intros
tauto
intros
refine le_of_tendsto (tendsto_const_nhds.edist ha) (mem_at_top_sets.2 ‚ü®n, Œª m hnm, _‚ü©)
refine le_trans (edist_le_Ico_sum_of_edist_le hnm (Œª k _ _, hf k)) _
rw [finset.sum_Ico_eq_sum_range]
exact sum_le_tsum _ (Œª _ _, zero_le _) ennreal.summable
intros
rw [‚Üê not_iff_not, not_not, not_summable_iff_tendsto_nat_at_top]
intros
change continuous_at ((Œª (p : ereal √ó ereal), p.2 + p.1) ‚àò prod.swap) (a, ‚ä§)
apply continuous_at.comp _ continuous_swap.continuous_at
simp_rw add_comm
exact continuous_at_add_top_coe a
intros
rw [real.ball_eq_Ioo, ‚Üê sub_div, add_comm, ‚Üê sub_add, add_sub_cancel', add_self_div_two, ‚Üê add_div, add_assoc, add_sub_cancel'_right, add_self_div_two]
intros
simp only [subtype_restr_def] with mfld_simps
intros
refine ‚ü®(e.continuous_at hx).tendsto.comp, Œª fe_cont, _‚ü©
rw [‚Üê continuous_within_at_inter' h] at fe_cont ‚ä¢
have : continuous_within_at (e.symm ‚àò (e ‚àò f)) (s ‚à© f ‚Åª¬π' e.source) x
have : continuous_within_at e.symm univ (e (f x)) := (e.continuous_at_symm (e.map_source hx)).continuous_within_at
{ have : continuous_within_at e.symm univ (e (f x)) := (e.continuous_at_symm (e.map_source hx)).continuous_within_at, exact continuous_within_at.comp this fe_cont (subset_univ _) }
exact continuous_within_at.comp this fe_cont (subset_univ _)
exact this.congr (Œªy hy, by simp [e.left_inv hy.2]) (by simp [e.left_inv hx])
intros
ext
rw coe_comap
{ simp only [h, coe_mk, function.comp_app] }
simp only [h, coe_mk, function.comp_app]
rw show f = Œª x, y, by ext; apply h
{ rw show f = Œª x, y, by ext; apply h, exact continuous_const }
exact continuous_const
intros
simpa only [sub_zero] using real.dist_le_of_mem_Icc hx hy
intros
rw [eq_comm, dist_eq_zero]
intros
rw [union_comm, ball_union_sphere]
intros
rw [‚Üê e.image_symm, e.symm.dimH_image]
intros
rw [Hausdorff_edist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]
intros
simp [Hausdorff_dist]
intros
rintros ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
simp only [function.uncurry, ennreal.coe_add, add_mul]
apply le_trans (edist_triangle _ (f a‚ÇÇ b‚ÇÅ) _)
exact add_le_add (le_trans (hŒ± _ _ _) $ ennreal.mul_left_mono $ le_max_left _ _) (le_trans (hŒ≤ _ _ _) $ ennreal.mul_left_mono $ le_max_right _ _)
intros
{ rw [‚Üêmem_coe], simp, }
rw [‚Üêmem_coe]
simp
intros
simp [lower_semicontinuous_within_at, lower_semicontinuous_at, nhds_within_univ]
intros
simp [coclosed_compact, cocompact, infi_and', and_iff_right_of_imp is_compact.is_closed]
intros
letI : topological_space Œ± := ‚ä•; exact ‚ü®‚ü®induced_topology_pure.symm‚ü©, dense_range_pure‚ü©
letI : topological_space Œ± := ‚ä•
exact ‚ü®‚ü®induced_topology_pure.symm‚ü©, dense_range_pure‚ü©
intros
refine (forall_ne_bot_le_iff _).trans _
rintro f g hle ‚ü®a, has, haf‚ü©
{ rintro f g hle ‚ü®a, has, haf‚ü©, exact ‚ü®a, has, haf.mono hle‚ü© }
exact ‚ü®a, has, haf.mono hle‚ü©
{ simp only [ultrafilter.cluster_pt_iff] }
simp only [ultrafilter.cluster_pt_iff]
intros
refine hs.compl_mem_sets (Œª a ha, _)
rcases hf a ha with ‚ü®t, ht, hst‚ü©
replace ht := mem_inf_principal.1 ht
apply mem_inf_of_inter ht hst
rintros x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© hs
exact h‚ÇÇ (h‚ÇÅ hs)
intros
casesI is_empty_or_nonempty Œπ
rw [infi_of_empty, infi_of_empty, to_topological_space_top]
{ rw [infi_of_empty, infi_of_empty, to_topological_space_top] }
refine (eq_of_nhds_eq_nhds $ assume a, _)
{ refine (eq_of_nhds_eq_nhds $ assume a, _), rw [nhds_infi, nhds_eq_uniformity], change (infi u).uniformity.lift' (preimage $ prod.mk a) = _, rw [infi_uniformity, lift'_infi], { simp only [nhds_eq_uniformity], refl }, { exact assume a b, rfl } }
rw [nhds_infi, nhds_eq_uniformity]
change (infi u).uniformity.lift' (preimage $ prod.mk a) = _
rw [infi_uniformity, lift'_infi]
{ simp only [nhds_eq_uniformity], refl }
simp only [nhds_eq_uniformity]
refl
{ exact assume a b, rfl }
exact assume a b, rfl
intros
unfold interleave corec_on
rw corec_eq
refl
intros
apply bind_ext_congr; intro a; cases a; simp [state_t.bind, state_t.run]
apply bind_ext_congr; intro a; cases a
apply bind_ext_congr; intro a
apply bind_ext_congr
intro a
cases a
simp [state_t.bind, state_t.run]
intros
cases a; simp
cases a
simp
simp
intros
have h := int.add_le_add_left h (-a)
rwa int.neg_add_cancel_left at h
intros
have h := int.lt_neg_add_of_add_lt (int.sub_left_lt_of_lt_add h)
rwa int.add_comm at h
intros
induction n with n IH
{ simp, cases bodd m; refl }
simp
cases bodd m
cases bodd m; refl
refl
refl
{ simp [mul_succ, IH], cases bodd m; cases bodd n; refl }
simp [mul_succ, IH]
cases bodd m
cases bodd m; cases bodd n; refl
cases bodd m; cases bodd n
cases bodd n
refl
refl
cases bodd n
refl
refl
intros
rw [nat.mul_comm, mul_div_right _ H]
intros
rw [sub_eq_sub_min, nat.sub_add_cancel (min_le_left n m)]
intros
tactic.mk_inj_eq
intros
simp only [algebra.lmul', tensor_product.lift.tmul, alg_hom.to_linear_map_apply, lmul_apply]
intros
simpa only [sub_eq_add_neg] using S.add_mem hx (S.neg_mem hy)
intros
simpa only [rat.cast_pos] using exists_rat_btwn x0
intros
{ convert (s.prod_piecewise t f f).symm, simp [finset.piecewise] }
convert (s.prod_piecewise t f f).symm
simp [finset.piecewise]
intros
haveI : unique Œ± := unique_of_subsingleton a
convert prod_unique f
intros
simp_rw [prod_subtype_eq_prod_filter, filter_true_of_mem h]
intros
rw finprod_mem_def
apply finprod_of_infinite_mul_support
rwa [‚Üê mul_support_mul_indicator] at hs
intros
classical
rcases Hlt with ‚ü®i, hi, hlt‚ü©
rw [‚Üê insert_erase hi, prod_insert (not_mem_erase _ _), prod_insert (not_mem_erase _ _)]
exact mul_lt_mul_of_lt_of_le hlt (prod_le_prod'' $ Œª j hj, Hle j $ mem_of_mem_erase hj)
intros
casesI hq
{ exact char_p.eq R hp infer_instance, }
exact char_p.eq R hp infer_instance
{ exact false.elim (char_p.char_ne_one R 1 rfl), }
exact false.elim (char_p.char_ne_one R 1 rfl)
intros
funext n
{ funext n, exact (int_fract_pair.coe_stream_nth_rat_eq v_eq_q n) }
exact (int_fract_pair.coe_stream_nth_rat_eq v_eq_q n)
intros
cases n
case nat.zero { change g.s.nth 0 = none at terminated_at_n, simp only [convergents', squash_gcf, convergents'_aux, terminated_at_n] }
change g.s.nth 0 = none at terminated_at_n
simp only [convergents', squash_gcf, convergents'_aux, terminated_at_n]
case nat.succ { cases g, simp [(squash_seq_eq_self_of_terminated terminated_at_n), squash_gcf] }
cases g
simp [(squash_seq_eq_self_of_terminated terminated_at_n), squash_gcf]
intros
simpa
intros
rw [from_add_monoid_of, add_monoid_hom.coe_comp]
intros
{ rw mul_comm, apply mul_right_dvd }
rw mul_comm
apply mul_right_dvd
intros
rw [xgcd, ‚Üê xgcd_aux_fst x y 1 0 0 1, prod.mk.eta]
intros
simpa using div_add_div b a one_ne_zero hc
intros
classical
apply s.induction_on
{ simp }
simp
intros b t hbt h
rw [gcd_insert, gcd_insert, h, ‚Üê gcd_mul_left]
apply ((normalize_associated a).mul_right _).gcd_eq_right
intros
simp [h]
intros
simp [h]
intros
rw [‚Üê add_sub_assoc, add_sub_cancel']
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
congr'
congr'; injection h
injection h
injection h
injection h
intros
induction m with m ih
{ rw [pow_zero, pow_zero, int.cast_one] }
rw [pow_zero, pow_zero, int.cast_one]
{ rw [pow_succ, pow_succ, int.cast_mul, ih] }
rw [pow_succ, pow_succ, int.cast_mul, ih]
intros
rw [‚Üê mul_one (a*d), mul_assoc, mul_comm d, ‚Üê mul_assoc, ‚Üê div_self hb, ‚Üê div_mul_eq_mul_div_comm, h, div_mul_eq_mul_div, div_mul_cancel _ hd]
intros
cases i; refl
{ cases i; refl, }
cases i
refl
refl
intros
dsimp [d_to]
rw h
refl
intros
dsimp [mk_hom, mk_hom_aux]
induction n; congr
induction n
congr
congr
intros
{ ext, simp, }
ext
simp
intros
simp only [mul_indicator]
{ simp only [mul_indicator], split_ifs with has has, exacts [ha has, h1] }
split_ifs with has has
exacts [ha has, h1]
intros
simp [sub_eq_add_neg]
intros
revert l
induction k with k ih
induction k with k ih; intros l h‚ÇÇ
intros l h‚ÇÇ
rw nat.le_zero_iff at h‚ÇÇ
{ rw nat.le_zero_iff at h‚ÇÇ, rw [h‚ÇÇ, derived_series_of_ideal_zero], exact h‚ÇÅ, }
rw [h‚ÇÇ, derived_series_of_ideal_zero]
exact h‚ÇÅ
intros l h‚ÇÇ
have h : l = k.succ ‚à® l ‚â§ k
{ have h : l = k.succ ‚à® l ‚â§ k, by rwa [le_iff_eq_or_lt, nat.lt_succ_iff] at h‚ÇÇ, cases h, { rw [h, derived_series_of_ideal_succ, derived_series_of_ideal_succ], exact lie_submodule.mono_lie _ _ _ _ (ih (le_refl k)) (ih (le_refl k)), }, { rw derived_series_of_ideal_succ, exact le_trans (lie_submodule.lie_le_left _ _) (ih h), }, }
rwa [le_iff_eq_or_lt, nat.lt_succ_iff] at h‚ÇÇ
rwa [le_iff_eq_or_lt, nat.lt_succ_iff] at h‚ÇÇ
cases h
rw [h, derived_series_of_ideal_succ, derived_series_of_ideal_succ]
{ rw [h, derived_series_of_ideal_succ, derived_series_of_ideal_succ], exact lie_submodule.mono_lie _ _ _ _ (ih (le_refl k)) (ih (le_refl k)), }
exact lie_submodule.mono_lie _ _ _ _ (ih (le_refl k)) (ih (le_refl k))
rw derived_series_of_ideal_succ
{ rw derived_series_of_ideal_succ, exact le_trans (lie_submodule.lie_le_left _ _) (ih h), }
exact le_trans (lie_submodule.lie_le_left _ _) (ih h)
intros
rw p.exists_lie_subalgebra_coe_eq_iff
split
split; intros h
intros h
intros x m hm
{ intros x m hm, rw [‚Üê h, mem_coe_submodule], exact lie_mem _ (subset_lie_span hm), }
rw [‚Üê h, mem_coe_submodule]
exact lie_mem _ (subset_lie_span hm)
intros h
rw [‚Üê coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq]
{ rw [‚Üê coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq], }
intros
rw p.exists_lie_submodule_coe_eq_iff L
split
split; intros h
intros h
intros x m hm
{ intros x m hm, rw [‚Üê h, mem_coe_submodule], exact lie_mem _ (subset_lie_span hm), }
rw [‚Üê h, mem_coe_submodule]
exact lie_mem _ (subset_lie_span hm)
intros h
rw [‚Üê coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq]
{ rw [‚Üê coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq], }
intros
rw ‚Üê lie_submodule.coe_to_submodule_eq_iff
{ rw ‚Üê lie_submodule.coe_to_submodule_eq_iff, exact submodule.comap_subtype_self _, }
exact submodule.comap_subtype_self _
intros
{ intros f g h, ext, exact linear_map.congr_fun h x }
intros f g h
ext
exact linear_map.congr_fun h x
intros
simp
intros
cases o‚ÇÅ; cases o‚ÇÇ; exact dec_trivial
cases o‚ÇÅ; cases o‚ÇÇ
cases o‚ÇÅ
cases o‚ÇÇ
exact dec_trivial
exact dec_trivial
exact dec_trivial
cases o‚ÇÇ
exact dec_trivial
exact dec_trivial
exact dec_trivial
cases o‚ÇÇ
exact dec_trivial
exact dec_trivial
exact dec_trivial
intros
rw [‚Üê one_div, div_le_iff_of_neg ha, ‚Üê div_eq_inv_mul, div_le_iff_of_neg hb, one_mul]
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, hb.ne, div_le_one_of_neg] }
simp [hb, hb.not_lt, hb.ne, div_le_one_of_neg]
{ simp [zero_le_one], }
simp [zero_le_one]
{ simp [hb, hb.not_lt, div_le_one, hb.ne.symm] }
simp [hb, hb.not_lt, div_le_one, hb.ne.symm]
intros
simp [division_def, mul_neg_iff]
intros
rw [‚Üê mul_le_mul_iff_left d, ‚Üê mul_le_mul_iff_right b, mul_inv_cancel_left, mul_assoc, inv_mul_cancel_right]
intros
rw [div_lt_iff_lt_mul, mul_comm]
intros
{ rw [mul_comm], exact self_le_mul_right a b }
rw [mul_comm]
exact self_le_mul_right a b
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioi]
split
rintro ‚ü®a_w, a_h_left, rfl‚ü©
{ rintro ‚ü®a_w, a_h_left, rfl‚ü©, exact (mul_le_mul_left hr).mpr a_h_left, }
exact (mul_le_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (le_div_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (le_div_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
nontriviality
calc 1 = 1 * 1 : by rw one_mul ... < a * b : decidable.mul_lt_mul ha hb zero_lt_one $ zero_le_one.trans ha.le
intros
simp_rw [zero_lt_iff, pow_ne_zero_iff hn]
intros
simpa only [inv_inv] using h.const_smul a‚Åª¬π
intros
induction n with n ih
rw pow_zero
{ rw pow_zero, exact subset.rfl }
exact subset.rfl
rw [pow_succ, pow_succ]
{ rw [pow_succ, pow_succ], exact mul_subset_mul hst ih }
exact mul_subset_mul hst ih
intros
rintro _ ‚ü®p, q, hp, hq, rfl‚ü©
{ rintro _ ‚ü®p, q, hp, hq, rfl‚ü©, exact submonoid.mul_mem _ (hs hp) (ht hq) }
exact submonoid.mul_mem _ (hs hp) (ht hq)
intros
induction l with hd tl IH
{ simp }
simp
simpa using nat_degree_mul_le.trans (add_le_add_left IH _)
{ simpa using nat_degree_mul_le.trans (add_le_add_left IH _) }
intros
{ rw ‚Üêleft_cancel x, simp }
rw ‚Üêleft_cancel x
simp
intros
refine ‚ü®_, is_left_regular.pow n‚ü©
rw [‚Üê nat.succ_pred_eq_of_pos n0, pow_succ']
exact is_left_regular.of_mul
intros
simp
intros
{ rw [‚Üê ring_hom.comp_apply, comp_eq], simp }
rw [‚Üê ring_hom.comp_apply, comp_eq]
simp
intros
{ dsimp [mk_ring_hom], rintro ‚ü®‚ü®‚ü©‚ü©, simp, }
dsimp [mk_ring_hom]
rintro ‚ü®‚ü®‚ü©‚ü©
simp
intros
rw [finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, multiset.map_map, finset.sum_eq_multiset_sum]
intros
split_ifs with h
split_ifs with h; simp [h]
{ split_ifs with h; simp [h] }
simp [h]
simp [h]
intros
rw [image_of_Df, set_of_exists (Œª i (x : prime_spectrum R), coeff f i ‚àâ x.val)]
exact is_open_Union (Œª i, is_open_basic_open)
intros
simpa using (gc R).u_top
intros
unfold is_o at *
intros c' c'pos
have : 0 < c' / c
from div_pos c'pos hc
exact (hfg.trans (hgk this) (le_of_lt hc)).congr_const (mul_div_cancel' _ (ne_of_gt hc))
intros
refine (is_O_with_const_const c _ l).congr_const _
{ rw [norm_one, div_one] }
rw [norm_one, div_one]
{ exact one_ne_zero }
exact one_ne_zero
intros
have := (hc.has_strict_fderiv_at.clm_comp hd.has_strict_fderiv_at).has_strict_deriv_at
rwa [add_apply, comp_apply, comp_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw fderiv_within_inter ht hs }
unfold deriv_within
rw fderiv_within_inter ht hs
intros
simp only [has_strict_fderiv_at, continuous_linear_map.coe_pi]
exact is_o_pi
intros
simpa only [smul_zero, zero_add] using hc.smul (has_strict_fderiv_at_const f x)
intros
rw [‚Üê differentiable_within_at_univ, ‚Üê fderiv_within_univ]
exact differentiable_within_at_iff_restrict_scalars ùïú hf.differentiable_within_at unique_diff_within_at_univ
intros
rw differentiable_at.fderiv_within (differentiable_at_id) hxs
exact fderiv_id
intros
simp only [implicit_to_local_homeomorph_of_complemented_apply, add_sub_cancel, classical.some_spec hker]
intros
rw eventually_iff_exists_mem at *
rcases hff' with ‚ü®s‚ÇÅ, hs‚ÇÅ, hff'‚ü©
rcases hgg' with ‚ü®s‚ÇÇ, hs‚ÇÇ, hgg'‚ü©
rcases hg' with ‚ü®s‚ÇÉ, hs‚ÇÉ, hg'‚ü©
let s := s‚ÇÅ ‚à© s‚ÇÇ ‚à© s‚ÇÉ
have hs : s ‚àà at_top := inter_mem (inter_mem hs‚ÇÅ hs‚ÇÇ) hs‚ÇÉ
rw mem_at_top_sets at hs
rcases hs with ‚ü®l, hl‚ü©
have hl' : Ioi l ‚äÜ s := Œª x hx, hl x (le_of_lt hx)
refine lhopital_zero_at_top_on_Ioi _ _ (Œª x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv
refine lhopital_zero_at_top_on_Ioi _ _ (Œª x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv; intros x hx; apply_assumption; exact (hl' hx).1.1 <|> exact (hl' hx).1.2
refine lhopital_zero_at_top_on_Ioi _ _ (Œª x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv; intros x hx; apply_assumption
refine lhopital_zero_at_top_on_Ioi _ _ (Œª x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv; intros x hx
intros x hx
apply_assumption
exact (hl' hx).1.1
intros x hx
apply_assumption
exact (hl' hx).1.2
exact (hl' hx).1.1
intros
rw ‚Üê f_aux_zero_eq
apply times_cont_diff_of_differentiable_iterated_deriv (Œª m hm, _)
rw f_aux_iterated_deriv m
exact Œª x, (f_aux_has_deriv_at m x).differentiable_at
intros
rw [‚Üê times_cont_diff_within_at_univ] at *; exact hf.mul hg
rw [‚Üê times_cont_diff_within_at_univ] at *
exact hf.mul hg
intros
assume m hm
rcases h m hm with ‚ü®u, hu, p, H‚ü©
exact ‚ü®u, nhds_within_le_of_mem (insert_mem_nhds_within_insert hst) hu, p, H‚ü©
simpa [mul_self_abs] using tendsto_abs_cocompact_at_top.at_top_mul_at_top tendsto_abs_cocompact_at_top
intros
rw ‚Üêopen_segment_eq_Ioo h
simp_rw [‚Üêexists_prop]
refl
intros
split
rintro ‚ü®hconv, h‚ü©
{ rintro ‚ü®hconv, h‚ü©, refine ‚ü®hconv, Œª x y hx hy a b ha hb hab, _‚ü©, simp [neg_apply, neg_le, add_comm] at h, exact h hx hy ha hb hab }
refine ‚ü®hconv, Œª x y hx hy a b ha hb hab, _‚ü©
simp [neg_apply, neg_le, add_comm] at h
exact h hx hy ha hb hab
rintro ‚ü®hconv, h‚ü©
{ rintro ‚ü®hconv, h‚ü©, refine ‚ü®hconv, Œª x y hx hy a b ha hb hab, _‚ü©, rw ‚Üêneg_le_neg_iff, simp_rw [neg_add, pi.neg_apply, smul_neg, neg_neg], exact h hx hy ha hb hab }
refine ‚ü®hconv, Œª x y hx hy a b ha hb hab, _‚ü©
rw ‚Üêneg_le_neg_iff
simp_rw [neg_add, pi.neg_apply, smul_neg, neg_neg]
exact h hx hy ha hb hab
intros
rw [‚Üêinner_conj_sym, inner_add_left, ring_hom.map_add]
rw [‚Üêinner_conj_sym, inner_add_left, ring_hom.map_add]; simp only [inner_conj_sym]
simp only [inner_conj_sym]
intros
simp only [inner_zero_right, add_monoid_hom.map_zero]
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
convert submodule.finrank_add_inf_finrank_orthogonal (le_top : K ‚â§ ‚ä§) using 1
{ rw inf_top_eq }
rw inf_top_eq
{ simp }
simp
intros
simp only [‚Üê dist_zero_right, dist_pi_lt_iff hr, pi.zero_apply]
intros
{ rw norm_sub_rev, exact norm_le_insert v u }
rw norm_sub_rev
exact norm_le_insert v u
intros
rw [edist_dist, dist_eq_norm, of_real_norm_eq_coe_nnnorm]
intros
{ ext, refl }
ext
refl
intros
simp only [eventually_iff, metric.mem_nhds_iff]
use [1, by norm_num]
intros t ht
simp only [mem_ball, dist_zero_right] at ht
simp only [inverse_one_sub t ht, set.mem_set_of_eq]
have h : 1 = ((range n).sum (Œª i, t ^ i)) * (units.one_sub t ht) + t ^ n
simp only [units.coe_one_sub]
{ simp only [units.coe_one_sub], rw [‚Üê geom_sum, geom_sum_mul_neg], simp }
rw [‚Üê geom_sum, geom_sum_mul_neg]
simp
rw [‚Üê one_mul ‚Üë(units.one_sub t ht)‚Åª¬π, h, add_mul]
congr
rw [mul_assoc, (units.one_sub t ht).mul_inv]
{ rw [mul_assoc, (units.one_sub t ht).mul_inv], simp }
simp
simp only [units.coe_one_sub]
{ simp only [units.coe_one_sub], rw [‚Üê add_mul, ‚Üê geom_sum, geom_sum_mul_neg], simp }
rw [‚Üê add_mul, ‚Üê geom_sum, geom_sum_mul_neg]
simp
intros
rw [norm_eq_sqrt_real_inner, inner_self, norm_sq_coe, real.sqrt_sq_eq_abs, real.norm_eq_abs]
intros
simp only [bernstein_apply]
exact mul_nonneg (mul_nonneg (nat.cast_nonneg _) (pow_nonneg (by unit_interval) _)) (pow_nonneg (by unit_interval) _)
intros
simp [log]
intros
rw [log_of_ne_zero hx, ‚Üê coe_exp_order_iso_apply, order_iso.apply_symm_apply, subtype.coe_mk]
intros
simpa using integral_sin_pow_mul_cos_pow_odd 2 0
convert tendsto_rpow_div_mul_add (1:‚Ñù) _ (0:‚Ñù) zero_ne_one
{ convert tendsto_rpow_div_mul_add (1:‚Ñù) _ (0:‚Ñù) zero_ne_one, ring_nf }
ring_nf
intros
rw ‚Üê abs_cpow_real; simp [-abs_cpow_real]
rw ‚Üê abs_cpow_real
simp [-abs_cpow_real]
intros
convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz
{ convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
intros
simpa only [cos_zero] using (cos_periodic.int_mul n).sub_antiperiod_eq cos_antiperiodic
simp
intros
rw [arcsin, function.comp_app, Icc_extend_coe, function.comp_app, Icc_extend]
intros
obtain ‚ü®g, hg‚ü© := cokernel_cofork.is_colimit.desc' is_colimit_œÉ (limits.prod.map f f ‚â´ œÉ) (by simp)
suffices hfg : f = g
{ rw [‚Üêhg, cofork.œÄ_of_œÄ, hfg] }
rw [‚Üêhg, cofork.œÄ_of_œÄ, hfg]
calc f = f ‚â´ prod.lift (ùüô Y) 0 ‚â´ œÉ : by rw [lift_œÉ, category.comp_id] ... = prod.lift (ùüô X) 0 ‚â´ limits.prod.map f f ‚â´ œÉ : by rw lift_map_assoc ... = prod.lift (ùüô X) 0 ‚â´ œÉ ‚â´ g : by rw [‚Üêhg, cokernel_cofork.œÄ_of_œÄ] ... = g : by rw [‚Üêcategory.assoc, lift_œÉ, category.id_comp]
intros
rw [hom_equiv_counit, F.map_comp, assoc, adj.hom_equiv_counit.symm]
intros
{ substI h, exact mono_of_mono f g, }
substI h
exact mono_of_mono f g
intros
{ cases q, simp, }
cases q
simp
intros
apply (cancel_epi f.hom).mp
simp [hom_inv_id]
intros
{ rw ‚Üê c.œÄ.naturality f, apply id_comp }
rw ‚Üê c.œÄ.naturality f
apply id_comp
intros
dsimp [limit_obj_iso_limit_comp_evaluation]
simp
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
simp
intros
tidy
intros
let y' : punit ‚ü∂ Y := Œª _, y
have hy' : y' ‚â´ g = y' ‚â´ h := funext (Œª _, hy)
refine ‚ü®(fork.is_limit.lift' t _ hy').1 ‚ü®‚ü©, congr_fun (fork.is_limit.lift' t y' _).2 ‚ü®‚ü©, _‚ü©
intros x' hx'
suffices : (Œª (_ : punit), x') = (fork.is_limit.lift' t y' hy').1
rw ‚Üê this
apply fork.is_limit.hom_ext t
ext ‚ü®‚ü©
apply hx'.trans (congr_fun (fork.is_limit.lift' t _ hy').2 ‚ü®‚ü©).symm
intros
suffices : (Œª (x : t.X), ulift.up (‚àÉ j y, t.Œπ.app j y = x)) = (Œª _, ulift.up true)
have := congr_fun this x
{ have := congr_fun this x, have H := congr_arg ulift.down this, dsimp at H, rwa eq_true at H }
have H := congr_arg ulift.down this
dsimp at H
rwa eq_true at H
refine h.hom_ext _
intro j
ext y
erw iff_true
exact ‚ü®j, y, rfl‚ü©
intros
{ rw [‚Üêtensor_comp], simp }
rw [‚Üêtensor_comp]
simp
intros
{ rw ‚Üêpentagon W X Y Z, simp }
rw ‚Üêpentagon W X Y Z
simp
intros
{ ext, rw ‚Üênat_trans.comp_app, simp, }
ext
rw ‚Üênat_trans.comp_app
simp
intros
simp [covers_iff]
intros
split
intros PJ X R hR
{ intros PJ X R hR, rw is_sheaf_for_iff_generate, apply PJ (sieve.generate R) ‚ü®_, hR, le_generate R‚ü© }
rw is_sheaf_for_iff_generate
apply PJ (sieve.generate R) ‚ü®_, hR, le_generate R‚ü©
rintro PK X S ‚ü®R, hR, RS‚ü©
{ rintro PK X S ‚ü®R, hR, RS‚ü©, have gRS : ‚áë(generate R) ‚â§ S, { apply gi_generate.gc.monotone_u, rwa sets_iff_generate }, apply is_sheaf_for_subsieve P gRS _, intros Y f, rw [‚Üê pullback_arrows_comm, ‚Üê is_sheaf_for_iff_generate], exact PK (pullback_arrows f R) (K.pullbacks f R hR) }
have gRS : ‚áë(generate R) ‚â§ S
apply gi_generate.gc.monotone_u
{ apply gi_generate.gc.monotone_u, rwa sets_iff_generate }
rwa sets_iff_generate
apply is_sheaf_for_subsieve P gRS _
intros Y f
rw [‚Üê pullback_arrows_comm, ‚Üê is_sheaf_for_iff_generate]
exact PK (pullback_arrows f R) (K.pullbacks f R hR)
intros
ext
simp only [functor_inclusion_app, sieve_of_subfunctor_apply, subtype.val_eq_coe]
split
rintro ‚ü®‚ü®f, hf‚ü©, rfl‚ü©
{ rintro ‚ü®‚ü®f, hf‚ü©, rfl‚ü©, exact hf }
exact hf
intro hf
{ intro hf, exact ‚ü®‚ü®_, hf‚ü©, rfl‚ü© }
exact ‚ü®‚ü®_, hf‚ü©, rfl‚ü©
intros
apply quotient.induction_on' x
intro t
apply quotient.sound
refine ‚ü®(mono_over.pullback_comp _ _).app t‚ü©
intros
{ simp [kernel_subobject_iso_comp], }
simp [kernel_subobject_iso_comp]
intros
simp [types_id]
intros
simp only [lt_def, mem_singleton, ‚Üêand_assoc, exists_eq_right]
split
intros t x hx
{ intros t x hx, rw ‚Üênot_le, intro h, rcases lt_or_eq_of_le h with h‚ÇÅ | rfl, { exact ne_of_irrefl h‚ÇÅ ((t.1 h‚ÇÅ).1 hx).symm }, { exact t.2 hx } }
rw ‚Üênot_le
intro h
rcases lt_or_eq_of_le h with h‚ÇÅ | rfl
{ exact ne_of_irrefl h‚ÇÅ ((t.1 h‚ÇÅ).1 hx).symm }
exact ne_of_irrefl h‚ÇÅ ((t.1 h‚ÇÅ).1 hx).symm
{ exact t.2 hx }
exact t.2 hx
exact Œª h, ‚ü®Œª z hz, ‚ü®Œª i, (asymm hz (h _ i)).elim, Œª i, (hz.ne' i).elim‚ü©, by simpa using h r‚ü©
{ exact Œª h, ‚ü®Œª z hz, ‚ü®Œª i, (asymm hz (h _ i)).elim, Œª i, (hz.ne' i).elim‚ü©, by simpa using h r‚ü© }
intros
rw [boundary, finset.order_emb_of_fin_zero rfl c.card_boundaries_pos]
exact le_antisymm (finset.min'_le _ _ c.zero_mem) (fin.zero_le _)
intros
simp_rw [line.apply, line.diagonal, option.get_or_else_none]
intros
ext v w
cases h.zero_or_one v w with h h; by_cases hvw : v = w; simp [matrix.compl, h, hvw]
cases h.zero_or_one v w with h h; by_cases hvw : v = w
cases h.zero_or_one v w with h h
by_cases hvw : v = w
simp [matrix.compl, h, hvw]
simp [matrix.compl, h, hvw]
by_cases hvw : v = w
simp [matrix.compl, h, hvw]
simp [matrix.compl, h, hvw]
intros
ext w
have h := @ne_of_adj _ G
simp_rw [set.mem_union, mem_neighbor_set, compl_adj, set.mem_compl_eq, set.mem_singleton_iff]
tauto
intros
conv {to_lhs, rw [‚Üê list_blank.cons_head_tail l]}
exact quotient.induction_on' l (Œª a, rfl)
intros
{ cases Œ∑, cases Œ∑', congr, exact h }
cases Œ∑
cases Œ∑'
congr
exact h
intros
ext
ext; simp [naturality]
simp [naturality]
intros
cases b; simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ‚Üêtwo_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]; norm_num
cases b; simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ‚Üêtwo_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]
cases b
simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ‚Üêtwo_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]
simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ‚Üêtwo_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]
norm_num
intros
induction l with hd tl hl generalizing b i
{ exact absurd i.zero_le (not_le_of_lt h) }
exact absurd i.zero_le (not_le_of_lt h)
convert_to ((b.push_back hd).append_list tl).read _ = _
{ convert_to ((b.push_back hd).append_list tl).read _ = _, cases i, { convert read_append_list_left _ _ _; simp }, { rw [list.length, nat.succ_lt_succ_iff] at h, have : b.size + i.succ = (b.push_back hd).size + i, { simp [add_comm, add_left_comm, nat.succ_eq_add_one] }, convert hl (b.push_back hd) h using 1, simpa [nat.add_succ, nat.succ_add] } }
cases i
convert read_append_list_left _ _ _; simp
convert read_append_list_left _ _ _
{ convert read_append_list_left _ _ _; simp }
simp
simp
rw [list.length, nat.succ_lt_succ_iff] at h
{ rw [list.length, nat.succ_lt_succ_iff] at h, have : b.size + i.succ = (b.push_back hd).size + i, { simp [add_comm, add_left_comm, nat.succ_eq_add_one] }, convert hl (b.push_back hd) h using 1, simpa [nat.add_succ, nat.succ_add] }
have : b.size + i.succ = (b.push_back hd).size + i
simp [add_comm, add_left_comm, nat.succ_eq_add_one]
{ simp [add_comm, add_left_comm, nat.succ_eq_add_one] }
convert hl (b.push_back hd) h using 1
simpa [nat.add_succ, nat.succ_add]
intros
simp only [map_const_eq, map_eq_fail]
intros
simp_rw [any_char]
split_ifs with h; simp [h, eq_comm]
split_ifs with h
simp [h, eq_comm]
simp [h, eq_comm]
intros
simp [many1, seq_eq_done]
intros
rw [inv_def, ‚Üê mul_assoc, mul_conj, ‚Üê of_real_mul, mul_inv_cancel (mt norm_sq_eq_zero.1 h), of_real_one]
intros
simp [le_def]
intros
have hxc : complex.abs x ‚â§ 1
exact_mod_cast hx
exact_mod_cast hx
convert exp_bound hxc hn; norm_cast
convert exp_bound hxc hn
norm_cast
norm_cast
intros
have h1 : x + 2 * x = 3 * x
ring
ring
rw [‚Üê h1, cosh_add x (2 * x)]
simp only [cosh_two_mul, sinh_two_mul]
have h2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2
ring
ring
rw [h2, sinh_sq]
ring
intros
rw algebra.smul_def
{ rw algebra.smul_def, apply of_real_mul_im }
apply of_real_mul_im
intros
by_cases h : (I : K) = 0; field_simp [h]
{ by_cases h : (I : K) = 0; field_simp [h] }
by_cases h : (I : K) = 0
field_simp [h]
field_simp [h]
intros
{ ext, simp only [map_range_apply, id.def] }
ext
simp only [map_range_apply, id.def]
intros
{ ext, simp }
ext
simp
intros
rw [swap_eq_update, comp_update, comp_update, comp.right_id]
intros
simp [perm.subtype_congr.apply, h]
intros
{ cases k, refl, }
cases k
refl
intros
simp only [‚Üê image_source_eq_target, ‚Üê h.source_eq, h.2.image_eq]
intros
rw [succ_above_above, succ_pred]
{ rw [succ_above_above, succ_pred], simpa [le_iff_coe_le_coe] using nat.le_pred_of_lt h }
simpa [le_iff_coe_le_coe] using nat.le_pred_of_lt h
intros
ext y
simp only [set.mem_range, set.mem_insert_iff]
split
rintros ‚ü®i, rfl‚ü©
{ rintros ‚ü®i, rfl‚ü©, refine cases (or.inl (cons_zero _ _)) (Œª i, or.inr ‚ü®i, _‚ü©) i, rw cons_succ }
refine cases (or.inl (cons_zero _ _)) (Œª i, or.inr ‚ü®i, _‚ü©) i
rw cons_succ
rintros (rfl | ‚ü®i, hi‚ü©)
{ rintros (rfl | ‚ü®i, hi‚ü©), { exact ‚ü®0, fin.cons_zero _ _‚ü© }, { refine ‚ü®i.succ, _‚ü©, rw [cons_succ, hi] } }
{ exact ‚ü®0, fin.cons_zero _ _‚ü© }
exact ‚ü®0, fin.cons_zero _ _‚ü©
refine ‚ü®i.succ, _‚ü©
{ refine ‚ü®i.succ, _‚ü©, rw [cons_succ, hi] }
rw [cons_succ, hi]
intros
cases s
cases s; refl
refl
intros
simp only [insert_eq, image_singleton, image_union]
intros
rw strong_induction
intros
simp only [‚Üêfinset.coe_subset, set.not_subset, exists_prop, finset.mem_coe]
intros
rw [‚Üê coe_empty, coe_inj]
intros
simp only [insert_union, union_insert, insert_idem]
intros
{ dunfold fold, rw [cons_val, map_cons, fold_cons_left], }
dunfold fold
rw [cons_val, map_cons, fold_cons_left]
intros
classical
induction s using finset.induction_on with a s' ha ih
induction s using finset.induction_on with a s' ha ih; simp *
simp *
simp *
intros
ext
simp only [exists_prop, mem_map, mem_antidiagonal, prod.exists]
rw add_comm
split
rintro ‚ü®b, c, ‚ü®rfl, rfl‚ü©‚ü©
{ rintro ‚ü®b, c, ‚ü®rfl, rfl‚ü©‚ü©, simp }
simp
rintro rfl
{ rintro rfl, use [a.snd, a.fst], simp }
use [a.snd, a.fst]
simp
intros
{ ext x, simp [part.mem_eq, and.exists, -exists_prop] }
ext x
simp [part.mem_eq, and.exists, -exists_prop]
intros
simp only [order_emb_of_fin_apply, subtype.coe_mk, sorted_zero_eq_min']
intros
rw ‚Üê finset.bUnion_singleton
refine finset.subset.trans support_sum _
refine finset.bUnion_mono (assume a _, support_single_subset)
intros
ext s
by_cases hs : s = a
{ rw [hs, erase_same], refl }
rw [hs, erase_same]
refl
{ rw [erase_ne hs], exact single_eq_of_ne (ne.symm hs) }
rw [erase_ne hs]
exact single_eq_of_ne (ne.symm hs)
intros
{ ext, simp, }
ext
simp
intros
classical
by_contra hf
push_neg at hf
apply not_injective_infinite_fintype f
intros x y
contrapose
apply hf
intros
rw [‚Üê fin.prod_univ_eq_prod_range, finset.prod_congr rfl]
rintros ‚ü®i, hi‚ü© _
simp only [fin.coe_eq_val, hi, dif_pos]
intros
rw [‚Üê nat_abs_mul, h, nat_abs_of_nat]
intros
rcases nat_abs_eq z with eq | eq; rw eq; simp [coe_nat_dvd]
rcases nat_abs_eq z with eq | eq; rw eq
rcases nat_abs_eq z with eq | eq
rw eq
simp [coe_nat_dvd]
rw eq
simp [coe_nat_dvd]
intros
rw [‚Üê int.div_mul_cancel H2]; exact decidable.mul_le_mul_of_nonneg_right H3 H1
rw [‚Üê int.div_mul_cancel H2]
exact decidable.mul_le_mul_of_nonneg_right H3 H1
intros
rw int.gcd at h ‚ä¢; rwa int.nat_abs_neg
rw int.gcd at h ‚ä¢
rwa int.nat_abs_neg
intros
rw [not_odd_iff, even_iff]
intros
simp only [insert_entries]; rw [kerase_cons_ne,kerase_cons_ne,kerase_comm]; [apply perm.swap, exact h, exact h.symm]
simp only [insert_entries]; rw [kerase_cons_ne,kerase_cons_ne,kerase_comm]
simp only [insert_entries]
rw [kerase_cons_ne,kerase_cons_ne,kerase_comm]
apply perm.swap
exact h
exact h.symm
intros
induction l‚ÇÅ generalizing n
simp
{ simp }
cases n
simp
{ simp }
simp *
intros
funext l
induction l with a l IH
refl
{refl}
by_cases pa : p a
simp only [filter_map, option.guard, IH, if_pos pa, filter_cons_of_pos _ pa]
{ simp only [filter_map, option.guard, IH, if_pos pa, filter_cons_of_pos _ pa], split; refl }
split
split; refl
refl
refl
simp only [filter_map, option.guard, IH, if_neg pa, filter_cons_of_neg _ pa]
{ simp only [filter_map, option.guard, IH, if_neg pa, filter_cons_of_neg _ pa] }
intros
convert filter_eq_self.2 (Œª _ _, trivial)
intros
convert map_permutations_aux2' id _ _ _ _ _ _ _ _
convert map_permutations_aux2' id _ _ _ _ _ _ _ _; simp only [map_id, id.def]
simp only [map_id, id.def]
simp only [map_id, id.def]
simp only [map_id, id.def]
exact (Œª _, rfl)
intros
rcases exists_or_eq_self_of_erasep p l with h | ‚ü®c, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
rcases exists_or_eq_self_of_erasep p l with h | ‚ü®c, l‚ÇÅ, l‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©; [rw h, {rw [h‚ÇÑ, h‚ÇÉ], simp}]
rw h
rw [h‚ÇÑ, h‚ÇÉ]
simp
intros
simp only [product, mem_bind, mem_map, prod.ext_iff, exists_prop, and.left_comm, exists_and_distrib_left, exists_eq_left, exists_eq_right]
intros
have : (Œª a b, flip f a (some b)) = (flip (Œª a b, f (some a) b)) := rfl
simp only [map‚ÇÇ_right, map‚ÇÇ_left_eq_map‚ÇÇ, map‚ÇÇ_flip, *]
intros
rw [concat_eq_append, reverse_append, reverse_singleton, singleton_append]
intros
cases l
{ contradiction }
contradiction
{ simp }
simp
intros
rw [next, nth_le, ‚Üêinit_append_last (cons_ne_nil y l), hx, next_or_concat]
subst hx
intro H
obtain ‚ü®_ | k, hk, hk'‚ü© := nth_le_of_mem H
{ simpa [init_eq_take, nth_le_take', hy.symm] using hk' }
simpa [init_eq_take, nth_le_take', hy.symm] using hk'
suffices : k.succ = l.length
{ simpa [this] using hk }
simpa [this] using hk
cases l with hd tl
{ simpa using hk }
simpa using hk
rw nodup_iff_nth_le_inj at hl
{ rw nodup_iff_nth_le_inj at hl, rw [length, nat.succ_inj'], apply hl, simpa [init_eq_take, nth_le_take', last_eq_nth_le] using hk' }
rw [length, nat.succ_inj']
apply hl
simpa [init_eq_take, nth_le_take', last_eq_nth_le] using hk'
intros
funext a b
apply propext
split
intro h
{ intro h, induction h, {refl}, simp only [*]; split; refl }
induction h
refl
{refl}
simp only [*]
simp only [*]; split; refl
simp only [*]; split
split
refl
refl
{ intro h, subst h, exact forall‚ÇÇ_refl _ }
intro h
subst h
exact forall‚ÇÇ_refl _
intros
simp only [mfoldr_with_index, mfoldr_eq_foldr, foldr_with_index_eq_foldr_enum, uncurry]
intros
simp only [slice_eq]
have : n ‚â§ n + m := nat.le_add_right _ _
have := h.nodup_iff.2 h'
apply perm.trans _ (perm.inter_append _).symm
apply perm.trans _ (perm.inter_append _).symm; solve_by_elim [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h, h'] { max_depth := 7 }
solve_by_elim [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h, h'] { max_depth := 7 }
solve_by_elim [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h, h'] { max_depth := 7 }
intros
rw [countp_eq_length_filter, countp_eq_length_filter]
rw [countp_eq_length_filter, countp_eq_length_filter]; exact (s.filter _).length_eq
exact (s.filter _).length_eq
intros
{ dsimp [(‚à©), list.inter], congr, funext a, rw [p.mem_iff] }
dsimp [(‚à©), list.inter]
congr
funext a
rw [p.mem_iff]
intros
simp only [enum, enum_from_map_fst, range_eq_range']
intros
rintros l l' (h : l.rotate n = l'.rotate n)
have hle : l.length = l'.length := (l.length_rotate n).symm.trans (h.symm ‚ñ∏ l'.length_rotate n)
rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod] at h
obtain ‚ü®hd, ht‚ü© := append_inj h _
{ rw [‚Üêtake_append_drop _ l, ht, hd, take_append_drop] }
rw [‚Üêtake_append_drop _ l, ht, hd, take_append_drop]
{ rw [length_drop, length_drop, hle] }
rw [length_drop, length_drop, hle]
intros
simp [nodupkeys, keys_kreplace]
intros
simp only [unzip_eq_map]
intros
{ ext, apply add_dot_product }
ext
apply add_dot_product
intros
simp [dot_product]
intros
{ ext, simp [vec_mul] }
ext
simp [vec_mul]
intros
ext ‚ü®i, k‚ü© ‚ü®j, k'‚ü©
simp only [block_diagonal_apply, diagonal]
split_ifs; finish
split_ifs
finish
finish
finish
finish
finish
finish
intros
{ ext, simp [vec_tail] }
ext
simp [vec_tail]
intros
{ ext i, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
apply le_antisymm
rw union_add_distrib
{ rw union_add_distrib, refine union_le (add_le_add_left (inter_le_right _ _) _) _, rw add_comm, exact add_le_add_right (inter_le_left _ _) _ }
refine union_le (add_le_add_left (inter_le_right _ _) _) _
rw add_comm
exact add_le_add_right (inter_le_left _ _) _
rw [add_comm, add_inter_distrib]
{ rw [add_comm, add_inter_distrib], refine le_inter (add_le_add_right (le_union_right _ _) _) _, rw add_comm, exact add_le_add_right (le_union_left _ _) _ }
refine le_inter (add_le_add_right (le_union_right _ _) _) _
rw add_comm
exact add_le_add_right (le_union_left _ _) _
intros
simp [ndinter, h]
intros
apply mv_polynomial.ring_hom_ext
intro r
{ intro r, rw [ring_hom.comp_apply, eval‚ÇÇ_hom_C, eval‚ÇÇ_hom_C, ring_hom.comp_apply] }
rw [ring_hom.comp_apply, eval‚ÇÇ_hom_C, eval‚ÇÇ_hom_C, ring_hom.comp_apply]
intro i
{ intro i, rw [ring_hom.comp_apply, eval‚ÇÇ_hom_X', eval‚ÇÇ_hom_X'] }
rw [ring_hom.comp_apply, eval‚ÇÇ_hom_X', eval‚ÇÇ_hom_X']
intros
{ ext i, simp only [rename_X, comap_apply, aeval_X] }
ext i
simp only [rename_X, comap_apply, aeval_X]
intros
cases n
{ exact (m % 0).div_zero }
exact (m % 0).div_zero
{ exact nat.div_eq_zero (m.mod_lt n.succ_pos) }
exact nat.div_eq_zero (m.mod_lt n.succ_pos)
intros
simp [or_imp_distrib] {contextual := tt}
intros
rw [cast_choose K (le_add_right le_rfl), nat.add_sub_cancel_left]
intros
rw dist_comm; apply dist_tri_right
rw dist_comm
apply dist_tri_right
intros
rw [‚Üê add_mod_add_ite, if_pos hc]
intros
by_cases h‚ÇÅ : a‚ÇÅ < b; simp [mkpair, h‚ÇÅ, add_assoc]
by_cases h‚ÇÅ : a‚ÇÅ < b
simp [mkpair, h‚ÇÅ, add_assoc]
by_cases h‚ÇÇ : a‚ÇÇ < b; simp [mkpair, h‚ÇÇ, h]
by_cases h‚ÇÇ : a‚ÇÇ < b
{ by_cases h‚ÇÇ : a‚ÇÇ < b; simp [mkpair, h‚ÇÇ, h], simp at h‚ÇÇ, apply add_lt_add_of_le_of_lt, exact mul_self_le_mul_self h‚ÇÇ, exact lt_add_right _ _ _ h }
simp [mkpair, h‚ÇÇ, h]
simp [mkpair, h‚ÇÇ, h]
simp at h‚ÇÇ
apply add_lt_add_of_le_of_lt
exact mul_self_le_mul_self h‚ÇÇ
exact lt_add_right _ _ _ h
simp [mkpair, h‚ÇÅ, add_assoc]
simp at h‚ÇÅ
{ simp at h‚ÇÅ, simp [not_lt_of_gt (lt_of_le_of_lt h‚ÇÅ h)], apply add_lt_add, exact mul_self_lt_mul_self h, apply add_lt_add_right; assumption }
simp [not_lt_of_gt (lt_of_le_of_lt h‚ÇÅ h)]
apply add_lt_add
exact mul_self_lt_mul_self h
apply add_lt_add_right; assumption
apply add_lt_add_right
assumption
intros
rcases x with _ | _ | x; simp
{ rcases x with _ | _ | x; simp }
rcases x with _ | _ | x
simp
simp
simp
intros
rw balance_eq_balance' hl.3 hr.3 hl.2 hr.2; exact hl.balance' hr H
rw balance_eq_balance' hl.3 hr.3 hl.2 hr.2
exact hl.balance' hr H
intros
cases m; simp [node4_l, node4_r, dual_node3_r, dual_node']
cases m
simp [node4_l, node4_r, dual_node3_r, dual_node']
simp [node4_l, node4_r, dual_node3_r, dual_node']
intros
rw [‚Üê find_min_dual, dual_dual]
intros
induction n generalizing x y; cases x; cases y
induction n generalizing x y; cases x
induction n generalizing x y
cases x
cases y
{ refl }
refl
cases x
cases y
{ cases h with _ _ _ _ _ h‚ÇÄ h‚ÇÅ, cases h, simp only [truncate, function.comp, true_and, eq_self_iff_true, heq_iff_eq], ext y, apply n_ih, apply h‚ÇÅ }
cases h with _ _ _ _ _ h‚ÇÄ h‚ÇÅ
cases h
simp only [truncate, function.comp, true_and, eq_self_iff_true, heq_iff_eq]
ext y
apply n_ih
apply h‚ÇÅ
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
apply le_antisymm
rw[‚Üê prime_multiset.prod_dvd_iff, prod_factor_multiset]
{ rw[‚Üê prime_multiset.prod_dvd_iff, prod_factor_multiset], apply lcm_dvd; rw[‚Üê factor_multiset_le_iff'], exact le_sup_left, exact le_sup_right}
apply lcm_dvd; rw[‚Üê factor_multiset_le_iff']
apply lcm_dvd
rw[‚Üê factor_multiset_le_iff']
exact le_sup_left
rw[‚Üê factor_multiset_le_iff']
exact le_sup_right
apply sup_le_iff.mpr; split; apply factor_multiset_le_iff.mpr
apply sup_le_iff.mpr; split
apply sup_le_iff.mpr
{ apply sup_le_iff.mpr; split; apply factor_multiset_le_iff.mpr, exact dvd_lcm_left m n, exact dvd_lcm_right m n }
split
apply factor_multiset_le_iff.mpr
exact dvd_lcm_left m n
apply factor_multiset_le_iff.mpr
exact dvd_lcm_right m n
intros
rw [aeval_def, eval‚ÇÇ_map, ‚Üêis_scalar_tower.algebra_map_eq, ‚Üêaeval_def]
intros
simp [monomial, monomial_fun, smul_to_finsupp]
intros
rcases p
{ rcases p, simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.single_zero_mul_apply p a n] }
simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.single_zero_mul_apply p a n]
intros
by_cases h : a = 0; [rw [h, C_0], rw [degree_C h]]; [exact bot_le, exact le_refl _]
by_cases h : a = 0; [rw [h, C_0], rw [degree_C h]]
by_cases h : a = 0
rw [h, C_0]
exact bot_le
rw [degree_C h]
exact le_refl _
intros
by_cases h : p = 0
{ simp [h] }
simp [h]
rw [degree_eq_nat_degree h, with_bot.coe_lt_coe]
intros
convert derivative_C_mul_X_pow (1 : R) n; simp
convert derivative_C_mul_X_pow (1 : R) n
simp
simp
intros
rw [eval‚ÇÇ_eq_sum, p.sum_over_range' _ _ hn]
intro i
rw [f.map_zero, zero_mul]
intros
rw [eq_neg_iff_add_eq_zero, ‚Üêeval‚ÇÇ_add, add_left_neg, eval‚ÇÇ_zero]
intros
simp [hp]
intros
induction n with n hn
{ exact iterated_deriv_zero_right _ }
exact iterated_deriv_zero_right _
{ rw [iterated_deriv_succ, hn, derivative_zero] }
rw [iterated_deriv_succ, hn, derivative_zero]
intros
rw [mirror, mirror, reverse_neg, nat_trailing_degree_neg, neg_mul_eq_neg_mul]
intros
by_cases h : p = 1
{ simpa [h] }
simpa [h]
rw [ne.def, ‚Üêdegree_eq_bot, hp.degree_mul_comm, hp.degree_mul, with_bot.add_eq_bot, not_or_distrib, degree_eq_bot]
refine ‚ü®hq, _‚ü©
rw [‚Üêhp.degree_le_zero_iff_eq_one, not_le] at h
refine (lt_trans _ h).ne'
simp
intros
ext u
rw [mem_supp]
split
{ intro h', apply h' _ _ rfl }
intro h'
apply h' _ _ rfl
intros h' a' f' e
rw [‚Üêh _ _ _ _ e.symm]
apply h'
intros
have : ((n : ‚Ñö) / d) = rat.mk n d
rw [‚Üêrat.mk_eq_div]
rw [‚Üêrat.mk_eq_div]
exact rat.num_denom_mk n_ne_zero d_ne_zero this
intros
simpa [-cast_le] using not_congr (@cast_le Œ± _ n m)
intros
simp [ennreal.to_real, ennreal.of_real, real.coe_to_nnreal _ h]
intros
rw [ennreal.to_real, to_nnreal_mul_top, nnreal.coe_zero]
intros
rw [infi_subtype', cinfi_ne_top]
intros
unfold bit1; rw add_eq_top; simp
unfold bit1; rw add_eq_top
unfold bit1
rw add_eq_top
simp
change ((-0 : ‚Ñù) : ereal) = 0
{ change ((-0 : ‚Ñù) : ereal) = 0, simp }
simp
rw [golden_ratio, golden_conj]
{rw [golden_ratio, golden_conj], ring}
ring
pi_upper_bound [ 27720/19601, 56935/30813, 49359/25163, 258754/130003, 113599/56868, 1101994/551163, 8671537/4336095, 3877807/1938940, 52483813/26242030, 56946167/28473117, 23798415/11899211]
intros
rw [sqrt, sqrt, nnreal.coe_le_coe, nnreal.sqrt_le_sqrt_iff]
{ rw [sqrt, sqrt, nnreal.coe_le_coe, nnreal.sqrt_le_sqrt_iff], exact to_nnreal_le_to_nnreal h }
exact to_nnreal_le_to_nnreal h
intros
simp [set.image, function.graph, rel.image]
intros
apply le_antisymm
exact nat.find_min' _ (nat.find_spec ((terminates_def _).1 h))
{ exact nat.find_min' _ (nat.find_spec ((terminates_def _).1 h)) }
have : (option.is_some ((think s).val (length (think s))) : Prop) := nat.find_spec ((terminates_def _).1 s.think_terminates)
{ have : (option.is_some ((think s).val (length (think s))) : Prop) := nat.find_spec ((terminates_def _).1 s.think_terminates), cases length (think s) with n, { contradiction }, { apply nat.succ_le_succ, apply nat.find_min', apply this } }
cases length (think s) with n
{ contradiction }
contradiction
{ apply nat.succ_le_succ, apply nat.find_min', apply this }
apply nat.succ_le_succ
apply nat.find_min'
apply this
intros
apply mem_rec_on h
intros a' s' h
{ intros a' s' h, cases h with h h, { existsi 0, simp [nth], rw h, apply ret_mem }, { cases h with n h, existsi n+1, simp [nth], exact h } }
cases h with h h
{ existsi 0, simp [nth], rw h, apply ret_mem }
existsi 0
simp [nth]
rw h
apply ret_mem
cases h with n h
{ cases h with n h, existsi n+1, simp [nth], exact h }
existsi n+1
simp [nth]
exact h
intros s' h
{ intros s' h, cases h with n h, existsi n, simp [nth], apply think_mem h }
cases h with n h
existsi n
simp [nth]
apply think_mem h
intros
{ ext, simp [image, eq_comm] }
ext
simp [image, eq_comm]
intros
rw [‚Üê not_nonempty_iff, ‚Üê range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]
intros
rw [‚Üê ne_empty_iff_nonempty, ‚Üê h2, ‚Üê ne_empty_iff_nonempty, hf.ne_iff]
intros
{ cases x, refl }
cases x
refl
intros
rw [‚Üêlt_eq_ssubset, ‚Üêfinset.lt_iff_ssubset, lt_iff_le_and_ne, lt_iff_le_and_ne]
simp
intros
ext x
rcases em (x ‚àà range f) with ‚ü®a, rfl‚ü©|hx
rw [mem_preimage, left_inverse_inv_fun hf, hf.mem_set_image]
{ rw [mem_preimage, left_inverse_inv_fun hf, hf.mem_set_image] }
have : x ‚àâ f '' s
{ have : x ‚àâ f '' s, from Œª h', hx (image_subset_range _ _ h'), simp only [mem_preimage, inv_fun_neg hx, h, this] }
from Œª h', hx (image_subset_range _ _ h')
simp only [mem_preimage, inv_fun_neg hx, h, this]
intros
ext1 x
simp_rw [mem_union, mem_Ioo, min_lt_iff, lt_max_iff]
by_cases hc : c < x; by_cases hd : x < d
by_cases hc : c < x
by_cases hd : x < d
{ tauto }
tauto
have hax : a < x := h‚ÇÇ.trans_le (le_of_not_lt hd)
{ have hax : a < x := h‚ÇÇ.trans_le (le_of_not_lt hd), tauto }
tauto
by_cases hd : x < d
have hxb : x < b := (le_of_not_lt hc).trans_lt h‚ÇÅ
{ have hxb : x < b := (le_of_not_lt hc).trans_lt h‚ÇÅ, tauto }
tauto
{ tauto }
tauto
intros
rw [e.image_eq_preimage, e.symm.preimage_Ioc, e.symm_symm]
intros
simp [‚Üê Ici_inter_Iic]
intros
simp [le_refl]
intros
simp [‚Üê Ioi_inter_Iio, inter_comm]
intros
simp [sub_eq_neg_add]
intros
obtain hab | hab := lt_or_le a b
intros p hp
{ intros p hp, rcases mem_Ioo_or_eq_left_of_mem_Ico hp with hp'|hp', { rw hp', exact ‚ü®a, left_mem_Ico.mpr hab, rfl‚ü© }, { have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ‚ü®x, Ioo_subset_Ico_self hx.1, hx.2‚ü© } }
rcases mem_Ioo_or_eq_left_of_mem_Ico hp with hp'|hp'
rw hp'
{ rw hp', exact ‚ü®a, left_mem_Ico.mpr hab, rfl‚ü© }
exact ‚ü®a, left_mem_Ico.mpr hab, rfl‚ü©
have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp'
{ have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ‚ü®x, Ioo_subset_Ico_self hx.1, hx.2‚ü© }
cases this with x hx
exact ‚ü®x, Ioo_subset_Ico_self hx.1, hx.2‚ü©
rw Ico_eq_empty (h_mono hab).not_lt
{ rw Ico_eq_empty (h_mono hab).not_lt, exact surj_on_empty f _ }
exact surj_on_empty f _
intros
{ assume x h, rwa interval_of_le, exact le_trans h.1 h.2 }
assume x h
rwa interval_of_le
exact le_trans h.1 h.2
intros
simp only [Union_and, @Union_comm _ Œπ']
intros
{ subst h, subst h', rw [heq_iff_eq, heq_iff_eq, ext_iff] }
subst h
subst h'
rw [heq_iff_eq, heq_iff_eq, ext_iff]
intros
tidy
intros
have : { i | i ‚àà l} = univ
ext i
{ ext i, simp [h] }
simp [h]
rw [‚Üê this, ‚Üê mk_preimage_tprod, preimage_preimage]
convert preimage_id
simp [tprod.mk_elim hnd h, id_def]
intros
ext i a
induction i
{ cases a, refl }
cases a
refl
{ apply i_ih }
apply i_ih
intros
cases n
{ exact fin_zero_elim i }
exact fin_zero_elim i
induction n with n hn generalizing b
have i0 : i = 0 := by simp only [eq_iff_true_of_subsingleton]
{ have i0 : i = 0 := by simp only [eq_iff_true_of_subsingleton], simpa only [scanl_singleton, i0, nth_zero] }
simpa only [scanl_singleton, i0, nth_zero]
rw [‚Üêcons_head_tail v, scanl_cons, nth_cons_succ]
{ rw [‚Üêcons_head_tail v, scanl_cons, nth_cons_succ], refine fin.cases _ _ i, { simp only [nth_zero, scanl_head, fin.cast_succ_zero, cons_head] }, { intro i', simp only [hn, fin.cast_succ_fin_succ, nth_cons_succ] } }
refine fin.cases _ _ i
{ simp only [nth_zero, scanl_head, fin.cast_succ_zero, cons_head] }
simp only [nth_zero, scanl_head, fin.cast_succ_zero, cons_head]
intro i'
{ intro i', simp only [hn, fin.cast_succ_fin_succ, nth_cons_succ] }
simp only [hn, fin.cast_succ_fin_succ, nth_cons_succ]
intros
rintros _ ‚ü®p, hp, q, hq, hq0, rfl‚ü©; exact hT.div_mem (ring.closure_subset hT.to_is_subring H hp) (ring.closure_subset hT.to_is_subring H hq)
rintros _ ‚ü®p, hp, q, hq, hq0, rfl‚ü©
exact hT.div_mem (ring.closure_subset hT.to_is_subring H hp) (ring.closure_subset hT.to_is_subring H hq)
intros
have := (f^n).translation_number_of_eq_add_int h
rwa [translation_number_pow, mul_comm, ‚Üê eq_div_iff] at this
exact nat.cast_ne_zero.2 (ne_of_gt hn)
intros
simp_rw [mem_omega_limit_iff_frequently, image_inter_nonempty_iff]
intros
cases le_total n m with h h
refine left_of_add _ hn
{ refine left_of_add _ hn, rwa [nat.sub_add_cancel h] }
rwa [nat.sub_add_cancel h]
rw [nat.sub_eq_zero_of_le h]
{ rw [nat.sub_eq_zero_of_le h], apply is_periodic_pt_zero }
apply is_periodic_pt_zero
intros
rw [‚Üê to_subalgebra_eq_iff, ‚Üê dim_eq_dim_subalgebra, subalgebra.dim_eq_one_iff, bot_to_subalgebra]
intros
let b := is_noetherian.finset_basis (zmod p) (galois_field p n)
rw [module.card_fintype b, ‚Üê finite_dimensional.finrank_eq_card_basis b, zmod.card, finrank p h]
intros
rw [ideal.ne_top_iff_one, span_eval, ideal.span, ‚Üê set.image_univ, finsupp.mem_span_image_iff_total]
rintros ‚ü®v, _, hv‚ü©
replace hv := congr_arg (to_splitting_field k v.support) hv
rw [alg_hom.map_one, finsupp.total_apply, finsupp.sum, alg_hom.map_sum, finset.sum_eq_zero] at hv
{ exact zero_ne_one hv }
exact zero_ne_one hv
intros j hj
rw [smul_eq_mul, alg_hom.map_mul, to_splitting_field_eval_X_self k hj, mul_zero]
intros
delta minpoly
split_ifs with hx
{ exact (well_founded.min_mem degree_lt_wf _ hx).2 }
exact (well_founded.min_mem degree_lt_wf _ hx).2
{ exact aeval_zero _ }
exact aeval_zero _
intros
refine ‚ü®Œª h, _, norm_add_eq_add_norm_of_angle_eq_zero‚ü©
rw ‚Üê inner_eq_mul_norm_iff_angle_eq_zero hx hy
obtain ‚ü®hxy‚ÇÅ, hxy‚ÇÇ‚ü© := ‚ü®norm_nonneg (x + y), add_nonneg (norm_nonneg x) (norm_nonneg y)‚ü©
rw [‚Üê sq_eq_sq hxy‚ÇÅ hxy‚ÇÇ, norm_add_pow_two_real] at h
calc inner x y = ((‚à•x‚à• + ‚à•y‚à•) ^ 2 - ‚à•x‚à• ^ 2 - ‚à•y‚à• ^ 2)/ 2 : by linarith ... = ‚à•x‚à• * ‚à•y‚à• : by ring
intros
obtain ‚ü®-, k‚ÇÅ, _, hab‚ü© := angle_eq_pi_iff.mp hapb
obtain ‚ü®-, k‚ÇÇ, _, hcd‚ü© := angle_eq_pi_iff.mp hcpd
exact mul_dist_eq_mul_dist_of_cospherical h ‚ü®k‚ÇÅ, (by linarith), hab‚ü© ‚ü®k‚ÇÇ, (by linarith), hcd‚ü©
intros
rw ‚Üê lift_prop_on_univ
apply hG.lift_prop_on_of_locally_lift_prop_on (Œª x hx, _)
simp [h x]
intros
simp only [mfderiv, h, dif_neg, not_false_iff]
intros
rw ‚Üê has_mfderiv_within_at_univ at *
exact has_mfderiv_within_at.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ
intros
rcases u with ‚ü®‚ü®x‚ü©, ‚ü®y‚ü©, h‚ÇÅ, h‚ÇÇ‚ü©
exact H x y (c.eq.1 h‚ÇÅ) (c.eq.1 h‚ÇÇ)
intros
rw [cons_eq_rcons, of_smul_def, equiv_pair_eq_of_fst_idx_ne _]
rw [cons_eq_rcons, of_smul_def, equiv_pair_eq_of_fst_idx_ne _]; simp only [mul_one]
simp only [mul_one]
intros
rw [‚Üêmul_one (f y), eq_comm, ‚Üêmul_inv_left hf y (f z) 1, h]
rw [‚Üêmul_one (f y), eq_comm, ‚Üêmul_inv_left hf y (f z) 1, h]; convert units.inv_mul _; exact (is_unit.coe_lift_right (f.mrestrict S) hf _).symm
rw [‚Üêmul_one (f y), eq_comm, ‚Üêmul_inv_left hf y (f z) 1, h]; convert units.inv_mul _
convert units.inv_mul _
exact (is_unit.coe_lift_right (f.mrestrict S) hf _).symm
intros
split
intros H v
{ intros H v, obtain ‚ü®z, hz‚ü© := H v, obtain ‚ü®x, hx‚ü© := f.surj z, use x, rw [‚Üêhz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ‚Üëx.2)], erw [is_unit.mul_lift_right_inv (g.mrestrict S) hg, mul_one] }
obtain ‚ü®z, hz‚ü© := H v
obtain ‚ü®x, hx‚ü© := f.surj z
use x
rw [‚Üêhz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ‚Üëx.2)]
erw [is_unit.mul_lift_right_inv (g.mrestrict S) hg, mul_one]
intros H v
{ intros H v, obtain ‚ü®x, hx‚ü© := H v, use f.mk' x.1 x.2, rw [lift_mk', mul_inv_left hg, mul_comm, ‚Üêhx] }
obtain ‚ü®x, hx‚ü© := H v
use f.mk' x.1 x.2
rw [lift_mk', mul_inv_left hg, mul_comm, ‚Üêhx]
intros
cases (order_of x).zero_le.eq_or_lt with hx hx
{ simp [pow_inj_iff_of_order_of_eq_zero, hx.symm] }
simp [pow_inj_iff_of_order_of_eq_zero, hx.symm]
rw [pow_eq_mod_order_of, @pow_eq_mod_order_of _ _ _ m]
exact ‚ü®pow_injective_of_lt_order_of _ (nat.mod_lt _ hx) (nat.mod_lt _ hx), Œª h, congr_arg _ h‚ü©
intros
classical
contrapose! hŒ±
simp_rw ‚Üê mem_support at hŒ±
exact nat.modeq_zero_iff_dvd.mp ((congr_arg _ (finset.card_eq_zero.mpr (compl_eq_bot.mpr (finset.eq_univ_iff_forall.mpr hŒ±)))).mp (card_compl_support_modeq hœÉ).symm)
intros
rw [‚Üê same_cycle_inv, same_cycle_apply, same_cycle_inv]
intros
ext x
simp only [set.mem_set_of_eq, ne.def]
rw [inv_def, symm_apply_eq, eq_comm]
intros
split
split; intro h
intro h
obtain ‚ü®x, t, hmem, hins, ht‚ü© := card_eq_succ.1 h
{ obtain ‚ü®x, t, hmem, hins, ht‚ü© := card_eq_succ.1 h, obtain ‚ü®y, rfl‚ü© := card_eq_one.1 ht, rw mem_singleton at hmem, refine ‚ü®x, y, hmem, _‚ü©, ext a, have key : ‚àÄ b, f b ‚â† b ‚Üî _ := Œª b, by rw [‚Üêmem_support, ‚Üêhins, mem_insert, mem_singleton], by_cases ha : f a = a, { have ha' := not_or_distrib.mp (mt (key a).mpr (not_not.mpr ha)), rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2] }, { have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha), obtain rfl | rfl := ((key a).mp ha), { rw [or.resolve_left ha' ha, swap_apply_left] }, { rw [or.resolve_right ha' ha, swap_apply_right] } } }
obtain ‚ü®y, rfl‚ü© := card_eq_one.1 ht
rw mem_singleton at hmem
refine ‚ü®x, y, hmem, _‚ü©
ext a
have key : ‚àÄ b, f b ‚â† b ‚Üî _ := Œª b, by rw [‚Üêmem_support, ‚Üêhins, mem_insert, mem_singleton]
by_cases ha : f a = a
have ha' := not_or_distrib.mp (mt (key a).mpr (not_not.mpr ha))
{ have ha' := not_or_distrib.mp (mt (key a).mpr (not_not.mpr ha)), rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2] }
rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2]
have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha)
{ have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha), obtain rfl | rfl := ((key a).mp ha), { rw [or.resolve_left ha' ha, swap_apply_left] }, { rw [or.resolve_right ha' ha, swap_apply_right] } }
obtain rfl | rfl := ((key a).mp ha)
{ rw [or.resolve_left ha' ha, swap_apply_left] }
rw [or.resolve_left ha' ha, swap_apply_left]
{ rw [or.resolve_right ha' ha, swap_apply_right] }
rw [or.resolve_right ha' ha, swap_apply_right]
intro h
obtain ‚ü®x, y, hxy, rfl‚ü© := h
{ obtain ‚ü®x, y, hxy, rfl‚ü© := h, exact card_support_swap hxy }
exact card_support_swap hxy
intros
simp [right_hom]
intros
rw map_commutator_eq_commutator_map
{ rw map_commutator_eq_commutator_map, exact general_commutator_mono h‚ÇÅ h‚ÇÇ }
exact general_commutator_mono h‚ÇÅ h‚ÇÇ
intros
rw eq_bot_iff
split
{ exact Œª h x hx, h ‚ü®x, hx, rfl‚ü© }
exact Œª h x hx, h ‚ü®x, hx, rfl‚ü©
intros h x hx
{ intros h x hx, obtain ‚ü®y, hy, rfl‚ü© := hx, exact h hy }
obtain ‚ü®y, hy, rfl‚ü© := hx
exact h hy
intros
ext
simp only [coe_inf, set.inf_eq_inter, set.mem_mul, set.mem_inter_iff]
split
rintros ‚ü®y, z, hy, ‚ü®hzB, hzC‚ü©, rfl‚ü©
{ rintros ‚ü®y, z, hy, ‚ü®hzB, hzC‚ü©, rfl‚ü©, refine ‚ü®_, mul_mem C (h hy) hzC‚ü©, exact ‚ü®y, z, hy, hzB, rfl‚ü© }
refine ‚ü®_, mul_mem C (h hy) hzC‚ü©
exact ‚ü®y, z, hy, hzB, rfl‚ü©
rintros ‚ü®‚ü®y, z, hy, hz, rfl‚ü©, hyz‚ü©
refine ‚ü®y, z, hy, ‚ü®hz, _‚ü©, rfl‚ü©
suffices : y‚Åª¬π * (y * z) ‚àà C
simpa
{ simpa }
exact mul_mem C (inv_mem C (h hy)) hyz
intros
{ rw [‚Üê le_bot_iff], exact closure_le _}
rw [‚Üê le_bot_iff]
exact closure_le _
intros
rw [line_map_symm p‚ÇÄ, comp_apply]
{ rw [line_map_symm p‚ÇÄ, comp_apply], congr, simp [line_map_apply] }
congr
simp [line_map_apply]
intros
convert (finset.univ.centroid_map k (fs.order_emb_of_fin h).to_embedding s.points).symm
rw [‚Üê finset.coe_inj, finset.coe_map, finset.coe_univ, set.image_univ]
simp
intros
ext a
change (equiv_fun_on_fintype (single x m)) a = _
convert _root_.congr_fun (equiv_fun_on_fintype_single x m) a
intros
ext ‚ü®x, y‚ü©; simp [prod.zero_eq_mk]
ext ‚ü®x, y‚ü©
simp [prod.zero_eq_mk]
intros
induction n with n ih
{ refl, }
refl
simp only [function.comp_app, function.iterate_succ, linear_map.mul_apply, pow_succ, ih]
{ simp only [function.comp_app, function.iterate_succ, linear_map.mul_apply, pow_succ, ih], exact (function.commute.iterate_self _ _ m).symm, }
exact (function.commute.iterate_self _ _ m).symm
intros
nontriviality
subst h
refine (b.repr_apply_eq (Œª x i, b.reindex_range.repr x ‚ü®b i, _‚ü©) _ _ _ x i).symm
intros x y
{ intros x y, ext i, simp only [pi.add_apply, linear_equiv.map_add, finsupp.coe_add] }
ext i
simp only [pi.add_apply, linear_equiv.map_add, finsupp.coe_add]
intros c x
{ intros c x, ext i, simp only [pi.smul_apply, linear_equiv.map_smul, finsupp.coe_smul] }
ext i
simp only [pi.smul_apply, linear_equiv.map_smul, finsupp.coe_smul]
intros i
{ intros i, ext j, simp only [reindex_range_repr_self], refine @finsupp.single_apply_left _ _ _ _ (Œª i, (‚ü®b i, _‚ü© : set.range b)) _ _ _ _, exact Œª i j h, b.injective (subtype.mk.inj h) }
ext j
simp only [reindex_range_repr_self]
refine @finsupp.single_apply_left _ _ _ _ (Œª i, (‚ü®b i, _‚ü© : set.range b)) _ _ _ _
exact Œª i j h, b.injective (subtype.mk.inj h)
intros
simp [b.constr_apply, b.equiv_fun_apply, finsupp.sum_fintype]
intros
ext B x y
{ ext B x y, simp only [congr_apply, linear_equiv.symm_symm], refl }
simp only [congr_apply, linear_equiv.symm_symm]
refl
ext
dsimp only [linear_map.comp_apply, subtype.coe_mk, alg_hom.id_apply, alg_hom.to_linear_map_apply, alg_hom.comp_apply]
rw [to_complex_Œπ, one_smul, of_complex_I]
intros
rw [basis.det_apply, basis.det_apply, ‚Üê f.det_to_matrix e, ‚Üê matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f ‚àò v), e.to_matrix_eq_to_matrix_constr v, ‚Üê to_matrix_comp, e.constr_comp]
{ rw [basis.det_apply, basis.det_apply, ‚Üê f.det_to_matrix e, ‚Üê matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f ‚àò v), e.to_matrix_eq_to_matrix_constr v, ‚Üê to_matrix_comp, e.constr_comp] }
intros
have : (‚ä§ : submodule R M) ‚âÉ‚Çó[R] M := linear_equiv.of_top ‚ä§ rfl
rw this.dim_eq
intros
classical
rw [‚Üê b.to_dual_to_dual, range_comp, b.to_dual_range, map_top, to_dual_range _]
apply_instance
intros
convert finrank_eq_dim K V
rw h
norm_cast
intros
refine (eq_top_iff.2 $ set_like.le_def.2 $ assume f _, _)
rw [‚Üê sum_single f]
exact sum_mem _ (assume a ha, submodule.mem_supr_of_mem a ‚ü®_, rfl‚ü©)
intros
simp only [finsupp.total_apply, finsupp.sum, finsupp.on_finset_apply, finsupp.support_on_finset]
rw finset.sum_filter_of_ne
intros x hx h
contrapose! h
simp [h]
intros
rw [linear_independent.repr, linear_equiv.range]
intros
have := classical.dec_eq Œπ
have := classical.dec_eq Œπ'
haveI := classical.dec_eq Œπ''
ext i j
simp only [matrix.mul_apply, basis.to_matrix_apply, basis.sum_repr_mul_repr]
intros
rw [smul_eq_diagonal_mul]
simp [card_univ]
intros
rw [‚Üê comap_bot, ‚Üê infi_ker_proj, comap_infi]
have := Œª i : m, ker_comp (to_lin' (diagonal w)) (proj i)
simp only [comap_infi, ‚Üê this, proj_diagonal, ker_smul']
have : univ ‚äÜ {i : m | w i = 0} ‚à™ {i : m | w i = 0}·∂ú
rw set.union_compl_self
{ rw set.union_compl_self }
exact (supr_range_std_basis_eq_infi_ker_proj K (Œªi:m, K) disjoint_compl_right this (finite.of_fintype _)).symm
intros
ext ‚ü®i, k‚ü© ‚ü®j, k'‚ü©
rw [smul_left_mul_matrix, alg_hom.commutes, block_diagonal_apply, algebra_map_matrix_apply]
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
cases t
ext a b
cases a; cases b
cases a
cases b
by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
by_cases h : a = b
{ by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix], }
simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
{ simp [transvection_struct.sum_inl, transvection] }
simp [transvection_struct.sum_inl, transvection]
cases b
{ simp [transvection_struct.sum_inl, transvection] }
simp [transvection_struct.sum_inl, transvection]
by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h]
by_cases h : a = b
{ by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h] }
simp [transvection_struct.sum_inl, transvection, h]
simp [transvection_struct.sum_inl, transvection, h]
intros
ext m x
simp only [tail_cons, linear_map.uncurry_left_apply, multilinear_map.curry_left_apply]
rw cons_zero
intros
rw [span_union, prod_eq_sup_map, ‚Üê span_image, ‚Üê span_image]
intros
rw [‚Üêneg_one_smul R y, polar_smul_right, neg_one_mul]
intros
conv_lhs { rw [‚Üê fin.cons_self_tail v, vandermonde_cons] }
simp only [fin.tail]
intros
rw [@iff.comm p, and_iff_left_iff_imp]
intros
{funext b, by_cases b = a; simp [update, h]}
funext b
by_cases b = a
by_cases b = a; simp [update, h]
simp [update, h]
simp [update, h]
intros
simp only [nontrivial_iff_exists_ne x, subtype.exists, ne.def, subtype.ext_iff, subtype.coe_mk]
intros
haveI : encodable s := hs.to_encodable
{ haveI : encodable s := hs.to_encodable, simp only [infi_subtype'], exact measurable_infi (Œª i, hf i) }
simp only [infi_subtype']
exact measurable_infi (Œª i, hf i)
intros
{ rw [comp_eq_mk], apply coe_fn_mk }
rw [comp_eq_mk]
apply coe_fn_mk
intros
simp_rw [filter.eventually_eq, ae_iff, supr_apply]
have h_ss : ae_seq_set hf p ‚äÜ {a : Œ± | (‚®Ü (i : Œπ), ae_seq hf p i a) = ‚®Ü (i : Œπ), f i a}
intros x hx
{ intros x hx, congr, exact funext (Œª i, ae_seq_eq_fun_of_mem_ae_seq_set hf hx i), }
congr
exact funext (Œª i, ae_seq_eq_fun_of_mem_ae_seq_set hf hx i)
exact measure_mono_null (set.compl_subset_compl.mpr h_ss) (measure_compl_ae_seq_set_eq_zero hf hp)
intros
ext1
{ ext1, push_cast, exact condexp_ind_disjoint_union_apply hs ht hŒºs hŒºt hst x, }
push_cast
exact condexp_ind_disjoint_union_apply hs ht hŒºs hŒºt hst x
intros
rw [sub_eq_add_neg, sub_eq_add_neg, Lp_meas_subgroup_to_Lp_trim_add, Lp_meas_subgroup_to_Lp_trim_neg]
intros
refine limsup_le_limsup_of_le (measure.ae_le_iff_absolutely_continuous.mpr hŒºŒΩ) _ _
is_bounded_default
all_goals { is_bounded_default, }
is_bounded_default
intros
simp [integrable, measurable_const.ae_measurable]
intros
rw [norm_def]
congr' 1
rw lintegral_congr_ae
filter_upwards [Lp.coe_fn_sub f g]
assume a ha
simp only [ha, pi.sub_apply]
intros
simp [hfp.2]
intros
refine le_antisymm (snorm_ess_sup_indicator_const_le s c) _
by_contra h
push_neg at h
have h' := ae_iff.mp (ae_lt_of_ess_sup_lt h)
push_neg at h'
refine hŒºs (measure_mono_null (Œª x hx_mem, _) h')
rw [set.mem_set_of_eq, set.indicator_of_mem hx_mem]
exact le_rfl
intros
rw ‚Üê mem_‚Ñíp_one_iff_integrable at hf hi‚ÇÄ ‚ä¢
exact mem_‚Ñíp_approx_on fmeas hf h‚ÇÄ hi‚ÇÄ n
intros
rcases hf with ‚ü®fs, hT_lt_top, h_approx‚ü©
let T := Œª n, support (fs n)
have hT_meas : ‚àÄ n, measurable_set (T n)
from Œª n, simple_func.measurable_set_support (fs n)
let t := ‚ãÉ n, T n
refine ‚ü®t, measurable_set.Union hT_meas, _, _‚ü©
have h_fs_zero : ‚àÄ n, ‚àÄ x ‚àà t·∂ú, fs n x = 0
{ have h_fs_zero : ‚àÄ n, ‚àÄ x ‚àà t·∂ú, fs n x = 0, { intros n x hxt, rw [set.mem_compl_iff, set.mem_Union, not_exists] at hxt, simpa using (hxt n), }, refine Œª x hxt, tendsto_nhds_unique (h_approx x) _, rw funext (Œª n, h_fs_zero n x hxt), exact tendsto_const_nhds, }
intros n x hxt
{ intros n x hxt, rw [set.mem_compl_iff, set.mem_Union, not_exists] at hxt, simpa using (hxt n), }
rw [set.mem_compl_iff, set.mem_Union, not_exists] at hxt
simpa using (hxt n)
refine Œª x hxt, tendsto_nhds_unique (h_approx x) _
rw funext (Œª n, h_fs_zero n x hxt)
exact tendsto_const_nhds
refine ‚ü®‚ü®‚ü®Œª n, t·∂ú ‚à™ T n, Œª n, trivial, Œª n, _, _‚ü©‚ü©‚ü©
{ refine ‚ü®‚ü®‚ü®Œª n, t·∂ú ‚à™ T n, Œª n, trivial, Œª n, _, _‚ü©‚ü©‚ü©, { rw [measure.restrict_apply' (measurable_set.Union hT_meas), set.union_inter_distrib_right, set.compl_inter_self t, set.empty_union], exact (measure_mono (set.inter_subset_left _ _)).trans_lt (hT_lt_top n), }, { rw ‚Üê set.union_Union t·∂ú T, exact set.compl_union_self _ } }
rw [measure.restrict_apply' (measurable_set.Union hT_meas), set.union_inter_distrib_right, set.compl_inter_self t, set.empty_union]
{ rw [measure.restrict_apply' (measurable_set.Union hT_meas), set.union_inter_distrib_right, set.compl_inter_self t, set.empty_union], exact (measure_mono (set.inter_subset_left _ _)).trans_lt (hT_lt_top n), }
exact (measure_mono (set.inter_subset_left _ _)).trans_lt (hT_lt_top n)
rw ‚Üê set.union_Union t·∂ú T
{ rw ‚Üê set.union_Union t·∂ú T, exact set.compl_union_self _ }
exact set.compl_union_self _
intros
simp_rw [(integral_nonneg_of_ae hf).lt_iff_ne, pos_iff_ne_zero, ne.def, @eq_comm ‚Ñù 0, integral_eq_zero_iff_of_nonneg_ae hf hfi, filter.eventually_eq, ae_iff, pi.zero_apply, function.support]
intros
{ ext1 x, rw [weighted_smul_apply, h_zero], simp, }
ext1 x
rw [weighted_smul_apply, h_zero]
simp
intros
simp only [interval_integral, integral_add hf.1 hg.1, integral_add hf.2 hg.2]
{ simp only [interval_integral, integral_add hf.1 hg.1, integral_add hf.2 hg.2], abel }
abel
intros
cases le_or_lt a b with hab hab
have : Icc a b = Icc a a ‚à™ Ioc a b := (Icc_union_Ioc_eq_Icc le_rfl hab).symm
{ have : Icc a b = Icc a a ‚à™ Ioc a b := (Icc_union_Ioc_eq_Icc le_rfl hab).symm, rw [this, integrable_on_union], simp [lt_top_iff_ne_top.2 ha] }
rw [this, integrable_on_union]
simp [lt_top_iff_ne_top.2 ha]
{ simp [hab, hab.le] }
simp [hab, hab.le]
intros
have : monotone (Œª n, ‚à´‚Åª x, f n x ‚àÇŒº) := Œª i j hij, lintegral_mono_ae (h_mono.mono $ Œª x hx, hx hij)
suffices key : ‚à´‚Åª x, F x ‚àÇŒº = ‚®Ün, ‚à´‚Åª x, f n x ‚àÇŒº
rw key
{ rw key, exact tendsto_at_top_supr this }
exact tendsto_at_top_supr this
rw ‚Üê lintegral_supr' hf h_mono
refine lintegral_congr_ae _
filter_upwards [h_mono, h_tendsto]
exact Œª x hx_mono hx_tendsto, tendsto_nhds_unique hx_tendsto (tendsto_at_top_supr hx_mono)
intros
simp [pos_iff_ne_zero, hf, filter.eventually_eq, ae_iff, function.support]
intros
simp only [f.coe_restrict hs]
intros
{ rw [mul_eq_map‚ÇÇ], exact hf.map‚ÇÇ hg (zero_mul 0) }
rw [mul_eq_map‚ÇÇ]
exact hf.map‚ÇÇ hg (zero_mul 0)
intros
rw [set_to_fun_eq hT (hf.add hg), set_to_fun_eq hT hf, set_to_fun_eq hT hg, integrable.to_L1_add, (L1.set_to_L1 hT).map_add]
intros
{ rw sUnion_eq_bUnion, exact measurable_set.bUnion hs h }
rw sUnion_eq_bUnion
exact measurable_set.bUnion hs h
intros
refine induced_outer_measure_preimage _ Œº.inner_content_Union_nat Œº.inner_content_mono _ (Œª s, f.is_open_preimage) _
intros s hs
convert Œº.inner_content_comap f h ‚ü®s, hs‚ü©
intros
apply div_nonneg; norm_cast; apply zero_le
apply div_nonneg; norm_cast
apply div_nonneg
norm_cast
apply zero_le
norm_cast
apply zero_le
intros
rw @borel_space.measurable_eq X _ _
{ rw @borel_space.measurable_eq X _ _, exact hm.borel_le_caratheodory }
exact hm.borel_le_caratheodory
intros
simp [volume_val]
intros
simp only [count, sum_apply, hs, dirac_apply', ‚Üê tsum_subtype s 1, pi.one_apply]
intros
{ ext s, simp [mem_ae_iff, imp_false] }
ext s
simp [mem_ae_iff, imp_false]
intros
rw [‚Üê measure.measure_univ_eq_zero, to_measure_apply _ _ measurable_set.univ, outer_measure.coe_zero, pi.zero_apply]
intros
split_ifs; simp [h]
{ split_ifs; simp [h] }
split_ifs
simp [h]
simp [h]
intros
rcases exists_measurable_superset_eq_trim m s with ‚ü®t, hst, ht, hm‚ü©
exact ‚ü®t, hst, ht, h ‚ñ∏ hm‚ü©
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
obtain ‚ü®t, ht‚ü© := exists_partition_polynomial_aux n hŒµ hb A
exact ‚ü®t, Œª i‚ÇÄ i‚ÇÅ hi, (ht i‚ÇÄ i‚ÇÅ).mp hi‚ü©
intros
refine congr_arg dioph (set.ext $ Œªv, _); exact pfun.lift_graph.symm
refine congr_arg dioph (set.ext $ Œªv, _)
exact pfun.lift_graph.symm
intros
suffices h : ‚àÄ n : ‚Ñï, complex.abs (f n) / complex.abs (‚Üën ^ w) = complex.abs (f n) / complex.abs (‚Üën ^ z)
simp [l_series_summable, ‚Üê summable_norm_iff, h, complex.norm_eq_abs]
{ simp [l_series_summable, ‚Üê summable_norm_iff, h, complex.norm_eq_abs] }
intro n
cases n
simp
{ simp }
apply congr rfl
have h0 : (n.succ : ‚ÑÇ) ‚â† 0
rw [ne.def, nat.cast_eq_zero]
{ rw [ne.def, nat.cast_eq_zero], apply n.succ_ne_zero }
apply n.succ_ne_zero
rw [complex.cpow_def, complex.cpow_def, if_neg h0, if_neg h0, complex.abs_exp_eq_iff_re_eq]
simp only [h, complex.mul_re, mul_eq_mul_left_iff, sub_right_inj]
right
rw [complex.log_im, ‚Üê complex.of_real_nat_cast]
exact complex.arg_of_real_of_nonneg (le_of_lt (cast_pos.2 n.succ_pos))
intros
dsimp [œâ, œâb]
ext
ext; simp; ring
ext; simp
simp
ring
simp
intros
simp [padic_norm, (show p ‚â† 0, by linarith), padic_val_rat.padic_val_rat_self hp]
intros
rw ‚Üê(padic_norm_e.neg); simp
rw ‚Üê(padic_norm_e.neg)
simp
intros
simp [ext]
intros
rw [inf_comm, inf_inf_sdiff]
intros
rw [sdiff_le_iff, sup_comm, sdiff_le_iff]
intros
rw [is_greatest_univ.upper_bounds_eq, Ici_top]
intros
{ ext x, refl }
ext x
refl
intros
rw [supr_bool_eq, bool.cond_tt, bool.cond_ff]
intros
{ convert h1.supr_comp g, exact (funext h2).symm }
convert h1.supr_comp g
exact (funext h2).symm
intros
rw [‚Üê map_coe_Iic_at_bot a, tendsto_map'_iff]
intros
simpa only [mul_comm] using hf.const_mul_at_top hr
intros
erw h.filter_basis.generate ; refl
erw h.filter_basis.generate
refl
intros
simpa only [infi_true] using h.eq_binfi
intros
simp only [filter.frequently, ‚Üê not_and_distrib, not_or_distrib, eventually_and]
intros
simp only [ne_bot_iff, ne, map_eq_bot_iff]
intros
simp only [tendsto, iff_self, le_infi_iff]
intros
rw [filter.coprod, comap_principal, comap_principal, sup_principal]
congr
ext x
simp
simp ; tauto
tauto
intros
rw [sup_assoc, sup_assoc, @sup_comm _ _ b]
intros
simp [is_cobounded, subset_def]
intros
rw [inf_comm, sup_comm, ‚Üê sup_inf_assoc_of_le y h, inf_comm, sup_comm]
intros
rintro f g h n
induction n with n ih
{ exact h 0 }
exact h 0
{ exact sup_le_sup ih (h _) }
exact sup_le_sup ih (h _)
intros
simp only [‚Üêtop_sdiff, sdiff_symm_diff, top_inf_eq]
intros
classical
obtain ‚ü®t, rfl‚ü© := S.fg_of_noetherian
refine finset.induction_on t _ _
{ simpa using base }
simpa using base
intros x t hxt h
convert ih _ x h using 1
rw [finset.coe_insert, algebra.adjoin_insert_adjoin]
intros
rcases hR with ‚ü®œñ, hœñ, hR‚ü©
suffices : ‚àÄ {p : R} (hp : irreducible p), associated p œñ
{ apply associated.trans (this hp) (this hq).symm, }
apply associated.trans (this hp) (this hq).symm
clear hp hq p q
intros p hp
obtain ‚ü®n, hn‚ü© := hR hp.ne_zero
have : irreducible (œñ ^ n) := hn.symm.irreducible hp
rcases lt_trichotomy n 1 with (H|rfl|H)
obtain rfl : n = 0
{ obtain rfl : n = 0, { clear hn this, revert H n, exact dec_trivial }, simpa only [not_irreducible_one, pow_zero] using this, }
clear hn this
{ clear hn this, revert H n, exact dec_trivial }
revert H n
exact dec_trivial
simpa only [not_irreducible_one, pow_zero] using this
{ simpa only [pow_one] using hn.symm, }
simpa only [pow_one] using hn.symm
obtain ‚ü®n, rfl‚ü© : ‚àÉ k, n = 1 + k + 1 := nat.exists_eq_add_of_lt H
{ obtain ‚ü®n, rfl‚ü© : ‚àÉ k, n = 1 + k + 1 := nat.exists_eq_add_of_lt H, rw pow_succ at this, rcases this.is_unit_or_is_unit rfl with H0|H0, { exact (hœñ.not_unit H0).elim, }, { rw [add_comm, pow_succ] at H0, exact (hœñ.not_unit (is_unit_of_mul_is_unit_left H0)).elim } }
rw pow_succ at this
rcases this.is_unit_or_is_unit rfl with H0|H0
{ exact (hœñ.not_unit H0).elim, }
exact (hœñ.not_unit H0).elim
rw [add_comm, pow_succ] at H0
{ rw [add_comm, pow_succ] at H0, exact (hœñ.not_unit (is_unit_of_mul_is_unit_left H0)).elim }
exact (hœñ.not_unit (is_unit_of_mul_is_unit_left H0)).elim
intros
split
rintro ‚ü®s, hs‚ü©
{ rintro ‚ü®s, hs‚ü©, use [s, mv_polynomial.aeval coe], intro x, have hrw : (‚Üës : set A) = (Œª (x : A), x ‚àà s.val) := rfl, rw [‚Üê set.mem_range, ‚Üê alg_hom.coe_range, ‚Üê adjoin_eq_range, ‚Üê hrw, hs], exact set.mem_univ x }
use [s, mv_polynomial.aeval coe]
intro x
have hrw : (‚Üës : set A) = (Œª (x : A), x ‚àà s.val) := rfl
rw [‚Üê set.mem_range, ‚Üê alg_hom.coe_range, ‚Üê adjoin_eq_range, ‚Üê hrw, hs]
exact set.mem_univ x
rintro ‚ü®s, ‚ü®f, hsur‚ü©‚ü©
{ rintro ‚ü®s, ‚ü®f, hsur‚ü©‚ü©, exact finite_type.of_surjective (finite_type.mv_polynomial R {x // x ‚àà s}) f hsur }
exact finite_type.of_surjective (finite_type.mv_polynomial R {x // x ‚àà s}) f hsur
intros
obtain ‚ü®S, hS‚ü© := h
unfreezingI { obtain ‚ü®S, hS‚ü© := h }
letI : decidable_eq M := classical.dec_eq M
use finset.bUnion S (Œª f, f.support)
have : (finset.bUnion S (Œª f, f.support) : set M) = ‚ãÉ f ‚àà S, (f.support : set M)
{ simp only [finset.set_bUnion_coe, finset.coe_bUnion] }
simp only [finset.set_bUnion_coe, finset.coe_bUnion]
rw [this]
exact support_gen_of_gen' hS
intros
rw div_nonzero hJ'
convert submodule.le_div_iff_mul_le using 1
rw [‚Üê coe_mul, coe_le_coe]
intros
ext
{ ext, simp [sub_eq_add_neg] }
simp [sub_eq_add_neg]
intros
split
contrapose! h
unfreezingI { contrapose! h }
{ unfreezingI { contrapose! h }, simp [is_prime_iff, h] }
simp [is_prime_iff, h]
intros x y hxy
{ intros x y hxy, have : (‚ü®x, 1‚ü© : R √ó S) * ‚ü®y, 1‚ü© ‚àà prod I ‚ä§, { rw [prod.mk_mul_mk, mul_one, mem_prod], exact ‚ü®hxy, trivial‚ü© }, simpa using h.mem_or_mem this }
have : (‚ü®x, 1‚ü© : R √ó S) * ‚ü®y, 1‚ü© ‚àà prod I ‚ä§
rw [prod.mk_mul_mk, mul_one, mem_prod]
{ rw [prod.mk_mul_mk, mul_one, mem_prod], exact ‚ü®hxy, trivial‚ü© }
exact ‚ü®hxy, trivial‚ü©
simpa using h.mem_or_mem this
intros
split
intros h x hx
{ intros h x hx, erw [‚Üê h, mem_Inf] at hx, push_neg at hx, exact hx }
erw [‚Üê h, mem_Inf] at hx
push_neg at hx
exact hx
refine Œª h, le_antisymm (Œª x hx, _) le_jacobson
{ refine Œª h, le_antisymm (Œª x hx, _) le_jacobson, contrapose hx, erw mem_Inf, push_neg, exact h x hx }
contrapose hx
erw mem_Inf
push_neg
exact h x hx
intros
rw [aeval_def, is_scalar_tower.algebra_map_eq R S R', integer_normalization_eval‚ÇÇ_eq_zero _ _ _ hx]
intros
rw [mul_comm, sec_spec]
intros
apply tensor_product.induction_on M
{ simp, }
simp
{ intros a m, simp, }
intros a m
simp
{ intros x y hx hy, simp [alg_hom.map_sum, hx, hy], }
intros x y hx hy
simp [alg_hom.map_sum, hx, hy]
intros
refine classical.by_contradiction (Œª hx0, hI.ne_top ((eq_top_iff_one I).2 _))
obtain ‚ü®y, hy‚ü© := hR.mul_inv_cancel hx0
convert I.smul_mem (C y) hx
rw [smul_eq_mul, ‚Üê C.map_mul, mul_comm y x, hy, ring_hom.map_one]
intros
simp [bernstein_polynomial, nat.choose_eq_zero_of_lt h]
intros
rw [‚Üêmap_cyclotomic_int n R, ‚Üêmap_cyclotomic_int n S]
ext i
simp only [coeff_map, ring_hom.eq_int_cast, ring_hom.map_int_cast]
intros
simp only [dickson, sq]
intros
{ rw support_esymm', exact bUnion_singleton }
rw support_esymm'
exact bUnion_singleton
intros
refine le_of_not_lt (Œª hlt, ne_zero _)
let p_coeff : fin (h.dim) ‚Üí A := Œª i, p.coeff i
suffices : ‚àÄ i, p_coeff i = 0
ext i
{ ext i, by_cases hi : i < h.dim, { exact this ‚ü®i, hi‚ü© }, exact coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi)) }
by_cases hi : i < h.dim
{ exact this ‚ü®i, hi‚ü© }
exact this ‚ü®i, hi‚ü©
exact coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi))
intro i
refine linear_independent_iff'.mp h.basis.linear_independent _ _ _ i (finset.mem_univ _)
rw aeval_eq_sum_range' hlt at root
rw finset.sum_fin_eq_sum_range
convert root
ext i
split_ifs with hi
{ simp_rw [coe_basis, p_coeff, fin.coe_mk] }
simp_rw [coe_basis, p_coeff, fin.coe_mk]
rw [coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi)), zero_smul]
{ rw [coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi)), zero_smul] }
intros
erw [coeff, ‚Üê h, ‚Üê finsupp.unique_single s]
intros
{ ext, simp }
ext
simp
intros
induction k with k ih
{ simp [one_def], }
simp [one_def]
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
rw to_padic_int_comp_from_padic_int
intros
rw [‚Üê aeval_eq_bind‚ÇÅ, aeval_zero, constant_coeff_witt_polynomial, ring_hom.map_zero]
intros
rw [out, witt_vector.coeff_mk, dif_pos i.is_lt, fin.eta]
intros
simp only [witt_polynomial, ring_hom.map_sum, constant_coeff_monomial]
rw [sum_eq_zero]
rintro i hi
rw [if_neg]
rw [finsupp.single_eq_zero]
exact ne_of_gt (pow_pos hp.1.pos _)
intros
rw ‚Üê quotient.out_eq (f i); exact ‚ü®‚ü®Œª a, ‚ü®i, a‚ü©, Œª a b h, eq_of_heq $ by injection h‚ü©‚ü©
rw ‚Üê quotient.out_eq (f i)
exact ‚ü®‚ü®Œª a, ‚ü®i, a‚ü©, Œª a b h, eq_of_heq $ by injection h‚ü©‚ü©
intros
rw [one_le_iff_pos, pos_iff_ne_zero]
simp only [aleph, add_zero, aleph'_omega]
intros
convert card_typein_lt c.ord.out.r x _
{ convert card_typein_lt c.ord.out.r x _, rw [mk_ord_out], rw [type_out, mk_ord_out] }
rw [mk_ord_out]
rw [type_out, mk_ord_out]
intros
simp only [le_antisymm_iff, card_le_nat, nat_le_card]
intros
cases n; refl
cases n
refl
refl
intros
rwa add_zero
intros
simp [h‚ÇÇ.symm, h‚ÇÉ.symm, h‚ÇÅ.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]
simp [h‚ÇÇ.symm, h‚ÇÉ.symm, h‚ÇÅ.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]; cc
cc
intros
cases t; unfold_wf; linarith
cases t; unfold_wf
cases t
unfold_wf
unfold_wf
linarith
intros
rw [‚Üê set.indicator_range_comp, subtype.range_coe, has_sum_subtype_iff_of_support_subset set.support_indicator_subset]
intros
simpa only [sub_add_cancel] using hfg.add hg
intros
simp only [ext_ring_iff, smul_right_apply, one_apply, one_smul]
intros
rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, ‚Üê range_comp, supr]
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Iio _ _ _ _ (a‚Åª¬π)
intros
simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]
intros
rw [@ring_sep_rel Œ± r]; refl
rw [@ring_sep_rel Œ± r]
refl
intros
simp [frontier_prod_eq]
intros
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]; abel
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
cases le_total x y with h h
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
abel
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
intros
have h' : ‚àÄ (C : ‚Ñù) (x : Œ±), ‚à•f x‚à• ‚â§ C
intros
{ intros, exfalso, apply h.false, use x, }
exfalso
apply h.false
use x
simp only [norm_eq, h', and_true, implies_true_iff]
exact cInf_Ici
intros
rw [‚Üê ite_compl, ite_inter_closure_eq_of_inter_frontier_eq]
{ rw [‚Üê ite_compl, ite_inter_closure_eq_of_inter_frontier_eq], rwa [frontier_compl, eq_comm] }
rwa [frontier_compl, eq_comm]
intros
simp only [mem_nhds_subtype_iff_nhds_within, subtype.image_preimage_coe, inter_mem_iff, self_mem_nhds_within, and_true]
intros
ext ‚ü®‚ü©
{ ext ‚ü®‚ü©, refl }
refl
intros
rw [‚Üê preimage_symm, is_open_preimage]
intros
simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0
intros
apply summable_iff_not_tendsto_nat_at_top.2 (Œª H, _)
rcases exists_lt_of_tendsto_at_top H 0 c with ‚ü®n, -, hn‚ü©
exact lt_irrefl _ (hn.trans_le (h n))
intros
simp only [continuous_at, tendsto_nhds_bot_iff_real, nhds_prod_eq, bot_add_coe]
assume r
rw eventually_prod_iff
refine ‚ü®Œª z, z < ((r - (a + 1): ‚Ñù) : ereal), Iio_mem_nhds (bot_lt_coe _), Œª z, z < ((a + 1 : ‚Ñù) : ereal), Iio_mem_nhds (by simp [-coe_add, zero_lt_one]), Œª x hx y hy, _‚ü©
dsimp
convert add_lt_add hx hy
dsimp
ring
intros
simp only [subtype_restr_def, trans_symm_eq_symm_trans_symm]
have openness‚ÇÅ : is_open (f.target ‚à© f.symm ‚Åª¬π' s) := f.preimage_open_of_open_symm s.2
rw [‚Üê of_set_trans _ openness‚ÇÅ, ‚Üê trans_assoc, ‚Üê trans_assoc]
refine eq_on_source.trans' _ (eq_on_source_refl _)
have sets_identity : f.symm.source ‚à© (f.target ‚à© (f.symm) ‚Åª¬π' s) = f.symm.source ‚à© f.symm ‚Åª¬π' s
{ mfld_set_tac }
mfld_set_tac
have openness‚ÇÇ : is_open (s : set Œ±) := s.2
rw [of_set_trans', sets_identity, ‚Üê trans_of_set' _ openness‚ÇÇ, trans_assoc]
refine eq_on_source.trans' (eq_on_source_refl _) _
refine setoid.trans (trans_symm_self s.local_homeomorph_subtype_coe) _
simp only with mfld_simps
intros
simpa only [dist_comm] using tendsto_dist_right_cocompact_at_top x
intros
simpa only [not_iff_not] using dist_eq_zero
intros
rw [‚Üê ball_union_sphere, set.union_diff_cancel_right sphere_disjoint_ball.symm]
intros
ext y
simp only [emetric.mem_ball, mem_ball, edist_dist]
exact ennreal.of_real_lt_of_real_iff_of_nonneg dist_nonneg
intros
haveI := hsc.complete_space_coe
rcases hf.exists_fixed_point ‚ü®x, hxs‚ü© hx with ‚ü®y, hfy, h_tendsto, hle‚ü©
refine ‚ü®y, y.2, subtype.ext_iff_val.1 hfy, _, Œª n, _‚ü©
convert (continuous_subtype_coe.tendsto _).comp h_tendsto
{ convert (continuous_subtype_coe.tendsto _).comp h_tendsto, ext n, simp only [(‚àò), maps_to.iterate_restrict, maps_to.coe_restrict_apply, subtype.coe_mk] }
ext n
simp only [(‚àò), maps_to.iterate_restrict, maps_to.coe_restrict_apply, subtype.coe_mk]
convert hle n
{ convert hle n, rw [maps_to.iterate_restrict, eq_comm, maps_to.coe_restrict_apply, subtype.coe_mk] }
rw [maps_to.iterate_restrict, eq_comm, maps_to.coe_restrict_apply, subtype.coe_mk]
intros
rw [emetric.ball_eq_empty_iff]
intros
rcases ne with ‚ü®x, xs‚ü©
have : inf_edist x ‚àÖ ‚â§ Hausdorff_edist s ‚àÖ := inf_edist_le_Hausdorff_edist_of_mem xs
simpa using this
intros
simp [Hausdorff_edist_zero_iff_closure_eq_closure.symm, Hausdorff_dist, ennreal.to_real_eq_zero_iff, fin]
intros
rw ‚Üê Œ≥.extend_range
simp only [range_subset_iff, set_coe.exists, set_coe.forall]
intros x hx
simp only [has_coe_to_fun.coe, coe_fn, path.truncate, mem_range_self]
intros
simp [lower_semicontinuous_on, lower_semicontinuous, lower_semicontinuous_within_at_univ_iff]
intros
rcases compact_compact_separated (hK.diff hU) (hK.diff hV) (by rwa [diff_inter_diff, diff_eq_empty]) with ‚ü®O‚ÇÅ, O‚ÇÇ, h1O‚ÇÅ, h1O‚ÇÇ, h2O‚ÇÅ, h2O‚ÇÇ, hO‚ü©
refine ‚ü®_, _, hK.diff h1O‚ÇÅ, hK.diff h1O‚ÇÇ, by rwa [diff_subset_comm], by rwa [diff_subset_comm], by rw [‚Üê diff_inter, hO, diff_empty]‚ü©
intros
letI : topological_space Œ± := ‚ä• ; exact { inj := ultrafilter_pure_injective, ..dense_inducing_pure }
letI : topological_space Œ± := ‚ä•
exact { inj := ultrafilter_pure_injective, ..dense_inducing_pure }
intros
ext ‚ü®x, y‚ü©
simp_rw [mem_closure_iff_nhds_basis (uniform_space.has_basis_nhds_prod x y), mem_Inter, mem_set_of_eq]
apply forall_congr
intro V
apply forall_congr
rintros ‚ü®V_in, V_symm‚ü©
simp_rw [mem_comp_comp V_symm, inter_comm, exists_prop]
exact iff.rfl
intros
split
rintro ‚ü®‚ü®h‚ü©, h'‚ü©
{ rintro ‚ü®‚ü®h‚ü©, h'‚ü©, rw [eq_comm, filter.ext_iff] at h, simp [*, subset_def] }
rw [eq_comm, filter.ext_iff] at h
simp [*, subset_def]
rintro ‚ü®h, h'‚ü©
{ rintro ‚ü®h, h'‚ü©, refine uniform_embedding.mk ‚ü®_‚ü© h, rw [eq_comm, filter.ext_iff], simp [*, subset_def] }
refine uniform_embedding.mk ‚ü®_‚ü© h
rw [eq_comm, filter.ext_iff]
simp [*, subset_def]
intros
rw [interleave_eq s‚ÇÅ s‚ÇÇ]
refl
intros
rw ‚Üê bind_pure_comp_eq_map _ (x.run st)
change (x >>= pure ‚àò f).run st = _
simp
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
rw [int.add_comm a c, int.add_comm b c]
exact (int.add_lt_add_left h c)
intros
have h := int.add_le_add_left h a
rwa [‚Üê int.add_sub_assoc, int.add_comm a c, int.add_sub_cancel] at h
intros
have := congr_arg bodd (mod_add_div n 2)
simp [bnot] at this
rw [show ‚àÄ b, ff && b = ff, by intros; cases b; refl, show ‚àÄ b, bxor b ff = b, by intros; cases b; refl] at this
rw [‚Üê this]
cases mod_two_eq_zero_or_one n with h h; rw h; refl
cases mod_two_eq_zero_or_one n with h h; rw h
cases mod_two_eq_zero_or_one n with h h
rw h
refl
rw h
refl
intros
rw [nat.mul_comm, nat.mul_one]
intros
rw [nat.add_comm n k, nat.add_comm m k]
apply nat.add_le_add_left h
intros
tactic.mk_inj_eq
intros
ext
{ ext, simp only [linear_map.id_coe, one_mul, id.def, lmul_left_apply] }
simp only [linear_map.id_coe, one_mul, id.def, lmul_left_apply]
intros
{ ext, simp, }
ext
simp
intros
simp only [sum_eq_multiset_sum, multiset.sum_map_singleton]
intros
classical
let s := {x | p x}.to_finset
rw [‚Üê finset.prod_subtype s, ‚Üê finset.prod_subtype s·∂ú]
{ exact finset.prod_mul_prod_compl _ _ }
exact finset.prod_mul_prod_compl _ _
{ simp }
simp
{ simp }
simp
intros
rw finset.prod_map
exact finset.prod_congr rfl h
intros
haveI := classical.dec_eq Œ±; exact finset.induction_on s (by simp) (Œª a s has ih, by rw [prod_insert has, card_insert_of_not_mem has, pow_succ, ih])
haveI := classical.dec_eq Œ±
exact finset.induction_on s (by simp) (Œª a s has ih, by rw [prod_insert has, card_insert_of_not_mem has, pow_succ, ih])
intros
rw [finprod_mem_def, finprod_mem_def, mul_indicator_inter_mul_support]
intros
{ classical, rw finprod_mem_finset_product', simp, }
classical
rw finprod_mem_finset_product'
simp
intros
simp only [div_eq_mul_inv, csupr_mul hf]
intros
apply coevaluation_apply_one K V
intros
apply G.mk_eq
obtain ‚ü®k, f, g, hfg‚ü© := h
use [k, f, g]
rw [monoid_hom.map_inv, monoid_hom.map_inv, inv_inj]
exact hfg
intros
simp only [squash_gcf, (squash_seq_nth_of_lt m_lt_n)]
intros
simpa
intros
rcases hu with ‚ü®u, rfl‚ü©
{ rcases hu with ‚ü®u, rfl‚ü©, apply units.coe_dvd, }
apply units.coe_dvd
intros
simpa using div_sub_div b a one_ne_zero hc
intros
classical
revert h
apply s.induction_on
{ simp }
simp
intros b s bs hi h
rw [gcd_insert, gcd_insert, gcd_comm (f b), ‚Üê gcd_assoc, hi (Œª x hx, h _ (mem_insert_of_mem hx)), gcd_comm a, gcd_assoc, gcd_comm a (gcd_monoid.gcd _ _), gcd_comm (g b), gcd_assoc _ _ a, gcd_comm _ a]
exact congr_arg _ (gcd_eq_of_dvd_sub_right (h _ (mem_insert_self _ _)))
intros
simp [h.symm]
intros
{ rw [sub_eq_add_neg, sub_eq_add_neg], exact add_left_inj _ }
rw [sub_eq_add_neg, sub_eq_add_neg]
exact add_left_inj _
intros
rw [‚Üê sub_eq_add_neg, add_sub_cancel'_right a b]
intros
rintros ‚ü®‚ü© ‚ü®‚ü© h
congr'
congr'; injection h
injection h
injection h
injection h
intros
rw [‚Üêunits.coe_one, eq_iff]
intros
rw [div_eq_mul_one_div, one_div_div, ‚Üê mul_div_assoc]
intros
{ rw C.shape, simpa using i.succ_succ_ne_one.symm }
rw C.shape
simpa using i.succ_succ_ne_one.symm
intros
rw ‚Üêkernel_subobject_arrow'
{ rw ‚Üêkernel_subobject_arrow', simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A], }
simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A]
intros
dsimp [d_from, X_next_iso]
rw c.next_eq_some r
refl
intros
{ dsimp [cycles], simp, }
dsimp [cycles]
simp
intros
dsimp [homology_functor]
apply eq_of_sub_eq_zero
apply eq_of_sub_eq_zero
ext
simp only [homology.œÄ_map, comp_zero, preadditive.comp_sub]
dsimp [kernel_subobject_map]
simp_rw [h.comm i]
simp only [zero_add, zero_comp, d_next_eq_d_from_from_next, kernel_subobject_arrow_comp_assoc, preadditive.comp_add]
rw [‚Üêpreadditive.sub_comp]
simp only [category_theory.subobject.factor_thru_add_sub_factor_thru_right]
erw [subobject.factor_thru_of_le (D.boundaries_le_cycles i)]
{ simp, }
simp
rw [prev_d_eq_to_prev_d_to, ‚Üêcategory.assoc]
{ rw [prev_d_eq_to_prev_d_to, ‚Üêcategory.assoc], apply image_subobject_factors_comp_self, }
apply image_subobject_factors_comp_self
intros
{ ext, simp }
ext
simp
intros
by_cases hs : a ‚àà s; by_cases ht : a ‚àà t; simp *
by_cases hs : a ‚àà s; by_cases ht : a ‚àà t
by_cases hs : a ‚àà s
by_cases ht : a ‚àà t
simp *
simp *
by_cases ht : a ‚àà t
simp *
simp *
intros
rw [‚Üêmul_assoc, inv_of_mul_self, one_mul]
intros
simp [sub_eq_add_neg]
intros
ext x
simpa only [lie_subalgebra.mem_normalizer_iff, lie_subalgebra.mem_top, iff_true] using Œª y hy, I.lie_mem hy
intros
simp [skew_adjoint_matrices_lie_subalgebra_equiv]
intros
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, I.incl.ker_coe_submodule, lie_submodule.bot_coe_submodule, incl_coe, submodule.ker_subtype]
intros
simp only [zero_root_subalgebra, mem_weight_space, mem_pre_weight_space, pi.zero_apply, sub_zero, set_like.mem_coe, zero_smul, lie_submodule.mem_coe_submodule, submodule.mem_carrier, lie_subalgebra.mem_mk_iff]
intros
{ intros f g h, ext, exact linear_map.congr_fun h x }
intros f g h
ext
exact linear_map.congr_fun h x
intros
rcases x with ‚ü®x, xm‚ü©
rcases y with ‚ü®y, ym‚ü©
congr
rw (submodule.eq_bot_iff _).mp rfl x xm
rw (submodule.eq_bot_iff _).mp rfl y ym
intros
simp
intros
unfold cmp cmp_using
by_cases a < b; simp [h]
by_cases a < b
simp [h]
simp [h]
by_cases h‚ÇÇ : b < a; simp [h‚ÇÇ, gt]
by_cases h‚ÇÇ : b < a
simp [h‚ÇÇ, gt]
simp [h‚ÇÇ, gt]
exact (decidable.lt_or_eq_of_le (le_of_not_gt h‚ÇÇ)).resolve_left h
intros
rwa [lt_div_iff' ha, ‚Üê div_eq_mul_one_div, div_lt_one (ha.trans h)]
intros
simp [division_def, mul_nonneg_iff]
intros
simp [div_eq_mul_inv]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_lt_inv_mul_iff, mul_comm]
exact mul_lt_mul_of_lt_of_lt hab hcd
intros
obtain ‚ü®c, hc‚ü© := le_iff_exists_mul.1 h.le
refine ‚ü®c, one_lt_iff_ne_one.2 _, hc.symm‚ü©
rintro rfl
simpa [hc, lt_irrefl] using h
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Iio]
split
rintro ‚ü®a_w, a_h_left, rfl‚ü©
{ rintro ‚ü®a_w, a_h_left, rfl‚ü©, exact (mul_le_mul_left hr).mpr a_h_left, }
exact (mul_le_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (div_le_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (div_le_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
have : ‚àÄx, ‚àÉa b : Œ±, a * b = x := Œªx, ‚ü®x, ‚ü®1, mul_one x‚ü©‚ü©
simpa only [mem_mul, eq_univ_iff_forall, mem_univ, true_and]
intros
ext x
refine ‚ü®_, Œª h, ‚ü®x, 1, h, s.one_mem, mul_one x‚ü©‚ü©
rintros ‚ü®a, b, ha, hb, rfl‚ü©
exact s.mul_mem ha hb
intros
rw [‚Üê polynomial.coeff_smul, prod_X_sub_smul.smul]
intros
refine ‚ü®_, is_right_regular.pow n‚ü©
rw [‚Üê nat.succ_pred_eq_of_pos n0, pow_succ]
exact is_right_regular.of_mul
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h], }
by_cases h : P
simp [h]
simp [h]
intros
ext
rcases mk_ring_hom_surjective r x with ‚ü®x, rfl‚ü©
exact (ring_hom.congr_fun w x : _)
intros
let S := {s ‚àà finset.range (n + 1) | s ‚à£ n ‚àß ‚àÉ x, s = x ^ 2}
have hSne : S.nonempty
use 1
{ use 1, have h1 : 0 < n ‚àß ‚àÉ (x : ‚Ñï), 1 = x ^ 2 := ‚ü®hn, ‚ü®1, (one_pow 2).symm‚ü©‚ü©, simpa [S] }
have h1 : 0 < n ‚àß ‚àÉ (x : ‚Ñï), 1 = x ^ 2 := ‚ü®hn, ‚ü®1, (one_pow 2).symm‚ü©‚ü©
simpa [S]
let s := finset.max' S hSne
have hs : s ‚àà S := finset.max'_mem S hSne
simp only [finset.sep_def, S, finset.mem_filter, finset.mem_range] at hs
obtain ‚ü®hsn1, ‚ü®a, hsa‚ü©, ‚ü®b, hsb‚ü©‚ü© := hs
rw hsa at hn
obtain ‚ü®hlts, hlta‚ü© := canonically_ordered_comm_semiring.mul_pos.mp hn
rw hsb at hsa hn hlts
refine ‚ü®a, b, hlta, (pow_pos_iff zero_lt_two).mp hlts, hsa.symm, _‚ü©
rintro x ‚ü®y, hy‚ü©
rw nat.is_unit_iff
by_contra hx
refine lt_le_antisymm _ (finset.le_max' S ((b * x) ^ 2) _)
simp_rw [S, hsa, finset.sep_def, finset.mem_filter, finset.mem_range]
{ simp_rw [S, hsa, finset.sep_def, finset.mem_filter, finset.mem_range], refine ‚ü®lt_succ_iff.mpr (le_of_dvd hn _), _, ‚ü®b * x, rfl‚ü©‚ü©; use y; rw hy; ring }
refine ‚ü®lt_succ_iff.mpr (le_of_dvd hn _), _, ‚ü®b * x, rfl‚ü©‚ü©
refine ‚ü®lt_succ_iff.mpr (le_of_dvd hn _), _, ‚ü®b * x, rfl‚ü©‚ü©; use y; rw hy; ring
refine ‚ü®lt_succ_iff.mpr (le_of_dvd hn _), _, ‚ü®b * x, rfl‚ü©‚ü©; use y; rw hy
refine ‚ü®lt_succ_iff.mpr (le_of_dvd hn _), _, ‚ü®b * x, rfl‚ü©‚ü©; use y
use y
use y
rw hy
rw hy
ring
ring
use y
use y
rw hy
rw hy
ring
ring
convert lt_mul_of_one_lt_right hlts (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr ‚ü®Œª h, by simp * at *, hx‚ü©))
{ convert lt_mul_of_one_lt_right hlts (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr ‚ü®Œª h, by simp * at *, hx‚ü©)), rw mul_pow }
rw mul_pow
intros
simpa [support_single, hb, hb'] using ne_comm
intros
refine ext (Œª x, ‚ü®Œª hx, ‚ü®‚ü®map C x.val, (is_prime_map_C_of_is_prime x.property)‚ü©, ‚ü®_, _‚ü©‚ü©, _‚ü©)
rw [mem_compl_eq, mem_zero_locus, singleton_subset_iff]
{ rw [mem_compl_eq, mem_zero_locus, singleton_subset_iff], cases hx with i hi, exact Œª a, hi (mem_map_C_iff.mp a i) }
cases hx with i hi
exact Œª a, hi (mem_map_C_iff.mp a i)
refine subtype.ext (ext (Œª x, ‚ü®Œª h, _, Œª h, subset_span (mem_image_of_mem C.1 h)‚ü©))
{ refine subtype.ext (ext (Œª x, ‚ü®Œª h, _, Œª h, subset_span (mem_image_of_mem C.1 h)‚ü©)), rw ‚Üê @coeff_C_zero R x _, exact mem_map_C_iff.mp h 0 }
rw ‚Üê @coeff_C_zero R x _
exact mem_map_C_iff.mp h 0
rintro ‚ü®xli, complement, rfl‚ü©
{ rintro ‚ü®xli, complement, rfl‚ü©, exact comap_C_mem_image_of_Df complement }
exact comap_C_mem_image_of_Df complement
intros
rw set.eq_empty_iff_forall_not_mem
intros x hx
rw mem_zero_locus at hx
have x_prime : x.as_ideal.is_prime := by apply_instance
have eq_top : x.as_ideal = ‚ä§
rw ideal.eq_top_iff_one
{ rw ideal.eq_top_iff_one, exact hx h }
exact hx h
apply x_prime.ne_top eq_top
intros
rw [‚Üê stalk_map.congr Œ± Œ≤ h x x rfl, eq_to_hom_refl, category.comp_id]
intros
rw mem_emetric_ball_zero_iff at hx
refine summable_of_nonneg_of_le (Œª _, norm_nonneg _) (Œª n, ((p n).le_op_norm _).trans_eq _) (p.summable_norm_mul_pow hx)
simp
intros
rw ‚Üê change_origin_index_equiv.symm.summable_iff
dsimp only [(‚àò), change_origin_index_equiv_symm_apply_fst, change_origin_index_equiv_symm_apply_snd_fst]
have : ‚àÄ n : ‚Ñï, has_sum (Œª s : finset (fin n), ‚à•p (n - s.card + s.card)‚à•‚Çä * r ^ s.card * r' ^ (n - s.card)) (‚à•p n‚à•‚Çä * (r + r') ^ n)
intro n
{ intro n, convert_to has_sum (Œª s : finset (fin n), ‚à•p n‚à•‚Çä * (r ^ s.card * r' ^ (n - s.card))) _, { ext1 s, rw [nat.sub_add_cancel (card_finset_fin_le _), mul_assoc] }, rw ‚Üê fin.sum_pow_mul_eq_add_pow, exact (has_sum_fintype _).mul_left _ }
convert_to has_sum (Œª s : finset (fin n), ‚à•p n‚à•‚Çä * (r ^ s.card * r' ^ (n - s.card))) _
{ ext1 s, rw [nat.sub_add_cancel (card_finset_fin_le _), mul_assoc] }
ext1 s
rw [nat.sub_add_cancel (card_finset_fin_le _), mul_assoc]
rw ‚Üê fin.sum_pow_mul_eq_add_pow
exact (has_sum_fintype _).mul_left _
refine nnreal.summable_sigma.2 ‚ü®Œª n, (this n).summable, _‚ü©
simp only [(this _).tsum_eq]
exact p.summable_nnnorm_mul_pow hr
intros
have := (hc.has_fderiv_within_at.clm_comp hd.has_fderiv_within_at).has_deriv_within_at
rwa [add_apply, comp_apply, comp_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw fderiv_within_of_open hs hx, refl }
unfold deriv_within
rw fderiv_within_of_open hs hx
refl
intros
rcases eq_or_ne y x with rfl|hne
{ exact has_deriv_at_of_has_deriv_at_of_ne f_diff hf hg }
exact has_deriv_at_of_has_deriv_at_of_ne f_diff hf hg
{ exact f_diff y hne }
exact f_diff y hne
intros
simp only [has_fderiv_at_filter, continuous_linear_map.coe_pi]
exact is_o_pi
intros
simpa only [smul_zero, zero_add] using hc.smul (has_fderiv_within_at_const f x s)
intros
{ simp only [has_fderiv_within_at, nhds_within_univ], refl }
simp only [has_fderiv_within_at, nhds_within_univ]
refl
intros
simpa only [implicit_to_local_homeomorph_of_complemented_self] using ((hf.implicit_to_local_homeomorph_of_complemented f f' hf' hker).map_source $ (hf.mem_implicit_to_local_homeomorph_of_complemented_source hf' hker))
intros
rw eventually_iff_exists_mem at *
rcases hff' with ‚ü®s‚ÇÅ, hs‚ÇÅ, hff'‚ü©
rcases hgg' with ‚ü®s‚ÇÇ, hs‚ÇÇ, hgg'‚ü©
rcases hg' with ‚ü®s‚ÇÉ, hs‚ÇÉ, hg'‚ü©
let s := s‚ÇÅ ‚à© s‚ÇÇ ‚à© s‚ÇÉ
have hs : s ‚àà at_bot := inter_mem (inter_mem hs‚ÇÅ hs‚ÇÇ) hs‚ÇÉ
rw mem_at_bot_sets at hs
rcases hs with ‚ü®l, hl‚ü©
have hl' : Iio l ‚äÜ s := Œª x hx, hl x (le_of_lt hx)
refine lhopital_zero_at_bot_on_Iio _ _ (Œª x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv
refine lhopital_zero_at_bot_on_Iio _ _ (Œª x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv; intros x hx; apply_assumption; exact (hl' hx).1.1 <|> exact (hl' hx).1.2
refine lhopital_zero_at_bot_on_Iio _ _ (Œª x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv; intros x hx; apply_assumption
refine lhopital_zero_at_bot_on_Iio _ _ (Œª x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv; intros x hx
intros x hx
apply_assumption
exact (hl' hx).1.1
intros x hx
apply_assumption
exact (hl' hx).1.2
exact (hl' hx).1.1
intros
simp [exp_neg_inv_glue, hx]
intros
rw ‚Üê h.zero_eq x
{ rw ‚Üê h.zero_eq x, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
symmetry
exact continuous_multilinear_map.uncurry0_curry0 _
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_at_const
intros
rcases h 1 hn with ‚ü®u, hu, p, H‚ü©
rcases mem_nhds_within.1 hu with ‚ü®t, t_open, xt, tu‚ü©
rw inter_comm at tu
have := ((H.mono tu).differentiable_on (le_refl _)) x ‚ü®mem_insert x s, xt‚ü©
exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 this
intros
split
rintro hz
{ rintro hz, obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := (convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz), obtain rfl | hb' := hb.eq_or_lt, { rw add_zero at hab, rw [hab, one_mul, zero_mul, add_zero] at hz, exact (hz.1.ne rfl).elim }, { exact ‚ü®a, b, ha, hb', hab, rfl‚ü© } }
obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := (convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)
obtain rfl | hb' := hb.eq_or_lt
rw add_zero at hab
{ rw add_zero at hab, rw [hab, one_mul, zero_mul, add_zero] at hz, exact (hz.1.ne rfl).elim }
rw [hab, one_mul, zero_mul, add_zero] at hz
exact (hz.1.ne rfl).elim
{ exact ‚ü®a, b, ha, hb', hab, rfl‚ü© }
exact ‚ü®a, b, ha, hb', hab, rfl‚ü©
rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
{ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©, obtain rfl | ha' := ha.eq_or_lt, { rw zero_add at hab, rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc] }, { exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ‚ü®a, b, ha', hb, hab, rfl‚ü©) } }
obtain rfl | ha' := ha.eq_or_lt
rw zero_add at hab
{ rw zero_add at hab, rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc] }
rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc]
exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ‚ü®a, b, ha', hb, hab, rfl‚ü©)
{ exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ‚ü®a, b, ha', hb, hab, rfl‚ü©) }
intros
rw [center_mass, sum_singleton, sum_singleton, ‚Üê mul_smul, inv_mul_cancel hw, one_smul]
intros
rw [‚Üê neg_convex_on_iff, neg_neg f]
intros
rcases hn with ‚ü®n, rfl‚ü©
induction n with n ihn
simp
{ simp }
rw [nat.succ_eq_add_one, mul_add, mul_one, bit0, ‚Üê add_assoc, finset.prod_range_succ, finset.prod_range_succ, mul_assoc]
refine mul_nonneg ihn _
generalize : (1 + 1) * n = k
cases le_or_lt m k with hmk hmk
have : m ‚â§ k + 1
{ have : m ‚â§ k + 1, from hmk.trans (lt_add_one ‚Üëk).le, exact mul_nonneg_of_nonpos_of_nonpos (sub_nonpos.2 hmk) (sub_nonpos.2 this) }
from hmk.trans (lt_add_one ‚Üëk).le
exact mul_nonneg_of_nonpos_of_nonpos (sub_nonpos.2 hmk) (sub_nonpos.2 this)
exact mul_nonneg (sub_nonneg.2 hmk.le) (sub_nonneg.2 hmk)
{ exact mul_nonneg (sub_nonneg.2 hmk.le) (sub_nonneg.2 hmk) }
intros
rw ext_iff
exact ‚ü®by simp only [of_real_re]; refl, by simp only [inner_self_nonneg_im, of_real_im]‚ü©
intros
rw [‚Üênorm_sq_eq_inner]; exact pow_nonneg (norm_nonneg x) 2
rw [‚Üênorm_sq_eq_inner]
exact pow_nonneg (norm_nonneg x) 2
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
rw ‚Üê add_right_inj (finrank ùïú K)
{ rw ‚Üê add_right_inj (finrank ùïú K), simp [submodule.finrank_add_finrank_orthogonal, h_dim] }
simp [submodule.finrank_add_finrank_orthogonal, h_dim]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, vadd_vsub_vadd_cancel_left]
intros
simpa only [‚Üê dist_zero_right] using dist_pi_const a 0
intros
rw [edist_eq_coe_nnnorm_sub, _root_.sub_zero]
intros
rwa [‚Üê sub_eq_zero, ‚Üê norm_le_zero_iff]
intros
obtain ‚ü®q, hq‚ü© : ‚àÉ q, is_compl p q := p.exists_is_compl
haveI : finite_dimensional ùïú q := (p.quotient_equiv_of_is_compl q hq).finite_dimensional
exact closed_complemented_of_closed_compl hq hp q.closed_of_finite_dimensional
intros
simp only [coe_sum, finset.sum_apply]
intros
intros a h
replace h : ‚àÉ y : f.ker, to_compl (y : G) = a
simpa using h
simpa using h
rcases h with ‚ü®‚ü®g, g_in : g ‚àà f.ker‚ü©, rfl‚ü©
rw f.mem_ker at g_in
change f.completion (g : completion G) = 0
simp [normed_group_hom.mem_ker, f.completion_coe g, g_in, completion.coe_zero]
intros
ext
ext; simp
simp
simp
simp
simp
intros
rw div_eq_inv_mul
{ rw div_eq_inv_mul, exact (has_strict_deriv_at_log h‚ÇÇ).has_deriv_at.comp_has_deriv_within_at x h‚ÇÅ }
exact (has_strict_deriv_at_log h‚ÇÇ).has_deriv_at.comp_has_deriv_within_at x h‚ÇÅ
intros
{ rw exp_log_eq_abs hx.ne', exact abs_of_pos hx }
rw exp_log_eq_abs hx.ne'
exact abs_of_pos hx
intros
simpa using integral_sin_pow_mul_cos_pow_odd 0 1
convert tendsto_rpow_div_mul_add (-(1:‚Ñù)) _ (0:‚Ñù) zero_ne_one
{ convert tendsto_rpow_div_mul_add (-(1:‚Ñù)) _ (0:‚Ñù) zero_ne_one, ring_nf }
ring_nf
intros
cases x
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz
rcases lt_trichotomy y 0 with Hy|Hy|Hy
{ rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg] }
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
by_cases h : x = 0
{ by_cases h : x = 0, { rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg] }, { have : x ^ y ‚â† 0, by simp [h], simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, nnreal.rpow_mul] } }
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz
rcases lt_trichotomy y 0 with Hy|Hy|Hy
{ rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg] }
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
have : x ^ y ‚â† 0
{ have : x ^ y ‚â† 0, by simp [h], simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, nnreal.rpow_mul] }
simp [h]
simp [h]
simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, nnreal.rpow_mul]
intros
convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz
{ convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
intros
simpa only [(‚àò), div_eq_inv_mul, mul_one] using (has_deriv_at_sqrt hx).comp x hf
simp
intros
rw [tan_eq_sin_div_cos, tan_eq_sin_div_cos]
exact div_lt_div (sin_lt_sin_of_lt_of_le_pi_div_two (by linarith) (le_of_lt hy‚ÇÇ) hxy) (cos_le_cos_of_nonneg_of_le_pi hx‚ÇÅ (by linarith) (le_of_lt hxy)) (sin_nonneg_of_nonneg_of_le_pi (by linarith) (by linarith)) (cos_pos_of_mem_Ioo ‚ü®by linarith, hy‚ÇÇ‚ü©)
intros
simp only [sin, div_eq_mul_inv, neg_mul_eq_neg_mul]
convert (((has_strict_deriv_at_id x).mul_const I).cexp.add ((has_strict_deriv_at_id x).neg.mul_const I).cexp).mul_const (2:‚ÑÇ)‚Åª¬π
simp only [function.comp, id]
ring
intros
simpa only [mul_zero] using tendsto_const_nhds.mul tendsto_inverse_at_top_nhds_0_nat
intros
rw sub_def
conv_lhs { congr, congr, rw ‚Üêcategory.comp_id a, skip, rw (show 0 = a ‚â´ (0 : Y ‚ü∂ Y), by simp)}
rw [‚Üê prod.comp_lift, category.assoc, lift_œÉ, category.comp_id]
intros
rw [‚Üê equiv.eq_symm_apply]; simp [-hom_equiv_unit]
rw [‚Üê equiv.eq_symm_apply]
simp [-hom_equiv_unit]
intros
split
intros Z a b w
replace w := congr_arg (Œª k, f ‚â´ k) w
dsimp at w
rw [‚Üêcategory.assoc, ‚Üêcategory.assoc] at w
exact (cancel_epi _).1 w
intros
{ symmetry, ext, assumption, }
symmetry
ext
assumption
intros
dsimp [limit_obj_iso_limit_comp_evaluation]
rw iso.inv_comp_eq
simp
intros
simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
dsimp
simp
intros
rw [h.hom_lift f, h.hom_lift f']; congr; exact funext w
rw [h.hom_lift f, h.hom_lift f']; congr
rw [h.hom_lift f, h.hom_lift f']
congr
exact funext w
intros
{ rw ‚Üê coprod.map_desc, simp }
rw ‚Üê coprod.map_desc
simp
intros
tidy
intros
{ ext, simp, }
ext
simp
intros
apply (cancel_mono (Œª_ X').hom).1
simp only [assoc, comp_id, iso.inv_hom_id]
rw [left_unitor_naturality, ‚Üêcategory.assoc, iso.inv_hom_id, category.id_comp]
intros
simp [of_components]
intros
apply quotient.induction_on' x
intro f
apply quotient.sound
exact ‚ü®mono_over.map_id.app f‚ü©
intros
{ simp [kernel_subobject_iso_comp], }
simp [kernel_subobject_iso_comp]
intros
{ ext, dsimp, simp }
ext
dsimp
simp
intros
{ rw ‚Üênot_lt, simp [lt_singleton_iff_mem_lt] }
rw ‚Üênot_lt
simp [lt_singleton_iff_mem_lt]
intros
convert finset.order_emb_of_fin_last rfl c.card_boundaries_pos
exact le_antisymm (finset.le_max' _ _ c.last_mem) (fin.le_last _)
intros
{ ext, simp [adj_comm] }
ext
simp [adj_comm]
intros
simp [common_neighbors]
intros
ext x
split
rintro ‚ü®S, rfl, h‚ü©
{ rintro ‚ü®S, rfl, h‚ü©, refine ‚ü®S.filter (Œª l, ¬¨list.empty l), by simp, Œª y hy, _‚ü©, rw [list.mem_filter, list.empty_iff_eq_nil] at hy, exact ‚ü®h y hy.1, hy.2‚ü© }
refine ‚ü®S.filter (Œª l, ¬¨list.empty l), by simp, Œª y hy, _‚ü©
rw [list.mem_filter, list.empty_iff_eq_nil] at hy
exact ‚ü®h y hy.1, hy.2‚ü©
rintro ‚ü®S, hx, h‚ü©
{ rintro ‚ü®S, hx, h‚ü©, exact ‚ü®S, hx, Œª y hy, (h y hy).1‚ü© }
exact ‚ü®S, hx, Œª y hy, (h y hy).1‚ü©
intros
refine (list_blank.cons_head_tail _).symm.trans _
simp only [list_blank.head_map, list_blank.head_cons, list_blank.tail_map, list_blank.tail_cons]
intros
rw [‚Üê pure_seq_eq_map, Œ∑.preserves_seq]; simp with functor_norm
rw [‚Üê pure_seq_eq_map, Œ∑.preserves_seq]
simp with functor_norm
intros
delta of_equiv
delta of_equiv; simp
simp
intros
cases v with xs h
ext1
change vector.to_list _ = xs
dsimp [bitvec.to_nat,bits_to_nat]
rw ‚Üê list.length_reverse at h
rw [‚Üê list.reverse_reverse xs,list.foldl_reverse]
generalize_hyp : xs.reverse = ys at ‚ä¢ h
clear xs
induction ys generalizing n
{ cases h, simp [bitvec.of_nat] }
cases h
simp [bitvec.of_nat]
simp only [‚Üênat.succ_eq_add_one, list.length] at h
{ simp only [‚Üênat.succ_eq_add_one, list.length] at h, subst n, simp only [bitvec.of_nat, vector.to_list_cons, vector.to_list_nil, list.reverse_cons, vector.to_list_append, list.foldr], erw [add_lsb_div_two, to_bool_add_lsb_mod_two], congr, apply ys_ih, refl }
subst n
simp only [bitvec.of_nat, vector.to_list_cons, vector.to_list_nil, list.reverse_cons, vector.to_list_append, list.foldr]
erw [add_lsb_div_two, to_bool_add_lsb_mod_two]
congr
apply ys_ih
refl
intros
cases l with hd tl
{ simpa using h' }
simpa using h'
have hi : i < ([hd].to_buffer.append_list tl).size := by simpa [add_comm] using h
{ have hi : i < ([hd].to_buffer.append_list tl).size := by simpa [add_comm] using h, convert_to ([hd].to_buffer.append_list tl).read ‚ü®i, hi‚ü© = _, cases i, { convert read_append_list_left _ _ _, simp }, { rw list.nth_le, convert read_append_list_right _ _ _, simp [nat.succ_eq_add_one, add_comm] } }
convert_to ([hd].to_buffer.append_list tl).read ‚ü®i, hi‚ü© = _
cases i
convert read_append_list_left _ _ _
{ convert read_append_list_left _ _ _, simp }
simp
rw list.nth_le
{ rw list.nth_le, convert read_append_list_right _ _ _, simp [nat.succ_eq_add_one, add_comm] }
convert read_append_list_right _ _ _
simp [nat.succ_eq_add_one, add_comm]
intros
cases p cb n; simp
cases p cb n
simp
simp
intros
simp_rw [any_char]
split_ifs with h; simp [‚Üênot_lt, h, eq_comm]
split_ifs with h
simp [‚Üênot_lt, h, eq_comm]
simp [‚Üênot_lt, h, eq_comm]
intros
simp [many1, seq_eq_fail]
intros
simp [lt_def]
intros
simp [exp_near]
intros
have h1 : x + 2 * x = 3 * x
ring
ring
rw [‚Üê h1, sinh_add x (2 * x)]
simp only [cosh_two_mul, sinh_two_mul]
have h2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2
ring
ring
rw [h2, cosh_sq]
ring
intros
rw [‚Üê of_real_tan_of_real_re, of_real_im]
intros
rw [mul_comm, I_im _]
intros
{ ext, simp [ite_add_zero] }
ext
simp [ite_add_zero]
intros
{ ext ‚ü®a, b‚ü© : 1, simp }
ext ‚ü®a, b‚ü© : 1
simp
intros
ext
{ ext, refl }
refl
intros
{ convert perm.subtype_congr.right_apply _ _ a.property, simp }
convert perm.subtype_congr.right_apply _ _ a.property
simp
intros
{ cases k, refl, }
cases k
refl
intros
refine ‚ü®h.target_eq, eq_on_of_left_inv_on_of_right_inv_on e.left_inv_on _ _‚ü©
refine ‚ü®h.target_eq, eq_on_of_left_inv_on_of_right_inv_on e.left_inv_on _ _‚ü©; simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
exact e'.right_inv_on.congr_right e'.symm_maps_to (h.source_eq ‚ñ∏ h.eq_on.symm)
simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
intros
simp only [succ_above_below _ _ h, cast_lt_cast_succ]
intros
rw [reverse_induction]; simp
rw [reverse_induction]
simp
intros
{ dunfold strong_induction_on, rw strong_induction }
dunfold strong_induction_on
rw strong_induction
intros
simp [finset.nonempty]
intros
{ ext, simp }
ext
simp
intros
rw [‚Üê infi_coe, coe_image, infi_image, infi_coe]
intros
refine ‚ü®congr_arg prod.fst, (Œª h, prod.ext h ((add_right_inj q.fst).mp _))‚ü©
rw mem_antidiagonal at hp hq
rw [hq, ‚Üê h, hp]
intros
simp [order_emb_of_fin_apply, max'_eq_sorted_last, h]
intros
ext x
ext x; simp only [equiv_map_domain_apply, coe_zero, pi.zero_apply]
simp only [equiv_map_domain_apply, coe_zero, pi.zero_apply]
intros
refine ‚ü®Œª h, h.symm ‚ñ∏ ‚ü®support_single_subset, single_eq_same‚ü©, _‚ü©
rintro ‚ü®h, rfl‚ü©
ext x
by_cases hx : a = x; simp only [hx, single_eq_same, single_eq_of_ne, ne.def, not_false_iff]
by_cases hx : a = x
simp only [hx, single_eq_same, single_eq_of_ne, ne.def, not_false_iff]
simp only [hx, single_eq_same, single_eq_of_ne, ne.def, not_false_iff]
exact not_mem_support_iff.1 (mt (Œª hx, (mem_singleton.1 (h hx)).symm) hx)
intros
ext s
by_cases hs : s = a
{ rw [hs, erase_same, single_eq_of_ne (h.symm)] }
rw [hs, erase_same, single_eq_of_ne (h.symm)]
{ rw [erase_ne hs] }
rw [erase_ne hs]
intros
{ ext, simp [finsupp.single_apply, dfinsupp.single_apply] }
ext
simp [finsupp.single_apply, dfinsupp.single_apply]
intros
{ ext y, simp [eq_or_ne] }
ext y
simp [eq_or_ne]
intros
{ rw ‚Üê finset.prod_subtype, simp }
rw ‚Üê finset.prod_subtype
simp
intros
rw [foldl, as_list, list.foldl_join, ‚Üê array.to_list_foldl]
intros
subst eq; refl
subst eq
refl
intros
lift a to ‚Ñï using ha
lift b to ‚Ñï using hb
norm_cast
intros
rw [‚Üê int.coe_nat_mul, nat_abs_mul_self]
intros
rcases nat_abs_eq z with eq | eq; rw eq; simp [coe_nat_dvd]
rcases nat_abs_eq z with eq | eq; rw eq
rcases nat_abs_eq z with eq | eq
rw eq
simp [coe_nat_dvd]
rw eq
simp [coe_nat_dvd]
intros
rw [abs_eq_nat_abs, sign_mul_nat_abs]
intros
rw int.gcd at h ‚ä¢; rwa int.nat_abs_neg
rw int.gcd at h ‚ä¢
rwa int.nat_abs_neg
intros
rw [not_even_iff, odd_iff]
intros
rw ‚Üê h; apply take'_left
rw ‚Üê h
apply take'_left
intros
rw [split_on_p, split_on_p_aux_nil]
suffices : ‚àÄ xs, join (zip_with (++) (split_on_p_aux' p as xs) ((as.filter p).map(Œª x, [x]) ++ [[]])) = xs ++ as
{ rw this, refl }
rw this
refl
induction as; intro; simp! only [split_on_p_aux', append_nil]
induction as; intro
induction as
intro
simp! only [split_on_p_aux', append_nil]
intro
simp! only [split_on_p_aux', append_nil]
split_ifs; simp [zip_with, join, *]
split_ifs
simp [zip_with, join, *]
simp [zip_with, join, *]
intros
induction l with a l IH
refl
{refl}
cases h : f a with b
rw [filter_map_cons_none _ _ h, filter_map_cons_none, IH]
{ rw [filter_map_cons_none _ _ h, filter_map_cons_none, IH], simp only [h, option.none_bind'] }
simp only [h, option.none_bind']
rw filter_map_cons_some _ _ _ h
cases h' : g b with c; [ rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH], rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH] ]; simp only [h, h', option.some_bind']
cases h' : g b with c; [ rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH], rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH] ]
cases h' : g b with c
rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH]
simp only [h, h', option.some_bind']
rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH]
simp only [h, h', option.some_bind']
intros
convert filter_eq_nil.2 (Œª _ _, id)
intros
induction s
refl
case list.sublist.slnil { refl }
case list.sublist.cons : l‚ÇÅ l‚ÇÇ a s IH { by_cases h : p a; simp [h], exacts [IH.trans (erasep_sublist _), IH.cons _ _ _] }
case list.sublist.cons2 : l‚ÇÅ l‚ÇÇ a s IH { by_cases h : p a; simp [h], exacts [s, IH.cons2 _ _ _] }
intros
induction l‚ÇÅ with x l‚ÇÅ IH; [exact (zero_mul _).symm, simp only [length, product_cons, length_append, IH, right_distrib, one_mul, length_map, add_comm]]
induction l‚ÇÅ with x l‚ÇÅ IH
exact (zero_mul _).symm
simp only [length, product_cons, length_append, IH, right_distrib, one_mul, length_map, add_comm]
intros
cases as; refl
cases as
refl
refl
intros
induction l; [refl, simp only [*, reverse_cons, reverse_append]]; refl
induction l; [refl, simp only [*, reverse_cons, reverse_append]]
induction l
refl
simp only [*, reverse_cons, reverse_append]
refl
intros
cases l
{ cases h, }
cases h
{ simpa }
simpa
intros
cases l; simp [prev, hx]
cases l
simp [prev, hx]
simp [prev, hx]
intros
induction xs with y ys IH
{ simpa using h }
simpa using h
cases ys with z zs
{ simpa using h }
simpa using h
by_cases hx : x = y
{ by_cases hx : x = y, { simp [hx] }, { rw [next_or_cons_of_ne _ _ _ _ hx] at h, simpa [hx] using IH h } }
{ simp [hx] }
simp [hx]
rw [next_or_cons_of_ne _ _ _ _ hx] at h
{ rw [next_or_cons_of_ne _ _ _ _ hx] at h, simpa [hx] using IH h }
simpa [hx] using IH h
intros
rw [mfoldl_with_index, mfoldl_eq_foldl, foldl_with_index_eq_foldl_enum]
intros
dunfold Ico
convert range'_append _ _ _
{ exact (nat.add_sub_of_le hnm).symm }
exact (nat.add_sub_of_le hnm).symm
{ rwa [‚Üê nat.add_sub_assoc hnm, nat.sub_add_cancel] }
rwa [‚Üê nat.add_sub_assoc hnm, nat.sub_add_cancel]
intros
induction l
case list.nil { simp }
simp
case list.cons : x xs l_ih { by_cases h‚ÇÅ : x ‚àà t‚ÇÅ, { have h‚ÇÇ : x ‚àâ t‚ÇÇ := h h‚ÇÅ, simp * }, by_cases h‚ÇÇ : x ‚àà t‚ÇÇ, { simp only [*, inter_cons_of_not_mem, false_or, mem_append, inter_cons_of_mem, not_false_iff], transitivity, { apply perm.cons _ l_ih, }, change [x] ++ xs ‚à© t‚ÇÅ ++ xs ‚à© t‚ÇÇ ~ xs ‚à© t‚ÇÅ ++ ([x] ++ xs ‚à© t‚ÇÇ), rw [‚Üê list.append_assoc], solve_by_elim [perm.append_right, perm_append_comm] }, { simp * } }
intros
simp only [enum_eq_zip_range, unzip_zip, length_range]
intros
refine ‚ü®Œª h, _, Œª h, by simp [h]‚ü©
rw [eq_comm, ‚Üêis_rotated_nil_iff', ‚Üêmem_cyclic_permutations_iff, h, mem_singleton]
intros
rw [sublists_len, ‚Üê sublists_len_aux_append]; refl
rw [sublists_len, ‚Üê sublists_len_aux_append]
refl
intros
simp only [unzip_eq_map, map_map]; split; refl
simp only [unzip_eq_map, map_map]; split
simp only [unzip_eq_map, map_map]
split
intros
{ ext, apply dot_product_add }
ext
apply dot_product_add
intros
simp [diagonal]
intros
simp [dot_product]
intros
{ ext i j, simp [vec_mul_vec, mul_apply], refl }
ext i j
simp [vec_mul_vec, mul_apply]
refl
intros
refine fin.cases _ _ i; simp
{ refine fin.cases _ _ i; simp }
refine fin.cases _ _ i
simp
simp
intros
{ ext i, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
rw [inter_comm]
revert s
refine multiset.induction_on t (by simp) (Œª a t IH s, _)
by_cases a ‚àà s
rw [cons_inter_of_pos _ h, sub_cons, add_cons, IH, cons_erase h]
{ rw [cons_inter_of_pos _ h, sub_cons, add_cons, IH, cons_erase h] }
rw [cons_inter_of_neg _ h, sub_cons, erase_of_not_mem h, IH]
{ rw [cons_inter_of_neg _ h, sub_cons, erase_of_not_mem h, IH] }
intros
rw [add_comm, erase_add_left_pos s h, add_comm]
intros
simp [ndinter, h]
intros
{ rw ‚Üê comp_eval‚ÇÇ_hom, refl }
rw ‚Üê comp_eval‚ÇÇ_hom
refl
intros
ext : 2; simp
{ ext : 2; simp }
ext : 2
simp
simp
intros
simp only [degrees, mv_polynomial.support_map_of_injective _ hf]
intros
split
rintro ‚ü®k, h1k, h2k‚ü© ‚ü®l, rfl‚ü©
{ rintro ‚ü®k, h1k, h2k‚ü© ‚ü®l, rfl‚ü©, rw [mul_lt_mul_left hn] at h1k h2k, rw [lt_succ_iff, ‚Üê not_lt] at h2k, exact h2k h1k }
rw [mul_lt_mul_left hn] at h1k h2k
rw [lt_succ_iff, ‚Üê not_lt] at h2k
exact h2k h1k
intro h
{ intro h, rw [dvd_iff_mod_eq_zero, ‚Üê ne.def, ‚Üê pos_iff_ne_zero] at h, simp only [‚Üê mod_add_div m n] {single_pass := tt}, refine ‚ü®m / n, lt_add_of_pos_left _ h, _‚ü©, rw [add_comm _ 1, left_distrib, mul_one], exact add_lt_add_right (mod_lt _ hn) _ }
rw [dvd_iff_mod_eq_zero, ‚Üê ne.def, ‚Üê pos_iff_ne_zero] at h
simp only [‚Üê mod_add_div m n] {single_pass := tt}
refine ‚ü®m / n, lt_add_of_pos_left _ h, _‚ü©
rw [add_comm _ 1, left_distrib, mul_one]
exact add_lt_add_right (mod_lt _ hn) _
intros
rw [eq_comm, nat.mul_eq_zero]
intros
conv {to_lhs, rw [‚Üê one_mul(m)]}
exact decidable.mul_le_mul_of_nonneg_right (nat.succ_le_of_lt h) dec_trivial
intros
set v := lxor a (lxor b c) with hv
have hab : lxor a b = lxor c v
{ rw hv, conv_rhs { rw lxor_comm, simp [lxor_assoc] } }
rw hv
conv_rhs { rw lxor_comm, simp [lxor_assoc] }
have hac : lxor a c = lxor b v
rw hv
{ rw hv, conv_rhs { congr, skip, rw lxor_comm }, rw [‚Üêlxor_assoc, ‚Üêlxor_assoc, lxor_self, zero_lxor, lxor_comm] }
conv_rhs { congr, skip, rw lxor_comm }
rw [‚Üêlxor_assoc, ‚Üêlxor_assoc, lxor_self, zero_lxor, lxor_comm]
have hbc : lxor b c = lxor a v
{ simp [hv, ‚Üêlxor_assoc] }
simp [hv, ‚Üêlxor_assoc]
obtain ‚ü®i, ‚ü®hi, hi'‚ü©‚ü© := exists_most_significant_bit h
have : test_bit a i = tt ‚à® test_bit b i = tt ‚à® test_bit c i = tt
contrapose! hi
{ contrapose! hi, simp only [eq_ff_eq_not_eq_tt, ne, test_bit_lxor] at ‚ä¢ hi, rw [hi.1, hi.2.1, hi.2.2, bxor_ff, bxor_ff] }
simp only [eq_ff_eq_not_eq_tt, ne, test_bit_lxor] at ‚ä¢ hi
rw [hi.1, hi.2.1, hi.2.2, bxor_ff, bxor_ff]
rcases this with h|h|h; [{ left, rw hbc }, { right, left, rw hac }, { right, right, rw hab }]; exact lt_of_test_bit i (by simp [h, hi]) h (Œª j hj, by simp [hi' _ hj])
rcases this with h|h|h; [{ left, rw hbc }, { right, left, rw hac }, { right, right, rw hab }]
rcases this with h|h|h
left
rw hbc
exact lt_of_test_bit i (by simp [h, hi]) h (Œª j hj, by simp [hi' _ hj])
right
left
rw hac
exact lt_of_test_bit i (by simp [h, hi]) h (Œª j hj, by simp [hi' _ hj])
right
right
rw hab
exact lt_of_test_bit i (by simp [h, hi]) h (Œª j hj, by simp [hi' _ hj])
intros
{ ext, rw pi.nat_apply }
ext
rw pi.nat_apply
intros
rw [‚Üêcast_desc_factorial_two, desc_factorial_eq_factorial_mul_choose, factorial_two, mul_comm, cast_mul, cast_two, eq_div_iff_mul_eq (two_ne_zero' : (2 : K) ‚â† 0)]
intros
convert of_digits_lt_base_pow_length' (Œª _, digits_lt_base')
rw of_digits_digits (b+2) m
intros
rw pow_succ
exact nat.mul_lt_mul (nat.add_lt_add_right (nat.lt_add_of_pos_right succ_pos') 1) (pow_succ_le_asc_factorial n _) (pow_pos succ_pos' _)
intros
wlog h : m ‚â§ n using [n m, m n]
exact le_total m n
apply gcd.induction m n
{ apply gcd.induction m n, { simp }, intros m n mpos h, rw ‚Üê gcd_rec m n at h, conv_rhs { rw ‚Üê mod_add_div' n m }, rwa [gcd_fib_add_mul_self m (n % m) (n / m), gcd_comm (fib m) _] }
{ simp }
simp
intros m n mpos h
rw ‚Üê gcd_rec m n at h
conv_rhs { rw ‚Üê mod_add_div' n m }
rwa [gcd_fib_add_mul_self m (n % m) (n / m), gcd_comm (fib m) _]
rwa [gcd_comm, gcd_comm (fib m)]
intros
by_cases a_split : (a = 0)
subst a_split
{ subst a_split, rw zero_dvd_iff at dvd, simpa [dvd] using cmn, }
rw zero_dvd_iff at dvd
simpa [dvd] using cmn
rcases dvd with ‚ü®k, rfl‚ü©
{ rcases dvd with ‚ü®k, rfl‚ü©, rw nat.mul_div_cancel_left _ (nat.pos_of_ne_zero a_split), exact coprime.coprime_mul_left cmn, }
rw nat.mul_div_cancel_left _ (nat.pos_of_ne_zero a_split)
exact coprime.coprime_mul_left cmn
intros
rw [clog, if_neg (Œª h : 1 < b ‚àß 1 < n, h.2.not_le hn)]
intros
rw [‚Üê nat.mul_right_inj hc0, ‚Üê @add_left_cancel_iff _ _ ((a + b) % c + a % c + b % c)]
suffices : (a + b) % c + c * ((a + b) / c) + a % c + b % c = a % c + c * (a / c) + (b % c + c * (b / c)) + c * (if c ‚â§ a % c + b % c then 1 else 0) + (a + b) % c
simpa only [mul_add, add_comm, add_left_comm, add_assoc]
{ simpa only [mul_add, add_comm, add_left_comm, add_assoc] }
rw [mod_add_div, mod_add_div, mod_add_div, mul_ite, add_assoc, add_assoc]
conv_lhs { rw ‚Üê add_mod_add_ite }
simp
ac_refl
intros
by_cases h‚ÇÅ : a < b‚ÇÅ; simp [mkpair, h‚ÇÅ, add_assoc]
by_cases h‚ÇÅ : a < b‚ÇÅ
simp [mkpair, h‚ÇÅ, add_assoc]
simp [mkpair, lt_trans h‚ÇÅ h, h]
{ simp [mkpair, lt_trans h‚ÇÅ h, h], exact mul_self_lt_mul_self h }
exact mul_self_lt_mul_self h
simp [mkpair, h‚ÇÅ, add_assoc]
by_cases h‚ÇÇ : a < b‚ÇÇ; simp [mkpair, h‚ÇÇ, h]
by_cases h‚ÇÇ : a < b‚ÇÇ
{ by_cases h‚ÇÇ : a < b‚ÇÇ; simp [mkpair, h‚ÇÇ, h], simp at h‚ÇÅ, rw [add_comm, add_comm _ a, add_assoc, add_lt_add_iff_left], rwa [add_comm, ‚Üê sqrt_lt, sqrt_add_eq], exact le_trans h‚ÇÅ (nat.le_add_left _ _) }
simp [mkpair, h‚ÇÇ, h]
simp at h‚ÇÅ
rw [add_comm, add_comm _ a, add_assoc, add_lt_add_iff_left]
rwa [add_comm, ‚Üê sqrt_lt, sqrt_add_eq]
exact le_trans h‚ÇÅ (nat.le_add_left _ _)
simp [mkpair, h‚ÇÇ, h]
intros
cases mod_two_eq_zero_or_one n with h h; simp [h]
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
rw [‚Üê not_lt, decidable.iff_not_comm, not_lt, size_le]
intros
induction n with n IH; [exact pp.not_dvd_one.elim h, by { rw pow_succ at h, exact (pp.dvd_mul.1 h).elim id IH } ]
induction n with n IH
exact pp.not_dvd_one.elim h
rw pow_succ at h
rw pow_succ at h
{ rw pow_succ at h, exact (pp.dvd_mul.1 h).elim id IH }
{ rw pow_succ at h, exact (pp.dvd_mul.1 h).elim id IH }
exact (pp.dvd_mul.1 h).elim id IH
exact (pp.dvd_mul.1 h).elim id IH
intros
rcases x with _ | _ | _ | x; simp
{ rcases x with _ | _ | _ | x; simp }
rcases x with _ | _ | _ | x
simp
simp
simp
simp
intros
cases t; [simp, simp [ht.1]]
cases t
simp
simp [ht.1]
intros
cases r; simp [rotate_l, rotate_r, dual_node']; split_ifs; simp [dual_node3_l, dual_node4_l]
cases r; simp [rotate_l, rotate_r, dual_node']; split_ifs
cases r; simp [rotate_l, rotate_r, dual_node']
cases r
simp [rotate_l, rotate_r, dual_node']
simp [rotate_l, rotate_r, dual_node']
split_ifs
simp [dual_node3_l, dual_node4_l]
simp [dual_node3_l, dual_node4_l]
intros
{ congr, exact h }
congr
exact h
intros
dsimp [of_set]; split_ifs; simp *
dsimp [of_set]; split_ifs
dsimp [of_set]
split_ifs
simp *
simp *
intros
induction n with n generalizing i
constructor
cases h : f i with y g
constructor
introv
apply n_ih
intros
ext x
apply bisim' (Œª x, true) _ _ _ _ trivial
clear x
intros x _
cases gxeq : g x with a f'
have h‚ÇÄ : M.dest (f x) = ‚ü®a, f ‚àò f'‚ü©
{ rw [hyp, gxeq, pfunctor.map_eq] }
rw [hyp, gxeq, pfunctor.map_eq]
have h‚ÇÅ : M.dest (M.corec g x) = ‚ü®a, M.corec g ‚àò f'‚ü©
{ rw [dest_corec, gxeq, pfunctor.map_eq], }
rw [dest_corec, gxeq, pfunctor.map_eq]
refine ‚ü®_, _, _, h‚ÇÄ, h‚ÇÅ, _‚ü©
intro i
exact ‚ü®f' i, trivial, rfl, rfl‚ü©
intros
dsimp [mod, mod_div]
cases (m : ‚Ñï) % (k : ‚Ñï)
{ rw [if_pos rfl], refl }
rw [if_pos rfl]
refl
{ rw [if_neg n.succ_ne_zero], refl }
rw [if_neg n.succ_ne_zero]
refl
intros
rw pnat.dvd_iff
{ rw pnat.dvd_iff, rw nat.dvd_prime pp, simp }
rw nat.dvd_prime pp
simp
intros
apply polynomial.induction_on p
{ intro r, rw eval‚ÇÇ_C, exact œÜ.commutes r }
intro r
rw eval‚ÇÇ_C
exact œÜ.commutes r
intros f g ih1 ih2
{ intros f g ih1 ih2, rw [œÜ.map_add, ih1, ih2, eval‚ÇÇ_add] }
rw [œÜ.map_add, ih1, ih2, eval‚ÇÇ_add]
intros n r ih
{ intros n r ih, rw [pow_succ', ‚Üê mul_assoc, œÜ.map_mul, eval‚ÇÇ_mul_noncomm (algebra_map R A) _ (Œª k, algebra.commutes _ _), eval‚ÇÇ_X, ih] }
rw [pow_succ', ‚Üê mul_assoc, œÜ.map_mul, eval‚ÇÇ_mul_noncomm (algebra_map R A) _ (Œª k, algebra.commutes _ _), eval‚ÇÇ_X, ih]
intros
simp [to_finsupp_iso, monomial, monomial_fun]
intros
rcases p
{ rcases p, simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.mul_single_zero_apply p a n] }
simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.mul_single_zero_apply p a n]
intros
rw [‚Üê C_1]; exact degree_C_le
rw [‚Üê C_1]
exact degree_C_le
intros
ext (_|n)
simp
{ simp }
rw [coeff_C, if_neg (nat.succ_ne_zero _), coeff_eq_zero_of_degree_lt]
exact h.trans_lt (with_bot.some_lt_some.2 n.succ_pos)
intros
by_cases p0 : p = 0
{ rw [p0, zero_mul] }
rw [p0, zero_mul]
exact nat_degree_mul_C_eq_of_mul_ne_zero (mul_ne_zero (leading_coeff_ne_zero.mpr p0) a0)
{ exact nat_degree_mul_C_eq_of_mul_ne_zero (mul_ne_zero (leading_coeff_ne_zero.mpr p0) a0) }
intros
simp [derivative_apply]
intros
by_cases f0 : f = 0
rw [‚Üê fc, f0, erase_lead_zero, support_zero, card_empty]
{ rw [‚Üê fc, f0, erase_lead_zero, support_zero, card_empty] }
rw [erase_lead_support, card_erase_of_mem (nat_degree_mem_support_of_nonzero f0), fc]
{ rw [erase_lead_support, card_erase_of_mem (nat_degree_mem_support_of_nonzero f0), fc], exact c.pred_eq_sub_one }
exact c.pred_eq_sub_one
intros
{ rw [eval_eq_sum, sum_over_range], simp }
rw [eval_eq_sum, sum_over_range]
simp
intros
rw [is_root.def, eval_sub, eval_X, eval_C, sub_eq_zero, eq_comm]
intros
simp [h]
intros
induction n with n ih
{ simp only [iterated_deriv_zero_right], }
simp only [iterated_deriv_zero_right]
{ simp only [iterated_deriv_succ, ih, derivative_add] }
simp only [iterated_deriv_succ, ih, derivative_add]
intros
split
{ exact h1 }
exact h1
intros g h fgh
{ intros g h fgh, let k := g * h.mirror, have key : f * f.mirror = k * k.mirror, { rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror, mul_assoc, ‚Üêmul_assoc] }, have g_dvd_f : g ‚à£ f, { rw fgh, exact dvd_mul_right g h }, have h_dvd_f : h ‚à£ f, { rw fgh, exact dvd_mul_left h g }, have g_dvd_k : g ‚à£ k, { exact dvd_mul_right g h.mirror }, have h_dvd_k_rev : h ‚à£ k.mirror, { rw [mirror_mul_of_domain, mirror_mirror], exact dvd_mul_left h g.mirror }, have hk := h2 k key, rcases hk with hk | hk | hk | hk, { exact or.inr (h3 h h_dvd_f (by rwa ‚Üê hk)) }, { exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg])) }, { exact or.inl (h3 g g_dvd_f (by rwa ‚Üê hk)) }, { exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg])) } }
let k := g * h.mirror
have key : f * f.mirror = k * k.mirror
rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror, mul_assoc, ‚Üêmul_assoc]
{ rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror, mul_assoc, ‚Üêmul_assoc] }
have g_dvd_f : g ‚à£ f
rw fgh
{ rw fgh, exact dvd_mul_right g h }
exact dvd_mul_right g h
have h_dvd_f : h ‚à£ f
rw fgh
{ rw fgh, exact dvd_mul_left h g }
exact dvd_mul_left h g
have g_dvd_k : g ‚à£ k
{ exact dvd_mul_right g h.mirror }
exact dvd_mul_right g h.mirror
have h_dvd_k_rev : h ‚à£ k.mirror
rw [mirror_mul_of_domain, mirror_mirror]
{ rw [mirror_mul_of_domain, mirror_mirror], exact dvd_mul_left h g.mirror }
exact dvd_mul_left h g.mirror
have hk := h2 k key
rcases hk with hk | hk | hk | hk
{ exact or.inr (h3 h h_dvd_f (by rwa ‚Üê hk)) }
exact or.inr (h3 h h_dvd_f (by rwa ‚Üê hk))
exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg]))
{ exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg])) }
{ exact or.inl (h3 g g_dvd_f (by rwa ‚Üê hk)) }
exact or.inl (h3 g g_dvd_f (by rwa ‚Üê hk))
{ exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg])) }
exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg]))
intros
by_cases hq : q = 0
suffices : 0 < p.nat_degree ‚Üî p.nat_degree ‚â† 0
{ suffices : 0 < p.nat_degree ‚Üî p.nat_degree ‚â† 0, { simpa [hq, ‚Üêh.nat_degree_eq_zero_iff_eq_one] }, exact ‚ü®Œª h, h.ne', Œª h, lt_of_le_of_ne (nat.zero_le _) h.symm ‚ü© }
{ simpa [hq, ‚Üêh.nat_degree_eq_zero_iff_eq_one] }
simpa [hq, ‚Üêh.nat_degree_eq_zero_iff_eq_one]
exact ‚ü®Œª h, h.ne', Œª h, lt_of_le_of_ne (nat.zero_le _) h.symm ‚ü©
{ simp [h.nat_degree_mul', hq] }
simp [h.nat_degree_mul', hq]
intros
rw [f.nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree, nat.add_sub_cancel]
intros
rw coe_int_eq_of_int; refl
rw coe_int_eq_of_int
refl
intros
rw [‚Üê cast_zero, cast_le]
intros
{ rw mul_comm, exact to_real_mul_top _ }
rw mul_comm
exact to_real_mul_top _
intros
simp
linarith [gold_add_gold_conj]
intros
rw [‚Üênnreal.coe_eq, nnreal.coe_sum, real.coe_to_nnreal _ (finset.sum_nonneg hf)]
exact finset.sum_congr rfl (Œª x hxs, by rw real.coe_to_nnreal _ (hf x hxs))
intros
rw [‚Üê mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h]
intros
rw [sqrt, ‚Üê real.le_to_nnreal_iff_coe_le hy, nnreal.sqrt_le_iff, ‚Üê real.to_nnreal_mul hy, real.to_nnreal_le_to_nnreal_iff (mul_self_nonneg y), sq]
intros
simp [set.preimage, function.graph, rel.preimage, rel.inv, flip, rel.image]
intros
haveI := h.terminates; exact ‚ü®think_mem h.mem, by rw [length_think, h.length]‚ü©
haveI := h.terminates
exact ‚ü®think_mem h.mem, by rw [length_think, h.length]‚ü©
intros
rw [‚Üêdiff_singleton_subset_iff]
intros
rw [‚Üê image_union, ‚Üê image_univ, ‚Üê union_compl_self]
intros
ext y
rcases em (y ‚àà range f) with ‚ü®x, rfl‚ü©|hx
{ simp [hf.eq_iff] }
simp [hf.eq_iff]
rw [mem_range, not_exists] at hx
{ rw [mem_range, not_exists] at hx, simp [hx] }
simp [hx]
intros
{ ext ‚ü®x, hx‚ü©, simp [inclusion] }
ext ‚ü®x, hx‚ü©
simp [inclusion]
intros
simp only [subset_def, or_imp_distrib, forall_and_distrib, forall_eq, mem_insert_iff]
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
rw [e.image_eq_preimage, e.symm.preimage_Ico, e.symm_symm]
intros
simp [‚Üê Ici_inter_Iio]
intros
simp [le_refl]
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
convert image_mul_right_Ioo b c h using 1; simp only [mul_comm _ a]
convert image_mul_right_Ioo b c h using 1
{ convert image_mul_right_Ioo b c h using 1; simp only [mul_comm _ a] }
simp only [mul_comm _ a]
simp only [mul_comm _ a]
intros
simp only [Union_and, @Union_comm _ Œπ]
intros
{ convert setoid.eqv_class_mem H, ext, rw setoid.comm' }
convert setoid.eqv_class_mem H
ext
rw setoid.comm'
intros
tidy
intros
refine funext (Œªj, j.cases' _ _); intros; refl
refine funext (Œªj, j.cases' _ _); intros
refine funext (Œªj, j.cases' _ _)
intros
refl
intros
refl
intros
ext
{ ext, rw [ideal.mem_span_singleton, ring_hom.mem_ker, int.coe_cast_ring_hom, int_coe_zmod_eq_zero_iff_dvd] }
rw [ideal.mem_span_singleton, ring_hom.mem_ker, int.coe_cast_ring_hom, int_coe_zmod_eq_zero_iff_dvd]
intros
rw zmod.val_min_abs_def_pos
split_ifs with h
exact h
{ exact h }
have : (x.val - n : ‚Ñ§) ‚â§ 0
{ rw [sub_nonpos, int.coe_nat_le], exact x.val_le, }
rw [sub_nonpos, int.coe_nat_le]
exact x.val_le
rw [‚Üê int.coe_nat_le, int.of_nat_nat_abs_of_nonpos this, neg_sub]
conv_lhs { congr, rw [‚Üê nat.mod_add_div n 2, int.coe_nat_add, int.coe_nat_mul, int.coe_nat_bit0, int.coe_nat_one] }
suffices : ((n % 2 : ‚Ñï) + (n / 2) : ‚Ñ§) ‚â§ (val x)
rw ‚Üê sub_nonneg at this ‚ä¢
{ rw ‚Üê sub_nonneg at this ‚ä¢, apply le_trans this (le_of_eq _), ring_nf, ring }
apply le_trans this (le_of_eq _)
ring_nf
ring
norm_cast
calc (n : ‚Ñï) % 2 + n / 2 ‚â§ 1 + n / 2 : nat.add_le_add_right (nat.le_of_lt_succ (nat.mod_lt _ dec_trivial)) _ ... ‚â§ x.val : by { rw add_comm, exact nat.succ_le_of_lt (lt_of_not_ge h) }
intros
rw div_eq_mul_inv
{ rw div_eq_mul_inv, exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy) }
exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy)
intros
simpa only [div_eq_mul_inv] using hs.mul_mem hx (hs.inv_mem hy)
intros
rw [‚Üê units_coe, ‚Üê coe_pow, ‚Üê units.coe_pow, translate_pow, units_coe]
intros
obtain ‚ü®x, xmem, hx‚ü© : ‚àÉ x ‚àà Icc (0:‚Ñù) 1, ‚àÄ y ‚àà Icc (0:‚Ñù) 1, f y - y ‚â§ f x - x
from is_compact_Icc.exists_forall_ge (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuous_on
refine lt_of_le_of_lt _ (sub_lt_iff_lt_add'.2 $ hz x)
apply translation_number_le_of_le_add
simp only [‚Üê sub_le_iff_le_add']
exact f.forall_map_sub_of_Icc (Œª a, a ‚â§ f x - x) hx
intros
simp_rw [mem_omega_limit_iff_frequently, map_cluster_pt_iff, singleton_inter_nonempty, mem_preimage]
intros
rw [‚Üê to_subalgebra_eq_iff, ‚Üê finrank_eq_finrank_subalgebra, subalgebra.finrank_eq_one_iff, bot_to_subalgebra]
intros
{ ext, refl }
ext
refl
intros
cases field.exists_primitive_element F E with Œ± hŒ±
let iso : F‚üÆŒ±‚üØ ‚âÉ‚Çê[F] E := { to_fun := Œª e, e.val, inv_fun := Œª e, ‚ü®e, by { rw hŒ±, exact intermediate_field.mem_top }‚ü©, left_inv := Œª _, by { ext, refl }, right_inv := Œª _, rfl, map_mul' := Œª _ _, rfl, map_add' := Œª _ _, rfl, commutes' := Œª _, rfl }
have H : is_integral F Œ± := is_galois.integral F Œ±
have h_sep : (minpoly F Œ±).separable := is_galois.separable F Œ±
have h_splits : (minpoly F Œ±).splits (algebra_map F E) := is_galois.splits F Œ±
replace h_splits : polynomial.splits (algebra_map F F‚üÆŒ±‚üØ) (minpoly F Œ±)
convert polynomial.splits_comp_of_splits (algebra_map F E) iso.symm.to_alg_hom.to_ring_hom h_splits
{ convert polynomial.splits_comp_of_splits (algebra_map F E) iso.symm.to_alg_hom.to_ring_hom h_splits }
rw ‚Üê linear_equiv.finrank_eq iso.to_linear_equiv
rw ‚Üê intermediate_field.adjoin_simple.card_aut_eq_finrank F E H h_sep h_splits
apply fintype.card_congr
apply equiv.mk (Œª œï, iso.trans (trans œï iso.symm)) (Œª œï, iso.symm.trans (trans œï iso))
intro œï
{ intro œï, ext1, simp only [trans_apply, apply_symm_apply] }
ext1
simp only [trans_apply, apply_symm_apply]
intro œï
{ intro œï, ext1, simp only [trans_apply, symm_apply_apply] }
ext1
simp only [trans_apply, symm_apply_apply]
intros
have h : is_integral A x
by_contra h
{ by_contra h, rw [eq_zero h, degree_zero, ‚Üêwith_bot.coe_one] at hx, exact (ne_of_lt (show ‚ä• < ‚Üë1, from with_bot.bot_lt_coe 1) hx) }
rw [eq_zero h, degree_zero, ‚Üêwith_bot.coe_one] at hx
exact (ne_of_lt (show ‚ä• < ‚Üë1, from with_bot.bot_lt_coe 1) hx)
have key := minpoly.aeval A x
rw [eq_X_add_C_of_degree_eq_one hx, (minpoly.monic h).leading_coeff, C_1, one_mul, aeval_add, aeval_C, aeval_X, ‚Üêeq_neg_iff_add_eq_zero, ‚Üêring_hom.map_neg] at key
exact ‚ü®-(minpoly A x).coeff 0, key.symm‚ü©
intros
apply orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero
intros c hc
rw [‚Üê neg_vsub_eq_vsub_rev, inner_neg_right, (orthogonal_projection_vsub_mem_direction_orthogonal s p c hc), neg_zero]
intros
rcases h‚ÇÅ.exists_mem with ‚ü®t, t_nhd, ht‚ü©
rw ‚Üê hG.lift_prop_within_at_inter' t_nhd at h ‚ä¢
exact hG.lift_prop_within_at_congr h (Œª y hy, ht hy.2) hx
intros
simp only [has_mfderiv_within_at, has_mfderiv_at, continuous_within_at_univ] with mfld_simps
intros
rw ‚Üê has_mfderiv_within_at_univ at *
exact has_mfderiv_within_at.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ
intros
simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]
intros
simpa only [h‚ÇÅ.left_id, h‚ÇÅ.right_id, h‚ÇÇ.left_id, h‚ÇÇ.right_id] using distrib e‚ÇÇ e‚ÇÅ e‚ÇÅ e‚ÇÇ
intros
cases w with ls h1 h2
induction ls with l ls ih
{ exact h_empty }
exact h_empty
cases l with i m
rw cons_eq_smul
exact h_smul _ _ _ (ih _ _)
intros
rw [‚Üêone_mul ‚Üë(_)‚Åª¬π, mul_inv_left, ‚ÜêH]
intros
split
intros H x y
{ intros H x y, split, { exact f.eq_of_eq hg }, { intro h, rw [‚Üêf.lift_eq hg, ‚Üêf.lift_eq hg] at h, exact H h }}
split
exact f.eq_of_eq hg
{ exact f.eq_of_eq hg }
intro h
{ intro h, rw [‚Üêf.lift_eq hg, ‚Üêf.lift_eq hg] at h, exact H h }
rw [‚Üêf.lift_eq hg, ‚Üêf.lift_eq hg] at h
exact H h
intros H z w h
{ intros H z w h, obtain ‚ü®x, hx‚ü© := f.surj z, obtain ‚ü®y, hy‚ü© := f.surj w, rw [‚Üêf.mk'_sec z, ‚Üêf.mk'_sec w], exact (mul_inv f.map_units).2 ((H _ _).2 $ (mul_inv hg).1 h) }
obtain ‚ü®x, hx‚ü© := f.surj z
obtain ‚ü®y, hy‚ü© := f.surj w
rw [‚Üêf.mk'_sec z, ‚Üêf.mk'_sec w]
exact (mul_inv f.map_units).2 ((H _ _).2 $ (mul_inv hg).1 h)
intros
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem hx
rw [next_nth_le _ hl, form_perm_apply_nth_le _ hl]
intros
classical
have h : ‚àÄ b : Œ±, b ‚àà œÉ.support·∂ú ‚Üî œÉ b = b := Œª b, by rw [finset.mem_compl, mem_support, not_not]
obtain ‚ü®b, hb1, hb2‚ü© := finset.exists_ne_of_one_lt_card (lt_of_lt_of_le hp.out.one_lt (nat.le_of_dvd (finset.card_pos.mpr ‚ü®a, (h a).mpr ha‚ü©) (nat.modeq_zero_iff_dvd.mp ((card_compl_support_modeq hœÉ).trans (nat.modeq_zero_iff_dvd.mpr hŒ±))))) a
exact ‚ü®b, (h b).mp hb1, hb2‚ü©
intros
revert f
apply cycle_induction_on _ g
{ simp }
simp
intros œÉ hœÉ f hf
{ intros œÉ hœÉ f hf, simp only [cycle_factors_finset_eq_singleton_self_iff.mpr hœÉ, mem_singleton] at hf ‚ä¢, simp [hf] }
simp only [cycle_factors_finset_eq_singleton_self_iff.mpr hœÉ, mem_singleton] at hf ‚ä¢
simp [hf]
intros œÉ œÑ hd hc hœÉ hœÑ f
{ intros œÉ œÑ hd hc hœÉ hœÑ f, simp_rw [hd.cycle_factors_finset_mul_eq_union, mem_union], rintro (hf | hf), { rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hœÉ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd.symm x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H) } }, { rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hœÑ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf) } } }
simp_rw [hd.cycle_factors_finset_mul_eq_union, mem_union]
rintro (hf | hf)
rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hœÉ hf]
{ rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hœÉ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd.symm x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H) } }
rw mem_cycle_factors_finset_iff at hf
{ rw mem_cycle_factors_finset_iff at hf, intro x, cases hd.symm x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } } }
intro x
cases hd.symm x with hx hx
exact or.inl hx
{ exact or.inl hx }
refine or.inr _
{ refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } }
by_cases hfx : f x = x
rw ‚Üêhfx
{ rw ‚Üêhfx, simpa [hx] using hfx.symm }
simpa [hx] using hfx.symm
rw mul_apply
{ rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction }
rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx
contradiction
{ exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H) }
exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H)
rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hœÑ hf]
{ rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hœÑ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf) } }
rw mem_cycle_factors_finset_iff at hf
{ rw mem_cycle_factors_finset_iff at hf, intro x, cases hd x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } } }
intro x
cases hd x with hx hx
exact or.inl hx
{ exact or.inl hx }
refine or.inr _
{ refine or.inr _, by_cases hfx : f x = x, { rw ‚Üêhfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction } }
by_cases hfx : f x = x
rw ‚Üêhfx
{ rw ‚Üêhfx, simpa [hx] using hfx.symm }
simpa [hx] using hfx.symm
rw mul_apply
{ rw mul_apply, rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx, contradiction }
rw ‚Üêhf.right _ (mem_support.mpr hfx) at hx
contradiction
{ exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf) }
exact Œª H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf)
intros
obtain ‚ü®‚ü®l', hp', hc', hd'‚ü©, hl‚ü© := trunc.exists_rep œÉ.trunc_cycle_factors
have ht : cycle_factors_finset œÉ = l'.to_finset
{ rw [cycle_factors_finset, ‚Üêhl, trunc.lift_mk] }
rw [cycle_factors_finset, ‚Üêhl, trunc.lift_mk]
rw ht
split
intro h
{ intro h, have hn' : l'.nodup := nodup_of_pairwise_disjoint_cycles hc' hd', have hperm : l ~ l' := list.perm_of_nodup_nodup_to_finset_eq hn hn' h.symm, refine ‚ü®_, _, _‚ü©, { exact Œª _ h, hc' _ (hperm.subset h)}, { rwa list.perm.pairwise_iff disjoint.symmetric hperm }, { rw [‚Üêhp', hperm.symm.prod_eq'], refine hd'.imp _, exact Œª _ _, disjoint.commute } }
have hn' : l'.nodup := nodup_of_pairwise_disjoint_cycles hc' hd'
have hperm : l ~ l' := list.perm_of_nodup_nodup_to_finset_eq hn hn' h.symm
refine ‚ü®_, _, _‚ü©
{ exact Œª _ h, hc' _ (hperm.subset h)}
exact Œª _ h, hc' _ (hperm.subset h)
{ rwa list.perm.pairwise_iff disjoint.symmetric hperm }
rwa list.perm.pairwise_iff disjoint.symmetric hperm
rw [‚Üêhp', hperm.symm.prod_eq']
{ rw [‚Üêhp', hperm.symm.prod_eq'], refine hd'.imp _, exact Œª _ _, disjoint.commute }
refine hd'.imp _
exact Œª _ _, disjoint.commute
rintro ‚ü®hc, hd, hp‚ü©
{ rintro ‚ü®hc, hd, hp‚ü©, refine list.to_finset_eq_of_perm _ _ _, refine list_cycles_perm_list_cycles _ hc' hc hd' hd, rw [hp, hp'] }
refine list.to_finset_eq_of_perm _ _ _
refine list_cycles_perm_list_cycles _ hc' hc hd' hd
rw [hp, hp']
intros
cases i with i hi
cases i
{ exact (h0 rfl).elim }
exact (h0 rfl).elim
exact is_cycle_fin_rotate.extend_domain _
intros
cases l with y l
{ simp }
simp
induction l with z l IH generalizing x y
{ simp }
simp
specialize IH x z (mt (mem_cons_of_mem y) h)
{ specialize IH x z (mt (mem_cons_of_mem y) h), simp only [not_or_distrib, mem_cons_iff] at h, simp [IH, swap_apply_of_ne_of_ne, h] }
simp only [not_or_distrib, mem_cons_iff] at h
simp [IH, swap_apply_of_ne_of_ne, h]
intros
simp
intros
rw ‚Üêfinset.card_disjoint_union
congr
{ congr, ext, simp [h.support_mul] }
ext
simp [h.support_mul]
{ simpa using h.disjoint_support }
simpa using h.disjoint_support
intros
rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]
intros
ext
simp only [coe_inf, set.inf_eq_inter, set.mem_mul, set.mem_inter_iff]
split
rintros ‚ü®y, z, ‚ü®hyA, hyB‚ü©, hz, rfl‚ü©
{ rintros ‚ü®y, z, ‚ü®hyA, hyB‚ü©, hz, rfl‚ü©, refine ‚ü®mul_mem A hyA (h hz), _‚ü©, exact ‚ü®y, z, hyB, hz, rfl‚ü© }
refine ‚ü®mul_mem A hyA (h hz), _‚ü©
exact ‚ü®y, z, hyB, hz, rfl‚ü©
rintros ‚ü®hyz, y, z, hy, hz, rfl‚ü©
refine ‚ü®y, z, ‚ü®_, hy‚ü©, hz, rfl‚ü©
suffices : (y * z) * z‚Åª¬π ‚àà A
simpa
{ simpa }
exact mul_mem A hyz (inv_mem A (h hz))
intros
rw [‚Üê neg_vsub_eq_vsub_rev, line_map_vsub_left, ‚Üê smul_neg, neg_vsub_eq_vsub_rev]
intros
rintros p ‚ü®p1, hp1, v, hv, hp‚ü©
rw hp
have hp1s1 : p1 ‚àà (s1 : set P) := set.mem_of_mem_of_subset hp1 h
refine vadd_mem_of_mem_direction _ hp1s1
have hs : vector_span k s ‚â§ s1.direction := vector_span_mono k h
rw set_like.le_def at hs
rw ‚Üêset_like.mem_coe
exact set.mem_of_mem_of_subset hv hs
intros
rw [‚Üêvadd_eq_add, affine_map.map_vadd, affine_combination_linear]
intros
split
intro h
{ intro h, rw [finset.centroid_eq_affine_combination_fintype, finset.centroid_eq_affine_combination_fintype] at h, have ha := (affine_independent_iff_indicator_eq_of_affine_combination_eq k s.points).1 s.independent _ _ _ _ (fs‚ÇÅ.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h‚ÇÅ) (fs‚ÇÇ.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h‚ÇÇ) h, simp_rw [finset.coe_univ, set.indicator_univ, function.funext_iff, finset.centroid_weights_indicator_def, finset.centroid_weights, h‚ÇÅ, h‚ÇÇ] at ha, ext i, replace ha := ha i, split, all_goals { intro hi, by_contradiction hni, simp [hi, hni] at ha, norm_cast at ha } }
rw [finset.centroid_eq_affine_combination_fintype, finset.centroid_eq_affine_combination_fintype] at h
have ha := (affine_independent_iff_indicator_eq_of_affine_combination_eq k s.points).1 s.independent _ _ _ _ (fs‚ÇÅ.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h‚ÇÅ) (fs‚ÇÇ.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h‚ÇÇ) h
simp_rw [finset.coe_univ, set.indicator_univ, function.funext_iff, finset.centroid_weights_indicator_def, finset.centroid_weights, h‚ÇÅ, h‚ÇÇ] at ha
ext i
replace ha := ha i
split
all_goals { intro hi, by_contradiction hni, simp [hi, hni] at ha, norm_cast at ha }
intro hi
by_contradiction hni
simp [hi, hni] at ha
norm_cast at ha
intro hi
by_contradiction hni
simp [hi, hni] at ha
norm_cast at ha
intro h
{ intro h, have hm : m‚ÇÅ = m‚ÇÇ, { subst h, simpa [h‚ÇÅ] using h‚ÇÇ }, subst hm, congr, exact h }
have hm : m‚ÇÅ = m‚ÇÇ
subst h
{ subst h, simpa [h‚ÇÅ] using h‚ÇÇ }
simpa [h‚ÇÅ] using h‚ÇÇ
subst hm
congr
exact h
intros
field_simp [sub_ne_zero.2 h.symm, ‚Üê sub_div_sub_smul_slope_add_sub_div_sub_smul_slope f a b c, line_map_apply_module]
intros
{ rw [span_le, comap_coe], exact preimage_mono (subset_span), }
rw [span_le, comap_coe]
exact preimage_mono (subset_span)
intros
have : disjoint ‚ä§ f.ker
rw [disjoint_ker, ‚Üê map_zero f]
rw [disjoint_ker, ‚Üê map_zero f]
{ rw [disjoint_ker, ‚Üê map_zero f], exact Œª x hx H, hf H }
{ rw [disjoint_ker, ‚Üê map_zero f], exact Œª x hx H, hf H }
exact Œª x hx H, hf H
exact Œª x hx H, hf H
simpa [disjoint]
intros
{ ext, refl }
ext
refl
intros
rw [‚Üê nat.sub_add_cancel hk, pow_add, mul_apply, hm, map_zero]
intros
ext y
simp_rw [mem_orthogonal_iff, linear_map.mem_ker, submodule.mem_span_singleton ]
split
{ exact Œª h, h x ‚ü®1, one_smul _ _‚ü© }
exact Œª h, h x ‚ü®1, one_smul _ _‚ü©
rintro h _ ‚ü®z, rfl‚ü©
{ rintro h _ ‚ü®z, rfl‚ü©, rw [is_ortho, smul_left, mul_eq_zero], exact or.intro_right _ h }
rw [is_ortho, smul_left, mul_eq_zero]
exact or.intro_right _ h
intros
induction x using clifford_algebra.induction
case h_grade0 : r { exact reverse.commutes _}
rw [reverse_Œπ]
case h_grade1 : x { rw [reverse_Œπ] }
case h_mul : x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ { rw [reverse.map_mul, mul_comm, hx‚ÇÅ, hx‚ÇÇ] }
case h_add : x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ { rw [reverse.map_add, hx‚ÇÅ, hx‚ÇÇ] }
intros
rw [basis.det_apply, basis.to_matrix_reindex', det_reindex_alg_equiv, basis.det_apply]
intros
rw [linear_map.range_eq_top.2 h, dim_top]
intros
haveI := classical.dec_eq Œπ
{ haveI := classical.dec_eq Œπ, rw [‚Üê coe_dual_basis, total_dual_basis] }
rw [‚Üê coe_dual_basis, total_dual_basis]
intros
rw ‚Üê @finrank_top K V at lt
exact lt_of_le_of_finrank_lt_finrank le_top lt
intros
by_cases h_cases: m < finrank K V
rw [‚Üênat.add_sub_of_le (nat.le_of_lt h_cases), add_comm, pow_add]
{ rw [‚Üênat.add_sub_of_le (nat.le_of_lt h_cases), add_comm, pow_add], apply linear_map.ker_le_ker_comp }
apply linear_map.ker_le_ker_comp
rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)]
{ rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)], exact le_refl _ }
exact le_refl _
intros
refine disjoint.mono (lsingle_range_le_ker_lapply _ _ $ disjoint_compl_right) (lsingle_range_le_ker_lapply _ _ $ disjoint_compl_right) (le_trans (le_infi $ assume i, _) infi_ker_lapply_le_bot)
classical
by_cases his : i ‚àà s
by_cases hit : i ‚àà t
{ by_cases hit : i ‚àà t, { exact (hs ‚ü®his, hit‚ü©).elim }, exact inf_le_of_right_le (infi_le_of_le i $ infi_le _ hit) }
{ exact (hs ‚ü®his, hit‚ü©).elim }
exact (hs ‚ü®his, hit‚ü©).elim
exact inf_le_of_right_le (infi_le_of_le i $ infi_le _ hit)
exact inf_le_of_left_le (infi_le_of_le i $ infi_le _ his)
intros
rw [basis, ‚Üê coe_eval_ring_hom, (eval_ring_hom y).map_prod, coe_eval_ring_hom, finset.prod_eq_zero (finset.mem_erase.2 ‚ü®h2, h1‚ü©)]
simp_rw [eval_mul, eval_sub, eval_C, eval_X, sub_self, mul_zero]
intros
apply hv.repr_eq
simp [finsupp.total_single, hx]
intros
rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
intros
have h := finite_field.matrix.charpoly_pow_card M
{ have h := finite_field.matrix.charpoly_pow_card M, rwa zmod.card at h, }
rwa zmod.card at h
intros
dsimp only [mem_set_of_eq]
rw [‚Üê map_top, ‚Üê supr_range_std_basis, map_supr]
congr
funext i
rw [‚Üê linear_map.range_comp, diagonal_comp_std_basis, ‚Üê range_smul']
intros
rw [‚Üênat.sub_add_cancel h, pow_add, mul_eq_mul, matrix.mul_assoc, mul_nonsing_inv, nat.sub_add_cancel h, matrix.mul_one]
simpa using ha.pow n
intros
rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_eq]
intros
induction L with t L IH
{ simp }
simp
simp [matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply]
{ simp [matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply], }
intros
{ ext m, simp, }
ext m
simp
intros
simp only [lift_aux, lift_add_hom, tprod, multilinear_map.coe_mk, tprod_coeff, free_add_monoid.lift_eval_of, one_smul, add_con.lift_mk']
intros
rw [ker, ‚Üê prod_bot, comap_prod_prod]; refl
rw [ker, ‚Üê prod_bot, comap_prod_prod]
refl
intros
ext
ext; refl
refl
intros
rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_right, polar_neg_right]
intros
rw [‚Üêrange_le_ker_iff, submodule.ker_mkq, submodule.range_subtype]
intros
simp only [vandermonde_apply, matrix.mul_apply, matrix.transpose_apply, mul_pow]
intros
rw [and_comm, iff_self_and]
intros
{ rw forall_swap, simp }
rw forall_swap
simp
intros
{ unfold extend, congr }
unfold extend
congr
intros
fsplit
rintro ‚ü®S, ‚ü®f‚ü©‚ü©
{ rintro ‚ü®S, ‚ü®f‚ü©‚ü©, exact small.mk' (e.symm.trans f), }
exact small.mk' (e.symm.trans f)
rintro ‚ü®S, ‚ü®f‚ü©‚ü©
{ rintro ‚ü®S, ‚ü®f‚ü©‚ü©, exact small.mk' (e.trans f), }
exact small.mk' (e.trans f)
intros
rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
exact measurable_set.sInter hSc (Œª t ht, (hSo t ht).measurable_set)
intros
haveI : encodable s := hs.to_encodable
simp only [infi_subtype']
exact ae_measurable_infi (Œª i, hf i)
intros
have : (s.singular_part Œº).to_jordan_decomposition = ‚ü®s.to_jordan_decomposition.pos_part.singular_part Œº, s.to_jordan_decomposition.neg_part.singular_part Œº, singular_part_mutually_singular s Œº‚ü©
refine jordan_decomposition.to_signed_measure_injective _
{ refine jordan_decomposition.to_signed_measure_injective _, rw to_signed_measure_to_jordan_decomposition, refl }
rw to_signed_measure_to_jordan_decomposition
refl
{ rw [total_variation, this] }
rw [total_variation, this]
intros
simp only [‚Üê pair_mk_mk, mk_coe_fn]
intros
have h_ss : ae_seq_set hf p ‚äÜ {x | ‚àÄ i, f i x = (hf i).mk (f i) x}
rw [ae_seq_set, ‚Üêcompl_compl {x | ‚àÄ i, f i x = (hf i).mk (f i) x}, set.compl_subset_compl]
{ rw [ae_seq_set, ‚Üêcompl_compl {x | ‚àÄ i, f i x = (hf i).mk (f i) x}, set.compl_subset_compl], refine set.subset.trans (set.compl_subset_compl.mpr (Œª x h, _)) (subset_to_measurable _ _), exact h.1, }
refine set.subset.trans (set.compl_subset_compl.mpr (Œª x h, _)) (subset_to_measurable _ _)
exact h.1
exact (h_ss hx i).symm
intros
ext1
refine eventually_eq.trans _ indicator_const_Lp_coe_fn.symm
refine (condexp_ind_ae_eq_condexp_ind_smul hm (hm s hs) hŒºs c).trans _
refine (condexp_ind_smul_ae_eq_smul hm (hm s hs) hŒºs c).trans _
rw [Lp_meas_coe, condexp_L2_indicator_of_measurable hm hs hŒºs (1 : ‚Ñù)]
refine (@indicator_const_Lp_coe_fn Œ± _ _ 2 Œº _ _ s (hm s hs) hŒºs (1 : ‚Ñù) _ _).mono (Œª x hx, _)
dsimp only
rw hx
by_cases hx_mem : x ‚àà s; simp [hx_mem]
by_cases hx_mem : x ‚àà s
simp [hx_mem]
simp [hx_mem]
intros
refine liminf_le_liminf_of_le (measure.ae_le_iff_absolutely_continuous.mpr hŒºŒΩ) _ _
is_bounded_default
all_goals { is_bounded_default, }
is_bounded_default
intros
simp_rw [of_real_norm_eq_lintegral, ‚Üê edist_eq_coe_nnnorm]
apply lintegral_congr_ae
filter_upwards [Lp.coe_fn_sub f g]
assume a ha
simp only [ha, pi.sub_apply]
intros
refine snorm_mono_ae (eventually_of_forall (Œª x, _))
suffices : ‚à•s.indicator f x‚à•‚Çä ‚â§ ‚à•f x‚à•‚Çä
{ exact nnreal.coe_mono this }
exact nnreal.coe_mono this
rw nnnorm_indicator_eq_indicator_nnnorm
exact s.indicator_le_self _ x
intros
rw [snorm_exponent_top, snorm_ess_sup]
refine ess_sup_congr_ae (h_lim.mono (Œª x hx, _))
rw tendsto.liminf_eq
rw ennreal.tendsto_coe
exact (continuous_nnnorm.tendsto (f_lim x)).comp hx
intros
rw [snorm', lintegral_const, ennreal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ‚â§ 1 / q)]
congr
rw ‚Üêennreal.rpow_mul
suffices hq_cancel : q * (1/q) = 1
rw [hq_cancel, ennreal.rpow_one]
rw [hq_cancel, ennreal.rpow_one]
rw [one_div, mul_inv_cancel (ne_of_lt hq_pos).symm]
intros
simp only [snorm, snorm', ennreal.one_to_real, ennreal.rpow_one, Lp.norm_def, if_false, ennreal.one_ne_top, one_ne_zero, _root_.div_one]
rw integral_eq_lintegral_of_nonneg_ae (eventually_of_forall (by simp [norm_nonneg])) (continuous_norm.measurable.comp_ae_measurable (Lp.ae_measurable f))
simp [of_real_norm_eq_coe_nnnorm]
intros
simp only [integral_symm b]
{ simp only [integral_symm b], exact (integral_has_deriv_within_at_of_tendsto_ae_right hf.symm hmeas ha).neg }
exact (integral_has_deriv_within_at_of_tendsto_ae_right hf.symm hmeas ha).neg
intros
{ simp only [interval_integral, integral_neg], abel }
simp only [interval_integral, integral_neg]
abel
intros
rw [‚Üê finset.mem_coe, coe_range, coe_restrict _ hs, mem_range_indicator]
intros
rw [integral_const, measure.restrict_apply_univ]
intros
by_cases hf : integrable f Œº
rw [set_to_fun_eq hT hf, set_to_fun_eq hT hf.neg, integrable.to_L1_neg, (L1.set_to_L1 hT).map_neg]
{ rw [set_to_fun_eq hT hf, set_to_fun_eq hT hf.neg, integrable.to_L1_neg, (L1.set_to_L1 hT).map_neg], }
rw [set_to_fun_undef hT hf, set_to_fun_undef hT, neg_zero]
{ rw [set_to_fun_undef hT hf, set_to_fun_undef hT, neg_zero], rwa [‚Üê integrable_neg_iff] at hf, }
rwa [‚Üê integrable_neg_iff] at hf
intros
by_cases p; simp [h, hf, measurable_set.empty]
{ by_cases p; simp [h, hf, measurable_set.empty] }
by_cases p
simp [h, hf, measurable_set.empty]
simp [h, hf, measurable_set.empty]
intros
rcases exists_compact_superset hK with ‚ü®F, h1F, h2F‚ü©
calc Œº.outer_measure K ‚â§ Œº.outer_measure (interior F) : outer_measure.mono' _ h2F ... ‚â§ Œº ‚ü®F, h1F‚ü© : by apply Œº.outer_measure_le ‚ü®interior F, is_open_interior‚ü© ‚ü®F, h1F‚ü© interior_subset ... < ‚ä§ : Œº.lt_top _
intros
simp only [haar_product, pi, forall_prop_of_true, mem_univ, mem_set_of_eq]
intros
have h : g - f =·µê[Œº.restrict s] (Œª x, real.to_nnreal (g x - f x))
from hfg.mono (Œª x hx, (real.coe_to_nnreal _ $ sub_nonneg.2 hx).symm)
rw [volume_region_between_eq_lintegral f_int.ae_measurable g_int.ae_measurable hs, integral_congr_ae h, lintegral_congr_ae, lintegral_coe_eq_integral _ ((integrable_congr h).mp (g_int.sub f_int))]
simpa only
intros
simp [filter.eventually_eq]
intros
simp [measure.trim]
intros
choose t hst ht hŒºt using Œª i, (Œº i).exists_measurable_superset_eq_trim s
replace hst := subset_Inter hst
replace ht := measurable_set.Inter ht
refine ‚ü®‚ãÇ i, t i, hst, ht, Œª i, le_antisymm _ _‚ü©
exacts [hŒºt i ‚ñ∏ (Œº i).mono (Inter_subset _ _), (mono' _ hst).trans_eq ((Œº i).trim_eq ht)]
intros
simp only [bind_on_support_apply, ennreal.coe_tsum (bind_on_support.summable p f b), dite_cast, ennreal.coe_mul, ennreal.coe_zero]
intros
simp only [infi, coe_Inf, set.bInter_range]
intros
set f : fin m.succ ‚Üí (fin d ‚Üí Fq) := Œª i j, (A i).coeff j
have : fintype.card (fin d ‚Üí Fq) < fintype.card (fin m.succ)
{ simpa using lt_of_le_of_lt hm (nat.lt_succ_self m) }
simpa using lt_of_le_of_lt hm (nat.lt_succ_self m)
obtain ‚ü®i‚ÇÄ, i‚ÇÅ, i_ne, i_eq‚ü© := fintype.exists_ne_map_eq_of_card_lt f this
use [i‚ÇÄ, i‚ÇÅ, i_ne]
ext j
by_cases hbj : degree b ‚â§ j
rw [coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj), coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj)]
{ rw [coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj), coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj)] }
rw not_le at hbj
apply congr_fun i_eq.symm ‚ü®j, _‚ü©
exact lt_of_lt_of_le (coe_lt_degree.mp hbj) hb
intros
refine of_no_dummies _ ((p.remap some - poly.proj none) * (p.remap some + poly.proj none)) (Œªv, _)
refine of_no_dummies _ ((p.remap some - poly.proj none) * (p.remap some + poly.proj none)) (Œªv, _); apply int.eq_nat_abs_iff_mul
apply int.eq_nat_abs_iff_mul
intros
rw [‚Üê erase_insert (proper_divisors.not_self_mem), ‚Üê divisors_eq_proper_divisors_insert_self_of_pos pp.pos, pp.divisors, insert_singleton_comm, erase_insert (Œª con, pp.ne_one (mem_singleton.1 con))]
intros
rw ‚Üê l_series_summable_iff_of_re_eq_re (complex.of_real_re z.re)
apply l_series_summable_of_bounded_of_one_lt_real h
exact hz
intros
induction i with i ih
dsimp [s, œâ, œâb]
{ dsimp [s, œâ, œâb], ext; { simp; refl, }, }
ext
ext; { simp; refl, }
{ simp; refl, }
simp
simp; refl
{ simp; refl, }
calc (s (i + 1) : X q) = ((s i)^2 - 2 : ‚Ñ§) : rfl ... = ((s i : X q)^2 - 2) : by push_cast ... = (œâ^(2^i) + œâb^(2^i))^2 - 2 : by rw ih ... = (œâ^(2^i))^2 + (œâb^(2^i))^2 + 2*(œâb^(2^i)*œâ^(2^i)) - 2 : by ring ... = (œâ^(2^i))^2 + (œâb^(2^i))^2 : by rw [‚Üêmul_pow œâb œâ, œâb_mul_œâ, one_pow, mul_one, add_sub_cancel] ... = œâ^(2^(i+1)) + œâb^(2^(i+1)) : by rw [‚Üêpow_mul, ‚Üêpow_mul, pow_succ']
{ calc (s (i + 1) : X q) = ((s i)^2 - 2 : ‚Ñ§) : rfl ... = ((s i : X q)^2 - 2) : by push_cast ... = (œâ^(2^i) + œâb^(2^i))^2 - 2 : by rw ih ... = (œâ^(2^i))^2 + (œâb^(2^i))^2 + 2*(œâb^(2^i)*œâ^(2^i)) - 2 : by ring ... = (œâ^(2^i))^2 + (œâb^(2^i))^2 : by rw [‚Üêmul_pow œâb œâ, œâb_mul_œâ, one_pow, mul_one, add_sub_cancel] ... = œâ^(2^(i+1)) + œâb^(2^(i+1)) : by rw [‚Üêpow_mul, ‚Üêpow_mul, pow_succ'] }
intros
unfold padic_val_rat; split_ifs; simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *
unfold padic_val_rat; split_ifs
unfold padic_val_rat
split_ifs
simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *
simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *
intros
have p : padic_val_rat p q = 0
exact_mod_cast @padic_val_nat_primes p q p_prime q_prime neq
{ exact_mod_cast @padic_val_nat_primes p q p_prime q_prime neq }
simp [padic_norm, p, q_prime.1.1, q_prime.1.ne_zero]
intros
simp [ext]
intros
conv_rhs at s { rw [‚Üêsup_inf_sdiff x y, sup_comm] }
rw sup_comm at s
conv_rhs at i { rw [‚Üêinf_inf_sdiff x y, inf_comm] }
rw inf_comm at i
exact (eq_of_inf_eq_sup_eq i s).symm
intros
rw [disjoint, disjoint, inf_comm]
intros
simp only [upper_bounds, eq_univ_iff_forall, mem_set_of_eq, ball_empty_iff, forall_true_iff]
intros
rw [Inf_eq_infi]; exact hf.map_infi2_le _
rw [Inf_eq_infi]
exact hf.map_infi2_le _
intros
simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)
intros
simp
intros
ext x
suffices : (‚àÄ (A : set Œ±) (B : set Œ≤), B ‚àà F ‚Üí f ‚Åª¬π' B ‚äÜ A ‚Üí x ‚àà A) ‚Üî ‚àÄ (B : set Œ≤), B ‚àà F ‚Üí f x ‚àà B
simp only [mem_sInter, mem_Inter, filter.mem_sets, mem_comap, this, and_imp, exists_prop, mem_preimage, exists_imp_distrib]
simp only [mem_sInter, mem_Inter, filter.mem_sets, mem_comap, this, and_imp, exists_prop, mem_preimage, exists_imp_distrib]
split
intros h U U_in
{ intros h U U_in, simpa only [subset.refl, forall_prop_of_true, mem_preimage] using h (f ‚Åª¬π' U) U U_in }
simpa only [subset.refl, forall_prop_of_true, mem_preimage] using h (f ‚Åª¬π' U) U U_in
intros h V U U_in f_U_V
{ intros h V U U_in f_U_V, exact f_U_V (h U U_in) }
exact f_U_V (h U U_in)
intros
simp only [tendsto, map_sup, sup_le_iff]
intros
ext ‚ü®f‚ü©
{ ext ‚ü®f‚ü©, refl }
refl
intros
{ change x ‚àà (‚ãÇ (I ‚àà s), (I : set P)) ‚Üî ‚àÄ I ‚àà s, x ‚àà I, simp }
change x ‚àà (‚ãÇ (I ‚àà s), (I : set P)) ‚Üî ‚àÄ I ‚àà s, x ‚àà I
simp
intros
have := partial_order.ext H
have ss := funext (Œª x, funext $ semilattice_sup.ext_sup H x)
casesI A
casesI B
injection this; congr'
injection this
congr'
intros
ext x
{ ext x, refl }
refl
intros
rw [set.well_founded_on_iff_no_descending_seq]
intros g con
apply set.infinite_of_injective_forall_mem g.injective (set.range_subset_iff.1 con)
exact f.finite_to_set
intros
rcases hz with ‚ü®p, p_ne_zero, px‚ü©
set a := p.leading_coeff with a_def
have a_ne_zero : a ‚â† 0 := mt polynomial.leading_coeff_eq_zero.mp p_ne_zero
have y_integral : is_integral R (algebra_map R S a) := is_integral_algebra_map
have x_integral : is_integral R (z * algebra_map R S a) := ‚ü®p.integral_normalization, monic_integral_normalization p_ne_zero, integral_normalization_aeval_eq_zero px inj‚ü©
exact ‚ü®‚ü®_, x_integral‚ü©, a, a_ne_zero, rfl‚ü©
intros
rw ‚Üê monoid_hom.map_mclosure at h
simpa using of_mem_span_of_iff.1 h
intros
rcases I.is_fractional with ‚ü®aI, haI, hI‚ü©
rcases J.is_fractional with ‚ü®aJ, haJ, hJ‚ü©
use aI * aJ
use S.mul_mem haI haJ
intros b hb
rcases mem_sup.mp hb with ‚ü®bI, hbI, bJ, hbJ, rfl‚ü©
rw smul_add
apply is_integer_add
rw [mul_smul, smul_comm]
{ rw [mul_smul, smul_comm], exact is_integer_smul (hI bI hbI), }
exact is_integer_smul (hI bI hbI)
rw mul_smul
{ rw mul_smul, exact is_integer_smul (hJ bJ hbJ) }
exact is_integer_smul (hJ bJ hbJ)
intros
split_ifs with h; simp [h]
{ split_ifs with h; simp [h] }
split_ifs with h
simp [h]
simp [h]
intros
simp
intros
simp
intros
rw [ker, ideal.mem_comap, submodule.mem_bot]
intros
rcases h with ‚ü®f, hf, hx‚ü©
use [f, hf]
rw [is_scalar_tower.algebra_map_eq R A B, ‚Üê hom_eval‚ÇÇ, hx, ring_hom.map_zero]
intros
rw ‚Üê (algebra_map R S).map_zero
split
split; intro h
intro h
cases (eq_iff_exists M S).mp h with c hc
{ cases (eq_iff_exists M S).mp h with c hc, rw zero_mul at hc, exact hM c.2 x hc }
rw zero_mul at hc
exact hM c.2 x hc
intro h
{ rw h }
rw h
intros
have t : ‚àÄ (p : n √ó n), (i = p.1 ‚àß j = p.2) ‚Üî (p = (i, j)) := by tidy
simp [ite_tmul, t, std_basis_matrix]
intros
obtain ‚ü®X, rfl‚ü© := hfin
use X
exact submodule.span_eq_restrict_scalars R S M X h
intros
simp [bernstein_polynomial]
intros
simp only [cyclotomic, dif_pos]
intros
rw dickson
intros
exact_mod_cast congr_arg nat.cast (pochhammer_nat_eval_succ r n)
intros
rw [degree_eq_nat_degree ne_zero, with_bot.coe_le_coe]
{ rw [degree_eq_nat_degree ne_zero, with_bot.coe_le_coe], exact h.dim_le_nat_degree_of_root ne_zero root }
exact h.dim_le_nat_degree_of_root ne_zero root
intros
{ ext, simp }
ext
simp
intros
simpa only [srange_eq_map] using (‚ä§ : subsemiring R).map_map g f
intros
have aux : ‚àÄ a s, v s = 0 ‚Üí v (a + s) ‚â§ v a
intros a' s' h'
{ intros a' s' h', refine le_trans (v.map_add a' s') (max_le (le_refl _) _), simp [h'], }
refine le_trans (v.map_add a' s') (max_le (le_refl _) _)
simp [h']
apply le_antisymm (aux a s h)
calc v a = v (a + s + -s) : by simp ... ‚â§ v (a + s) : aux (a + s) (-s) (by rwa ‚Üêideal.neg_mem_iff at h)
intros
apply witt_vector.hom_ext
intro n
rw [from_padic_int, ‚Üê ring_hom.comp_assoc, truncate_comp_lift, ring_hom.comp_assoc]
simp only [to_padic_int, to_zmod_pow, ring_hom.comp_id, padic_int.lift_spec, ring_hom.id_comp, ‚Üê ring_hom.comp_assoc, ring_equiv.to_ring_hom_comp_symm_to_ring_hom]
intros
simp only [ghost_component_apply, frobenius_fun, coeff_mk, ‚Üê bind‚ÇÅ_frobenius_poly_witt_polynomial, aeval_bind‚ÇÅ]
intros
rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum, finset.sum_eq_single 0]
simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bind‚ÇÅ_X_right, if_true, eq_self_iff_true]
{ simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bind‚ÇÅ_X_right, if_true, eq_self_iff_true], }
intros i hi hi0
{ intros i hi hi0, simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero, alg_hom.map_pow, bind‚ÇÅ_X_right, alg_hom.map_mul], }
simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero, alg_hom.map_pow, bind‚ÇÅ_X_right, alg_hom.map_mul]
{ rw finset.mem_range, dec_trivial }
rw finset.mem_range
dec_trivial
intros
intros x y h
ext i
rw [witt_vector.ext_iff] at h
simpa only [coeff_out] using h ‚Üëi
intros
simp only [witt_polynomial, X, sum_singleton, range_one, pow_zero]
intros
rw [‚Üê aleph'_omega, aleph'_le]
rw [‚Üê two_power_omega, ‚Üê power_mul, mul_eq_left le_rfl le_rfl omega_ne_zero]
intros
simp [‚Üêmove_left_card h, lt_add_one]
{ intros c c' h, rw [‚Üêcard_ord c, ‚Üêcard_ord c', h] }
intros c c' h
rw [‚Üêcard_ord c, ‚Üêcard_ord c', h]
intros
rw [‚Üê card_eq_nat, card_type, mk_fin]
intros
cases h with _ _ _ _ eb _ h‚ÇÅ h‚ÇÇ h‚ÇÉ; exact ‚ü®‚ü®_, h‚ÇÅ‚ü©‚ü©
cases h with _ _ _ _ eb _ h‚ÇÅ h‚ÇÇ h‚ÇÉ
exact ‚ü®‚ü®_, h‚ÇÅ‚ü©‚ü©
intros
cases n; cases i; refl
cases n; cases i
cases n
cases i
refl
cases i
refl
intros
cases a
cases b
refl
intros
classical
by_contradiction h''
revert h
apply not_le_of_lt
apply lt_of_mul_lt_mul_neg_right _ h'
apply lt_of_not_ge h''
intros
rwa add_comm
intros
simp only [inv_eq_one_div, one_div_div]
intros
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, horner]; cc
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, horner]
cc
intros
conv_lhs { rw [rec_shrink_with, well_founded.fix_eq], }
congr
ext ‚ü®y, h‚ü©
refl
intros
simpa only [zero_add] using dist_le_tsum_dist_of_tendsto h ha 0
intros
{ ext, refl }
ext
refl
intros
{ ext, simp [mul_smul] }
ext
simp [mul_smul]
intros
erw [nhds_prod_eq, filter.mem_prod_iff] at hU
rcases hU with ‚ü®U‚ÇÅ, hU‚ÇÅ, U‚ÇÇ, hU‚ÇÇ, h‚ü©
cases is_nonarchimedean _ hU‚ÇÅ with V hV
cases is_nonarchimedean _ hU‚ÇÇ with W hW
use V
use W
rw set.prod_subset_iff
intros x hX y hY
exact set.subset.trans (set.prod_mono hV hW) h (set.mem_sep hX hY)
intros
rcases (is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with ‚ü®u, hu‚ü©
exact ‚ü®u, hu.1, hu.2.2‚ü©
intros
simp_rw [‚Üê is_closed_compl_iff, compl_set_of, not_lt]
{ simp_rw [‚Üê is_closed_compl_iff, compl_set_of, not_lt], exact is_closed_le continuous_snd continuous_fst }
exact is_closed_le continuous_snd continuous_fst
intros
simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]
intros
convert is_closed_closure
intros
simp only [interior, mem_set_of_eq, exists_prop, and_assoc, and.left_comm]
intros
haveI := CompHaus.is_iso_of_bijective (Profinite_to_CompHaus.map f) bij
exact is_iso_of_fully_faithful Profinite_to_CompHaus _
intros
tidy
intros
rintros u v hu hv hs ‚ü®z, zs, zu‚ü© ‚ü®y, ys, yv‚ü©
have xs : x ‚àà s
rcases H y ys with ‚ü®t, ts, xt, yt, ht‚ü©
rcases H y ys with ‚ü®t, ts, xt, yt, ht‚ü©
{ rcases H y ys with ‚ü®t, ts, xt, yt, ht‚ü©, exact ts xt }
{ rcases H y ys with ‚ü®t, ts, xt, yt, ht‚ü©, exact ts xt }
exact ts xt
exact ts xt
wlog xu : x ‚àà u := hs xs using [u v y z, v u z y]
rcases H y ys with ‚ü®t, ts, xt, yt, ht‚ü©
have := ht u v hu hv(subset.trans ts hs) ‚ü®x, xt, xu‚ü© ‚ü®y, yt, yv‚ü©
exact this.imp (Œª z hz, ‚ü®ts hz.1, hz.2‚ü©)
intros
simp [frontier_prod_eq]
intros
simp only [is_open_supr_iff, is_open_coinduced]
intros
{ ext, simp [polynomial_functions], }
ext
simp [polynomial_functions]
intros
apply continuous_on.piecewise
{ rwa ite_inter_of_inter_eq _ H }
rwa ite_inter_of_inter_eq _ H
{ rwa ite_inter_closure_eq_of_inter_frontier_eq H }
rwa ite_inter_closure_eq_of_inter_frontier_eq H
{ rwa ite_inter_closure_compl_eq_of_inter_frontier_eq H }
rwa ite_inter_closure_compl_eq_of_inter_frontier_eq H
intros
simp only [tendsto, nhds_within_eq_map_subtype_coe h, filter.map_map, restrict]
intros
assume x xs
rcases h x xs with ‚ü®t, open_t, xt, ct‚ü©
have := ct x ‚ü®xs, xt‚ü©
rwa [continuous_within_at, ‚Üê nhds_within_restrict _ xt open_t] at this
intros
ext ‚ü®‚ü©
{ ext ‚ü®‚ü©, refl }
refl
intros
refine prod.ext _ rfl
rw [e‚ÇÇ.coe_fst', ‚Üê e‚ÇÅ.coe_fst', e‚ÇÅ.apply_symm_apply' h‚ÇÅ]
{ rwa [e‚ÇÅ.proj_symm_apply' h‚ÇÅ] }
rwa [e‚ÇÅ.proj_symm_apply' h‚ÇÅ]
{ rwa [e‚ÇÅ.proj_symm_apply' h‚ÇÅ] }
rwa [e‚ÇÅ.proj_symm_apply' h‚ÇÅ]
intros
simp only [‚Üê is_open_compl_iff, ‚Üê preimage_compl, is_open_preimage]
intros
change continuous_at ((Œª (p : ereal √ó ereal), p.2 + p.1) ‚àò prod.swap) (a, ‚ä•)
apply continuous_at.comp _ continuous_swap.continuous_at
simp_rw add_comm
exact continuous_at_add_bot_coe a
intros
rw real.ball_eq_Ioo; apply totally_bounded_Ioo
rw real.ball_eq_Ioo
apply totally_bounded_Ioo
intros
{ cases e, subst e', refl }
cases e
subst e'
refl
intros
tfae_have : 1 ‚Üí 4
from Œª h y, h {y}
tfae_have : 4 ‚Üí 3
from Œª h x, h (f x)
tfae_have : 3 ‚Üí 2
from Œª h x, is_open.mem_nhds (h x) rfl
tfae_have : 2 ‚Üí 5
intros h x
{ intros h x, rcases mem_nhds_iff.1 (h x) with ‚ü®U, eq, hU, hx‚ü©, exact ‚ü®U, hU, hx, eq‚ü© }
rcases mem_nhds_iff.1 (h x) with ‚ü®U, eq, hU, hx‚ü©
exact ‚ü®U, hU, hx, eq‚ü©
tfae_have : 5 ‚Üí 1
intros h s
{ intros h s, refine is_open_iff_forall_mem_open.2 (Œª x hx, _), rcases h x with ‚ü®U, hU, hxU, eq‚ü©, exact ‚ü®U, Œª x' hx', mem_preimage.2 $ (eq x' hx').symm ‚ñ∏ hx, hU, hxU‚ü© }
refine is_open_iff_forall_mem_open.2 (Œª x hx, _)
rcases h x with ‚ü®U, hU, hxU, eq‚ü©
exact ‚ü®U, Œª x' hx', mem_preimage.2 $ (eq x' hx').symm ‚ñ∏ hx, hU, hxU‚ü©
tfae_finish
intros
simpa only [not_le] using not_congr dist_le_zero
intros
rw [‚Üê ball_union_sphere, set.union_diff_cancel_left sphere_disjoint_ball.symm]
intros
{ convert metric.emetric_closed_ball Œµ.2, simp }
convert metric.emetric_closed_ball Œµ.2
simp
intros
convert hf.apriori_edist_iterate_efixed_point_le' hsc hsf hxs hx 0
{ convert hf.apriori_edist_iterate_efixed_point_le' hsc hsf hxs hx 0, rw [pow_zero, mul_one] }
rw [pow_zero, mul_one]
intros
rw [‚Üê e.image_symm_eq_preimage, e.symm.dimH_image]
intros
simp [inf_dist]
intros
rw [iterate_succ, mul_comm]
simpa only [ennreal.coe_pow] using (hf.iterate n) x (f x)
intros
simp [‚Üê is_open_compl_iff, is_open_supr_iff]
intros
assume x z hz
by_cases h : x ‚àà s; simp [h] at hz
by_cases h : x ‚àà s
simp [h] at hz
filter_upwards [hs.mem_nhds h]
{ filter_upwards [hs.mem_nhds h], simp [hz] { contextual := tt} }
simp [hz] { contextual := tt}
simp [h] at hz
apply filter.eventually_of_forall (Œª x', _)
{ apply filter.eventually_of_forall (Œª x', _), by_cases h' : x' ‚àà s; simp [h', hz.trans_le hy, hz] }
by_cases h' : x' ‚àà s; simp [h', hz.trans_le hy, hz]
by_cases h' : x' ‚àà s
simp [h', hz.trans_le hy, hz]
simp [h', hz.trans_le hy, hz]
intros
classical
induction t using finset.induction with x t hx ih generalizing U hU s hs hsC
refine ‚ü®Œª _, ‚àÖ, Œª i, is_compact_empty, Œª i, empty_subset _, _‚ü©
{ refine ‚ü®Œª _, ‚àÖ, Œª i, is_compact_empty, Œª i, empty_subset _, _‚ü©, simpa only [subset_empty_iff, Union_false, Union_empty] using hsC }
simpa only [subset_empty_iff, Union_false, Union_empty] using hsC
simp only [finset.set_bUnion_insert] at hsC
simp only [finset.mem_insert] at hU
have hU' : ‚àÄ i ‚àà t, is_open (U i) := Œª i hi, hU i (or.inr hi)
rcases hs.binary_compact_cover (hU x (or.inl rfl)) (is_open_bUnion hU') hsC with ‚ü®K‚ÇÅ, K‚ÇÇ, h1K‚ÇÅ, h1K‚ÇÇ, h2K‚ÇÅ, h2K‚ÇÇ, hK‚ü©
rcases ih U hU' h1K‚ÇÇ h2K‚ÇÇ with ‚ü®K, h1K, h2K, h3K‚ü©
refine ‚ü®update K x K‚ÇÅ, _, _, _‚ü©
intros i
{ intros i, by_cases hi : i = x, { simp only [update_same, hi, h1K‚ÇÅ] }, { rw [‚Üê ne.def] at hi, simp only [update_noteq hi, h1K] }}
by_cases hi : i = x
{ simp only [update_same, hi, h1K‚ÇÅ] }
simp only [update_same, hi, h1K‚ÇÅ]
{ rw [‚Üê ne.def] at hi, simp only [update_noteq hi, h1K] }
rw [‚Üê ne.def] at hi
simp only [update_noteq hi, h1K]
intros i
{ intros i, by_cases hi : i = x, { simp only [update_same, hi, h2K‚ÇÅ] }, { rw [‚Üê ne.def] at hi, simp only [update_noteq hi, h2K] }}
by_cases hi : i = x
{ simp only [update_same, hi, h2K‚ÇÅ] }
simp only [update_same, hi, h2K‚ÇÅ]
{ rw [‚Üê ne.def] at hi, simp only [update_noteq hi, h2K] }
rw [‚Üê ne.def] at hi
simp only [update_noteq hi, h2K]
{ simp only [set_bUnion_insert_update _ hx, hK, h3K] }
simp only [set_bUnion_insert_update _ hx, hK, h3K]
intros
{ dsimp [comp], tidy, }
dsimp [comp]
tidy
intros
rw [to_topological_space_Inf, infi_pair]
intros
refine filter.has_basis_self.2 (Œª t h, _)
rcases comp_comp_symm_mem_uniformity_sets h with ‚ü®w, w_in, w_symm, r‚ü©
refine ‚ü®closure w, mem_of_superset w_in subset_closure, is_closed_closure, _‚ü©
refine subset.trans _ r
rw closure_eq_uniformity
apply Inter_subset_of_subset
apply Inter_subset
exact ‚ü®w_in, w_symm‚ü©
intros
simp [uniform_continuous, hf.comap_uniformity.symm, tendsto_comap]
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
have h := int.add_le_add_right h (-a)
rwa [int.add_comm a b, int.add_neg_cancel_right] at h
intros
unfold bodd div2 bodd_div2; cases bodd_div2 n; cases fst; refl
unfold bodd div2 bodd_div2; cases bodd_div2 n; cases fst
unfold bodd div2 bodd_div2; cases bodd_div2 n
unfold bodd div2 bodd_div2
cases bodd_div2 n
cases fst
refl
refl
intros
tactic.mk_inj_eq
intros
rw [mul_sub, ‚Üêcommutes, sub_mul]
intros
ext
{ ext, simp only [linear_map.id_coe, mul_one, id.def, lmul_right_apply] }
simp only [linear_map.id_coe, mul_one, id.def, lmul_right_apply]
intros
{ ext, rw [set_like.mem_coe, mem_range], refl }
ext
rw [set_like.mem_coe, mem_range]
refl
intros
rw [algebra_map_apply R S A r, f.commutes, ‚Üê algebra_map_apply R S B]
intros
{ convert (s.prod_inter_mul_prod_diff {i} f).symm, simp [h] }
convert (s.prod_inter_mul_prod_diff {i} f).symm
simp [h]
intros
simp
intros
rw [‚Üê finprod_mem_inter_mul_support, h, finprod_mem_inter_mul_support]
intros
classical
{ classical, rw finprod_mem_finset_product', simp_rw finprod_mem_finset_product', simp, }
rw finprod_mem_finset_product'
simp_rw finprod_mem_finset_product'
simp
intros
split
rintro rfl
unfreezingI {rintro rfl}
{ unfreezingI {rintro rfl}, exact char_zero_of_exp_char_one R p, }
exact char_zero_of_exp_char_one R p
rintro rfl
unfreezingI {rintro rfl}
{ unfreezingI {rintro rfl}, exact exp_char_one_of_char_zero R q, }
exact exp_char_one_of_char_zero R q
intros
{ cases g, cases g', simp }
cases g
cases g'
simp
intros
cases n
case nat.zero { cases g_s_head_eq : (g.s.nth 0); simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head] }
cases g_s_head_eq : (g.s.nth 0); simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]
cases g_s_head_eq : (g.s.nth 0)
simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]
simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]
case nat.succ { simp only [succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq, convergents', squash_gcf] }
simp only [succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq, convergents', squash_gcf]
intros
refine ‚ü®Œª h a b c bc, _, Œª h a b c bc, _‚ü©
rw [‚Üê inv_mul_cancel_left a b, ‚Üê inv_mul_cancel_left a c]
{ rw [‚Üê inv_mul_cancel_left a b, ‚Üê inv_mul_cancel_left a c], exact h a‚Åª¬π bc }
exact h a‚Åª¬π bc
rw [‚Üê inv_mul_cancel_left a b, ‚Üê inv_mul_cancel_left a c] at bc
{ rw [‚Üê inv_mul_cancel_left a b, ‚Üê inv_mul_cancel_left a c] at bc, exact h a‚Åª¬π bc }
exact h a‚Åª¬π bc
intros
rw [add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom, add_monoid_hom.mrange_top_iff_surjective]
exact function.bijective.surjective h
intros
{ rcases hu with ‚ü®u, rfl‚ü©, apply units.mul_right_dvd, }
rcases hu with ‚ü®u, rfl‚ü©
apply units.mul_right_dvd
intros
rwa [add_comm, add_div', add_comm]
intros
apply iff.trans multiset.lcm_dvd
simp only [multiset.mem_map, and_imp, exists_imp_distrib]
exact ‚ü®Œª k b hb, k _ _ hb rfl, Œª k a' b hb h, h ‚ñ∏ k _ hb‚ü©
intros
simp [h.symm, mul_inv_cancel_left]
intros
rw [‚Üê add_sub_assoc, sub_add_cancel]
intros
{ rw [‚Üêh, u.inv_mul], }
rw [‚Üêh, u.inv_mul]
intros
split_ifs with h
{ rw [h, pow_zero], }
rw [h, pow_zero]
{ rw [zero_pow (nat.pos_of_ne_zero h)] }
rw [zero_pow (nat.pos_of_ne_zero h)]
intros
rw [‚Üê nat.mod_add_div n 2, pow_add, pow_mul]; simp [sq]
rw [‚Üê nat.mod_add_div n 2, pow_add, pow_mul]
simp [sq]
intros
rw [div_eq_mul_one_div, div_mul_div, mul_one]
intros
dsimp [d_from]
rw h
refl
intros
{ ext, simp }
ext
simp
intros
rw [‚Üê mul_indicator_union_mul_inter_apply f s t, mul_indicator_of_not_mem h, mul_one]
intros
rw [‚Üêmul_assoc, mul_inv_of_self, one_mul]
intros
rw [leibniz_lie, add_sub_cancel]
intros
induction h
case rel.lie_self : a' { simp only [lift_aux_map_mul, non_unital_alg_hom.map_zero, lie_self], }
case rel.leibniz_lie : a' b' c' { simp only [lift_aux_map_mul, lift_aux_map_add, sub_add_cancel, lie_lie], }
case rel.smul : t a' b' h‚ÇÅ h‚ÇÇ { simp only [lift_aux_map_smul, h‚ÇÇ], }
case rel.add_right : a' b' c' h‚ÇÅ h‚ÇÇ { simp only [lift_aux_map_add, h‚ÇÇ], }
case rel.mul_left : a' b' c' h‚ÇÅ h‚ÇÇ { simp only [lift_aux_map_mul, h‚ÇÇ], }
case rel.mul_right : a' b' c' h‚ÇÅ h‚ÇÇ { simp only [lift_aux_map_mul, h‚ÇÇ], }
intros
have h' : (‚ä§ : lie_ideal R L).map f = ‚ä§
rw ‚Üêf.ideal_range_eq_map
{ rw ‚Üêf.ideal_range_eq_map, exact f.ideal_range_eq_top_of_surjective h, }
exact f.ideal_range_eq_top_of_surjective h
induction k with k ih
simp only [lie_module.lower_central_series_zero]
{ simp only [lie_module.lower_central_series_zero], exact h', }
exact h'
simp only [lie_module.lower_central_series_succ, lie_ideal.map_bracket_eq f h, ih, h']
{ simp only [lie_module.lower_central_series_succ, lie_ideal.map_bracket_eq f h, ih, h'], }
intros
rw [lie_hom.ideal_range_eq_lie_span_range, ‚Üê lie_subalgebra.coe_to_submodule, ‚Üê lie_submodule.coe_to_submodule_eq_iff, incl_range, coe_to_lie_subalgebra_to_submodule, lie_submodule.coe_lie_span_submodule_eq_iff]
use I
intros
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_le_neg_iff]
exact smul_le_smul_iff_of_pos (neg_pos_of_neg hc)
intros
haveI := classical.prop_decidable
{ haveI := classical.prop_decidable, simp_rw [ne.def, p.eq_bot_iff, not_forall] }
simp_rw [ne.def, p.eq_bot_iff, not_forall]
intros
rw [lift_def, lift_nc_single, algebra.smul_def, ring_hom.coe_add_monoid_hom]
intros
refine finsupp.induction_linear f _ (Œª f g hf hg, hadd f g hf hg) (Œª g r, _)
{ simpa using hsmul 0 (of k G 1) (hM 1) }
simpa using hsmul 0 (of k G 1) (hM 1)
convert hsmul r (of k G g) (hM g)
{ convert hsmul r (of k G g) (hM g), simp only [mul_one, smul_single', of_apply] }
simp only [mul_one, smul_single', of_apply]
intros
split
{ split, rw [‚Üêcmp_swap _ y, ‚Üêcmp_swap _ y'], cc, rw [‚Üêcmp_swap _ x, ‚Üêcmp_swap _ x'], cc, }
rw [‚Üêcmp_swap _ y, ‚Üêcmp_swap _ y']
cc
rw [‚Üêcmp_swap _ x, ‚Üêcmp_swap _ x']
cc
intros
rwa [inv_lt ((@zero_lt_one Œ± _ _).trans ha) zero_lt_one, inv_one]
intros
rwa [div_le_iff_of_neg' hb, ‚Üê div_eq_mul_one_div, div_le_one_of_neg (h.trans_lt hb)]
intros
simp [division_def, mul_nonpos_iff]
intros
rw [‚Üê mul_le_mul_iff_left b, mul_inv_cancel_left]
intros
{ rw [‚Üê mul_lt_mul_iff_left a, ‚Üê mul_lt_mul_iff_right b], simp }
rw [‚Üê mul_lt_mul_iff_left a, ‚Üê mul_lt_mul_iff_right b]
simp
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioo]
split
rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©
{ rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©, split, exact (mul_lt_mul_left hr).mpr a_h_left_left, exact (mul_lt_mul_left hr).mpr a_h_left_right, }
split
exact (mul_lt_mul_left hr).mpr a_h_left_left
exact (mul_lt_mul_left hr).mpr a_h_left_right
rintro ‚ü®a_left, a_right‚ü©
{ rintro ‚ü®a_left, a_right‚ü©, use x / r, refine ‚ü®‚ü®(lt_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right‚ü©, _‚ü©, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ‚ü®‚ü®(lt_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right‚ü©, _‚ü©
rw mul_div_cancel' _ (ne_of_gt hr)
intros
simpa only [abs_one, one_mul] using @abs_le_iff_mul_self_le Œ± _ a 1
intros
haveI := @linear_order.decidable_le Œ± _; exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_left b_le_c ha
haveI := @linear_order.decidable_le Œ± _
exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_left b_le_c ha
intros
simpa only [div_eq_mul_inv] using h.mul_const a
intros
simpa only [div_eq_mul_inv] using h.mul_const ha
intros
dsimp
split
intro h
repeat { intro h, conv_rhs { rw eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h) }, simp, }
conv_rhs { rw eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h) }
simp
intro h
conv_rhs { rw eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h) }
simp
intros
rw [‚Üê a.commute_self_conj.eq, self_mul_conj]
intros
refine ‚ü®_, _‚ü©
rintros ‚ü®ab, ba‚ü©
{ rintros ‚ü®ab, ba‚ü©, refine ‚ü®ba.of_mul, ab.of_mul‚ü© }
refine ‚ü®ba.of_mul, ab.of_mul‚ü©
rintros ‚ü®ha, hb‚ü©
{ rintros ‚ü®ha, hb‚ü©, exact ‚ü®ha.mul hb, hb.mul ha‚ü© }
exact ‚ü®ha.mul hb, hb.mul ha‚ü©
intros
{ ext x, simp [even, eq_comm] }
ext x
simp [even, eq_comm]
intros
{ rw sub_eq_add_neg, exact dvd_add h‚ÇÅ (dvd_neg_of_dvd h‚ÇÇ) }
rw sub_eq_add_neg
exact dvd_add h‚ÇÅ (dvd_neg_of_dvd h‚ÇÇ)
intros
obtain ‚ü®a‚ÇÅ, b‚ÇÅ, ha‚ÇÅ, hb‚ÇÅ, hab‚ÇÅ, hab‚ÇÇ‚ü© := sq_mul_squarefree_of_pos h
refine ‚ü®a‚ÇÅ.pred, b‚ÇÅ.pred, _, _‚ü©; simpa only [add_one, succ_pred_eq_of_pos, ha‚ÇÅ, hb‚ÇÅ]
refine ‚ü®a‚ÇÅ.pred, b‚ÇÅ.pred, _, _‚ü©
simpa only [add_one, succ_pred_eq_of_pos, ha‚ÇÅ, hb‚ÇÅ]
simpa only [add_one, succ_pred_eq_of_pos, ha‚ÇÅ, hb‚ÇÅ]
intros
simp_rw [‚Üê subset_empty_iff, mul_support_subset_iff', funext_iff]
{ simp_rw [‚Üê subset_empty_iff, mul_support_subset_iff', funext_iff], simp }
simp
intros
rintros U ‚ü®s, z‚ü©
rw [‚Üê compl_compl U, ‚Üê z, ‚Üê Union_of_singleton_coe s, zero_locus_Union, compl_Inter, image_Union]
simp_rw [‚Üê image_of_Df_eq_comap_C_compl_zero_locus]
exact is_open_Union (Œª f, is_open_image_of_Df)
intros
rw stalk_map.congr Œ± Œ± rfl x x' h
intros
rw ‚Üê nnreal.summable_coe
{ rw ‚Üê nnreal.summable_coe, push_cast, exact p.summable_norm_mul_pow h }
push_cast
exact p.summable_norm_mul_pow h
intros
rcases i with ‚ü®k, blocks_fun‚ü©
dsimp [comp_change_of_variables]
simp only [composition.length, map_of_fn, length_of_fn]
intros
simp only [is_o, is_O_with]
intros
simp only [is_O_with, norm_norm]
intros
rw is_o_const_iff hc
refine ‚ü®Œª h, tendsto_nhds_unique tendsto_const_nhds h, _‚ü©
rintros rfl
exact tendsto_const_nhds
intros
have := hf.iterate hL hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
rw [‚Üê has_deriv_within_at_univ] at *
exact hc.clm_comp hd
intros
simpa only [smul_zero, zero_add] using hc.smul (has_fderiv_at_const f x)
intros
have := hf.add_is_O_with (f'.is_O_with_comp _ _) hK
simp only [sub_add_cancel, is_O_with] at this
rcases exists_nhds_square this with ‚ü®U, Uo, xU, hU‚ü©
exact ‚ü®U, Uo.mem_nhds xU, lipschitz_on_with_iff_norm_sub_le.2 $ Œª x hx y hy, hU (mk_mem_prod hx hy)‚ü©
intros
convert (hf.implicit_to_local_homeomorph_of_complemented f f' hf' hker).left_inv (hf.mem_implicit_to_local_homeomorph_of_complemented_source hf' hker)
exact congr_arg prod.snd (hf.implicit_to_local_homeomorph_of_complemented_self hf' hker).symm
intros
induction n with n IH generalizing x
{ simp }
simp
rw [iterated_deriv_within_succ (hs x hx), function.iterate_succ']
{ rw [iterated_deriv_within_succ (hs x hx), function.iterate_succ'], exact deriv_within_congr (hs x hx) (Œª y hy, IH hy) (IH hx) }
exact deriv_within_congr (hs x hx) (Œª y hy, IH hy) (IH hx)
intros
simpa only [sub_zero, mul_one] using norm_image_sub_le_of_norm_deriv_le_segment' hf bound 1 (right_mem_Icc.2 zero_le_one)
intros
simp [exp_neg_inv_glue, not_le.2 hx, exp_pos]
intros
split
assume H
{ assume H, split, { exact Œª x, H.zero_eq x (mem_univ x) }, { assume m hm x, rw ‚Üê has_fderiv_within_at_univ, exact H.fderiv_within m hm x (mem_univ x) }, { assume m hm, rw continuous_iff_continuous_on_univ, exact H.cont m hm } }
split
{ exact Œª x, H.zero_eq x (mem_univ x) }
exact Œª x, H.zero_eq x (mem_univ x)
assume m hm x
{ assume m hm x, rw ‚Üê has_fderiv_within_at_univ, exact H.fderiv_within m hm x (mem_univ x) }
rw ‚Üê has_fderiv_within_at_univ
exact H.fderiv_within m hm x (mem_univ x)
assume m hm
{ assume m hm, rw continuous_iff_continuous_on_univ, exact H.cont m hm }
rw continuous_iff_continuous_on_univ
exact H.cont m hm
assume H
{ assume H, split, { exact Œª x hx, H.zero_eq x }, { assume m hm x hx, rw has_fderiv_within_at_univ, exact H.fderiv m hm x }, { assume m hm, rw ‚Üê continuous_iff_continuous_on_univ, exact H.cont m hm } }
split
{ exact Œª x hx, H.zero_eq x }
exact Œª x hx, H.zero_eq x
assume m hm x hx
{ assume m hm x hx, rw has_fderiv_within_at_univ, exact H.fderiv m hm x }
rw has_fderiv_within_at_univ
exact H.fderiv m hm x
assume m hm
{ assume m hm, rw ‚Üê continuous_iff_continuous_on_univ, exact H.cont m hm }
rw ‚Üê continuous_iff_continuous_on_univ
exact H.cont m hm
intros
assume m hm
rcases hf m hm with ‚ü®u, hu, p, hp‚ü©
exact ‚ü®u, hu, _, hp.continuous_linear_map_comp g‚ü©
intros
refine ‚ü®Œª H, ‚ü®H.continuous_on, H.zero_eq‚ü©, Œª H, ‚ü®H.2, Œª m hm, false.elim (not_le.2 hm bot_le), _‚ü©‚ü©
assume m hm
obtain rfl : m = 0
exact_mod_cast (hm.antisymm (zero_le _))
exact_mod_cast (hm.antisymm (zero_le _))
have : ‚àÄ x ‚àà s, p x 0 = (continuous_multilinear_curry_fin0 ùïú E F).symm (f x)
assume x hx
assume x hx
{ assume x hx, rw ‚Üê H.2 x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
{ assume x hx, rw ‚Üê H.2 x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
rw ‚Üê H.2 x hx
rw ‚Üê H.2 x hx
symmetry
symmetry
exact continuous_multilinear_map.uncurry0_curry0 _
exact continuous_multilinear_map.uncurry0_curry0 _
rw [continuous_on_congr this, linear_isometry_equiv.comp_continuous_on_iff]
exact H.1
intros
split
rintro hz
{ rintro hz, obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := (convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz), obtain rfl | ha' := ha.eq_or_lt, { rw zero_add at hab, rw [hab, one_mul, zero_mul, zero_add] at hz, exact (hz.2.ne rfl).elim }, { exact ‚ü®a, b, ha', hb, hab, rfl‚ü© } }
obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := (convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)
obtain rfl | ha' := ha.eq_or_lt
rw zero_add at hab
{ rw zero_add at hab, rw [hab, one_mul, zero_mul, zero_add] at hz, exact (hz.2.ne rfl).elim }
rw [hab, one_mul, zero_mul, zero_add] at hz
exact (hz.2.ne rfl).elim
{ exact ‚ü®a, b, ha', hb, hab, rfl‚ü© }
exact ‚ü®a, b, ha', hb, hab, rfl‚ü©
rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
{ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©, obtain rfl | hb' := hb.eq_or_lt, { rw add_zero at hab, rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico] }, { exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ‚ü®a, b, ha, hb', hab, rfl‚ü©) } }
obtain rfl | hb' := hb.eq_or_lt
rw add_zero at hab
{ rw add_zero at hab, rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico] }
rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico]
exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ‚ü®a, b, ha, hb', hab, rfl‚ü©)
{ exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ‚ü®a, b, ha, hb', hab, rfl‚ü©) }
intros
intros x y hx hy a b ha hb hab
obtain hxy | hyx := h.total_of_refl hx hy
refine hs.out hx hy (mem_Icc.2 ‚ü®_, _‚ü©)
{ refine hs.out hx hy (mem_Icc.2 ‚ü®_, _‚ü©), calc x = a ‚Ä¢ x + b ‚Ä¢ x : by rw [‚Üêadd_smul, hab, one_smul] ... ‚â§ a ‚Ä¢ x + b ‚Ä¢ y : add_le_add_left (smul_le_smul_of_nonneg hxy hb) _, calc a ‚Ä¢ x + b ‚Ä¢ y ‚â§ a ‚Ä¢ y + b ‚Ä¢ y : add_le_add_right (smul_le_smul_of_nonneg hxy ha) _ ... = y : by rw [‚Üêadd_smul, hab, one_smul] }
calc x = a ‚Ä¢ x + b ‚Ä¢ x : by rw [‚Üêadd_smul, hab, one_smul] ... ‚â§ a ‚Ä¢ x + b ‚Ä¢ y : add_le_add_left (smul_le_smul_of_nonneg hxy hb) _
calc a ‚Ä¢ x + b ‚Ä¢ y ‚â§ a ‚Ä¢ y + b ‚Ä¢ y : add_le_add_right (smul_le_smul_of_nonneg hxy ha) _ ... = y : by rw [‚Üêadd_smul, hab, one_smul]
refine hs.out hy hx (mem_Icc.2 ‚ü®_, _‚ü©)
{ refine hs.out hy hx (mem_Icc.2 ‚ü®_, _‚ü©), calc y = a ‚Ä¢ y + b ‚Ä¢ y : by rw [‚Üêadd_smul, hab, one_smul] ... ‚â§ a ‚Ä¢ x + b ‚Ä¢ y : add_le_add_right (smul_le_smul_of_nonneg hyx ha) _, calc a ‚Ä¢ x + b ‚Ä¢ y ‚â§ a ‚Ä¢ x + b ‚Ä¢ x : add_le_add_left (smul_le_smul_of_nonneg hyx hb) _ ... = x : by rw [‚Üêadd_smul, hab, one_smul] }
calc y = a ‚Ä¢ y + b ‚Ä¢ y : by rw [‚Üêadd_smul, hab, one_smul] ... ‚â§ a ‚Ä¢ x + b ‚Ä¢ y : add_le_add_right (smul_le_smul_of_nonneg hyx ha) _
calc a ‚Ä¢ x + b ‚Ä¢ y ‚â§ a ‚Ä¢ x + b ‚Ä¢ x : add_le_add_left (smul_le_smul_of_nonneg hyx hb) _ ... = x : by rw [‚Üêadd_smul, hab, one_smul]
intros
simp only [finset.center_mass, hw, inv_one, one_smul]
intros
rw inter_comm
exact hC.inter_left hCA
intros
rw [‚Üêinner_conj_sym, conj_re]
intros
rw finsupp.mem_supported' at hl
simp [hv.inner_left_finsupp, hl i hi]
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
rw [dist_eq_norm_vsub V, dist_eq_norm, vadd_vsub_vadd_cancel_right]
intros
{ rw [‚Üê of_real_norm_eq_coe_nnnorm, norm_of_nonneg hx] }
rw [‚Üê of_real_norm_eq_coe_nnnorm, norm_of_nonneg hx]
intros
rcases eq_or_ne c 0 with rfl|hc
simp [hr, zero_smul_set, set.singleton_zero, ‚Üê nonempty_closed_ball]
{ simp [hr, zero_smul_set, set.singleton_zero, ‚Üê nonempty_closed_ball] }
{ exact smul_closed_ball' hc x r }
exact smul_closed_ball' hc x r
intros
rw [mem_ball, dist_eq_norm]
intros
rw [emetric.mem_ball, edist_eq_coe_nnnorm]
intros
set f' : E ‚ÜíL[ùïú] f.range := f.cod_restrict _ (f : E ‚Üí‚Çó[ùïú] F).mem_range_self
rcases f'.exists_right_inverse_of_surjective (f : E ‚Üí‚Çó[ùïú] F).range_range_restrict with ‚ü®g, hg‚ü©
simpa only [ker_cod_restrict] using f'.closed_complemented_ker_of_right_inverse g (ext_iff.1 hg)
intros
simpa using (has_strict_fderiv_at_exp_of_mem_ball hx).has_strict_deriv_at
intros
{ ext m, simp [(subsingleton.elim _ _ : x = m)] }
ext m
simp [(subsingleton.elim _ _ : x = m)]
intros
cases n; [exact hn.false.elim, exact norm_mk_pi_algebra_fin_succ_le]
cases n
exact hn.false.elim
exact norm_mk_pi_algebra_fin_succ_le
intros
rcases h.exists_pos with ‚ü®C', C'_pos, hC'‚ü©
apply le_antisymm
intros hatg hatg_in
{ intros hatg hatg_in, rw semi_normed_group.mem_closure_iff, intros Œµ Œµ_pos, have hCf : 0 ‚â§ C'*‚à•f‚à• := (zero_le_mul_left C'_pos).mpr (norm_nonneg f), have ineq : 0 < 1 + C'*‚à•f‚à•, by linarith, set Œ¥ := Œµ/(1 + C'*‚à•f‚à•), have Œ¥_pos : Œ¥ > 0, from div_pos Œµ_pos ineq, obtain ‚ü®_, ‚ü®g : G, rfl‚ü©, hg : ‚à•hatg - g‚à• < Œ¥‚ü© := semi_normed_group.mem_closure_iff.mp (completion.dense_inducing_coe.dense hatg) Œ¥ Œ¥_pos, obtain ‚ü®g' : G, hgg' : f g' = f g, hfg : ‚à•g'‚à• ‚â§ C' * ‚à•f g‚à•‚ü© := hC' (f g) (mem_range_self g), have mem_ker : g - g' ‚àà f.ker, by rw [f.mem_ker, f.map_sub, sub_eq_zero.mpr hgg'.symm], have : ‚à•f g‚à• ‚â§ ‚à•f‚à•*‚à•hatg - g‚à•, calc ‚à•f g‚à• = ‚à•f.completion g‚à• : by rw [f.completion_coe, completion.norm_coe] ... = ‚à•f.completion g - 0‚à• : by rw [sub_zero _] ... = ‚à•f.completion g - (f.completion hatg)‚à• : by rw [(f.completion.mem_ker _).mp hatg_in] ... = ‚à•f.completion (g - hatg)‚à• : by rw [f.completion.map_sub] ... ‚â§ ‚à•f.completion‚à• * ‚à•(g :completion G) - hatg‚à• : f.completion.le_op_norm _ ... = ‚à•f‚à• * ‚à•hatg - g‚à• : by rw [norm_sub_rev, f.norm_completion], have : ‚à•(g' : completion G)‚à• ‚â§ C'*‚à•f‚à•*‚à•hatg - g‚à•, calc ‚à•(g' : completion G)‚à• = ‚à•g'‚à• : completion.norm_coe _ ... ‚â§ C' * ‚à•f g‚à• : hfg ... ‚â§ C' * ‚à•f‚à• * ‚à•hatg - g‚à• : by { rw mul_assoc, exact (mul_le_mul_left C'_pos).mpr this }, refine ‚ü®g - g', _, _‚ü©, { norm_cast, rw normed_group_hom.comp_range, apply add_subgroup.mem_map_of_mem, simp only [incl_range, mem_ker] }, { calc ‚à•hatg - (g - g')‚à• = ‚à•hatg - g + g'‚à• : by abel ... ‚â§ ‚à•hatg - g‚à• + ‚à•(g' : completion G)‚à• : norm_add_le _ _ ... < Œ¥ + C'*‚à•f‚à•*‚à•hatg - g‚à• : by linarith ... ‚â§ Œ¥ + C'*‚à•f‚à•*Œ¥ : add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) Œ¥ ... = (1 + C'*‚à•f‚à•)*Œ¥ : by ring ... = Œµ : mul_div_cancel' _ ineq.ne.symm } }
rw semi_normed_group.mem_closure_iff
intros Œµ Œµ_pos
have hCf : 0 ‚â§ C'*‚à•f‚à• := (zero_le_mul_left C'_pos).mpr (norm_nonneg f)
have ineq : 0 < 1 + C'*‚à•f‚à•
linarith
linarith
set Œ¥ := Œµ/(1 + C'*‚à•f‚à•)
have Œ¥_pos : Œ¥ > 0
from div_pos Œµ_pos ineq
obtain ‚ü®_, ‚ü®g : G, rfl‚ü©, hg : ‚à•hatg - g‚à• < Œ¥‚ü© := semi_normed_group.mem_closure_iff.mp (completion.dense_inducing_coe.dense hatg) Œ¥ Œ¥_pos
obtain ‚ü®g' : G, hgg' : f g' = f g, hfg : ‚à•g'‚à• ‚â§ C' * ‚à•f g‚à•‚ü© := hC' (f g) (mem_range_self g)
have mem_ker : g - g' ‚àà f.ker
rw [f.mem_ker, f.map_sub, sub_eq_zero.mpr hgg'.symm]
rw [f.mem_ker, f.map_sub, sub_eq_zero.mpr hgg'.symm]
have : ‚à•f g‚à• ‚â§ ‚à•f‚à•*‚à•hatg - g‚à•
calc ‚à•f g‚à• = ‚à•f.completion g‚à• : by rw [f.completion_coe, completion.norm_coe] ... = ‚à•f.completion g - 0‚à• : by rw [sub_zero _] ... = ‚à•f.completion g - (f.completion hatg)‚à• : by rw [(f.completion.mem_ker _).mp hatg_in] ... = ‚à•f.completion (g - hatg)‚à• : by rw [f.completion.map_sub] ... ‚â§ ‚à•f.completion‚à• * ‚à•(g :completion G) - hatg‚à• : f.completion.le_op_norm _ ... = ‚à•f‚à• * ‚à•hatg - g‚à• : by rw [norm_sub_rev, f.norm_completion]
have : ‚à•(g' : completion G)‚à• ‚â§ C'*‚à•f‚à•*‚à•hatg - g‚à•
calc ‚à•(g' : completion G)‚à• = ‚à•g'‚à• : completion.norm_coe _ ... ‚â§ C' * ‚à•f g‚à• : hfg ... ‚â§ C' * ‚à•f‚à• * ‚à•hatg - g‚à• : by { rw mul_assoc, exact (mul_le_mul_left C'_pos).mpr this }
refine ‚ü®g - g', _, _‚ü©
norm_cast
{ norm_cast, rw normed_group_hom.comp_range, apply add_subgroup.mem_map_of_mem, simp only [incl_range, mem_ker] }
rw normed_group_hom.comp_range
apply add_subgroup.mem_map_of_mem
simp only [incl_range, mem_ker]
calc ‚à•hatg - (g - g')‚à• = ‚à•hatg - g + g'‚à• : by abel ... ‚â§ ‚à•hatg - g‚à• + ‚à•(g' : completion G)‚à• : norm_add_le _ _ ... < Œ¥ + C'*‚à•f‚à•*‚à•hatg - g‚à• : by linarith ... ‚â§ Œ¥ + C'*‚à•f‚à•*Œ¥ : add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) Œ¥ ... = (1 + C'*‚à•f‚à•)*Œ¥ : by ring ... = Œµ : mul_div_cancel' _ ineq.ne.symm
{ calc ‚à•hatg - (g - g')‚à• = ‚à•hatg - g + g'‚à• : by abel ... ‚â§ ‚à•hatg - g‚à• + ‚à•(g' : completion G)‚à• : norm_add_le _ _ ... < Œ¥ + C'*‚à•f‚à•*‚à•hatg - g‚à• : by linarith ... ‚â§ Œ¥ + C'*‚à•f‚à•*Œ¥ : add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) Œ¥ ... = (1 + C'*‚à•f‚à•)*Œ¥ : by ring ... = Œµ : mul_div_cancel' _ ineq.ne.symm }
rw ‚Üê f.completion.is_closed_ker.closure_eq
{ rw ‚Üê f.completion.is_closed_ker.closure_eq, exact closure_mono f.ker_le_ker_completion }
exact closure_mono f.ker_le_ker_completion
intros
ext
ext; simp
simp
simp
simp
simp
intros
simp [log]
intros
{ rw exp_log_eq_abs (ne_of_lt hx), exact abs_of_neg hx }
rw exp_log_eq_abs (ne_of_lt hx)
exact abs_of_neg hx
intros
cases x
cases n; simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)]
cases n
{ cases n; simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)] }
simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)]
simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)]
{ simp [coe_rpow_of_nonneg _ (nat.cast_nonneg n)] }
simp [coe_rpow_of_nonneg _ (nat.cast_nonneg n)]
intros
rw [rpow_def_of_pos hx, exp_lt_one_iff, mul_neg_iff, log_pos_iff hx, log_neg_iff hx]
intros
simpa only [(‚àò), div_eq_inv_mul, mul_one] using (has_strict_deriv_at_sqrt hx).comp x hf
intros
simp only [‚Üê complex.cos_sub_pi_div_two, cos_eq_cos_iff, sub_eq_iff_eq_add]
refine exists_congr (Œª k, or_congr _ _)
refine exists_congr (Œª k, or_congr _ _); refine eq.congr rfl _; field_simp; ring
refine exists_congr (Œª k, or_congr _ _); refine eq.congr rfl _; field_simp
refine exists_congr (Œª k, or_congr _ _); refine eq.congr rfl _
refine eq.congr rfl _
field_simp
ring
refine eq.congr rfl _
field_simp
ring
intros
rcases exists_between (pos_iff_ne_zero.2 hŒµ) with ‚ü®r, h0r, hrŒµ‚ü©
rcases lt_iff_exists_coe.1 hrŒµ with ‚ü®x, rfl, hx‚ü©
rcases nnreal.exists_pos_sum_of_encodable (coe_pos.1 h0r).ne' Œπ with ‚ü®Œµ', hp, c, hc, hcr‚ü©
exact ‚ü®Œµ', hp, (ennreal.tsum_coe_eq hc).symm ‚ñ∏ lt_trans (coe_lt_coe.2 hcr) hrŒµ‚ü©
intros
rw [sub_def, ‚Üêcategory.comp_id a, ‚Üê prod.comp_lift, category.assoc, diag_œÉ, comp_zero]
intros
rw [hom_equiv_unit, G.map_comp, ‚Üê assoc, ‚Üêhom_equiv_unit]
intros
substI h; exact epi_of_epi f g
substI h
exact epi_of_epi f g
intros
dsimp only [functor.left_derived, functor.left_derived_obj_iso]
dsimp
simp only [category.comp_id, category.id_comp]
rw [‚Üêhomology_functor_map, homotopy_category.homology_functor_map_factors]
simp only [‚Üêfunctor.map_comp]
congr' 1
apply homotopy_category.eq_of_homotopy
apply functor.map_homotopy
apply homotopy.trans
exact homotopy_category.homotopy_out_map _
apply ProjectiveResolution.lift_homotopy f
{ simp, }
simp
{ simp [w], }
simp [w]
intros
ext
ext; simp
simp
intros
unfold preimage; obviously
unfold preimage
obviously
intros
simp only [cancel_epi]
intros
apply (cancel_mono (limit_obj_iso_limit_comp_evaluation H k).hom).1
ext
simpa using w j
intros
simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
dsimp
simp
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
ext
intros
apply (cancel_mono (œÅ_ X').hom).1
simp only [assoc, comp_id, iso.inv_hom_id]
rw [right_unitor_naturality, ‚Üêcategory.assoc, iso.inv_hom_id, category.id_comp]
intros
tidy
intros
simp [biprod.of_components]
intros
split
rintro ‚ü®a, rfl‚ü©
{ rintro ‚ü®a, rfl‚ü©, refl }
refl
rintro rfl
{ rintro rfl, apply singleton.mk, }
apply singleton.mk
intros
{ ext, dsimp, simp }
ext
dsimp
simp
intros
simp [lt_singleton_iff_mem_lt]
intros
have : c.embedding (c.index j) (c.inv_embedding j) ‚àà set.range (c.embedding (c.index j)) := set.mem_range_self _
rwa c.embedding_comp_inv j at this
intros
cases d with f s h
simp only [dart.rev, not_and, ne.def]
rintro rfl
exact false.elim (G.loopless _ h)
intros
obtain ‚ü®f, hf, rfl‚ü© := computable_iff.1 hp; exact ‚ü®by apply_instance, (cond hf (const ff) (const tt)).of_eq (Œª n, by {dsimp, cases f n; refl})‚ü©
obtain ‚ü®f, hf, rfl‚ü© := computable_iff.1 hp
exact ‚ü®by apply_instance, (cond hf (const ff) (const tt)).of_eq (Œª n, by {dsimp, cases f n; refl})‚ü©
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
rcases h with ‚ü®n, ‚ü®_x, h‚ÇÅ‚ü©, h‚ÇÇ‚ü©
{ rcases h with ‚ü®n, ‚ü®_x, h‚ÇÅ‚ü©, h‚ÇÇ‚ü©, have : ‚àÄ m a' (_: sum.inr a' ‚àà F a m) (_: b ‚àà pfun.fix f a'), b ‚àà pfun.fix f a, { intros m a' am ba, induction m with m IH generalizing a'; simp [F] at am, { rwa ‚Üê am }, rcases am with ‚ü®a‚ÇÇ, am‚ÇÇ, fa‚ÇÇ‚ü©, exact IH _ am‚ÇÇ (pfun.mem_fix_iff.2 (or.inr ‚ü®_, fa‚ÇÇ, ba‚ü©)) }, cases n; simp [F] at h‚ÇÇ, {cases h‚ÇÇ}, rcases h‚ÇÇ with h‚ÇÇ | ‚ü®a', am', fa'‚ü©, { cases h‚ÇÅ (nat.lt_succ_self _) with a' h, injection mem_unique h h‚ÇÇ }, { exact this _ _ am' (pfun.mem_fix_iff.2 (or.inl fa')) } }
have : ‚àÄ m a' (_: sum.inr a' ‚àà F a m) (_: b ‚àà pfun.fix f a'), b ‚àà pfun.fix f a
intros m a' am ba
{ intros m a' am ba, induction m with m IH generalizing a'; simp [F] at am, { rwa ‚Üê am }, rcases am with ‚ü®a‚ÇÇ, am‚ÇÇ, fa‚ÇÇ‚ü©, exact IH _ am‚ÇÇ (pfun.mem_fix_iff.2 (or.inr ‚ü®_, fa‚ÇÇ, ba‚ü©)) }
induction m with m IH generalizing a'; simp [F] at am
induction m with m IH generalizing a'
simp [F] at am
{ rwa ‚Üê am }
rwa ‚Üê am
simp [F] at am
rcases am with ‚ü®a‚ÇÇ, am‚ÇÇ, fa‚ÇÇ‚ü©
exact IH _ am‚ÇÇ (pfun.mem_fix_iff.2 (or.inr ‚ü®_, fa‚ÇÇ, ba‚ü©))
cases n; simp [F] at h‚ÇÇ
cases n
simp [F] at h‚ÇÇ
cases h‚ÇÇ
{cases h‚ÇÇ}
simp [F] at h‚ÇÇ
rcases h‚ÇÇ with h‚ÇÇ | ‚ü®a', am', fa'‚ü©
cases h‚ÇÅ (nat.lt_succ_self _) with a' h
{ cases h‚ÇÅ (nat.lt_succ_self _) with a' h, injection mem_unique h h‚ÇÇ }
injection mem_unique h h‚ÇÇ
{ exact this _ _ am' (pfun.mem_fix_iff.2 (or.inl fa')) }
exact this _ _ am' (pfun.mem_fix_iff.2 (or.inl fa'))
suffices : ‚àÄ a' (_: b ‚àà pfun.fix f a') k (_: sum.inr a' ‚àà F a k), ‚àÉ n, sum.inl b ‚àà F a n ‚àß ‚àÄ (m < n) (_ : k ‚â§ m), ‚àÉ a‚ÇÇ, sum.inr a‚ÇÇ ‚àà F a m
{ suffices : ‚àÄ a' (_: b ‚àà pfun.fix f a') k (_: sum.inr a' ‚àà F a k), ‚àÉ n, sum.inl b ‚àà F a n ‚àß ‚àÄ (m < n) (_ : k ‚â§ m), ‚àÉ a‚ÇÇ, sum.inr a‚ÇÇ ‚àà F a m, { rcases this _ h 0 (by simp [F]) with ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü©, exact ‚ü®_, ‚ü®‚ü®_, hn‚ÇÅ‚ü©, Œª m mn, hn‚ÇÇ m mn (nat.zero_le _)‚ü©, hn‚ÇÅ‚ü© }, intros a‚ÇÅ h‚ÇÅ, apply pfun.fix_induction h‚ÇÅ, intros a‚ÇÇ h‚ÇÇ IH k hk, rcases pfun.mem_fix_iff.1 h‚ÇÇ with h‚ÇÇ | ‚ü®a‚ÇÉ, am‚ÇÉ, fa‚ÇÉ‚ü©, { refine ‚ü®k.succ, _, Œª m mk km, ‚ü®a‚ÇÇ, _‚ü©‚ü©, { simp [F], exact or.inr ‚ü®_, hk, h‚ÇÇ‚ü© }, { rwa le_antisymm (nat.le_of_lt_succ mk) km } }, { rcases IH _ fa‚ÇÉ am‚ÇÉ k.succ _ with ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü©, { refine ‚ü®n, hn‚ÇÅ, Œª m mn km, _‚ü©, cases km.lt_or_eq_dec with km km, { exact hn‚ÇÇ _ mn km }, { exact km ‚ñ∏ ‚ü®_, hk‚ü© } }, { simp [F], exact ‚ü®_, hk, am‚ÇÉ‚ü© } } }
rcases this _ h 0 (by simp [F]) with ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü©
{ rcases this _ h 0 (by simp [F]) with ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü©, exact ‚ü®_, ‚ü®‚ü®_, hn‚ÇÅ‚ü©, Œª m mn, hn‚ÇÇ m mn (nat.zero_le _)‚ü©, hn‚ÇÅ‚ü© }
exact ‚ü®_, ‚ü®‚ü®_, hn‚ÇÅ‚ü©, Œª m mn, hn‚ÇÇ m mn (nat.zero_le _)‚ü©, hn‚ÇÅ‚ü©
intros a‚ÇÅ h‚ÇÅ
apply pfun.fix_induction h‚ÇÅ
intros a‚ÇÇ h‚ÇÇ IH k hk
rcases pfun.mem_fix_iff.1 h‚ÇÇ with h‚ÇÇ | ‚ü®a‚ÇÉ, am‚ÇÉ, fa‚ÇÉ‚ü©
refine ‚ü®k.succ, _, Œª m mk km, ‚ü®a‚ÇÇ, _‚ü©‚ü©
{ refine ‚ü®k.succ, _, Œª m mk km, ‚ü®a‚ÇÇ, _‚ü©‚ü©, { simp [F], exact or.inr ‚ü®_, hk, h‚ÇÇ‚ü© }, { rwa le_antisymm (nat.le_of_lt_succ mk) km } }
{ simp [F], exact or.inr ‚ü®_, hk, h‚ÇÇ‚ü© }
simp [F]
exact or.inr ‚ü®_, hk, h‚ÇÇ‚ü©
{ rwa le_antisymm (nat.le_of_lt_succ mk) km }
rwa le_antisymm (nat.le_of_lt_succ mk) km
rcases IH _ fa‚ÇÉ am‚ÇÉ k.succ _ with ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü©
{ rcases IH _ fa‚ÇÉ am‚ÇÉ k.succ _ with ‚ü®n, hn‚ÇÅ, hn‚ÇÇ‚ü©, { refine ‚ü®n, hn‚ÇÅ, Œª m mn km, _‚ü©, cases km.lt_or_eq_dec with km km, { exact hn‚ÇÇ _ mn km }, { exact km ‚ñ∏ ‚ü®_, hk‚ü© } }, { simp [F], exact ‚ü®_, hk, am‚ÇÉ‚ü© } }
refine ‚ü®n, hn‚ÇÅ, Œª m mn km, _‚ü©
{ refine ‚ü®n, hn‚ÇÅ, Œª m mn km, _‚ü©, cases km.lt_or_eq_dec with km km, { exact hn‚ÇÇ _ mn km }, { exact km ‚ñ∏ ‚ü®_, hk‚ü© } }
cases km.lt_or_eq_dec with km km
exact hn‚ÇÇ _ mn km
{ exact hn‚ÇÇ _ mn km }
exact km ‚ñ∏ ‚ü®_, hk‚ü©
{ exact km ‚ñ∏ ‚ü®_, hk‚ü© }
{ simp [F], exact ‚ü®_, hk, am‚ÇÉ‚ü© }
simp [F]
exact ‚ü®_, hk, am‚ÇÉ‚ü©
intros
letI := primcodable.subtype hp
refine (primcodable.prim (subtype p)).of_eq (Œª n, _)
rcases decode (subtype p) n with _|‚ü®a,h‚ü©
rcases decode (subtype p) n with _|‚ü®a,h‚ü©; refl
refl
refl
intros
rw list_blank.nth_map; refl
rw list_blank.nth_map
refl
intros
induction ab with c‚ÇÇ d‚ÇÇ ac cd IH
exact ‚ü®_, _, refl_trans_gen.refl, aa, refl_trans_gen.refl‚ü©
{ exact ‚ü®_, _, refl_trans_gen.refl, aa, refl_trans_gen.refl‚ü© }
rcases IH with ‚ü®e‚ÇÅ, e‚ÇÇ, ce, ee, ae‚ü©
{ rcases IH with ‚ü®e‚ÇÅ, e‚ÇÇ, ce, ee, ae‚ü©, rcases refl_trans_gen.cases_head ce with rfl | ‚ü®d', cd', de‚ü©, { have := H ee, revert this, cases eg : f‚ÇÅ e‚ÇÅ with g‚ÇÅ; simp only [respects, and_imp, exists_imp_distrib], { intro c0, cases cd.symm.trans c0 }, { intros g‚ÇÇ gg cg, rcases trans_gen.head'_iff.1 cg with ‚ü®d', cd', dg‚ü©, cases option.mem_unique cd cd', exact ‚ü®_, _, dg, gg, ae.tail eg‚ü© } }, { cases option.mem_unique cd cd', exact ‚ü®_, _, de, ee, ae‚ü© } }
rcases refl_trans_gen.cases_head ce with rfl | ‚ü®d', cd', de‚ü©
have := H ee
{ have := H ee, revert this, cases eg : f‚ÇÅ e‚ÇÅ with g‚ÇÅ; simp only [respects, and_imp, exists_imp_distrib], { intro c0, cases cd.symm.trans c0 }, { intros g‚ÇÇ gg cg, rcases trans_gen.head'_iff.1 cg with ‚ü®d', cd', dg‚ü©, cases option.mem_unique cd cd', exact ‚ü®_, _, dg, gg, ae.tail eg‚ü© } }
revert this
cases eg : f‚ÇÅ e‚ÇÅ with g‚ÇÅ; simp only [respects, and_imp, exists_imp_distrib]
cases eg : f‚ÇÅ e‚ÇÅ with g‚ÇÅ
simp only [respects, and_imp, exists_imp_distrib]
{ intro c0, cases cd.symm.trans c0 }
intro c0
cases cd.symm.trans c0
simp only [respects, and_imp, exists_imp_distrib]
intros g‚ÇÇ gg cg
{ intros g‚ÇÇ gg cg, rcases trans_gen.head'_iff.1 cg with ‚ü®d', cd', dg‚ü©, cases option.mem_unique cd cd', exact ‚ü®_, _, dg, gg, ae.tail eg‚ü© }
rcases trans_gen.head'_iff.1 cg with ‚ü®d', cd', dg‚ü©
cases option.mem_unique cd cd'
exact ‚ü®_, _, dg, gg, ae.tail eg‚ü©
cases option.mem_unique cd cd'
{ cases option.mem_unique cd cd', exact ‚ü®_, _, de, ee, ae‚ü© }
exact ‚ü®_, _, de, ee, ae‚ü©
intros
dsimp [part.fix]; rw assert_neg h'
dsimp [part.fix]
rw assert_neg h'
intros
by_cases hh : ‚àÉ i b, b ‚àà approx f i x
rcases hh with ‚ü®i,b,hb‚ü©
{ rcases hh with ‚ü®i,b,hb‚ü©, existsi i, intros b' h', have hb' := approx_le_fix f i _ _ hb, have hh := part.mem_unique h' hb', subst hh, exact hb }
existsi i
intros b' h'
have hb' := approx_le_fix f i _ _ hb
have hh := part.mem_unique h' hb'
subst hh
exact hb
{ simp only [not_exists] at hh, existsi 0, intros b' h', simp only [mem_iff f] at h', cases h' with i h', cases hh _ _ h' }
simp only [not_exists] at hh
existsi 0
intros b' h'
simp only [mem_iff f] at h'
cases h' with i h'
cases hh _ _ h'
intros
{ ext y, exact preserves_map Œ∑ x y }
ext y
exact preserves_map Œ∑ x y
intros
rw @map_eq_traverse_id t _ _ _ _ f
refine (comp_traverse (id.mk ‚àò f) g x).symm.trans _
congr
apply comp.applicative_comp_id
intros
rw [to_fin, fin.coe_of_nat_eq_mod', nat.mod_eq_of_lt]
rw [to_fin, fin.coe_of_nat_eq_mod', nat.mod_eq_of_lt]; apply to_nat_lt
apply to_nat_lt
intros
convert read_to_buffer' _ _ _
{ convert read_to_buffer' _ _ _, { simp }, { simpa using i.property } }
simp
{ simp }
simpa using i.property
{ simpa using i.property }
intros
cases h : p cb n; simp [decorate_errors, h, eq_comm]
cases h : p cb n
simp [decorate_errors, h, eq_comm]
simp [decorate_errors, h, eq_comm]
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, ‚Üêorelse_eq_orelse, parser.orelse]
by_cases hn : np = n
{ by_cases hn : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] } }, { simp [hp, hn, ‚Üêorelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] } }
{ simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|rfl|H
{ rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
simp [hp, hn, hq, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ‚Üêorelse_eq_orelse, parser.orelse]
{ simp [hp, hn, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hn, ‚Üêorelse_eq_orelse, parser.orelse]
intros
dsimp only [sat]
split_ifs; simp [*, eq_comm]
split_ifs
simp [*, eq_comm]
simp [*, eq_comm]
simp [*, eq_comm]
intros
simp [many_char1, ‚Üêstring.nil_as_string_eq_empty]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
intros
rw [le_def, not_and_distrib, not_le]
intros
rw [‚Üê of_real_exp_of_real_re, of_real_im]
intros
rw [‚Üê cosh_add_sinh, sinh_mul_I, cosh_mul_I]
intros
simp only [I_re, zero_sub, I_im', zero_mul, mul_re]
intros
{ ext, simp [smul_ite] }
ext
simp [smul_ite]
intros
refine add_monoid_hom.eq_of_eq_on_mdense add_closure_Union_range_single (Œª f hf, _)
simp only [set.mem_Union, set.mem_range] at hf
rcases hf with ‚ü®x, y, rfl‚ü©
apply H
intros
ext
{ ext, refl }
refl
intros
{ ext x, by_cases h : p x; simp [h] }
ext x
by_cases h : p x
by_cases h : p x; simp [h]
simp [h]
simp [h]
intros
split
{ simp [he.1] }
simp [he.1]
assume x hx
{ assume x hx, simp only [mem_inter_eq, restr_source] at hx, exact he.2 hx.1 }
simp only [mem_inter_eq, restr_source] at hx
exact he.2 hx.1
intros
ext i
have h' := fin.cast_lt_cast_succ i i.is_lt
simp [init, snoc, i.is_lt, h']
convert cast_eq rfl (p i)
intros
simp [fin.eq_iff_veq]
intros
rw [reverse_induction, dif_neg (ne_of_lt (fin.cast_succ_lt_last i))]
cases i
refl
intros
cases s‚ÇÅ; cases s‚ÇÇ; refl
cases s‚ÇÅ; cases s‚ÇÇ
cases s‚ÇÅ
cases s‚ÇÇ
refl
intros
ext
ext; simp
simp
intros
simp [finset.ext_iff, perm_ext (nodup_erase_dup _) (nodup_erase_dup _)]
intros
simp only [‚Üê not_nonempty_iff_eq_empty, sigma_nonempty, not_exists]
intros
split
split; intro t
intro t
rw t
refine ‚ü®finset.mem_singleton_self _, Œª _, finset.mem_singleton.1‚ü©
intro t
ext
rw finset.mem_singleton
refine ‚ü®t.right _, Œª r, r.symm ‚ñ∏ t.left‚ü©
intros
rw [‚Üê union_eq_left_iff_subset, eq_comm]
intros
simp only [finset.supr_insert, update_same]
rcongr i hi
apply update_noteq
rintro rfl
exact hx hi
intros
rw le_iff_exists_add
use kl.2
rwa [mem_antidiagonal, eq_comm] at hlk
intros
ext
{ ext, simp }
simp
intros
rw [subsingleton.elim i ‚ü®0, zero_lt_one‚ü©, order_emb_of_fin_zero _ zero_lt_one, min'_singleton]
intros
ext x
ext x; simp [map_domain_equiv_apply]
simp [map_domain_equiv_apply]
intros
split
intro h
{ intro h, exact ‚ü®h.1, card_congr (equiv.of_bijective f h)‚ü© }
exact ‚ü®h.1, card_congr (equiv.of_bijective f h)‚ü©
rintro ‚ü®hf, h‚ü©
{ rintro ‚ü®hf, h‚ü©, refine ‚ü®hf, _‚ü©, rwa ‚Üêinjective_iff_surjective_of_equiv (equiv_of_card_eq h) }
refine ‚ü®hf, _‚ü©
rwa ‚Üêinjective_iff_surjective_of_equiv (equiv_of_card_eq h)
intros
let q
swap
change quotient.lift_on q _ _ = _
have : q = ‚ü¶Œª i h, f i‚üß
dsimp [q]
{ dsimp [q], exact quotient.induction_on (@finset.univ Œπ _).1 (Œª l, quotient.fin_choice_aux_eq _ _) }
exact quotient.induction_on (@finset.univ Œπ _).1 (Œª l, quotient.fin_choice_aux_eq _ _)
simp [this]
exact setoid.refl _
intros
classical
by_contra hf
push_neg at hf
haveI := Œª y, fintype_of_not_infinite $ hf y
let key : fintype Œ± := { elems := univ.bUnion (Œª (y : Œ≤), (f ‚Åª¬π' {y}).to_finset), complete := by simp }
exact key.false
intros
rw ‚Üê of_equiv_card f; congr
rw ‚Üê of_equiv_card f
congr
intros
simp only [prod_dite, attach_eq_univ]
congr' 1
convert (equiv.subtype_equiv_right _).prod_comp (Œª x : {x // p x}, f x x.2)
{ convert (equiv.subtype_equiv_right _).prod_comp (Œª x : {x // p x}, f x x.2), simp }
simp
convert (equiv.subtype_equiv_right _).prod_comp (Œª x : {x // ¬¨p x}, g x x.2)
{ convert (equiv.subtype_equiv_right _).prod_comp (Œª x : {x // ¬¨p x}, g x x.2), simp }
simp
intros
lift a to ‚Ñï using ha
norm_cast
intros
simp [neg_succ_of_nat_eq, sub_eq_neg_add]
intros
rw [mul_comm i k, mul_comm j k] at H; exact dvd_of_mul_dvd_mul_left k_non_zero H
rw [mul_comm i k, mul_comm j k] at H
exact dvd_of_mul_dvd_mul_left k_non_zero H
intros
rwa [‚Üê hx, ‚Üê hy, int.coe_nat_lcm]
intros
{ rw [add_comm a, add_comm b] at h‚ÇÇ, exact h‚ÇÅ.add_left_cancel h‚ÇÇ }
rw [add_comm a, add_comm b] at h‚ÇÇ
exact h‚ÇÅ.add_left_cancel h‚ÇÇ
simp [‚Üê set.compl_set_of, is_compl_compl]
intros
induction l with hd tl IH
intros n hn m hm h
{ intros n hn m hm h, simp only [set.mem_singleton_iff, set.set_of_eq_eq_singleton, length, nonpos_iff_eq_zero] at hn hm, simp [hn, hm] }
simp only [set.mem_singleton_iff, set.set_of_eq_eq_singleton, length, nonpos_iff_eq_zero] at hn hm
simp [hn, hm]
intros n hn m hm h
{ intros n hn m hm h, simp only [length, set.mem_set_of_eq] at hn hm, simp only [mem_cons_iff, not_or_distrib] at hx, cases n; cases m, { refl }, { simpa [hx.left] using h }, { simpa [ne.symm hx.left] using h }, { simp only [true_and, eq_self_iff_true, insert_nth_succ_cons] at h, rw nat.succ_inj', refine IH hx.right _ _ h, { simpa [nat.succ_le_succ_iff] using hn }, { simpa [nat.succ_le_succ_iff] using hm } } }
simp only [length, set.mem_set_of_eq] at hn hm
simp only [mem_cons_iff, not_or_distrib] at hx
cases n; cases m
cases n
cases m
{ refl }
refl
{ simpa [hx.left] using h }
simpa [hx.left] using h
cases m
{ simpa [ne.symm hx.left] using h }
simpa [ne.symm hx.left] using h
simp only [true_and, eq_self_iff_true, insert_nth_succ_cons] at h
{ simp only [true_and, eq_self_iff_true, insert_nth_succ_cons] at h, rw nat.succ_inj', refine IH hx.right _ _ h, { simpa [nat.succ_le_succ_iff] using hn }, { simpa [nat.succ_le_succ_iff] using hm } }
rw nat.succ_inj'
refine IH hx.right _ _ h
{ simpa [nat.succ_le_succ_iff] using hn }
simpa [nat.succ_le_succ_iff] using hn
{ simpa [nat.succ_le_succ_iff] using hm }
simpa [nat.succ_le_succ_iff] using hm
intros
simp [take_append_eq_append_take, take_all_of_le le_self_add]
intros
induction l with hd tl ih
refl
{refl}
simp only [mem_cons_iff, or_imp_distrib, forall_and_distrib, forall_eq] at H
simp only [foldr, ih H.2, H.1]
intros
rw [foldl_cons, hc.comm, foldl_assoc]
intros
{ cases L, { simp at h, cases h, }, { simp, }, }
cases L
simp at h
{ simp at h, cases h, }
cases h
simp
{ simp, }
intros
rw [‚Üê filter_map_eq_map, filter_map_filter_map]
rw [‚Üê filter_map_eq_map, filter_map_filter_map]; refl
refl
intros
rw [eq_comm, append_eq_cons_iff]
intros
rw [‚Üê permutations_aux2_append, map_permutations_aux2, permutations_aux2_comp_append]
intros
cases n; refl
cases n
refl
refl
intros
simp only [concat_eq_append, reverse_cons, reverse_reverse]
intros
rw [prev, dif_pos hx]
intros
induction xs with z zs IH
{ simp }
simp
obtain ‚ü®hz, hzs‚ü© := not_or_distrib.mp (mt (mem_cons_iff _ _ _).mp h)
{ obtain ‚ü®hz, hzs‚ü© := not_or_distrib.mp (mt (mem_cons_iff _ _ _).mp h), rw [cons_append, next_or_cons_of_ne _ _ _ _ hz, IH hzs] }
rw [cons_append, next_or_cons_of_ne _ _ _ _ hz, IH hzs]
intros
induction as generalizing start
{ refl }
refl
simp [mmap_with_index_aux, mmap_with_index_aux_spec_cons, *]
{ simp [mmap_with_index_aux, mmap_with_index_aux_spec_cons, *] }
intros
induction d with b l m d IH
refl
{refl}
by_cases b = a
subst h
{ subst h, rw [erase_cons_head, filter_cons_of_neg], symmetry, rw filter_eq_self, simpa only [ne.def, eq_comm] using m, exact not_not_intro rfl }
rw [erase_cons_head, filter_cons_of_neg]
symmetry
rw filter_eq_self
simpa only [ne.def, eq_comm] using m
exact not_not_intro rfl
rw [erase_cons_tail _ h, filter_cons_of_pos, IH]
{ rw [erase_cons_tail _ h, filter_cons_of_pos, IH], exact h }
exact h
intros
simp only [enum_from_eq_zip_range', unzip_zip, length_range']
intros
refine ‚ü®Œª h, _, Œª h, by simp [cyclic_permutations, h, init_eq_take]‚ü©
rw [eq_comm, ‚Üêis_rotated_singleton_iff', ‚Üêmem_cyclic_permutations_iff, h, mem_singleton]
intros
simp [kerase, h]
intros
cases l
cases l; refl
refl
refl
intros
{ ext, apply add_dot_product }
ext
apply add_dot_product
intros
{ ext, simp [h], }
ext
simp [h]
intros
simp [diagonal, h]
intros
simp [dot_product]
intros
{ ext, apply smul_dot_product, }
ext
apply smul_dot_product
intros
ext
simp only [block_diagonal_apply, pi.add_apply]
split_ifs; simp
split_ifs
simp
simp
intros
{ ext, simp [vec_tail] }
ext
simp [vec_tail]
intros
{ ext i, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
rw [add_comm, erase_add_right_neg s h, add_comm]
intros
rw [‚Üê sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]
rw [‚Üê sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]; simp
simp
intros
{ ext, exacts [hC _, hX _] }
ext
exacts [hC _, hX _]
intros
simp only [monomial_eq, ring_hom.map_mul, eval‚ÇÇ_hom_C, finsupp.prod, ring_hom.map_prod, ring_hom.map_pow, eval‚ÇÇ_hom_X']
intros
rw ‚Üêvars_neg q at hpq
convert vars_add_of_disjoint hpq using 2
convert vars_add_of_disjoint hpq using 2; simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
intros
simp only [join‚ÇÇ, bind‚ÇÇ, eval‚ÇÇ_hom_map_hom, ring_hom.id_comp]
intros
rw [vars, degrees_zero, multiset.to_finset_zero]
intros
conv {to_lhs, rw [‚Üê mul_one(m)]}
exact decidable.mul_le_mul_of_nonneg_left (nat.succ_le_of_lt h) dec_trivial
intros
cases b; norm_num [bit0_eq_zero, nat.bit1_ne_zero]
{ cases b; norm_num [bit0_eq_zero, nat.bit1_ne_zero] }
cases b
norm_num [bit0_eq_zero, nat.bit1_ne_zero]
norm_num [bit0_eq_zero, nat.bit1_ne_zero]
intros
split_ifs; refl
{ split_ifs; refl, }
split_ifs
refl
refl
intros
rw [add_comm k n, add_comm k m]
apply dist_add_add_right
intros
apply enat.cases_on a; apply enat.cases_on b; simp; simp only [(nat.cast_add _ _).symm, enat.coe_ne_top]; simp
apply enat.cases_on a; apply enat.cases_on b; simp; simp only [(nat.cast_add _ _).symm, enat.coe_ne_top]
apply enat.cases_on a; apply enat.cases_on b; simp
apply enat.cases_on a; apply enat.cases_on b
apply enat.cases_on a
apply enat.cases_on b
simp
simp
apply enat.cases_on b
simp
simp
simp only [(nat.cast_add _ _).symm, enat.coe_ne_top]
simp
intros
rwa [gcd_eq_left_iff_dvd, ‚Üê fib_gcd, gcd_eq_left_iff_dvd.mp]
intros
rw [clog, if_pos (‚ü®hb, hn‚ü© : 1 < b ‚àß 1 < n)]
intros
rw [‚Üê (supr_prod : (‚®Ü i : ‚Ñï √ó ‚Ñï, f i.1 i.2) = _), ‚Üê nat.surjective_unpair.supr_comp]
intros
rw lt_size; refl
rw lt_size
refl
intros
rw ‚Üê not_lt; exact not_congr cast_lt
rw ‚Üê not_lt
exact not_congr cast_lt
intros
cases x; simp only [pbind, none_bind', some_bind']
{ cases x; simp only [pbind, none_bind', some_bind'] }
cases x
simp only [pbind, none_bind', some_bind']
simp only [pbind, none_bind', some_bind']
intros
cases x; [contradiction, rw get_or_else_some]
cases x
contradiction
rw get_or_else_some
intros
rw [balance_l_eq_balance hl.2 hr.2 H‚ÇÅ H‚ÇÇ, balance_eq_balance' hl.3 hr.3 hl.2 hr.2]
refine hl.balance'_aux hr (or.inl _) H‚ÇÉ
cases nat.eq_zero_or_pos (size r) with r0 r0
{ rw r0, exact nat.zero_le _ }
rw r0
exact nat.zero_le _
cases nat.eq_zero_or_pos (size l) with l0 l0
rw l0
{ rw l0, exact le_trans (nat.mul_le_mul_left _ (H‚ÇÅ l0)) dec_trivial }
exact le_trans (nat.mul_le_mul_left _ (H‚ÇÅ l0)) dec_trivial
replace H‚ÇÇ : _ ‚â§ 3 * _ := H‚ÇÇ l0 r0
linarith
intros
rw [‚Üê dual_dual (rotate_l _ _ _), dual_rotate_l, dual_dual, dual_dual]
intros
rw [‚Üê dual_dual (erase_min _), dual_erase_min, dual_dual]
intros
dsimp [of_set]
split_ifs
simp only [iff_self_and, option.mem_def, eq_comm]
{ simp only [iff_self_and, option.mem_def, eq_comm], rintro rfl, exact h, }
rintro rfl
exact h
simp only [false_iff, not_and, option.not_mem_none]
{ simp only [false_iff, not_and, option.not_mem_none], rintro rfl, exact h, }
rintro rfl
exact h
intros
cases h‚ÇÅ.symm.trans h‚ÇÇ; refl
cases h‚ÇÅ.symm.trans h‚ÇÇ
refl
intros
{ constructor }
constructor
intros
dsimp [div, mod_div]
cases (m : ‚Ñï) % (k : ‚Ñï)
{ rw [if_pos rfl], refl }
rw [if_pos rfl]
refl
{ rw [if_neg n.succ_ne_zero], refl }
rw [if_neg n.succ_ne_zero]
refl
intros
simp [to_finsupp_iso, monomial, monomial_fun]
intros
induction n with n hn
{ rw [pow_zero, monomial_zero_one] }
rw [pow_zero, monomial_zero_one]
{ rw [pow_succ', hn, X, monomial_mul_monomial, one_mul] }
rw [pow_succ', hn, X, monomial_mul_monomial, one_mul]
intros
by_cases ha : a = 0
have : C a = 0
{ have : C a = 0, { rw [ha, C_0] }, rw [nat_degree, degree_eq_bot.2 this], refl }
rw [ha, C_0]
{ rw [ha, C_0] }
rw [nat_degree, degree_eq_bot.2 this]
refl
{ rw [nat_degree, degree_C ha], refl }
rw [nat_degree, degree_C ha]
refl
intros
rw [ne.def, leading_coeff_eq_zero]
intros
rw [‚Üê nonpos_iff_eq_zero, nat_degree_le_iff_degree_le, with_bot.coe_zero]
intros
by_cases p0 : p = 0
{ rw [p0, mul_zero] }
rw [p0, mul_zero]
exact nat_degree_C_mul_eq_of_mul_ne_zero (mul_ne_zero a0 (leading_coeff_ne_zero.mpr p0))
{ exact nat_degree_C_mul_eq_of_mul_ne_zero (mul_ne_zero a0 (leading_coeff_ne_zero.mpr p0)) }
intros
rw [trailing_degree_eq_nat_trailing_degree hp, with_top.coe_eq_coe]
intros
ext
exact P.eval_eq_finset_sum x
intros
have A : p.nat_degree < p.nat_degree.succ := nat.lt_succ_self _
have B : (s ‚Ä¢ p).nat_degree < p.nat_degree.succ := (nat_degree_smul_le _ _).trans_lt A
rw [eval‚ÇÇ_eq_sum, eval‚ÇÇ_eq_sum, sum_over_range' _ _ _ A, sum_over_range' _ _ _ B]
rw [eval‚ÇÇ_eq_sum, eval‚ÇÇ_eq_sum, sum_over_range' _ _ _ A, sum_over_range' _ _ _ B]; simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
intros
induction n with n ih
{ simp only [iterated_deriv_zero_right] }
simp only [iterated_deriv_zero_right]
{ simp only [iterated_deriv_succ, ih, derivative_smul] }
simp only [iterated_deriv_succ, ih, derivative_smul]
intros
simp [mirror]
intros
by_cases hq : q = 0; simp [h.mul_right_ne_zero, hq]
by_cases hq : q = 0
simp [h.mul_right_ne_zero, hq]
simp [h.mul_right_ne_zero, hq]
intros
rw [leading_coeff, reverse_nat_degree, ‚Üêrev_at_le f.nat_trailing_degree_le_nat_degree, coeff_reverse, rev_at_invol, trailing_coeff]
intros
simp_rw [is_root, eval_mul, mul_eq_zero]
intros
rw ‚Üêabs_repr x
cases repr x with a f
rw [‚Üêabs_map, mvpfunctor.map_eq]
rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, ‚Üê image_comp]
refl
intros
rw coe_int_eq_of_int; refl
rw coe_int_eq_of_int
refl
intros
rw [‚Üê cast_zero, cast_lt]
linarith [gold_add_gold_conj]
intros
rw [‚Üê and_iff_right_of_imp (Œª h, (sqrt_nonneg x).trans h), and.congr_right_iff]
exact sqrt_le_left
intros
simp [set.preimage, function.graph, rel.core]
intros
haveI := of_think_terminates h.terminates
have := results_of_terminates' _ (of_think_mem h.mem)
exact ‚ü®_, this, results.len_unique h (results_think this)‚ü©
intros
rw [lift_rel.swap, lift_rel_return_left]
intros
cases s with st
have : st n = some a
from s_nth_eq_some
cases s' with st'
have : st' n = some b
from s_nth_eq_some'
simp only [zip_with, seq.nth, *]
intros
{ ext, split; simp [or_imp_distrib, h] {contextual := tt} }
ext
split
split; simp [or_imp_distrib, h] {contextual := tt}
simp [or_imp_distrib, h] {contextual := tt}
simp [or_imp_distrib, h] {contextual := tt}
intros
suffices : ‚àÄ x, x·∂ú = t ‚Üî t·∂ú = x
simp [this]
{ simp [this] }
intro x
split
split; { intro e, subst e, simp }
{ intro e, subst e, simp }
intro e
{ intro e, subst e, simp }
subst e
simp
intros
rw [‚Üê image_comp, h.comp_eq_id, image_id]
intros
rw [‚Üê range_iff_surjective, range_inclusion, eq_univ_iff_forall] at h_surj
exact set.subset.antisymm h (Œª x hx, h_surj ‚ü®x, hx‚ü©)
intros
simp only [insert_subset, exists_and_distrib_right, ssubset_def, not_subset]
simp only [exists_prop, and_comm]
intros
letI : encodable s := countable.to_encodable hc
letI : nonempty s := hs.to_subtype
have : countable (univ : set s) := countable_encodable _
rcases countable_iff_exists_surjective.1 this with ‚ü®g, hg‚ü©
have : range g = univ := univ_subset_iff.1 hg
use coe ‚àò g
simp only [range_comp, this, image_univ, subtype.range_coe]
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
{ ext x, simp [Iic] }
ext x
simp [Iic]
intros
rw [e.image_eq_preimage, e.symm.preimage_Icc, e.symm_symm]
intros
rw [diff_eq, compl_Ici, Ici_inter_Iio]
intros
simp [lt_irrefl]
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
rcases lt_or_eq_of_le hab with hab|hab
intros p hp
{ intros p hp, rcases mem_Ioo_or_eq_endpoints_of_mem_Icc hp with hp'|‚ü®hp'|hp'‚ü©, { rw hp', refine ‚ü®a, left_mem_Icc.mpr (le_of_lt hab), rfl‚ü© }, { rw hp', refine ‚ü®b, right_mem_Icc.mpr (le_of_lt hab), rfl‚ü© }, { have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ‚ü®x, Ioo_subset_Icc_self hx.1, hx.2‚ü© } }
rcases mem_Ioo_or_eq_endpoints_of_mem_Icc hp with hp'|‚ü®hp'|hp'‚ü©
rw hp'
{ rw hp', refine ‚ü®a, left_mem_Icc.mpr (le_of_lt hab), rfl‚ü© }
refine ‚ü®a, left_mem_Icc.mpr (le_of_lt hab), rfl‚ü©
rw hp'
{ rw hp', refine ‚ü®b, right_mem_Icc.mpr (le_of_lt hab), rfl‚ü© }
refine ‚ü®b, right_mem_Icc.mpr (le_of_lt hab), rfl‚ü©
have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp'
{ have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ‚ü®x, Ioo_subset_Icc_self hx.1, hx.2‚ü© }
cases this with x hx
exact ‚ü®x, Ioo_subset_Icc_self hx.1, hx.2‚ü©
simp only [hab, Icc_self]
{ simp only [hab, Icc_self], intros _ hp, exact ‚ü®b, mem_singleton _, (mem_singleton_iff.mp hp).symm‚ü© }
intros _ hp
exact ‚ü®b, mem_singleton _, (mem_singleton_iff.mp hp).symm‚ü©
intros
refine set.ext (Œª c, iff.intro _ _)
rintro ‚ü®f, hfs, b, ‚ü®g, hg, a, hau, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®f, hfs, b, ‚ü®g, hg, a, hau, rfl‚ü©, rfl‚ü©, exact ‚ü®f ‚àò g, ‚ü®(‚àò) f, mem_image_of_mem _ hfs, g, hg, rfl‚ü©, a, hau, rfl‚ü© }
exact ‚ü®f ‚àò g, ‚ü®(‚àò) f, mem_image_of_mem _ hfs, g, hg, rfl‚ü©, a, hau, rfl‚ü©
rintro ‚ü®fg, ‚ü®fc, ‚ü®f, hfs, rfl‚ü©, g, hgt, rfl‚ü©, a, ha, rfl‚ü©
{ rintro ‚ü®fg, ‚ü®fc, ‚ü®f, hfs, rfl‚ü©, g, hgt, rfl‚ü©, a, ha, rfl‚ü©, exact ‚ü®f, hfs, g a, ‚ü®g, hgt, a, ha, rfl‚ü©, rfl‚ü© }
exact ‚ü®f, hfs, g a, ‚ü®g, hgt, a, ha, rfl‚ü©, rfl‚ü©
intros
simp only [Inter_and, @Inter_comm _ Œπ']
intros
simp [set.ext_iff]
intros
intros z z'
refine quotient.ind‚ÇÇ (Œª z z', _) z z'
cases z with x y
cases z' with x' y'
rw [map_pair_eq, eq_iff]
repeat { rw [map_pair_eq, eq_iff] }
rw [map_pair_eq, eq_iff]
rw [map_pair_eq, eq_iff]
rintro (h|h); simp [hinj h.1, hinj h.2]
rintro (h|h)
simp [hinj h.1, hinj h.2]
simp [hinj h.1, hinj h.2]
intros
simp [tprod.elim]
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
simp only [closure_eq_mclosure, monoid.mem_closure_union_iff, exists_prop, preimage_union]
split
rintro ‚ü®_, ‚ü®ys, hys, yt, hyt, rfl‚ü©, _, ‚ü®zs, hzs, zt, hzt, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®_, ‚ü®ys, hys, yt, hyt, rfl‚ü©, _, ‚ü®zs, hzs, zt, hzt, rfl‚ü©, rfl‚ü©, refine ‚ü®_, ‚ü®_, hys, _, hzs, rfl‚ü©, _, ‚ü®_, hyt, _, hzt, rfl‚ü©, _‚ü©, rw [mul_assoc, mul_assoc, mul_left_comm zs] }
refine ‚ü®_, ‚ü®_, hys, _, hzs, rfl‚ü©, _, ‚ü®_, hyt, _, hzt, rfl‚ü©, _‚ü©
rw [mul_assoc, mul_assoc, mul_left_comm zs]
rintro ‚ü®_, ‚ü®ys, hys, zs, hzs, rfl‚ü©, _, ‚ü®yt, hyt, zt, hzt, rfl‚ü©, rfl‚ü©
{ rintro ‚ü®_, ‚ü®ys, hys, zs, hzs, rfl‚ü©, _, ‚ü®yt, hyt, zt, hzt, rfl‚ü©, rfl‚ü©, refine ‚ü®_, ‚ü®ys, hys, yt, hyt, rfl‚ü©, _, ‚ü®zs, hzs, zt, hzt, rfl‚ü©, _‚ü©, rw [mul_assoc, mul_assoc, mul_left_comm yt] }
refine ‚ü®_, ‚ü®ys, hys, yt, hyt, rfl‚ü©, _, ‚ü®zs, hzs, zt, hzt, rfl‚ü©, _‚ü©
rw [mul_assoc, mul_assoc, mul_left_comm yt]
intros
simpa only [nsmul_one, add_left_iterate] using function.commute.iterate_right f.map_one_add n
intros
obtain ‚ü®x, xmem, hx‚ü© : ‚àÉ x ‚àà Icc (0:‚Ñù) 1, ‚àÄ y ‚àà Icc (0:‚Ñù) 1, f x - x ‚â§ f y - y
from is_compact_Icc.exists_forall_le (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuous_on
refine lt_of_lt_of_le (lt_sub_iff_add_lt'.2 $ hz x) _
apply le_translation_number_of_add_le
simp only [‚Üê le_sub_iff_add_le']
exact f.forall_map_sub_of_Icc _ hx
intros
by_cases ha : a = 0
rw [ha, C_0, sub_zero]
{ rw [ha, C_0, sub_zero], exact gal_X_pow_is_solvable n }
exact gal_X_pow_is_solvable n
have ha' : algebra_map F (X ^ n - C a).splitting_field a ‚â† 0 := mt ((ring_hom.injective_iff _).mp (ring_hom.injective _) a) ha
by_cases hn : n = 0
rw [hn, pow_zero, ‚ÜêC_1, ‚ÜêC_sub]
{ rw [hn, pow_zero, ‚ÜêC_1, ‚ÜêC_sub], exact gal_C_is_solvable (1 - a) }
exact gal_C_is_solvable (1 - a)
have hn' : 0 < n := pos_iff_ne_zero.mpr hn
have hn'' : X ^ n - C a ‚â† 0 := Œª h, one_ne_zero ((leading_coeff_X_pow_sub_C hn').symm.trans (congr_arg leading_coeff h))
have hn''' : (X ^ n - 1 : polynomial F) ‚â† 0 := Œª h, one_ne_zero ((leading_coeff_X_pow_sub_one hn').symm.trans (congr_arg leading_coeff h))
have mem_range : ‚àÄ {c}, c ^ n = 1 ‚Üí ‚àÉ d, algebra_map F (X ^ n - C a).splitting_field d = c := Œª c hc, ring_hom.mem_range.mp (minpoly.mem_range_of_degree_eq_one F c (or.resolve_left h hn''' (minpoly.irreducible ((splitting_field.normal (X ^ n - C a)).is_integral c)) (minpoly.dvd F c (by rwa [map_id, alg_hom.map_sub, sub_eq_zero, aeval_X_pow, aeval_one]))))
apply is_solvable_of_comm
intros œÉ œÑ
ext b hb
rw [mem_root_set hn'', alg_hom.map_sub, aeval_X_pow, aeval_C, sub_eq_zero] at hb
have hb' : b ‚â† 0
intro hb'
{ intro hb', rw [hb', zero_pow hn'] at hb, exact ha' hb.symm }
rw [hb', zero_pow hn'] at hb
exact ha' hb.symm
have key : ‚àÄ œÉ : (X ^ n - C a).gal, ‚àÉ c, œÉ b = b * algebra_map F _ c
intro œÉ
{ intro œÉ, have key : (œÉ b / b) ^ n = 1 := by rw [div_pow, ‚ÜêœÉ.map_pow, hb, œÉ.commutes, div_self ha'], obtain ‚ü®c, hc‚ü© := mem_range key, use c, rw [hc, mul_div_cancel' (œÉ b) hb'] }
have key : (œÉ b / b) ^ n = 1 := by rw [div_pow, ‚ÜêœÉ.map_pow, hb, œÉ.commutes, div_self ha']
obtain ‚ü®c, hc‚ü© := mem_range key
use c
rw [hc, mul_div_cancel' (œÉ b) hb']
obtain ‚ü®c, hc‚ü© := key œÉ
obtain ‚ü®d, hd‚ü© := key œÑ
rw [œÉ.mul_apply, œÑ.mul_apply, hc, œÑ.map_mul, œÑ.commutes, hd, œÉ.map_mul, œÉ.commutes, hc]
rw [mul_assoc, mul_assoc, mul_right_inj' hb', mul_comm]
intros
{ rw dim_adjoin_eq_one_iff, exact set.singleton_subset_iff }
rw dim_adjoin_eq_one_iff
exact set.singleton_subset_iff
intros
split
introI h
{ introI h, exact is_galois.tower_top_of_is_galois (‚ä• : intermediate_field F E) F E }
exact is_galois.tower_top_of_is_galois (‚ä• : intermediate_field F E) F E
{ introI h, apply_instance }
introI h
apply_instance
intros
delta minpoly
split_ifs with hx
exact le_of_not_lt (well_founded.not_lt_min degree_lt_wf _ hx ‚ü®pmonic, hp‚ü©)
{ exact le_of_not_lt (well_founded.not_lt_min degree_lt_wf _ hx ‚ü®pmonic, hp‚ü©) }
{ simp only [degree_zero, bot_le] }
simp only [degree_zero, bot_le]
intros
simp_rw [monomial_eq_smul_X, alg_hom.map_smul, alg_hom.map_pow, expand_X, mul_comm, pow_mul]
intros
have h := vsub_orthogonal_projection_mem_direction_orthogonal s (v +·µ• p)
rw [vadd_vsub_assoc, submodule.add_mem_iff_right _ hv] at h
refine (eq_of_vsub_eq_zero _).symm
ext
refine submodule.disjoint_def.1 s.direction.orthogonal_disjoint _ _ h
exact (_ : s.direction).2
intros
simp_rw [monge_point_eq_smul_vsub_vadd_circumcenter, centroid_eq_of_range_eq h, circumcenter_eq_of_range_eq h]
intros
rw div_eq_mul_inv
{ rw div_eq_mul_inv, exact ((smooth_mul I).comp_smooth_on (hf.prod_mk hg.inv) : _), }
exact ((smooth_mul I).comp_smooth_on (hf.prod_mk hg.inv) : _)
intros
split
introsI _i
{ introsI _i, apply structure_groupoid.le_iff.mpr, rintros e ‚ü®s, hs, hes‚ü©, refine G.eq_on_source _ hes, convert closed_under_restriction' G.id_mem hs, change s = _ ‚à© _, rw hs.interior_eq, simp only with mfld_simps }
apply structure_groupoid.le_iff.mpr
rintros e ‚ü®s, hs, hes‚ü©
refine G.eq_on_source _ hes
convert closed_under_restriction' G.id_mem hs
change s = _ ‚à© _
rw hs.interior_eq
simp only with mfld_simps
intros h
{ intros h, split, intros e he s hs, rw ‚Üê of_set_trans (e : local_homeomorph H H) hs, refine G.trans _ he, apply structure_groupoid.le_iff.mp h, exact id_restr_groupoid_mem hs }
split
intros e he s hs
rw ‚Üê of_set_trans (e : local_homeomorph H H) hs
refine G.trans _ he
apply structure_groupoid.le_iff.mp h
exact id_restr_groupoid_mem hs
intros
apply hG.lift_prop_within_at_congr_of_eventually_eq h _ h‚ÇÅ.eq_of_nhds
convert h‚ÇÅ
rw nhds_within_univ
intros
rw ‚Üê has_mfderiv_within_at_univ at h‚ÇÄ h‚ÇÅ
exact (unique_mdiff_within_at_univ I).eq h‚ÇÄ h‚ÇÅ
intros
rcases hf.2 with ‚ü®f', hf'‚ü©
have F : has_mfderiv_within_at I I' f s x f' := ‚ü®hf.1, hf'‚ü©
rcases hg.2 with ‚ü®g', hg'‚ü©
have G : has_mfderiv_within_at I' I'' g u (f x) g' := ‚ü®hg.1, hg'‚ü©
exact (has_mfderiv_within_at.comp x G F h).mdifferentiable_within_at
intros
rw ‚Üê times_cont_mdiff_on_univ at hf hg ‚ä¢
exact hg.comp hf subset_preimage_univ
intros
simp [left_coset]
intros
funext a b
calc m‚ÇÅ a b = m‚ÇÅ (m‚ÇÇ a e‚ÇÅ) (m‚ÇÇ e‚ÇÅ b) : by simp only [one h‚ÇÅ h‚ÇÇ distrib, h‚ÇÅ.left_id, h‚ÇÅ.right_id, h‚ÇÇ.left_id, h‚ÇÇ.right_id] ... = m‚ÇÇ a b : by simp only [distrib, h‚ÇÅ.left_id, h‚ÇÅ.right_id, h‚ÇÇ.left_id, h‚ÇÇ.right_id]
intros
rw ‚Üêsub_eq_zero
refine h _ _
rw [smul_sub, h', sub_self]
intros
classical
exact ‚ü®fintype.card H, H.index_mul_card.symm‚ü©
intros
rw [f.to_map.map_mul, f.to_map.map_mul] at h
cases f.map_units c with u hu
rw ‚Üêhu at h
exact (units.mul_right_inj u).1 h
intros
rwa [order_of, minimal_period, dif_neg]
intros
classical
exact is_cycle_of_prime_order h1 (lt_of_le_of_lt œÉ.support.card_le_univ h2)
intros
have : f.support = g.support
refine le_antisymm h _
{ refine le_antisymm h _, intros z hz, obtain ‚ü®x, hx, hf'‚ü© := id hf, have hx' : g x ‚â† x, { rwa [‚Üêh' x (mem_support.mpr hx)] }, obtain ‚ü®m, hm‚ü© := hg.exists_pow_eq hx' (mem_support.mp hz), have h'' : ‚àÄ (x ‚àà f.support ‚à© g.support), f x = g x, { intros x hx, exact h' x (mem_of_mem_inter_left hx) }, rwa [‚Üêhm, ‚Üêpow_eq_on_of_mem_support h'' _ x (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')), pow_apply_mem_support, mem_support] }
intros z hz
obtain ‚ü®x, hx, hf'‚ü© := id hf
have hx' : g x ‚â† x
{ rwa [‚Üêh' x (mem_support.mpr hx)] }
rwa [‚Üêh' x (mem_support.mpr hx)]
obtain ‚ü®m, hm‚ü© := hg.exists_pow_eq hx' (mem_support.mp hz)
have h'' : ‚àÄ (x ‚àà f.support ‚à© g.support), f x = g x
intros x hx
{ intros x hx, exact h' x (mem_of_mem_inter_left hx) }
exact h' x (mem_of_mem_inter_left hx)
rwa [‚Üêhm, ‚Üêpow_eq_on_of_mem_support h'' _ x (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')), pow_apply_mem_support, mem_support]
refine support_congr h _
simpa [‚Üêthis] using h'
intros
cases i with i hi
cases i
{ exact (h0 rfl).elim }
exact (h0 rfl).elim
rw [cycle_range, cycle_type_extend_domain]
exact cycle_type_fin_rotate
intros
cases l with y l
{ simpa }
simpa
induction l with z l IH generalizing x y
{ simpa using h }
simpa using h
by_cases hx : x ‚àà z :: l
{ by_cases hx : x ‚àà z :: l, { rw [form_perm_cons_cons, mul_apply, swap_apply_def], split_ifs; simp [IH _ _ hx] }, { replace h : x = y := or.resolve_right h hx, simp [form_perm_apply_of_not_mem _ _ hx, ‚Üêh] } }
rw [form_perm_cons_cons, mul_apply, swap_apply_def]
{ rw [form_perm_cons_cons, mul_apply, swap_apply_def], split_ifs; simp [IH _ _ hx] }
split_ifs; simp [IH _ _ hx]
split_ifs
simp [IH _ _ hx]
simp [IH _ _ hx]
simp [IH _ _ hx]
replace h : x = y := or.resolve_right h hx
{ replace h : x = y := or.resolve_right h hx, simp [form_perm_apply_of_not_mem _ _ hx, ‚Üêh] }
simp [form_perm_apply_of_not_mem _ _ hx, ‚Üêh]
intros
induction l with a t ih
{ exact card_support_eq_zero.mpr rfl, }
exact card_support_eq_zero.mpr rfl
obtain ‚ü®ha, ht‚ü© := list.pairwise_cons.1 h
{ obtain ‚ü®ha, ht‚ü© := list.pairwise_cons.1 h, rw [list.prod_cons, list.map_cons, list.sum_cons, ‚Üêih ht], exact (disjoint_prod_right _ ha).card_support_mul }
rw [list.prod_cons, list.map_cons, list.sum_cons, ‚Üêih ht]
exact (disjoint_prod_right _ ha).card_support_mul
intros
simp [eq_bot_iff_forall, mem_closure_singleton]
intros
rw [‚Üê line_map_apply_one_sub, line_map_vsub_left]
intros
apply le_antisymm
refine submodule.span_le.2 _
{ refine submodule.span_le.2 _, rintros v ‚ü®p1, p3, ‚ü®p2, hp2, v1, hv1, hp1‚ü©, ‚ü®p4, hp4, v2, hv2, hp3‚ü©, rfl‚ü©, rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, set_like.mem_coe], exact (vector_span k s).sub_mem ((vector_span k s).add_mem hv1 (vsub_mem_vector_span k hp2 hp4)) hv2 }
rintros v ‚ü®p1, p3, ‚ü®p2, hp2, v1, hv1, hp1‚ü©, ‚ü®p4, hp4, v2, hv2, hp3‚ü©, rfl‚ü©
rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, set_like.mem_coe]
exact (vector_span k s).sub_mem ((vector_span k s).add_mem hv1 (vsub_mem_vector_span k hp2 hp4)) hv2
{ exact vector_span_mono k (subset_span_points k s) }
exact vector_span_mono k (subset_span_points k s)
intros
rw [‚Üêaffine_map.linear_map_vsub, affine_combination_linear, vsub_eq_sub]
intros
rw [face_centroid_eq_centroid, face_centroid_eq_centroid]
exact s.centroid_eq_iff h‚ÇÅ h‚ÇÇ
intros
refine eq.symm (add_submonoid.closure_eq_of_le subset_span _)
apply add_submonoid.to_nat_submodule.symm.to_galois_connection.l_le _
rw span_le
exact add_submonoid.subset_closure
intros
refine bot_unique (set_like.le_def.2 $ assume b hb, (submodule.mem_bot R).2 _)
rw [‚Üê p.mk_eq_zero hb, ‚Üê e.map_eq_zero_iff]
apply submodule.eq_zero_of_bot_submodule
intros
induction k with k ih
{ simpa only [pow_zero], }
simpa only [pow_zero]
rw [pow_succ, pow_succ, linear_map.mul_eq_comp, linear_map.comp_assoc, ih, ‚Üê linear_map.comp_assoc, h, linear_map.comp_assoc, linear_map.mul_eq_comp]
{ rw [pow_succ, pow_succ, linear_map.mul_eq_comp, linear_map.comp_assoc, ih, ‚Üê linear_map.comp_assoc, h, linear_map.comp_assoc, linear_map.mul_eq_comp], }
intros
rw [reindex_finset_range, reindex_apply, reindex_range_apply]
{ rw [reindex_finset_range, reindex_apply, reindex_range_apply], refl }
refl
intros
conv_rhs { rw [‚Üê b'.sum_repr x] }
simp_rw [linear_equiv.map_sum, linear_equiv.map_smul, finset.sum_apply']
refine finset.sum_congr rfl (Œª j _, _)
rw [finsupp.smul_apply, smul_eq_mul, mul_comm]
intros
rw orthogonal_span_singleton_eq_to_lin_ker
exact linear_map.span_singleton_sup_ker_eq_top _ hx
intros
dunfold is_ortho
split
split; intro H
intro H
rw [smul_left, mul_eq_zero] at H
{ rw [smul_left, mul_eq_zero] at H, cases H, { trivial }, { exact H }}
cases H
{ trivial }
trivial
{ exact H }
exact H
intro H
{ rw [smul_left, H, mul_zero] }
rw [smul_left, H, mul_zero]
intros
rw [basis.det_reindex, function.comp.assoc, e.self_comp_symm, function.comp.right_id]
intros
rw ‚Üêdim_top R M
exact dim_le_of_submodule _ _ le_top
intros
rw ‚Üênot_iff_not
simpa using dim_zero_iff_forall_zero
intros
rw linear_equiv.finrank_eq (comap_subtype_equiv_of_le (le_of_lt hst)).symm
refine finrank_lt (lt_of_le_of_ne le_top _)
intro h_eq_top
rw comap_subtype_eq_top at h_eq_top
apply not_le_of_lt hst h_eq_top
intros
apply_fun to_nat at h
rw to_nat_cast at h
exact_mod_cast h
intros
rw ‚Üê span_image; refl
rw ‚Üê span_image
refl
intros
simp [finsupp.dom_lcongr, finsupp.dom_congr, equiv_map_domain_single]
intros
haveI := classical.dec_eq Œπ
haveI := classical.dec_eq Œπ'
let e := fintype.equiv_fin Œπ
let e' := fintype.equiv_fin Œπ'
let b := b.reindex e
have hv := (linear_independent_equiv e'.symm).mpr hv
have hv := hv.map' _ b.equiv_fun.ker
exact basis.card_le_card_of_linear_independent_aux (fintype.card Œπ) _ hv
intros
split_ifs with H
{ split_ifs with H, { subst H, apply eval_basis_self }, { exact eval_basis_ne s x y h H } }
subst H
{ subst H, apply eval_basis_self }
apply eval_basis_self
exact eval_basis_ne s x y h H
{ exact eval_basis_ne s x y h H }
intros
ext
{ ext, simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.minor_apply, id.def] }
simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.minor_apply, id.def]
intros
rw [matrix.trace_eq_neg_charpoly_coeff, matrix.trace_eq_neg_charpoly_coeff, finite_field.matrix.charpoly_pow_card, finite_field.pow_card]
intros
have hu : univ ‚äÜ {i : m | w i = 0}·∂ú ‚à™ {i : m | w i = 0}
rw set.compl_union_self
{ rw set.compl_union_self }
have hd : disjoint {i : m | w i ‚â† 0} {i : m | w i = 0} := disjoint_compl_left
have B‚ÇÅ := supr_range_std_basis_eq_infi_ker_proj K (Œªi:m, K) hd hu (finite.of_fintype _)
have B‚ÇÇ := @infi_ker_proj_equiv K _ _ (Œªi:m, K) _ _ _ _ (by simp; apply_instance) hd hu
rw [rank, range_diagonal, B‚ÇÅ, ‚Üê@dim_fun' K]
apply linear_equiv.dim_eq
apply B‚ÇÇ
intros
split
intros B C h
{ intros B C h, refine hA.matrix _, rw [‚Üêmatrix.one_mul B, ‚Üêmatrix.one_mul C, ‚Üêmatrix.smul_mul, ‚Üêmatrix.smul_mul, ‚Üêadjugate_mul, matrix.mul_assoc, matrix.mul_assoc, ‚Üêmul_eq_mul A, h, mul_eq_mul] }
refine hA.matrix _
rw [‚Üêmatrix.one_mul B, ‚Üêmatrix.one_mul C, ‚Üêmatrix.smul_mul, ‚Üêmatrix.smul_mul, ‚Üêadjugate_mul, matrix.mul_assoc, matrix.mul_assoc, ‚Üêmul_eq_mul A, h, mul_eq_mul]
intros B C h
{ intros B C h, simp only [mul_eq_mul] at h, refine hA.matrix _, rw [‚Üêmatrix.mul_one B, ‚Üêmatrix.mul_one C, ‚Üêmatrix.mul_smul, ‚Üêmatrix.mul_smul, ‚Üêmul_adjugate, ‚Üêmatrix.mul_assoc, ‚Üêmatrix.mul_assoc, h] }
simp only [mul_eq_mul] at h
refine hA.matrix _
rw [‚Üêmatrix.mul_one B, ‚Üêmatrix.mul_one C, ‚Üêmatrix.mul_smul, ‚Üêmatrix.mul_smul, ‚Üêmul_adjugate, ‚Üêmatrix.mul_assoc, ‚Üêmatrix.mul_assoc, h]
intros
rw [‚Üê matrix.to_lin_symm, linear_equiv.apply_symm_apply]
intros
rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_ne _ _ _ h]
intros
induction L with t L IH generalizing M N
{ simp }
simp
{ simp [IH, to_matrix_sum_inl, from_blocks_multiply], }
simp [IH, to_matrix_sum_inl, from_blocks_multiply]
intros
simp [lift_aux, lift_add_hom, tprod_coeff, free_add_monoid.lift_eval_of]
intros
simp only [set_like.le_def, prod_apply, mem_range, set_like.mem_coe, mem_prod, exists_imp_distrib]
rintro _ x rfl
exact ‚ü®‚ü®x, rfl‚ü©, ‚ü®x, rfl‚ü©‚ü©
intros
ext
ext; refl
refl
intros
rw [polar, map_add_self, sub_sub, sub_eq_iff_eq_add, ‚Üêtwo_mul, ‚Üêtwo_mul, ‚Üêmul_assoc]
norm_num
intros
{ simp only [polar, pi.add_apply], abel }
simp only [polar, pi.add_apply]
abel
intros
simp only [vandermonde_apply, matrix.mul_apply, matrix.transpose_apply, pow_add]
intros
simp [@eq_comm _ _ (f _)]
intros
simp_rw [hu.to_has_basis.limsup_eq_infi_supr]
refine measurable_binfi _ hu.countable _
exact Œª i, measurable_bsupr _ (hs i) hf
intros
rw [comp‚ÇÇ_eq_pair, pair_eq_mk, comp_mk]; refl
rw [comp‚ÇÇ_eq_pair, pair_eq_mk, comp_mk]
refl
intros
simp only [ae_seq, hx, if_true]
intros
rw isometry_emetric_iff_metric
intros f g
rw [dist_eq_norm, ‚Üê Lp_meas_subgroup_to_Lp_trim_sub, Lp_meas_subgroup_to_Lp_trim_norm_map, dist_eq_norm]
intros
simp_rw ess_sup
suffices h_smul : (c ‚Ä¢ Œº).ae = Œº.ae
rw h_smul
rw h_smul
ext1
simp_rw mem_ae_iff
simp [hc]
intros
simp [integrable.to_L1]
intros
simp [to_Lp]
intros
simp [snorm]
intros
rw [snorm', lintegral_const, ennreal.mul_rpow_of_ne_top _ (measure_ne_top Œº set.univ)]
congr
{ congr, rw ‚Üêennreal.rpow_mul, suffices hp_cancel : q * (1/q) = 1, by rw [hp_cancel, ennreal.rpow_one], rw [one_div, mul_inv_cancel hq_ne_zero], }
rw ‚Üêennreal.rpow_mul
suffices hp_cancel : q * (1/q) = 1
rw [hp_cancel, ennreal.rpow_one]
rw [hp_cancel, ennreal.rpow_one]
rw [one_div, mul_inv_cancel hq_ne_zero]
rw [ne.def, ennreal.rpow_eq_top_iff, auto.not_or_eq, auto.not_and_eq, auto.not_and_eq]
{ rw [ne.def, ennreal.rpow_eq_top_iff, auto.not_or_eq, auto.not_and_eq, auto.not_and_eq], split, { left, rwa [ennreal.coe_eq_zero, nnnorm_eq_zero], }, { exact or.inl ennreal.coe_ne_top, }, }
split
left
{ left, rwa [ennreal.coe_eq_zero, nnnorm_eq_zero], }
rwa [ennreal.coe_eq_zero, nnnorm_eq_zero]
{ exact or.inl ennreal.coe_ne_top, }
exact or.inl ennreal.coe_ne_top
intros
refine le_trans (ess_sup_mono_ae (eventually_of_forall (Œª x, _))) (ennreal.ess_sup_add_le _ _)
simp_rw [pi.add_apply, ‚Üêennreal.coe_add, ennreal.coe_le_coe]
exact nnnorm_add_le _ _
intros
rcases hf with ‚ü®g, hg, hfg‚ü©
obtain ‚ü®t, ht, hgt_zero, htŒº‚ü© := hg.exists_set_sigma_finite
refine ‚ü®t, ht, _, htŒº‚ü©
refine eventually_eq.trans (ae_restrict_of_ae hfg) _
rw [eventually_eq, ae_restrict_iff' ht.compl]
exact eventually_of_forall hgt_zero
intros
by_cases hfm : ae_measurable f Œº
refine integral_mono_ae ‚ü®hfm, _‚ü© hgi h
{ refine integral_mono_ae ‚ü®hfm, _‚ü© hgi h, refine (hgi.has_finite_integral.mono $ h.mp $ hf.mono $ Œª x hf hfg, _), simpa [real.norm_eq_abs, abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)] }
refine (hgi.has_finite_integral.mono $ h.mp $ hf.mono $ Œª x hf hfg, _)
simpa [real.norm_eq_abs, abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)]
rw [integral_non_ae_measurable hfm]
{ rw [integral_non_ae_measurable hfm], exact integral_nonneg_of_ae (hf.trans h) }
exact integral_nonneg_of_ae (hf.trans h)
intros
{ simp_rw [weighted_smul_apply, smul_comm], }
simp_rw [weighted_smul_apply, smul_comm]
intros
simp_rw ae_interval_oc_iff
rw [ae_restrict_eq, eventually_inf_principal, ae_restrict_eq, eventually_inf_principal]
rw [ae_restrict_eq, eventually_inf_principal, ae_restrict_eq, eventually_inf_principal] ; exact measurable_set_Ioc
exact measurable_set_Ioc
exact measurable_set_Ioc
intros
simpa only [sub_eq_add_neg] using (integral_add hf hg.neg).trans (congr_arg _ integral_neg)
intros
rw [interval_integrable_iff_integrable_Ioc_of_le hab, integrable_on_Icc_iff_integrable_on_Ioc]
intros
refine measure.ext (Œª s hs, _)
rw [with_density_apply _ hs, measure.coe_add, pi.add_apply, with_density_apply _ hs, with_density_apply _ hs, ‚Üê lintegral_add hf hg]
refl
intros
rw [integral_indicator s_meas, ‚Üê set_integral_const]
intros
specialize hf_int (‚à´ x, f x ‚àÇŒº)
{ specialize hf_int (‚à´ x, f x ‚àÇŒº), rwa [integral_inner hf, inner_self_eq_zero] at hf_int }
rwa [integral_inner hf, inner_self_eq_zero] at hf_int
intros
rw [sub_eq_add_neg, sub_eq_add_neg, set_to_fun_add hT hf hg.neg, set_to_fun_neg hT g]
intros
convert Œº.outer_measure_preimage (homeomorph.mul_left g) (Œª K, h g) A
intros
rcases compact_covered_by_mul_left_translates hK hV with ‚ü®t, ht‚ü©
{ rcases compact_covered_by_mul_left_translates hK hV with ‚ü®t, ht‚ü©, exact ‚ü®t.card, t, ht, rfl‚ü© }
exact ‚ü®t.card, t, ht, rfl‚ü©
intros
simp [volume_val]
intros
rw [‚Üê count_apply_finset, finite.coe_to_finset]
intros
simpa only [exists_prop, and.assoc] using (Œº.finite_at_nhds x).exists_mem_basis (nhds_basis_opens x)
intros
rw [measure.trim, to_measure_to_outer_measure]
intros
by_contra
push_neg at h
simp_rw nonpos_iff_eq_zero at h
exact hs (measure_Union_null h)
intros
rcases exists_measurable_superset_forall_eq_trim (![m‚ÇÅ, m‚ÇÇ, m‚ÇÉ]) s with ‚ü®t, hst, ht, htm‚ü©
simp only [fin.forall_fin_succ, matrix.cons_val_zero, matrix.cons_val_succ] at htm
rw [‚Üê htm.1, ‚Üê htm.2.1, ‚Üê htm.2.2.1, h]
intros
ext
{ ext, simp [mem_divisors_prime_pow, pp, nat.lt_succ_iff, @eq_comm _ a] }
simp [mem_divisors_prime_pow, pp, nat.lt_succ_iff, @eq_comm _ a]
intros
have me0 : 0 < max (1 / Œµ) M := lt_max_iff.mpr (or.inl (one_div_pos.mpr e0))
refine ‚ü®max (1 / Œµ) M, me0, Œª z a, _‚ü©
by_cases dm1 : 1 ‚â§ (dist Œ± (j z a) * max (1 / Œµ) M)
{ exact one_le_mul_of_one_le_of_one_le (d0 a) dm1 }
exact one_le_mul_of_one_le_of_one_le (d0 a) dm1
have : j z a ‚àà closed_ball Œ± Œµ
{ have : j z a ‚àà closed_ball Œ± Œµ, { refine mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _))), exact ((le_div_iff me0).mpr (not_le.mp dm1).le) }, refine (L this).trans _, refine mul_le_mul_of_nonneg_left ((B this).trans _) (zero_le_one.trans (d0 a)), exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg }
refine mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _)))
{ refine mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _))), exact ((le_div_iff me0).mpr (not_le.mp dm1).le) }
exact ((le_div_iff me0).mpr (not_le.mp dm1).le)
refine (L this).trans _
refine mul_le_mul_of_nonneg_left ((B this).trans _) (zero_le_one.trans (d0 a))
exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg
intros
by_contradiction H
simp at H
interval_cases q (p'+2); clear H
interval_cases q (p'+2)
clear H
dsimp [q] at h
{ dsimp [q] at h, injection h with h', clear h, simp [mersenne] at h', exact lt_irrefl 2 (calc 2 ‚â§ p'+2 : nat.le_add_left _ _ ... < 2^(p'+2) : nat.lt_two_pow _ ... = 2 : nat.pred_inj (nat.one_le_two_pow _) dec_trivial h'), }
injection h with h'
clear h
simp [mersenne] at h'
exact lt_irrefl 2 (calc 2 ‚â§ p'+2 : nat.le_add_left _ _ ... < 2^(p'+2) : nat.lt_two_pow _ ... = 2 : nat.pred_inj (nat.one_le_two_pow _) dec_trivial h')
clear H
dsimp [q] at h
{ dsimp [q] at h, injection h with h', clear h, rw [mersenne, pnat.one_coe, nat.min_fac_eq_two_iff, pow_succ] at h', exact nat.two_not_dvd_two_mul_sub_one (nat.one_le_two_pow _) h', }
injection h with h'
clear h
rw [mersenne, pnat.one_coe, nat.min_fac_eq_two_iff, pow_succ] at h'
exact nat.two_not_dvd_two_mul_sub_one (nat.one_le_two_pow _) h'
intros
rw [padic_val_rat, dif_pos]; simp *; refl
rw [padic_val_rat, dif_pos]; simp *
rw [padic_val_rat, dif_pos]
simp *
refl
simp *
intros
rw [padic_norm_p hp, div_lt_iff, one_mul]
{ exact_mod_cast hp }
exact_mod_cast hp
{ exact_mod_cast zero_lt_one.trans hp }
exact_mod_cast zero_lt_one.trans hp
intros
convert sub_zmod_repr_mem z using 2
dsimp [to_zmod, to_zmod_hom]
rcases (exists_eq_add_of_lt (hp_prime.1.pos)) with ‚ü®p', rfl‚ü©
unfreezingI { rcases (exists_eq_add_of_lt (hp_prime.1.pos)) with ‚ü®p', rfl‚ü© }
change ‚Üë(zmod.val _) = _
simp only [zmod.val_nat_cast, add_zero, add_def, nat.cast_inj, zero_add]
apply mod_eq_of_lt
simpa only [zero_add] using zmod_repr_lt_p z
intros
apply (iff_congr _ (by simp [units.ext_iff])).mp (euler_criterion_units p (units.mk0 a ha))
simp only [units.ext_iff, sq, units.coe_mk0, units.coe_mul]
split
rintro ‚ü®y, hy‚ü©
{ rintro ‚ü®y, hy‚ü©, exact ‚ü®y, hy‚ü© }
exact ‚ü®y, hy‚ü©
rintro ‚ü®y, rfl‚ü©
{ rintro ‚ü®y, rfl‚ü©, have hy : y ‚â† 0, { rintro rfl, simpa [zero_pow] using ha, }, refine ‚ü®units.mk0 y hy, _‚ü©, simp, }
have hy : y ‚â† 0
rintro rfl
{ rintro rfl, simpa [zero_pow] using ha, }
simpa [zero_pow] using ha
refine ‚ü®units.mk0 y hy, _‚ü©
simp
intros
simp [ext]
intros
rw [norm_mul, int.nat_abs_mul]; exact le_mul_of_one_le_right (nat.zero_le _) (int.coe_nat_le.1 (by rw [coe_nat_abs_norm]; exact int.add_one_le_of_lt (norm_pos.2 hy)))
rw [norm_mul, int.nat_abs_mul]
exact le_mul_of_one_le_right (nat.zero_le _) (int.coe_nat_le.1 (by rw [coe_nat_abs_norm]; exact int.add_one_le_of_lt (norm_pos.2 hy)))
intros
rw inf_assoc
rw [sup_inf_right, sup_inf_sdiff]
rw [inf_sup_right, inf_sdiff_left]
intros
simp [disjoint]
intros
simp only [bdd_above, upper_bounds_empty, univ_nonempty]
intros
simpa only [range_comp, subtype.range_coe, infi_subtype'] using @is_glb_infi Œ± s _ (f ‚àò coe)
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
simpa only [(‚àò), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))
intros
refine ‚ü®Œª U, (mem_infi_finite _).trans _‚ü©
simp only [infi_principal_finset, mem_Union, mem_principal, exists_prop, exists_finite_iff_finset, finset.set_bInter_coe]
intros
simp
intros
ext W
suffices : ‚àÉ t ‚àà f, (Œª (y : Œ±), x) ‚Åª¬π' t ‚äÜ W
simpa
simpa
use [V, hV]
simp [preimage_const_of_not_mem hx]
intros
simp only [tendsto, map_supr, supr_le_iff]
intros
simp [sup_comm, ‚Üê infi_sup_left]
intros
simp only [filter.frequently, filter.eventually, mem_cofinite, compl_set_of, not_not, set.infinite]
intros
rw [‚Üê principal_singleton, lift'_principal hh]
intros
{ use [nonempty, directed], exact Œª _ _ _ _, mem_of_le ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ }
use [nonempty, directed]
exact Œª _ _ _ _, mem_of_le ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
intros
ext x
{ ext x, refl }
refl
intros
simp only [symm_diff_eq, compl_compl, inf_idem, compl_sup_eq_top]
intros
rw ‚Üê h.coe_to_finset
exact h.to_finset.is_pwo
intros
obtain ‚ü®c, d, d_ne, hx‚ü© := exists_integral_multiple (h (algebra_map _ L a / algebra_map _ L b)) ((ring_hom.injective_iff _).mp inj)
refine ‚ü®is_integral_closure.mk' S (c : L) c.2, d, d_ne, is_integral_closure.algebra_map_injective S R L _‚ü©
simp only [algebra.smul_def, ring_hom.map_mul, is_integral_closure.algebra_map_mk', ‚Üê hx, ‚Üê is_scalar_tower.algebra_map_apply]
rw [‚Üê mul_assoc _ (_ / _), mul_div_cancel' (algebra_map S L a), mul_comm]
exact mt ((ring_hom.injective_iff _).mp (is_integral_closure.algebra_map_injective S R L) _) hb
intros
obtain ‚ü®a, b, h‚ü© := H
rw [‚Üê mul_one z, ‚Üê h, mul_add]
apply dvd_add
rw [mul_comm z, mul_assoc]
{ rw [mul_comm z, mul_assoc], exact (mul_dvd_mul_left _ H2).mul_left _ }
exact (mul_dvd_mul_left _ H2).mul_left _
rw [mul_comm b, ‚Üê mul_assoc]
{ rw [mul_comm b, ‚Üê mul_assoc], exact (mul_dvd_mul_right H1 _).mul_right _ }
exact (mul_dvd_mul_right H1 _).mul_right _
intros
obtain ‚ü®p, hp‚ü© := h‚ÇÅ
refine ‚ü®p, hp, _‚ü©
intros x hx
cases wf_dvd_monoid.exists_factors x hx with fx hfx
refine ‚ü®fx.card, _‚ü©
have H := hfx.2
rw ‚Üê associates.mk_eq_mk_iff_associated at H ‚ä¢
rw [‚Üê H, ‚Üê associates.prod_mk, associates.mk_pow, ‚Üê multiset.prod_repeat]
congr' 1
symmetry
rw multiset.eq_repeat
simp only [true_and, and_imp, multiset.card_map, eq_self_iff_true, multiset.mem_map, exists_imp_distrib]
rintros _ q hq rfl
rw associates.mk_eq_mk_iff_associated
apply h‚ÇÇ (hfx.1 _ hq) hp
intros
rcases I.is_fractional with ‚ü®aI, haI, hI‚ü©
use aI
use haI
intros b hb
rcases mem_inf.mp hb with ‚ü®hbI, hbJ‚ü©
exact hI b hbI
intros
rw [‚Üê lsum_apply, linear_map.map_sub, lsum_apply, lsum_apply]
intros
rw [‚Üêset.singleton_zero, span_singleton_eq_bot]
intros
rw [set_like.ext'_iff, ker_eq, set.ext_iff]
{ rw [set_like.ext'_iff, ker_eq, set.ext_iff], exact f.injective_iff' }
exact f.injective_iff'
intros
simp_rw ‚Üêhh
exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm
intros
refine ‚ü®_, Œª h, h.algebra_map‚ü©
rintros ‚ü®f, hf, hx‚ü©
use [f, hf]
exact is_scalar_tower.aeval_eq_zero_of_aeval_algebra_map_eq_zero R A B hAB hx
intros
rcases hx with ‚ü®x, rfl‚ü©
rcases hy with ‚ü®y, rfl‚ü©
refine card_congr (Œª g _, g * x‚Åª¬π * y) _ _ (Œª g hg, ‚ü®g * y‚Åª¬π * x, _‚ü©)
simp only [mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, monoid_hom.map_mul_inv, and_self, forall_true_iff] {contextual := tt}
{ simp only [mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, monoid_hom.map_mul_inv, and_self, forall_true_iff] {contextual := tt} }
simp only [mul_left_inj, imp_self, forall_2_true_iff]
{ simp only [mul_left_inj, imp_self, forall_2_true_iff], }
simp only [true_and, mem_filter, mem_univ] at hg
{ simp only [true_and, mem_filter, mem_univ] at hg, simp only [hg, mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, exists_prop_of_true, monoid_hom.map_mul_inv, and_self, mul_inv_cancel_right, inv_mul_cancel_right], }
simp only [hg, mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, exists_prop_of_true, monoid_hom.map_mul_inv, and_self, mul_inv_cancel_right, inv_mul_cancel_right]
intros
rw ring_hom.injective_iff (algebra_map R S)
intros a ha
rwa to_map_eq_zero_iff S hM at ha
intros
rw [hx, (algebra_map R S).map_zero] at h
{ rw [hx, (algebra_map R S).map_zero] at h, exact (is_unit.mul_left_eq_zero (is_localization.map_units S y)).1 h}
exact (is_unit.mul_left_eq_zero (is_localization.map_units S y)).1 h
intros
simp only [degree_le, submodule.mem_infi, degree_le_iff_coeff_zero, linear_map.mem_ker]
simp only [degree_le, submodule.mem_infi, degree_le_iff_coeff_zero, linear_map.mem_ker]; refl
refl
intros
rw [‚Üêflip _ _ _ h, polynomial.comp_assoc]
simp
intros
by_cases h : C p.content = 0
{ rw [C_eq_zero, content_eq_zero_iff] at h, simp [h] }
rw [C_eq_zero, content_eq_zero_iff] at h
simp [h]
conv_rhs { rw [p.eq_C_content_mul_prim_part, nat_degree_mul h p.prim_part_ne_zero, nat_degree_C, zero_add] }
intros
obtain ‚ü®n, rfl‚ü© := nat.exists_eq_add_of_le h
rw add_comm
exact dickson_add_two k a n
intros
simp [pochhammer]
intros
refine le_antisymm _ (dim_le_nat_degree_of_root pb (minpoly.ne_zero pb.is_integral_gen) (minpoly.aeval _ _))
rw ‚Üê nat_degree_minpoly_gen
apply nat_degree_le_of_degree_le
rw ‚Üê degree_eq_nat_degree (minpoly_gen_monic pb).ne_zero
exact minpoly.min _ _ (minpoly_gen_monic pb) (aeval_minpoly_gen pb)
intros
rintros _ ‚ü®Œ∂, h, rfl‚ü©
simp only [‚Üêmonoid_hom.map_pow, *, mem_roots_of_unity, set_like.mem_coe, monoid_hom.map_one] at *
intros
rw [trace_eq_trace_adjoin K x, algebra.smul_def, ring_hom.map_mul, ‚Üê algebra.smul_def, intermediate_field.adjoin_simple.trace_gen_eq_sum_roots _ hF, is_scalar_tower.algebra_map_smul]
intros
simp_rw ‚Üê unique_factorization_monoid.irreducible_iff_prime at h‚ÇÉ
exact wf_dvd_monoid.induction_on_irreducible a h‚ÇÅ h‚ÇÇ h‚ÇÉ
intros
rw [coeff_frobenius]
calc aeval (Œª k, x.coeff k) (frobenius_poly p n) = aeval (Œª k, x.coeff k) (mv_polynomial.map (int.cast_ring_hom (zmod p)) (frobenius_poly p n)) : _ ... = aeval (Œª k, x.coeff k) (X n ^ p : mv_polynomial ‚Ñï (zmod p)) : _ ... = (x.coeff n) ^ p : _
conv_rhs { rw [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_map_hom] }
{ conv_rhs { rw [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_map_hom] }, apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) rfl rfl }
apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) rfl rfl
{ rw frobenius_poly_zmod }
rw frobenius_poly_zmod
{ rw [alg_hom.map_pow, aeval_X] }
rw [alg_hom.map_pow, aeval_X]
intros
rw [truncate_fun, truncated_witt_vector.coeff_mk]
intros
simp [witt_polynomial, alg_hom.map_sum, aeval_monomial, finsupp.prod_single_index]
intros
rw [image_eq_range] at h
{ rw [image_eq_range] at h, convert mk_preimage_of_subset_range_lift _ _ h using 1, rw [mk_sep], refl }
convert mk_preimage_of_subset_range_lift _ _ h using 1
rw [mk_sep]
refl
simpa using nat_lt_omega 1
intros
rw [aleph, omega_le_aleph']; apply ordinal.le_add_right
rw [aleph, omega_le_aleph']
apply ordinal.le_add_right
rw [‚Üê two_power_omega, lift_two_power, lift_omega, two_power_omega]
intros
simp [‚Üêmove_right_card h, lt_add_one]
intros
simp only [log, dif_neg b1]
intros
cases h with _ _ _ _ eb _ h‚ÇÅ h‚ÇÇ h‚ÇÉ; exact h‚ÇÇ
cases h with _ _ _ _ eb _ h‚ÇÅ h‚ÇÇ h‚ÇÉ
exact h‚ÇÇ
intros
cases n; cases i; refl
cases n; cases i
cases n
cases i
refl
cases i
refl
intros
simp [h.symm, term]
simp [h.symm, term]; ac_refl
ac_refl
intros
have : z ‚â§ y
{ transitivity, assumption, apply le_of_lt h, }
transitivity
assumption
apply le_of_lt h
apply @nat.lt_of_add_lt_add_left z
rw [nat.add_sub_of_le,nat.add_sub_of_le]
rw [nat.add_sub_of_le,nat.add_sub_of_le]; solve_by_elim
solve_by_elim
solve_by_elim
solve_by_elim
intros
rwa [ ‚Üê hb, ‚Üê div_eq_mul_inv] at h
intros
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, horner, mul_add, mul_assoc]
intros
rw [‚Üê nhds_within_compl_infty_eq, nhds_within_compl_singleton_sup_pure]
intros
simpa only [div_eq_mul_inv] using is_open_map_mul_right (a‚Åª¬π)
intros
convert ((has_sum_ite_eq b _).add hf)
ext b'
by_cases h : b' = b
rw [h, update_same]
{ rw [h, update_same], simp only [eq_self_iff_true, if_true, sub_add_cancel] }
simp only [eq_self_iff_true, if_true, sub_add_cancel]
simp only [h, update_noteq, if_false, ne.def, zero_add, not_false_iff]
intros
{ ext, refl }
ext
refl
intros
convert nhds_basis_Ioo_pos a
ext Œµ
{ ext Œµ, change abs (x - a) < Œµ ‚Üî a - Œµ < x ‚àß x < a + Œµ, simp [abs_lt, sub_lt_iff_lt_add, add_comm Œµ a, add_comm x Œµ] }
change abs (x - a) < Œµ ‚Üî a - Œµ < x ‚àß x < a + Œµ
simp [abs_lt, sub_lt_iff_lt_add, add_comm Œµ a, add_comm x Œµ]
intros
refine ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm
refine (is_lub_cSup ne H).is_lub_of_tendsto (Œªx hx y hy xy, Mf xy) ne _
exact Cf.mono_left inf_le_left
intros
rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg]
rintros b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©
refine le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _)
convert hb‚ÇÇ using 2
simp only [not_le.symm]
refl
intros
intro x
rcases hf x with ‚ü®s, hsx, hsf‚ü©
refine ‚ü®interior s, interior_mem_nhds.2 hsx, hsf.subset $ Œª i hi, _‚ü©
exact (hi.mono (closure_inter_open' is_open_interior)).of_closure.mono (inter_subset_inter_right _ interior_subset)
intros
simp only [interior_eq_iff_open.symm, subset.antisymm_iff, interior_subset, true_and]
intros
tidy
intros
simp [‚Üê is_open_compl_iff, is_open_sigma_iff]
intros
{ ext, simp, }
ext
simp
intros
simpa using @dist_le _ _ _ _ f 0 _ C0
intros
rw [continuous_at, continuous_within_at, nhds_within_univ]
intros
ext ‚ü®‚ü©
{ ext ‚ü®‚ü©, refl }
refl
intros
rw [coord_change, e‚ÇÅ.symm_apply_mk_proj (e‚ÇÅ.mem_source.2 h)]
intros
rw [‚Üê preimage_symm, is_closed_preimage]
intros
rw [‚Üê Sup_range, mul_Sup, supr_range]
intros
split
simp only [‚Üê nnreal.summable_coe, nnreal.coe_tsum]
{ simp only [‚Üê nnreal.summable_coe, nnreal.coe_tsum], exact Œª h, ‚ü®h.sigma_factor, h.sigma‚ü© }
exact Œª h, ‚ü®h.sigma_factor, h.sigma‚ü©
rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
{ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, simpa only [‚Üê ennreal.tsum_coe_ne_top_iff_summable, ennreal.tsum_sigma', ennreal.coe_tsum, h‚ÇÅ] using h‚ÇÇ }
simpa only [‚Üê ennreal.tsum_coe_ne_top_iff_summable, ennreal.tsum_sigma', ennreal.coe_tsum, h‚ÇÅ] using h‚ÇÇ
simp only [continuous_at, tendsto_nhds_bot_iff_real, nhds_prod_eq, bot_add_bot]
assume r
rw eventually_prod_iff
refine ‚ü®Œª z, z < r, Iio_mem_nhds (bot_lt_coe _), Œª z, z < 0, Iio_mem_nhds (bot_lt_coe _), Œª x hx y hy, _‚ü©
dsimp
convert add_lt_add hx hy
simp
intros
{ cases e, cases e', cases h, refl }
cases e
cases e'
cases h
refl
intros
apply open_embedding_of_continuous_injective_open
apply continuous_iff_continuous_on_univ.mpr
{ apply continuous_iff_continuous_on_univ.mpr, rw ‚Üê h, exact e.continuous_to_fun }
rw ‚Üê h
exact e.continuous_to_fun
apply set.injective_iff_inj_on_univ.mpr
{ apply set.injective_iff_inj_on_univ.mpr, rw ‚Üê h, exact e.inj_on }
rw ‚Üê h
exact e.inj_on
intros U hU
{ intros U hU, simpa only [h, subset_univ] with mfld_simps using e.image_open_of_open hU}
simpa only [h, subset_univ] with mfld_simps using e.image_open_of_open hU
intros
rw [hf.induced, is_open_induced_iff]
intros
rw inter_comm at h
rw [add_comm, dist_comm]
exact dist_lt_add_of_nonempty_closed_ball_inter_ball h
intros
letI : pseudo_metric_space (X ‚äï Y) := glue_premetric hŒ¶ hŒ®
funext
simp only [comp, to_glue_l, to_glue_r, quotient.eq]
exact glue_dist_glued_points Œ¶ Œ® 0 x
intros
rw [‚Üê e.dimH_preimage, preimage_univ]
intros
simp [inf_dist]
intros
split
split; intro h
intro h
rintros ‚ü®sU, hU‚ü© x hx
{ rintros ‚ü®sU, hU‚ü© x hx, rcases h.mem_nhds_iff.mp (is_open.mem_nhds hU hx) with ‚ü®sV, ‚ü®‚ü®V, H‚ÇÅ, H‚ÇÇ‚ü©, hsV‚ü©‚ü©, refine ‚ü®V, H‚ÇÅ, _‚ü©, cases V, dsimp at H‚ÇÇ, subst H‚ÇÇ, exact hsV }
rcases h.mem_nhds_iff.mp (is_open.mem_nhds hU hx) with ‚ü®sV, ‚ü®‚ü®V, H‚ÇÅ, H‚ÇÇ‚ü©, hsV‚ü©‚ü©
refine ‚ü®V, H‚ÇÅ, _‚ü©
cases V
dsimp at H‚ÇÇ
subst H‚ÇÇ
exact hsV
intro h
refine is_topological_basis_of_open_of_nhds _ _
{ refine is_topological_basis_of_open_of_nhds _ _, { rintros sU ‚ü®U, ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü©, subst H‚ÇÇ, exact U.property }, { intros x sU hx hsU, rcases @h (‚ü®sU, hsU‚ü© : opens Œ±) x hx with ‚ü®V, hV, H‚ü©, exact ‚ü®V, ‚ü®V, hV, rfl‚ü©, H‚ü© } }
{ rintros sU ‚ü®U, ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü©, subst H‚ÇÇ, exact U.property }
rintros sU ‚ü®U, ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©‚ü©
subst H‚ÇÇ
exact U.property
intros x sU hx hsU
{ intros x sU hx hsU, rcases @h (‚ü®sU, hsU‚ü© : opens Œ±) x hx with ‚ü®V, hV, H‚ü©, exact ‚ü®V, ‚ü®V, hV, rfl‚ü©, H‚ü© }
rcases @h (‚ü®sU, hsU‚ü© : opens Œ±) x hx with ‚ü®V, hV, H‚ü©
exact ‚ü®V, ‚ü®V, hV, rfl‚ü©, H‚ü©
intros
assume x z hz
by_cases h : x ‚àà s; simp [h] at hz
by_cases h : x ‚àà s
simp [h] at hz
apply filter.eventually_of_forall (Œª x', _)
{ apply filter.eventually_of_forall (Œª x', _), by_cases h' : x' ‚àà s; simp [h', hz, hz.trans_le hy], }
by_cases h' : x' ‚àà s; simp [h', hz, hz.trans_le hy]
by_cases h' : x' ‚àà s
simp [h', hz, hz.trans_le hy]
simp [h', hz, hz.trans_le hy]
simp [h] at hz
filter_upwards [hs.is_open_compl.mem_nhds h]
{ filter_upwards [hs.is_open_compl.mem_nhds h], simp [hz] { contextual := tt } }
simp [hz] { contextual := tt }
intros
apply is_closed_map.of_nonempty
intros s hs h2s
simp_rw [h2s.image_const, is_closed_singleton]
intros
{ dsimp [comp], tidy, }
dsimp [comp]
tidy
intros
letI : topological_space Œ± := ‚ä•
haveI : discrete_topology Œ± := ‚ü®rfl‚ü©
exact funext (dense_inducing_pure.extend_eq continuous_of_discrete_topology)
intros
unfold uniform_continuous_on set.restrict uniform_continuous tendsto
rw [show (Œª x : s √ó s, (f x.1, f x.2)) = prod.map f f ‚àò coe, by ext x; cases x; refl, uniformity_comap rfl, show prod.map subtype.val subtype.val = (coe : s √ó s ‚Üí Œ± √ó Œ±), by ext x; cases x; refl]
conv in (map _ (comap _ _)) { rw ‚Üê filter.map_map }
rw subtype_coe_map_comap_prod
refl
intros
refine le_trans (le_lift' $ Œª s hs, mem_map.2 _) comp_le_uniformity
filter_upwards [h‚ÇÅ‚ÇÇ hs, h‚ÇÇ‚ÇÉ hs]
exact Œª x hx‚ÇÅ‚ÇÇ hx‚ÇÇ‚ÇÉ, ‚ü®_, hx‚ÇÅ‚ÇÇ, hx‚ÇÇ‚ÇÉ‚ü©
intros
refine ‚ü®Œª hs f, f.cauchy_of_totally_bounded hs, Œª H, totally_bounded_iff_filter.2 _‚ü©
introsI f hf hfs
exact ‚ü®ultrafilter.of f, ultrafilter.of_le f, H _ ((ultrafilter.of_le f).trans hfs)‚ü©
intros
split
assume h
{ assume h, exact ‚ü®separated_of_uniform_continuous uniform_continuous_fst h, separated_of_uniform_continuous uniform_continuous_snd h‚ü© }
exact ‚ü®separated_of_uniform_continuous uniform_continuous_fst h, separated_of_uniform_continuous uniform_continuous_snd h‚ü©
rintros ‚ü®eqv_Œ±, eqv_Œ≤‚ü© r r_in
{ rintros ‚ü®eqv_Œ±, eqv_Œ≤‚ü© r r_in, rw uniformity_prod at r_in, rcases r_in with ‚ü®t_Œ±, ‚ü®r_Œ±, r_Œ±_in, h_Œ±‚ü©, t_Œ≤, ‚ü®r_Œ≤, r_Œ≤_in, h_Œ≤‚ü©, rfl‚ü©, let p_Œ± := Œª(p : (Œ± √ó Œ≤) √ó (Œ± √ó Œ≤)), (p.1.1, p.2.1), let p_Œ≤ := Œª(p : (Œ± √ó Œ≤) √ó (Œ± √ó Œ≤)), (p.1.2, p.2.2), have key_Œ± : p_Œ± ((a‚ÇÅ, b‚ÇÅ), (a‚ÇÇ, b‚ÇÇ)) ‚àà r_Œ±, { simp [p_Œ±, eqv_Œ± r_Œ± r_Œ±_in] }, have key_Œ≤ : p_Œ≤ ((a‚ÇÅ, b‚ÇÅ), (a‚ÇÇ, b‚ÇÇ)) ‚àà r_Œ≤, { simp [p_Œ≤, eqv_Œ≤ r_Œ≤ r_Œ≤_in] }, exact ‚ü®h_Œ± key_Œ±, h_Œ≤ key_Œ≤‚ü© }
rw uniformity_prod at r_in
rcases r_in with ‚ü®t_Œ±, ‚ü®r_Œ±, r_Œ±_in, h_Œ±‚ü©, t_Œ≤, ‚ü®r_Œ≤, r_Œ≤_in, h_Œ≤‚ü©, rfl‚ü©
let p_Œ± := Œª(p : (Œ± √ó Œ≤) √ó (Œ± √ó Œ≤)), (p.1.1, p.2.1)
let p_Œ≤ := Œª(p : (Œ± √ó Œ≤) √ó (Œ± √ó Œ≤)), (p.1.2, p.2.2)
have key_Œ± : p_Œ± ((a‚ÇÅ, b‚ÇÅ), (a‚ÇÇ, b‚ÇÇ)) ‚àà r_Œ±
simp [p_Œ±, eqv_Œ± r_Œ± r_Œ±_in]
{ simp [p_Œ±, eqv_Œ± r_Œ± r_Œ±_in] }
have key_Œ≤ : p_Œ≤ ((a‚ÇÅ, b‚ÇÅ), (a‚ÇÇ, b‚ÇÇ)) ‚àà r_Œ≤
simp [p_Œ≤, eqv_Œ≤ r_Œ≤ r_Œ≤_in]
{ simp [p_Œ≤, eqv_Œ≤ r_Œ≤ r_Œ≤_in] }
exact ‚ü®h_Œ± key_Œ±, h_Œ≤ key_Œ≤‚ü©
intros
dsimp only [uniform_continuous, tendsto]
{ dsimp only [uniform_continuous, tendsto], rw [‚Üê hg.comap_uniformity, ‚Üê map_le_iff_le_comap, filter.map_map] }
rw [‚Üê hg.comap_uniformity, ‚Üê map_le_iff_le_comap, filter.map_map]
intros
cases a; simp
cases a
simp
simp
intros
rw [lt_iff_add_one_le, ‚Üê int.coe_nat_succ, coe_nat_le_coe_nat_iff]
reflexivity
intros
apply le_trans
apply int.add_le_add
apply int.add_le_add
assumption'
apply le_refl
intros
induction z with z ih
{ rw [nat.mul_zero, nat.add_zero, nat.add_zero] }
rw [nat.mul_zero, nat.add_zero, nat.add_zero]
rw [mul_succ, ‚Üê nat.add_assoc, add_div_right _ H, ih]
{ rw [mul_succ, ‚Üê nat.add_assoc, add_div_right _ H, ih], refl }
refl
intros
rw mod_def
have h' : ¬¨(0 < b ‚àß b ‚â§ a)
simp [not_le_of_gt h]
simp [if_neg, h']
intros
rw nat.sub_sub
apply nat.sub_lt
apply lt_of_lt_of_le (nat.zero_lt_succ _) h
rw nat.add_comm
apply nat.zero_lt_succ
intros
tactic.mk_inj_eq
intros
rw [point_reflection_apply, eq_comm, eq_vadd_iff_vsub_eq, ‚Üê neg_vsub_eq_vsub_rev, neg_eq_iff_add_eq_zero, ‚Üê bit0, ‚Üê bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]
intros
induction n with n ih
{ simp }
simp
rw [pow_succ, ‚Üêmul_assoc, mul_sub_algebra_map_commutes, mul_assoc, ih, ‚Üêmul_assoc]
{ rw [pow_succ, ‚Üêmul_assoc, mul_sub_algebra_map_commutes, mul_assoc, ih, ‚Üêmul_assoc], }
intros
ext
{ ext, simp only [lmul_right_apply, linear_map.comp_apply, mul_assoc] }
simp only [lmul_right_apply, linear_map.comp_apply, mul_assoc]
intros
split
{ rintro ‚ü®c, rfl‚ü©, simp [subsingleton.elim c 1] }
rintro ‚ü®c, rfl‚ü©
simp [subsingleton.elim c 1]
{ rintro rfl, refl }
rintro rfl
refl
intros
{ rw [prod_eq_mul_prod_diff_singleton h, mul_comm] }
rw [prod_eq_mul_prod_diff_singleton h, mul_comm]
intros
{ dunfold finset.sum, rw count_sum }
dunfold finset.sum
rw count_sum
intros
simp [prod_apply_dite _ _ (Œª x, x)]
intros
haveI := classical.dec_eq Œ±; exact finset.induction_on s (by simp) (by simp [mul_pow] {contextual := tt})
haveI := classical.dec_eq Œ±
exact finset.induction_on s (by simp) (by simp [mul_pow] {contextual := tt})
intros
apply finprod_mem_inter_mul_support_eq
ext x
exact and_congr_left (h x)
intros
contrapose! Hlt with Hle
exact prod_le_prod'' Hle
intros
apply contract_left_apply f x
intros
rw [‚Üê ring_char.spec, ‚Üê ne.def]
exact nonzero_of_invertible (t : K)
intros
{ ext n, rw ‚Üê(coe_of_s_nth_rat_eq v_eq_q), refl }
ext n
rw ‚Üê(coe_of_s_nth_rat_eq v_eq_q)
refl
intros
apply dfinsupp.induction x H_zero
intros i b f h1 h2 ih
solve_by_elim
intros
{ rcases hu with ‚ü®u, rfl‚ü©, apply units.dvd_mul_left, }
rcases hu with ‚ü®u, rfl‚ü©
apply units.dvd_mul_left
intros
simpa using div_sub_div a b hc one_ne_zero
intros
by_cases h : b ‚àà s
rw [insert_eq_of_mem h, (lcm_eq_right_iff (f b) (s.lcm f) (multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)]
{ rw [insert_eq_of_mem h, (lcm_eq_right_iff (f b) (s.lcm f) (multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)] }
apply fold_insert h
intros
rw [sum_Ico_eq_sub _ hmn, ‚Üê geom_sum_def, ‚Üê geom_sum_def, sub_mul, geom_sum_mul, geom_sum_mul, sub_sub_sub_cancel_right]
intros
rw [h, mul_inv_cancel_left]
intros
rw [‚Üê neg_sub c b, sub_neg_eq_add, sub_add_sub_cancel]
intros
rw [add_assoc, add_sub_cancel'_right]
intros
{ rw [‚Üêh, u.mul_inv], }
rw [‚Üêh, u.mul_inv]
intros
induction n with n ih; [rw [nat.add_zero, pow_zero, mul_one], rw [pow_succ', ‚Üê mul_assoc, ‚Üê ih, ‚Üê pow_succ', nat.add_assoc]]
induction n with n ih
rw [nat.add_zero, pow_zero, mul_one]
rw [pow_succ', ‚Üê mul_assoc, ‚Üê ih, ‚Üê pow_succ', nat.add_assoc]
intros
rw [‚Üê nat.sub_add_cancel hn, pow_add, hx, mul_zero]
intros
rcases nat.exists_eq_succ_of_ne_zero hk with ‚ü®l, rfl‚ü©
clear hk
induction l with l IH
{ simpa using ha }
simpa using ha
rw pow_succ
{ rw pow_succ, exact one_lt_mul' ha IH }
exact one_lt_mul' ha IH
intros
rw [div_div_eq_mul_div, div_mul_eq_mul_div, div_div_eq_div_mul]
intros
simp [C.d_to_eq r]
intros
{ simp, }
simp
intros
{ ext, simp }
ext
simp
intros
funext
{ funext, simp only [mul_indicator], split_ifs, { refl }, rw mul_one }
simp only [mul_indicator]
split_ifs
refl
{ refl }
rw mul_one
intros
simp [mul_assoc]
intros
rw [‚Üê neg_neg ‚ÅÖx, y‚ÅÜ, lie_neg z, lie_skew y x, ‚Üê lie_skew, lie_lie]
{ rw [‚Üê neg_neg ‚ÅÖx, y‚ÅÜ, lie_neg z, lie_skew y x, ‚Üê lie_skew, lie_lie], abel, }
abel
intros
rw [lie_hom.map_lie, lie_ring.of_associative_ring_bracket, mul_comm, sub_self]
intros
change A ‚àà skew_adjoint_matrices_submodule (u ‚Ä¢ J) ‚Üî A ‚àà skew_adjoint_matrices_submodule J
simp only [mem_skew_adjoint_matrices_submodule, matrix.is_skew_adjoint, matrix.is_adjoint_pair]
split
split; intros h
intros h
{ simpa using congr_arg (Œª B, u‚Åª¬π ‚Ä¢ B) h, }
simpa using congr_arg (Œª B, u‚Åª¬π ‚Ä¢ B) h
intros h
{ simp [h], }
simp [h]
intros
{ cases p, refl, }
cases p
refl
intros
rw [I.incl.is_ideal_morphism_def, incl_ideal_range]
exact (I : lie_subalgebra R L).incl_range.symm
intros
rw [‚Üê lie_subalgebra.coe_submodule_le_coe_submodule, ‚Üê H.coe_to_lie_submodule, coe_zero_root_subalgebra, lie_submodule.coe_submodule_le_coe_submodule]
exact to_lie_submodule_le_root_space_zero R L H
intros
rw [‚Üêneg_neg c, ‚Üêneg_neg a, neg_smul_neg, inv_neg, neg_smul _ b, neg_lt_neg_iff]
exact smul_lt_iff_of_pos (neg_pos_of_neg hc)
intros
rw [‚Üêcmp_eq_lt_iff, ‚Üêcmp_eq_lt_iff, h]
intros
rwa [lt_inv (@zero_lt_one Œ± _ _) h‚ÇÅ, inv_one]
intros
rwa [div_lt_iff_of_neg' hb, ‚Üê div_eq_mul_one_div, div_lt_one_of_neg (h.trans hb)]
intros
cases le_total a b; simp [h, hf h]
cases le_total a b
simp [h, hf h]
simp [h, hf h]
intros
rw [‚Üê inv_lt_inv_iff, inv_inv]
intros
rw [div_eq_mul_inv, mul_inv_le_inv_mul_iff]
exact ‚ü®Œª h, not_lt.mp (Œª k, not_lt.mpr h (mul_lt_mul''' k k)), Œª h, mul_le_mul' h h‚ü©
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Icc]
split
rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©
{ rintro ‚ü®a, ‚ü®a_h_left_left, a_h_left_right‚ü©, rfl‚ü©, split, exact (mul_le_mul_left hr).mpr a_h_left_left, exact (mul_le_mul_left hr).mpr a_h_left_right, }
split
exact (mul_le_mul_left hr).mpr a_h_left_left
exact (mul_le_mul_left hr).mpr a_h_left_right
rintro ‚ü®a_left, a_right‚ü©
{ rintro ‚ü®a_left, a_right‚ü©, use x / r, refine ‚ü®‚ü®(le_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right‚ü©, _‚ü©, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ‚ü®‚ü®(le_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right‚ü©, _‚ü©
rw mul_div_cancel' _ (ne_of_gt hr)
intros
haveI := @linear_order.decidable_le Œ± _; exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_right b_le_c ha
haveI := @linear_order.decidable_le Œ± _
exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_right b_le_c ha
intros
simpa only [div_eq_mul_inv] using h.mul_const_inv a
intros
simpa only [div_eq_mul_inv] using h.mul_const_inv ha
intros
suffices : distrib_mul_action.to_add_monoid_hom (polynomial R) m = (map_ring_hom (mul_semiring_action.to_ring_hom M R m)).to_add_monoid_hom
{ ext1 r, exact add_monoid_hom.congr_fun this r, }
ext1 r
exact add_monoid_hom.congr_fun this r
ext n r : 2
change m ‚Ä¢ monomial n r = map (mul_semiring_action.to_ring_hom M R m) (monomial n r)
simpa only [polynomial.map_monomial, polynomial.smul_monomial]
intros
simp [‚Üê self_mul_conj, mul_add, add_mul, add_assoc]
intros
induction n with n hn
{ simp only [one, pow_zero] }
simp only [one, pow_zero]
{ rw pow_succ, exact (ra.smul_iff (a ^ n)).mpr hn }
rw pow_succ
exact (ra.smul_iff (a ^ n)).mpr hn
intros
{ ext, simp [h], }
ext
simp [h]
intros
cases n
{ exact ‚ü®1, 0, (by simp), squarefree_one‚ü© }
exact ‚ü®1, 0, (by simp), squarefree_one‚ü©
obtain ‚ü®a, b, -, -, h‚ÇÅ, h‚ÇÇ‚ü© := sq_mul_squarefree_of_pos (succ_pos n)
{ obtain ‚ü®a, b, -, -, h‚ÇÅ, h‚ÇÇ‚ü© := sq_mul_squarefree_of_pos (succ_pos n), exact ‚ü®a, b, h‚ÇÅ, h‚ÇÇ‚ü© }
exact ‚ü®a, b, h‚ÇÅ, h‚ÇÇ‚ü©
intros
{ ext x, simp [hc] }
ext x
simp [hc]
intros
{ rw zero_locus_inf, simp }
rw zero_locus_inf
simp
intros
refine nnreal.summable_of_le (Œª n, _) (nnreal.summable_sigma.1 $ p.change_origin_series_summable_aux‚ÇÇ hr k).2
simp only [nnreal.tsum_mul_right]
exact mul_le_mul' (p.nnnorm_change_origin_series_le_tsum _ _) le_rfl
intros
rcases i with ‚ü®n, f‚ü©
dsimp [composition.blocks_fun, composition.blocks, comp_change_of_variables]
simp only [map_of_fn, nth_le_of_fn', function.comp_app]
apply congr_arg
exact fin.eta _ _
intros
refine ‚ü®is_equivalent.is_O, Œª h, _‚ü©
rw [is_equivalent_zero_iff_eventually_zero, eventually_eq_iff_exists_mem]
exact ‚ü®{x : Œ± | u x = 0}, is_O_zero_right_iff.mp h, Œª x hx, hx‚ü©
intros
unfold is_O_with
refine h.symm.rw (Œª x a, ‚à•a‚à• ‚â§ c * ‚à•v x‚à•) (hœÜ.mono $ Œª x hx, _)
simp only [normed_field.norm_mul, pi.mul_apply]
exact mul_le_mul_of_nonneg_right hx (norm_nonneg _)
intros
{ unfold is_O, exact exists_congr (Œª _, is_O_with_norm_right) }
unfold is_O
exact exists_congr (Œª _, is_O_with_norm_right)
intros
have := has_fderiv_at.iterate hf hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
have := (hc.has_strict_fderiv_at.clm_apply hu.has_strict_fderiv_at).has_strict_deriv_at
rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw hL.fderiv_within_eq hs hx }
unfold deriv_within
rw hL.fderiv_within_eq hs hx
intros
{ convert hc.mul' hd, ext z, apply mul_comm }
convert hc.mul' hd
ext z
apply mul_comm
intros
refine (has_fderiv_within_at_univ.2 hf).lim _ (univ_mem' (Œª _, trivial)) hc _
assume U hU
refine (eventually_ne_of_tendsto_norm_at_top hc (0:ùïú)).mono (Œª y hy, _)
convert mem_of_mem_nhds hU
dsimp only
rw [‚Üê mul_smul, mul_inv_cancel hy, one_smul]
intros
{ ext m, rw fderiv_const_apply, refl }
ext m
rw fderiv_const_apply
refl
intros
rw [iterated_deriv_within_eq_iterate hxs hx, iterated_deriv_within_eq_iterate hxs hx]
{ rw [iterated_deriv_within_eq_iterate hxs hx, iterated_deriv_within_eq_iterate hxs hx], refl }
refl
intros
simpa only [sub_zero, mul_one] using norm_image_sub_le_of_norm_deriv_le_segment hf bound 1 (right_mem_Icc.2 zero_le_one)
intros
cases le_or_gt x 0
{ exact ge_of_eq (zero_of_nonpos h) }
exact ge_of_eq (zero_of_nonpos h)
{ exact le_of_lt (pos_of_pos h) }
exact le_of_lt (pos_of_pos h)
intros
rw ‚Üê has_ftaylor_series_up_to_on_univ_iff at h ‚ä¢
{ rw ‚Üê has_ftaylor_series_up_to_on_univ_iff at h ‚ä¢, exact h.of_le hmn }
exact h.of_le hmn
intros
split
assume H
{ assume H, have : f = e.symm ‚àò (e ‚àò f), by { ext y, simp only [function.comp_app], rw e.symm_apply_apply (f y) }, rw this, exact H.continuous_linear_map_comp _ }
have : f = e.symm ‚àò (e ‚àò f)
ext y
ext y
{ ext y, simp only [function.comp_app], rw e.symm_apply_apply (f y) }
{ ext y, simp only [function.comp_app], rw e.symm_apply_apply (f y) }
simp only [function.comp_app]
simp only [function.comp_app]
rw e.symm_apply_apply (f y)
rw e.symm_apply_apply (f y)
rw this
exact H.continuous_linear_map_comp _
assume H
{ assume H, exact H.continuous_linear_map_comp _ }
exact H.continuous_linear_map_comp _
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_on_const
intros
rcases h m hm with ‚ü®u, u_nhd, p, hp‚ü©
refine ‚ü®u ‚à© insert x s, filter.inter_mem u_nhd self_mem_nhds_within, inter_subset_right _ _, _‚ü©
assume y hy m' hm'
refine ‚ü®u ‚à© insert x s, _, p, (hp.mono (inter_subset_left _ _)).of_le hm'‚ü©
convert self_mem_nhds_within
exact insert_eq_of_mem hy
ext
{ ext, simp }
simp
intros
refine ‚ü®Œª h x y hx hy a b ha hb hab, h hx hy ha.le hb.le hab, _‚ü©
intros h x y hx hy a b ha hb hab
cases ha.eq_or_lt with ha ha
{ subst a, rw [zero_add] at hab, simp [hab, hy] }
subst a
rw [zero_add] at hab
simp [hab, hy]
cases hb.eq_or_lt with hb hb
{ subst b, rw [add_zero] at hab, simp [hab, hx] }
subst b
rw [add_zero] at hab
simp [hab, hx]
exact h hx hy ha hb hab
intros
simp only [finset.center_mass, finset.smul_sum, (mul_smul _ _ _).symm, mul_comm c, mul_assoc]
intros
rw [hs.convex_hull_eq_image]
apply (compact_std_simplex _).image
haveI := hs.fintype
apply linear_map.continuous_on_pi
intros
rw [‚Üêinner_conj_sym, conj_im]
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
simp [dist_eq_norm_vsub V _ x]
intros
by_cases hx : 0 ‚â§ x
{ rw real.ennnorm_eq_of_real hx, refl' }
rw real.ennnorm_eq_of_real hx
refl'
rw [ennreal.of_real_eq_zero.2 (le_of_lt (not_le.1 hx))]
{ rw [ennreal.of_real_eq_zero.2 (le_of_lt (not_le.1 hx))], exact bot_le }
exact bot_le
intros
rw [mem_ball_iff_norm, add_sub_cancel']
intros
intros w
rcases exists_ne (0 : M') with ‚ü®a, ha‚ü©
have : f' a = f' 0
{ simp_rw [w, continuous_linear_map.zero_apply], }
simp_rw [w, continuous_linear_map.zero_apply]
exact ha (hf'.injective this)
intros
simp
intros
refine le_antisymm (multilinear_map.mk_continuous_norm_le _ (norm_nonneg _) _) _
convert ratio_le_op_norm _ (Œª _, 1); [simp, apply_instance]
convert ratio_le_op_norm _ (Œª _, 1)
simp
apply_instance
intros
{ rw h, exact norm_comp_le_of_le hg hf }
rw h
exact norm_comp_le_of_le hg hf
intros
ext
ext; simp
simp
simp
simp
simp
intros
simp only [log_im, neg_pi_lt_arg]
intros
rw has_deriv_at_iff_is_o_nhds_zero
have : (1 : ‚Ñï) < 2 := by norm_num
refine (is_O.of_bound (‚à•exp x‚à•) _).trans_is_o (is_o_pow_id this)
filter_upwards [metric.ball_mem_nhds (0 : ‚ÑÇ) zero_lt_one]
simp only [metric.mem_ball, dist_zero_right, normed_field.norm_pow]
intros z hz
calc ‚à•exp (x + z) - exp x - z * exp x‚à• = ‚à•exp x * (exp z - 1 - z)‚à• : by { congr, rw [exp_add], ring } ... = ‚à•exp x‚à• * ‚à•exp z - 1 - z‚à• : normed_field.norm_mul _ _ ... ‚â§ ‚à•exp x‚à• * ‚à•z‚à•^2 : mul_le_mul_of_nonneg_left (abs_exp_sub_one_sub_id_le (le_of_lt hz)) (norm_nonneg _)
intros
simpa using integral_sin_pow_odd_mul_cos_pow 0 1
intros
rcases eq_or_ne z 0 with rfl|hz
simp
{ simp }
replace hz := hz.lt_or_lt
wlog hxy : x ‚â§ y := le_total x y using [x y, y x] tactic.skip
rcases eq_or_ne x 0 with rfl|hx0
{ rcases eq_or_ne x 0 with rfl|hx0, { induction y using with_top.rec_top_coe; cases hz with hz hz; simp [*, hz.not_lt] }, rcases eq_or_ne y 0 with rfl|hy0, { exact (hx0 (bot_unique hxy)).elim }, induction x using with_top.rec_top_coe, { cases hz with hz hz; simp [hz, top_unique hxy] }, induction y using with_top.rec_top_coe, { cases hz with hz hz; simp * }, simp only [*, false_and, and_false, false_or, if_false], norm_cast at *, rw [coe_rpow_of_ne_zero (mul_ne_zero hx0 hy0), nnreal.mul_rpow] }
induction y using with_top.rec_top_coe; cases hz with hz hz; simp [*, hz.not_lt]
induction y using with_top.rec_top_coe; cases hz with hz hz
induction y using with_top.rec_top_coe
{ induction y using with_top.rec_top_coe; cases hz with hz hz; simp [*, hz.not_lt] }
cases hz with hz hz
simp [*, hz.not_lt]
simp [*, hz.not_lt]
cases hz with hz hz
simp [*, hz.not_lt]
simp [*, hz.not_lt]
rcases eq_or_ne y 0 with rfl|hy0
exact (hx0 (bot_unique hxy)).elim
{ exact (hx0 (bot_unique hxy)).elim }
induction x using with_top.rec_top_coe
cases hz with hz hz
cases hz with hz hz; simp [hz, top_unique hxy]
{ cases hz with hz hz; simp [hz, top_unique hxy] }
simp [hz, top_unique hxy]
simp [hz, top_unique hxy]
induction y using with_top.rec_top_coe
cases hz with hz hz
cases hz with hz hz; simp *
{ cases hz with hz hz; simp * }
simp *
simp *
simp only [*, false_and, and_false, false_or, if_false]
norm_cast at *
rw [coe_rpow_of_ne_zero (mul_ne_zero hx0 hy0), nnreal.mul_rpow]
convert this using 2; simp only [mul_comm, and_comm, or_comm]
convert this using 2
{ convert this using 2; simp only [mul_comm, and_comm, or_comm] }
simp only [mul_comm, and_comm, or_comm]
simp only [mul_comm, and_comm, or_comm]
simp only [mul_comm, and_comm, or_comm]
intros
rcases le_iff_eq_or_lt.1 hx with H|pos
by_cases h : y + z = 0
{ by_cases h : y + z = 0, { simp only [H.symm, h, rpow_zero], calc (0 : ‚Ñù) ^ y * 0 ^ z ‚â§ 1 * 1 : mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one ... = 1 : by simp }, { simp [rpow_add', ‚Üê H, h] } }
simp only [H.symm, h, rpow_zero]
{ simp only [H.symm, h, rpow_zero], calc (0 : ‚Ñù) ^ y * 0 ^ z ‚â§ 1 * 1 : mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one ... = 1 : by simp }
calc (0 : ‚Ñù) ^ y * 0 ^ z ‚â§ 1 * 1 : mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one ... = 1 : by simp
{ simp [rpow_add', ‚Üê H, h] }
simp [rpow_add', ‚Üê H, h]
{ simp [rpow_add pos] }
simp [rpow_add pos]
intros
rcases hx.eq_or_lt with (rfl|hx)
rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, zero_lt_one]
rcases em (y = 0) with (rfl|hy)
{ rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, zero_lt_one] }
simp [*, lt_irrefl, zero_lt_one]
simp [*, lt_irrefl, zero_lt_one]
{ simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm] }
simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm]
intros
simp [sin_add]
simpa only [function.periodic, tan_eq_sin_div_cos] using sin_antiperiodic.div cos_antiperiodic
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]; exact (classical.some_spec exists_cos_eq_zero).1.1
exact (classical.some_spec exists_cos_eq_zero).1.1
intros
cases le_total x (-1) with hx‚ÇÅ hx‚ÇÅ
rw [arcsin_of_le_neg_one hx‚ÇÅ, neg_neg, arcsin_of_one_le (le_neg.2 hx‚ÇÅ)]
{ rw [arcsin_of_le_neg_one hx‚ÇÅ, neg_neg, arcsin_of_one_le (le_neg.2 hx‚ÇÅ)] }
cases le_total 1 x with hx‚ÇÇ hx‚ÇÇ
rw [arcsin_of_one_le hx‚ÇÇ, arcsin_of_le_neg_one (neg_le_neg hx‚ÇÇ)]
{ rw [arcsin_of_one_le hx‚ÇÇ, arcsin_of_le_neg_one (neg_le_neg hx‚ÇÇ)] }
refine arcsin_eq_of_sin_eq _ _
{ rw [sin_neg, sin_arcsin hx‚ÇÅ hx‚ÇÇ] }
rw [sin_neg, sin_arcsin hx‚ÇÅ hx‚ÇÇ]
exact ‚ü®neg_le_neg (arcsin_le_pi_div_two _), neg_le.2 (neg_pi_div_two_le_arcsin _)‚ü©
{ exact ‚ü®neg_le_neg (arcsin_le_pi_div_two _), neg_le.2 (neg_pi_div_two_le_arcsin _)‚ü© }
rw ‚Üê nnreal.tendsto_coe
{ rw ‚Üê nnreal.tendsto_coe, convert tendsto_inverse_at_top_nhds_0_nat, simp }
convert tendsto_inverse_at_top_nhds_0_nat
simp
intros
rw [equiv.symm_apply_eq]; simp [-hom_equiv_counit]
rw [equiv.symm_apply_eq]
simp [-hom_equiv_counit]
intros
{ erw functor.map_comp, simp }
erw functor.map_comp
simp
intros
{ simp [nat_trans.left_derived], refl, }
simp [nat_trans.left_derived]
refl
intros
{ cases h, refl, }
cases h
refl
intros
simp only [cancel_epi]
intros
dsimp [colimit_obj_iso_colimit_comp_evaluation]
simp
intros
{ erw is_colimit.fac, refl, }
erw is_colimit.fac
refl
intros
simp
intros
simp
intros
simp
intros
ext
intros
rw [right_unitor_naturality, ‚Üêcategory.assoc, iso.inv_hom_id, category.id_comp]
intros
tidy
intros
simp [biprod.of_components]
intros
simp [exact.lift]
conv_lhs { congr, skip, rw ‚Üê image_subobject_arrow_comp f, }
rw [‚Üêcategory.assoc, factor_thru_comp, ‚Üêimage_to_kernel_arrow, ‚Üêcategory.assoc, category_theory.projective.factor_thru_comp, factor_thru_kernel_subobject_comp_arrow]
intros
ext W h
split
rintro ‚ü®W, _, _, _‚ü©
{ rintro ‚ü®W, _, _, _‚ü©, exact singleton.mk }
exact singleton.mk
rintro ‚ü®_‚ü©
{ rintro ‚ü®_‚ü©, exact pullback_arrows.mk Z g singleton.mk }
exact pullback_arrows.mk Z g singleton.mk
intros
revert g
apply quotient.ind
intro g'
apply quotient.sound
exact ‚ü®(mono_over.pullback_map_self f).app _‚ü©
intros
rw [le_iff_le_iff_lt_iff_lt, singleton_lt_iff_lt]
intros
split
rw ‚Üê not_imp_not
{ rw ‚Üê not_imp_not, assume h, exact set.disjoint_right.1 (c.disjoint_range h) (c.mem_range_embedding j) }
assume h
exact set.disjoint_right.1 (c.disjoint_range h) (c.mem_range_embedding j)
assume h
{ assume h, rw h, exact c.mem_range_embedding j }
rw h
exact c.mem_range_embedding j
intros
ext
simp only [is_adj_matrix.to_graph_adj, adj_matrix_apply, ite_eq_left_iff, zero_ne_one]
apply not_not
intros
cases d‚ÇÅ with s‚ÇÅ t‚ÇÅ h‚ÇÅ
cases d‚ÇÇ with s‚ÇÇ t‚ÇÇ h‚ÇÇ
simp only [dart.edge, dart.rev_edge, dart.rev]
rw sym2.eq_iff
intros
letI := primcodable.subtype hp
refine ‚ü®Œª h, _, Œª hf, subtype_val.comp hf‚ü©
refine nat.primrec.of_eq h (Œª n, _)
cases decode Œ± n with a
refl
{refl}
simp
cases f a; refl
cases f a
refl
intros
cases q; apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
cases q
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
intros
induction n with n IH generalizing L; simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]
induction n with n IH generalizing L
simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]
simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]
intros
cases mem_eval.1 ab with ab b0
rcases tr_reaches H aa ab with ‚ü®b‚ÇÇ, bb, ab‚ü©
refine ‚ü®_, bb, mem_eval.2 ‚ü®ab, _‚ü©‚ü©
have := H bb
rwa b0 at this
intros
revert hx
simp [(‚àà)]
intros i hx
subst x
apply approx_mono'
intros
rw @map_eq_traverse_id t _ _ _ _ g
refine (comp_traverse f (id.mk ‚àò g) x).symm.trans _
congr
apply comp.applicative_id_comp
intros
refine eq_of_nhds_eq_nhds (Œª x, _)
ext s
rw [mem_nhds_to_topsp, H]
intros
have : b.to_list.to_buffer.read ‚ü®i, (by simpa using h')‚ü© = b.read ‚ü®i, h'‚ü©
congr' 1; simp [fin.heq_ext_iff]
{ congr' 1; simp [fin.heq_ext_iff] }
congr' 1
simp [fin.heq_ext_iff]
simp [fin.heq_ext_iff]
simp [‚Üêthis]
intros
introI h
have : (pure a : parser Œ±) buffer.nil 0 = done 0 a := by simp [pure_eq_done]
replace this : 0 < 0 := prog.of_done this
exact (lt_irrefl _) this
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, ‚Üêorelse_eq_orelse, parser.orelse]
by_cases hn : np = n
{ by_cases hn : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, lt_irrefl] } }, { simp [hp, hn, ‚Üêorelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, lt_irrefl] } }
{ simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hn, hq, ‚Üêorelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, lt_irrefl]
rcases lt_trichotomy nq n with H|rfl|H
{ rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, lt_irrefl] }
simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H]
simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H]
simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, lt_irrefl]
simp [hp, hq, hn, ‚Üêorelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H]
{ simp [hp, hn, ‚Üêorelse_eq_orelse, parser.orelse] }
simp [hp, hn, ‚Üêorelse_eq_orelse, parser.orelse]
intros
simp [eps, pure_eq_done]
intros
simp [many_char1, list.as_string_eq, string.to_list_nonempty h, many1_eq_done, many_char_eq_many_of_to_list]
intros
rw [pow_bit0', I_mul_I]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]
intros
simp [exp_near, mul_sub]
intros
rw [‚Üê neg_mul_eq_neg_mul, ‚Üê cosh_sub_sinh, sinh_mul_I, cosh_mul_I]
intros
rw ext_iff
{ rw ext_iff, simp only [of_real_im, conj_im, eq_self_iff_true, conj_re, and_self, neg_zero] }
simp only [of_real_im, conj_im, eq_self_iff_true, conj_re, and_self, neg_zero]
intros
rw [‚Üê of_real_nat_cast, of_real_re]
intros
letI : normed_space ‚Ñù E := restrict_scalars.normed_space ‚Ñù K E
letI : is_scalar_tower ‚Ñù K E := restrict_scalars.is_scalar_tower _ _ _
letI : finite_dimensional ‚Ñù E := finite_dimensional.trans ‚Ñù K E
apply_instance
intros
{ ext ‚ü®a, b‚ü© : 1, simp }
ext ‚ü®a, b‚ü© : 1
simp
intros
by_cases hi : k = i
rw [hi, swap_apply_left, hv]
{ rw [hi, swap_apply_left, hv] }
by_cases hj : k = j
rw [hj, swap_apply_right, hv]
{ rw [hj, swap_apply_right, hv] }
rw swap_apply_of_ne_of_ne hi hj
intros
{ ext, refl }
ext
refl
intros
ext x
by_cases h : p x
have : p (ep.symm ‚ü®x, h‚ü©) := subtype.property _
{ have : p (ep.symm ‚ü®x, h‚ü©) := subtype.property _, simp [perm.subtype_congr.apply, h, symm_apply_eq, this] }
simp [perm.subtype_congr.apply, h, symm_apply_eq, this]
have : ¬¨ p (en.symm ‚ü®x, h‚ü©) := subtype.property (en.symm _)
{ have : ¬¨ p (en.symm ‚ü®x, h‚ü©) := subtype.property (en.symm _), simp [perm.subtype_congr.apply, h, symm_apply_eq, this] }
simp [perm.subtype_congr.apply, h, symm_apply_eq, this]
intros
simp [fin_succ_equiv']
intros
have A : (e.trans e.symm).source = e.source
mfld_set_tac
mfld_set_tac
refine ‚ü®by simp [A], Œªx hx, _‚ü©
rw A at hx
simp only [hx] with mfld_simps
intros
cases h.lt_or_lt with hlt hlt
exacts [‚ü®_, succ_above_cast_lt hlt‚ü©, ‚ü®_, succ_above_pred hlt‚ü©]
intros
have : i.cast_succ.val < n := i.is_lt
have h' := fin.cast_lt_cast_succ i i.is_lt
simp [snoc, this, h']
convert cast_eq rfl (p i)
intros
{ ext, refl }
ext
refl
intros
rcases s with ‚ü®‚ü®a‚ü©, h‚ü©; exact H ‚ü®a, h‚ü©
rcases s with ‚ü®‚ü®a‚ü©, h‚ü©
exact H ‚ü®a, h‚ü©
intros
rw ‚Üêmultiset.coe_eq_coe
exact multiset.nodup.to_finset_inj hl hl' h
intros
{ ext ‚ü®x, y‚ü©, simp [and.left_comm] }
ext ‚ü®x, y‚ü©
simp [and.left_comm]
intros
split
{ intros h, subst h, simp, }
intros h
subst h
simp
rintros ‚ü®hne, h_uniq‚ü©
{ rintros ‚ü®hne, h_uniq‚ü©, rw eq_singleton_iff_unique_mem, refine ‚ü®_, h_uniq‚ü©, rw ‚Üê h_uniq hne.some hne.some_spec, apply hne.some_spec, }
rw eq_singleton_iff_unique_mem
refine ‚ü®_, h_uniq‚ü©
rw ‚Üê h_uniq hne.some hne.some_spec
apply hne.some_spec
intros
rw le_iff_exists_add
use kl.1
rwa [mem_antidiagonal, eq_comm, add_comm] at hlk
intros
simp [subset_iff, @forall_swap _ Œ≤]
intros
apply fin.strict_mono_unique hmono (s.order_emb_of_fin h).strict_mono
rw [range_order_emb_of_fin, ‚Üê set.image_univ, ‚Üê coe_fin_range, ‚Üê coe_image, coe_inj]
refine eq_of_subset_of_card_le (Œª x hx, _) _
{ rcases mem_image.1 hx with ‚ü®x, hx, rfl‚ü©, exact hfs x }
rcases mem_image.1 hx with ‚ü®x, hx, rfl‚ü©
exact hfs x
rw [h, card_image_of_injective _ hmono.injective, fin_range_card]
{ rw [h, card_image_of_injective _ hmono.injective, fin_range_card] }
intros
rw [‚Üê coe_zero, coe_fn_inj]
intros
rw [single_eq_indicator, ‚Üê set.piecewise_eq_indicator, set.piecewise_singleton]
intros
split
intro h
{ intro h, exact ‚ü®h.2, card_congr (equiv.of_bijective f h)‚ü©, }
exact ‚ü®h.2, card_congr (equiv.of_bijective f h)‚ü©
rintro ‚ü®hf, h‚ü©
{ rintro ‚ü®hf, h‚ü©, refine ‚ü®_, hf‚ü©, rwa injective_iff_surjective_of_equiv (equiv_of_card_eq h) }
refine ‚ü®_, hf‚ü©
rwa injective_iff_surjective_of_equiv (equiv_of_card_eq h)
intros
{ classical, rw [univ_sum_type, prod_sum_elim] }
classical
rw [univ_sum_type, prod_sum_elim]
intros
unfold contains_aux
cases h : find_aux a l with b; simp
cases h : find_aux a l with b
simp
assume (b : Œ≤ a) (m : sigma.mk a b ‚àà l)
{ assume (b : Œ≤ a) (m : sigma.mk a b ‚àà l), rw (find_aux_iff nd).2 m at h, contradiction }
rw (find_aux_iff nd).2 m at h
contradiction
simp
show ‚àÉ (b : Œ≤ a), sigma.mk a b ‚àà l
{ show ‚àÉ (b : Œ≤ a), sigma.mk a b ‚àà l, exact ‚ü®_, (find_aux_iff nd).1 h‚ü© }
exact ‚ü®_, (find_aux_iff nd).1 h‚ü©
intros
simp [cast_heq, mul_assoc0, assoc_left]
intros
rw [‚Üê int.coe_nat_zero, coe_nat_lt]
intros
apply @nat.prime.dvd_of_dvd_pow _ _ 2 hp
rwa [sq, ‚Üê nat_abs_mul, ‚Üê coe_nat_dvd_left, ‚Üê sq]
intros
rw int.lcm at h ‚ä¢; rwa int.nat_abs_neg
rw int.lcm at h ‚ä¢
rwa int.nat_abs_neg
intros
cases even_or_odd n with h
{ exact or.inl ‚ü®h, even_iff_not_odd.mp h‚ü© }
exact or.inl ‚ü®h, even_iff_not_odd.mp h‚ü©
{ exact or.inr ‚ü®h, odd_iff_not_even.mp h‚ü© }
exact or.inr ‚ü®h, odd_iff_not_even.mp h‚ü©
intros
simp [extract]; split; refl
simp [extract]; split
simp [extract]
split
refl
refl
intros
induction l with hd tl IH generalizing n
cases n
{ cases n, { simpa using h }, { simp } }
{ simpa using h }
simpa using h
{ simp }
simp
cases n
{ cases n, { simpa using h }, { simp only [nat.succ_lt_succ_iff, length] at h, simpa using IH _ h } }
{ simpa using h }
simpa using h
simp only [nat.succ_lt_succ_iff, length] at h
{ simp only [nat.succ_lt_succ_iff, length] at h, simpa using IH _ h }
simpa using IH _ h
intros
rw nth_le_of_eq (take_append_drop j L).symm hi
{ rw nth_le_of_eq (take_append_drop j L).symm hi, exact nth_le_append _ _ }
exact nth_le_append _ _
intros
induction l; simp *
induction l
simp *
simp *
intros
induction L with j L IH h
simp
{ simp }
rw [sum_cons, length, add_comm]
exact add_le_add (h _ (set.mem_insert _ _)) (IH (Œª i hi, h i (set.mem_union_right _ hi)))
intros
rw [‚Üê filter_map_eq_map, filter_map_filter_map]
rw [‚Üê filter_map_eq_map, filter_map_filter_map]; refl
refl
intros
rw ‚Üê drop_one
rw ‚Üê drop_one; apply drop_suffix
apply drop_suffix
intros
induction ts with a ts ih; [refl, {simp [‚Üê ih], refl}]
induction ts with a ts ih
refl
simp [‚Üê ih]
refl
intros
simp only [list.sigma, mem_bind, mem_map, exists_prop, exists_and_distrib_left, and.left_comm, exists_eq_left, heq_iff_eq, exists_eq_right]
intros
simp only [zip_left, zip_left', map‚ÇÇ_left_eq_map‚ÇÇ_left']
intros
induction l; [refl, simp only [*, reverse_cons, length_append, length]]
induction l
refl
simp only [*, reverse_cons, length_append, length]
intros
cases l
{ simp [prev, hy, hz] }
simp [prev, hy, hz]
{ rw [prev, dif_neg hy, if_pos hz] }
rw [prev, dif_neg hy, if_pos hz]
intros
induction as generalizing start; simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const] with functor_norm
induction as generalizing start
simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const] with functor_norm
simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const] with functor_norm
intros
induction p with a l‚ÇÅ l‚ÇÇ p IH a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ p‚ÇÇ IH‚ÇÅ IH‚ÇÇ
simp
{simp}
{ simp, exact IH.append_left _ }
simp
exact IH.append_left _
simp
{ simp, rw [‚Üê append_assoc, ‚Üê append_assoc], exact perm_append_comm.append_right _ }
rw [‚Üê append_assoc, ‚Üê append_assoc]
exact perm_append_comm.append_right _
{ exact IH‚ÇÅ.trans IH‚ÇÇ }
exact IH‚ÇÅ.trans IH‚ÇÇ
intros
cases l with x l
{ simp }
simp
rw nodup_iff_nth_le_inj
intros i j hi hj h
simp only [length_cyclic_permutations_cons] at hi hj
rw [‚Üêmod_eq_of_lt hi, ‚Üêmod_eq_of_lt hj, ‚Üêlength_cons x l]
apply hn.rotate_congr
{ simp }
simp
{ simpa using h }
simpa using h
intros
simp [kerase, h]
intros
rw [(L.perm_ordered_insert r b).count_eq, count_cons]
split_ifs; simp only [nat.succ_eq_add_one, add_zero]
split_ifs
simp only [nat.succ_eq_add_one, add_zero]
simp only [nat.succ_eq_add_one, add_zero]
intros
rw [sublists_len, sublists_len_aux, sublists_len_aux_eq, sublists_len_aux_eq, map_id, append_nil]
rw [sublists_len, sublists_len_aux, sublists_len_aux_eq, sublists_len_aux_eq, map_id, append_nil]; refl
refl
intros
ext i
{ ext i, simp only [vec_mul, dot_product, finset.smul_sum, pi.smul_apply, smul_mul_assoc] }
simp only [vec_mul, dot_product, finset.smul_sum, pi.smul_apply, smul_mul_assoc]
intros
{ ext i j, apply dot_product_zero }
ext i j
apply dot_product_zero
intros
{ simp only [std_basis_matrix, and_imp, ite_eq_right_iff], tauto }
simp only [std_basis_matrix, and_imp, ite_eq_right_iff]
tauto
intros
ext
simp only [block_diagonal_apply, pi.neg_apply]
split_ifs; simp
split_ifs
simp
simp
intros
{ ext i j, refine fin.cases _ _ i, { refl }, simp }
ext i j
refine fin.cases _ _ i
refl
{ refl }
simp
intros
simp [h]
intros
rw [‚Üê sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]
rw [‚Üê sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]; simp
simp
intros
convert rfl
intros
apply mv_polynomial.induction_on p; simp [ eval‚ÇÇ_add, k.map_add, eval‚ÇÇ_mul, k.map_mul] {contextual := tt}
apply mv_polynomial.induction_on p
simp [ eval‚ÇÇ_add, k.map_add, eval‚ÇÇ_mul, k.map_mul] {contextual := tt}
simp [ eval‚ÇÇ_add, k.map_add, eval‚ÇÇ_mul, k.map_mul] {contextual := tt}
simp [ eval‚ÇÇ_add, k.map_add, eval‚ÇÇ_mul, k.map_mul] {contextual := tt}
intros
rw [aeval_rename, function.comp.left_id]
intros
rw [vars, degrees_monomial_eq _ _ h, finsupp.to_finset_to_multiset]
intros
split
intro h
{ intro h, cases le_total n m with H H, { simpa [H] using or.inr h }, { simpa [H] using or.inl h } }
cases le_total n m with H H
{ simpa [H] using or.inr h }
simpa [H] using or.inr h
{ simpa [H] using or.inl h }
simpa [H] using or.inl h
rintro (rfl|rfl); simp
rintro (rfl|rfl)
{ rintro (rfl|rfl); simp }
simp
simp
intros
induction n using nat.binary_rec with b n hn
{ refl }
refl
have : b = ff := by simpa using h 0
{ have : b = ff := by simpa using h 0, rw [this, bit_ff, bit0_val, hn (Œª i, by rw [‚Üêh (i + 1), test_bit_succ]), mul_zero] }
rw [this, bit_ff, bit0_val, hn (Œª i, by rw [‚Üêh (i + 1), test_bit_succ]), mul_zero]
intros
have r : k + (p - k) = p
rw [‚Üê nat.add_sub_assoc (nat.le_of_lt hkp) k, nat.add_sub_cancel_left]
rw [‚Üê nat.add_sub_assoc (nat.le_of_lt hkp) k, nat.add_sub_cancel_left]
have e : p ‚à£ choose (k + (p - k)) k
exact dvd_choose_add hkp (nat.sub_lt (hk.trans hkp) hk) (by rw r) hp
exact dvd_choose_add hkp (nat.sub_lt (hk.trans hkp) hk) (by rw r) hp
rwa r at e
intros
rw [of_digits_append, of_digits_digits, of_digits_digits]
intros
rcases ne_top_iff.1 hc with ‚ü®c, rfl‚ü©
apply enat.cases_on a; apply enat.cases_on b; simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]; simp only [(nat.cast_add _ _).symm, add_left_cancel_iff, enat.coe_inj, add_comm]; tauto
apply enat.cases_on a; apply enat.cases_on b; simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]; simp only [(nat.cast_add _ _).symm, add_left_cancel_iff, enat.coe_inj, add_comm]
apply enat.cases_on a; apply enat.cases_on b; simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]
apply enat.cases_on a; apply enat.cases_on b
apply enat.cases_on a
apply enat.cases_on b
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]
apply enat.cases_on b
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (‚ä§ : enat)]
simp only [(nat.cast_add _ _).symm, add_left_cancel_iff, enat.coe_inj, add_comm]
tauto
intros
simpa only [coprime_comm] using coprime_mul_iff_left
intros
{ rw clog_of_two_le hb hn, exact zero_lt_succ _ }
rw clog_of_two_le hb hn
exact zero_lt_succ _
intros
rw [‚Üê Union_prod]
{ rw [‚Üê Union_prod], convert surjective_unpair.Union_comp _, refl }
convert surjective_unpair.Union_comp _
refl
intros
have := @size_pos n; simp [pos_iff_ne_zero] at this; exact decidable.not_iff_not.1 this
have := @size_pos n; simp [pos_iff_ne_zero] at this
have := @size_pos n
simp [pos_iff_ne_zero] at this
exact decidable.not_iff_not.1 this
intros
induction k; simp [*, add_succ, bind_assoc]
induction k
simp [*, add_succ, bind_assoc]
simp [*, add_succ, bind_assoc]
intros
cases b; refl
cases b
refl
refl
intros
simp_rw [‚Üêmap_eq_map, ‚Üêbind_pure_comp_eq_map,is_lawful_monad.bind_assoc]
intros
rw balance_l_eq_balance' hl.3 hr.3 hl.2 hr.2 H
refine hl.balance' hr _
rcases H with ‚ü®l', e, H‚ü© | ‚ü®r', e, H‚ü©
{ exact ‚ü®_, _, H, or.inl ‚ü®e.dist_le', rfl‚ü©‚ü© }
exact ‚ü®_, _, H, or.inl ‚ü®e.dist_le', rfl‚ü©‚ü©
{ exact ‚ü®_, _, H, or.inr ‚ü®e.dist_le, rfl‚ü©‚ü© }
exact ‚ü®_, _, H, or.inr ‚ü®e.dist_le, rfl‚ü©‚ü©
intros
simp [balance', add_comm]
split_ifs
split_ifs; simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
cases delta_lt_false h_1 h_2
simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
intros
transitivity
apply M.dest_corec'
cases g x with a f
dsimp
congr
conv { to_rhs, rw [‚Üêsplit_drop_fun_last_fun f, append_fun_comp_split_fun] }
refl
intros
cases h‚ÇÅ with _ _ _ _ _ _ hagree
cases h‚ÇÄ
apply hagree
intros
change ((mod m k) : ‚Ñï) ‚â§ (m : ‚Ñï) ‚àß ((mod m k) : ‚Ñï) ‚â§ (k : ‚Ñï)
rw [mod_coe]
split_ifs
have hm : (m : ‚Ñï) > 0 := m.pos
{ have hm : (m : ‚Ñï) > 0 := m.pos, rw [‚Üê nat.mod_add_div (m : ‚Ñï) (k : ‚Ñï), h, zero_add] at hm ‚ä¢, by_cases h' : ((m : ‚Ñï) / (k : ‚Ñï)) = 0, { rw [h', mul_zero] at hm, exact (lt_irrefl _ hm).elim}, { let h' := nat.mul_le_mul_left (k : ‚Ñï) (nat.succ_le_of_lt (nat.pos_of_ne_zero h')), rw [mul_one] at h', exact ‚ü®h', le_refl (k : ‚Ñï)‚ü© } }
rw [‚Üê nat.mod_add_div (m : ‚Ñï) (k : ‚Ñï), h, zero_add] at hm ‚ä¢
by_cases h' : ((m : ‚Ñï) / (k : ‚Ñï)) = 0
{ rw [h', mul_zero] at hm, exact (lt_irrefl _ hm).elim}
rw [h', mul_zero] at hm
exact (lt_irrefl _ hm).elim
let h' := nat.mul_le_mul_left (k : ‚Ñï) (nat.succ_le_of_lt (nat.pos_of_ne_zero h'))
{ let h' := nat.mul_le_mul_left (k : ‚Ñï) (nat.succ_le_of_lt (nat.pos_of_ne_zero h')), rw [mul_one] at h', exact ‚ü®h', le_refl (k : ‚Ñï)‚ü© }
rw [mul_one] at h'
exact ‚ü®h', le_refl (k : ‚Ñï)‚ü©
exact ‚ü®nat.mod_le (m : ‚Ñï) (k : ‚Ñï), (nat.mod_lt (m : ‚Ñï) k.pos).le‚ü©
{ exact ‚ü®nat.mod_le (m : ‚Ñï) (k : ‚Ñï), (nat.mod_lt (m : ‚Ñï) k.pos).le‚ü© }
intros
simp [coeff_zero_eq_eval_zero]
intros
convert (to_finsupp_iso R).symm.injective.comp (single_injective n)
ext
simp
intros
rw X_pow_eq_monomial
simp [monomial, monomial_fun, smul_to_finsupp]
intros
rw [coeff_mul, sum_eq_single (d,n), coeff_X_pow, if_pos rfl, mul_one]
rintros ‚ü®i,j‚ü© h1 h2
{ rintros ‚ü®i,j‚ü© h1 h2, rw [coeff_X_pow, if_neg, mul_zero], rintro rfl, apply h2, rw [nat.mem_antidiagonal, add_right_cancel_iff] at h1, subst h1 }
rw [coeff_X_pow, if_neg, mul_zero]
rintro rfl
apply h2
rw [nat.mem_antidiagonal, add_right_cancel_iff] at h1
subst h1
{ exact Œª h1, (h1 (nat.mem_antidiagonal.2 rfl)).elim }
exact Œª h1, (h1 (nat.mem_antidiagonal.2 rfl)).elim
intros
simp only [‚ÜêC_eq_nat_cast, nat_degree_C]
intros
rw [leading_coeff_eq_zero, degree_eq_bot]
intros
split
intro H
{ intro H, rwa ‚Üê trailing_degree_eq_iff_nat_trailing_degree_eq, rintro rfl, rw trailing_degree_zero at H, exact option.no_confusion H }
rwa ‚Üê trailing_degree_eq_iff_nat_trailing_degree_eq
rintro rfl
rw trailing_degree_zero at H
exact option.no_confusion H
intro H
{ intro H, rwa trailing_degree_eq_iff_nat_trailing_degree_eq, rintro rfl, rw nat_trailing_degree_zero at H, rw H at hn, exact lt_irrefl _ hn }
rwa trailing_degree_eq_iff_nat_trailing_degree_eq
rintro rfl
rw nat_trailing_degree_zero at H
rw H at hn
exact lt_irrefl _ hn
intros
simp [bit0]
intros
rw [X_pow_eq_monomial, erase_lead_monomial]
intros
simp [polynomial.ext_iff, coeff_map]
intros
cases i; simp
cases i
simp
simp
intros
simp
intros
simp only [iterated_deriv_zero_right]
intros
split
intros q r h
{ intros q r h, rw [‚Üêsub_eq_zero, ‚Üêhp.mul_right_eq_zero_iff, mul_sub, h, sub_self] }
rw [‚Üêsub_eq_zero, ‚Üêhp.mul_right_eq_zero_iff, mul_sub, h, sub_self]
intros q r h
{ intros q r h, simp only at h, rw [‚Üêsub_eq_zero, ‚Üêhp.mul_left_eq_zero_iff, sub_mul, h, sub_self] }
simp only at h
rw [‚Üêsub_eq_zero, ‚Üêhp.mul_left_eq_zero_iff, sub_mul, h, sub_self]
intros
by_cases hf : f = 0
{ rw [hf, reverse_zero, nat_trailing_degree_zero] }
rw [hf, reverse_zero, nat_trailing_degree_zero]
rw ‚Üê nat.le_zero_iff
{ rw ‚Üê nat.le_zero_iff, apply nat_trailing_degree_le_of_ne_zero, rw [coeff_zero_reverse], exact mt leading_coeff_eq_zero.mp hf }
apply nat_trailing_degree_le_of_ne_zero
rw [coeff_zero_reverse]
exact mt leading_coeff_eq_zero.mp hf
intros
split
intros h Œ± a a' f f' h' i
{ intros h Œ± a a' f f' h' i, rw [‚Üê mvpfunctor.supp_eq,‚Üê mvpfunctor.supp_eq,‚Üê h,h',h] }
rw [‚Üê mvpfunctor.supp_eq,‚Üê mvpfunctor.supp_eq,‚Üê h,h',h]
rintros h Œ± ‚ü®a,f‚ü©
{ rintros h Œ± ‚ü®a,f‚ü©, ext, rwa [supp_eq_of_is_uniform,mvpfunctor.supp_eq], }
ext
rwa [supp_eq_of_is_uniform,mvpfunctor.supp_eq]
intros
ext x
apply fix.ind_rec
intros x hyp'
rw [hyp, ‚Üêhyp', fix.rec_eq]
intros
rw [‚Üê cast_zero, cast_lt]
intros
rw [lt_top_iff_ne_top, not_not]
rw [golden_ratio, golden_conj]
{rw [golden_ratio, golden_conj], ring}
ring
intros
rw [‚Üê mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h, mul_comm]
intros
refine lt_of_le_of_lt _ (pi_gt_sqrt_two_add_series n)
rw [mul_comm]
refine (div_le_iff (pow_pos (by norm_num) _ : (0 : ‚Ñù) < _)).mp (le_sqrt_of_sq_le _)
rwa [le_sub, show (0:‚Ñù) = (0:‚Ñï)/(1:‚Ñï), by rw [nat.cast_zero, zero_div]]
intros
rw [sqrt, ‚Üê nnreal.coe_mk x hx.le, nnreal.coe_le_coe, nnreal.le_sqrt_iff, real.le_to_nnreal_iff_coe_le', sq, nnreal.coe_mul]
{ rw [sqrt, ‚Üê nnreal.coe_mk x hx.le, nnreal.coe_le_coe, nnreal.le_sqrt_iff, real.le_to_nnreal_iff_coe_le', sq, nnreal.coe_mul], exact mul_pos hx hx }
exact mul_pos hx hx
intros
ext x y
{ ext x y, reflexivity }
reflexivity
intros
cases s with st
have : st n = none
from s_nth_eq_none
cases s' with st'
cases st'_nth_eq : st' n; simp only [zip_with, seq.nth, *]
cases st'_nth_eq : st' n
simp only [zip_with, seq.nth, *]
simp only [zip_with, seq.nth, *]
intros
rw [lift_rel_destruct_iff]; simp
rw [lift_rel_destruct_iff]
simp
intros
classical
ext x
by_cases h' : x ‚àà t
have : x ‚â† a
{ have : x ‚â† a, { assume H, rw H at h', exact h h' }, simp [h, h', this] }
assume H
{ assume H, rw H at h', exact h h' }
rw H at h'
exact h h'
simp [h, h', this]
{ simp [h, h'] }
simp [h, h']
intros
ext
{ ext, simp }
simp
intros
rw [image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]
intros
rw [‚Üê preimage_comp, h.comp_eq_id, preimage_id]
intros
refine ‚ü®Œª h x x' hx, _, injective.preimage_surjective‚ü©
cases h {x} with s hs
have := mem_singleton x
rwa [‚Üê hs, mem_preimage, hx, ‚Üê mem_preimage, hs, mem_singleton_iff, eq_comm] at this
intros
simp only [set.nonempty, mem_inter_eq, mem_singleton_iff, exists_eq_left]
intros
rw sUnion_eq_Union; haveI := finite.fintype h; apply finite_Union; simpa using H
rw sUnion_eq_Union; haveI := finite.fintype h; apply finite_Union
rw sUnion_eq_Union; haveI := finite.fintype h
rw sUnion_eq_Union
haveI := finite.fintype h
apply finite_Union
simpa using H
intros
simp [‚Üêfinset.coe_inj]
intros
simp [piecewise]
intros
{ ext x, simp [Iio] }
ext x
simp [Iio]
intros
rw [diff_eq, compl_Ioi, Ici_inter_Iic]
intros
simp
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
suffices : (Œª x, x + b) '' ((Œª x, a * x) '' Icc c d) = Icc (a * c + b) (a * d + b)
{ rwa set.image_image at this, }
rwa set.image_image at this
rw [image_mul_left_Icc' h, image_add_const_Icc]
intros
classical
intros p hp
rcases h_surj p with ‚ü®x, rfl‚ü©
refine ‚ü®x, _, rfl‚ü©
simp only [mem_Ioi]
by_contra h
exact has_lt.lt.false (lt_of_lt_of_le hp (h_mono (not_lt.mp h)))
intros
rw [‚Üê singleton_seq, ‚Üê singleton_seq, seq_seq, image_singleton]
intros
simp only [Inter_and, @Inter_comm _ Œπ]
intros
ext x
simp only [mem_Union, mem_image, mem_preimage]
split
{ rintro ‚ü®i, a, h, rfl‚ü©, exact h }
rintro ‚ü®i, a, h, rfl‚ü©
exact h
{ intro h, cases x with i a, exact ‚ü®i, a, h, rfl‚ü© }
intro h
cases x with i a
exact ‚ü®i, a, h, rfl‚ü©
intros
rw ‚Üê update_inl_comp_inl
intros
simp [tprod.elim, hji]
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
assume a b h
ext
exact h
intros
cases n
simp
{ simp }
split
simp only [val_min_abs_def_pos, int.coe_nat_succ]
{ simp only [val_min_abs_def_pos, int.coe_nat_succ], split_ifs with h h; assume h0, { apply val_injective, rwa [int.coe_nat_eq_zero] at h0, }, { apply absurd h0, rw sub_eq_zero, apply ne_of_lt, exact_mod_cast x.val_lt } }
split_ifs with h h; assume h0
split_ifs with h h
assume h0
{ apply val_injective, rwa [int.coe_nat_eq_zero] at h0, }
apply val_injective
rwa [int.coe_nat_eq_zero] at h0
assume h0
apply absurd h0
{ apply absurd h0, rw sub_eq_zero, apply ne_of_lt, exact_mod_cast x.val_lt }
rw sub_eq_zero
apply ne_of_lt
exact_mod_cast x.val_lt
{ rintro rfl, rw val_min_abs_zero }
rintro rfl
rw val_min_abs_zero
intros
simp only [add_comm _ (n:‚Ñù), f.commute_nat_add n]
intros
rw Union_subset_iff
{ rw Union_subset_iff, exact Œª i, omega_limit_mono_right _ _ (subset_Union _ _)}
exact Œª i, omega_limit_mono_right _ _ (subset_Union _ _)
intros
{ rw [finrank_adjoin_eq_one_iff], exact set.singleton_subset_iff }
rw [finrank_adjoin_eq_one_iff]
exact set.singleton_subset_iff
intros
use [1, (X ^ q - X - 1)]
rw [‚Üê char_p.cast_eq_zero_iff (polynomial K) p] at h
rw [derivative_sub, derivative_pow, derivative_X, h]
ring
intros
refine (ring_hom.injective_iff _).2 (Œª x hx, _)
rw [ring_hom.comp_apply, ideal.quotient.eq_zero_iff_mem] at hx
refine classical.by_contradiction (Œª hx0, absurd (I.eq_top_iff_one.2 _) hI)
have := I.mul_mem_left (mv_polynomial.C x‚Åª¬π) hx
rwa [‚Üê mv_polynomial.C.map_mul, inv_mul_cancel hx0, mv_polynomial.C_1] at this
intros
rintro ‚ü®x, y, h‚ü©
simpa only [derivative_zero, mul_zero, add_zero, zero_ne_one] using h
intros
rcases hc with ‚ü®c, r, hcr‚ü©
exact ‚ü®c, r, Œª p hp, hcr p (hs hp)‚ü©
intros
rw [pseudo_metric_space.dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V _ p2, ‚Üê vsub_add_vsub_cancel p1 (orthogonal_projection s p2) p2, norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
exact submodule.inner_right_of_mem_orthogonal (vsub_orthogonal_projection_mem_direction p2 hp1) (orthogonal_projection_vsub_mem_direction_orthogonal s p2)
intros
ext
{ ext, simp only [times_cont_mdiff_map.comp_apply, L_apply, mul_assoc] }
simp only [times_cont_mdiff_map.comp_apply, L_apply, mul_assoc]
intros
{ unfold_coes, simp only with mfld_simps }
unfold_coes
simp only with mfld_simps
intros
refine ‚ü®h.1.mono hst, _‚ü©
apply mono (Œª y hy, _) h.2
simp only with mfld_simps at hy
simp only [hy, hst _] with mfld_simps
intros
rw [has_mfderiv_within_at, has_mfderiv_within_at, ext_chart_preimage_inter_eq, has_fderiv_within_at_inter', continuous_within_at_inter' h]
exact ext_chart_preimage_mem_nhds_within I x h
intros
apply has_mfderiv_within_at.mfderiv_within _ hxs
exact has_mfderiv_within_at.comp x hg.has_mfderiv_within_at hf.has_mfderiv_within_at h
intros
rw [times_cont_diff_groupoid, times_cont_diff_groupoid]
apply groupoid_of_pregroupoid_le
assume f s hfs
exact times_cont_diff_on.of_le hfs h
intros
have : times_cont_mdiff_on I.tangent I'.tangent 0 (tangent_map_within I I' f s) ((tangent_bundle.proj I M) ‚Åª¬π' s) := hf.times_cont_mdiff_on_tangent_map_within hmn hs
exact this.continuous_on
intros
assume x
refine ‚ü®continuous_within_at_const, _‚ü©
simp only [times_cont_diff_within_at_prop, (‚àò)]
exact times_cont_diff_within_at_const
intros
simp [right_coset]
intros
ext
simp only [add_monoid_hom.coe_comp, finsupp.single_add_hom_apply, function.comp_app, one_smul, to_free_abelian_group, finsupp.lift_add_hom_apply_single]
intros
refine le_antisymm (Œª g hg, equiv.perm.ext (Œª q, quotient_group.induction_on q (Œª g', (mul_action.quotient.smul_mk H g g').trans (quotient_group.eq.mpr _)))) (subgroup.normal_le_normal_core.mpr (Œª g hg, _))
rw [mul_inv_rev, ‚Üêinv_inv g', inv_inv]
{ rw [mul_inv_rev, ‚Üêinv_inv g', inv_inv], exact H.normal_core.inv_mem hg g'‚Åª¬π }
exact H.normal_core.inv_mem hg g'‚Åª¬π
rw [‚ÜêH.inv_mem_iff, ‚Üêmul_one g‚Åª¬π, ‚Üêquotient_group.eq, ‚Üêmul_one g]
{ rw [‚ÜêH.inv_mem_iff, ‚Üêmul_one g‚Åª¬π, ‚Üêquotient_group.eq, ‚Üêmul_one g], exact (mul_action.quotient.smul_mk H g 1).symm.trans (equiv.perm.ext_iff.mp hg (1 : G)) }
exact (mul_action.quotient.smul_mk H g 1).symm.trans (equiv.perm.ext_iff.mp hg (1 : G))
intros
rw [mul_comm, f.map_mul_right]
intros
induction s using quot.induction_on
simp only [form_perm_coe, mk_eq_coe]
simp only [length_subsingleton_iff, length_coe, mk_eq_coe] at h
cases s with hd tl
{ simp }
simp
simp only [length_eq_zero, add_le_iff_nonpos_left, list.length, nonpos_iff_eq_zero] at h
{ simp only [length_eq_zero, add_le_iff_nonpos_left, list.length, nonpos_iff_eq_zero] at h, simp [h] }
simp [h]
intros
have hx'' : x ‚àà g.support
{ rwa [mem_support, ‚Üêhx, ‚Üêmem_support] }
rwa [mem_support, ‚Üêhx, ‚Üêmem_support]
have : f.support ‚äÜ g.support
intros y hy
{ intros y hy, obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy), rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support] }
obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)
rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]
rw (inter_eq_left_iff_subset _ _).mpr this at h
exact hf.support_congr hg this h
intros
obtain ‚ü®l, hl, rfl‚ü© := s.exists_list_nodup_eq
rw cycle_factors_finset_eq_list_to_finset hl
simp only [noncomm_prod_to_finset, hl, exists_prop, list.mem_to_finset, and.congr_left_iff, and.congr_right_iff, list.map_id, ne.def]
intros
exact ‚ü®list.forall_of_pairwise disjoint.symmetric, hl.pairwise_of_forall_ne‚ü©
intros
refine fin.cases _ _ p
{ simp [equiv.perm.decompose_fin, equiv_functor.map] }
simp [equiv.perm.decompose_fin, equiv_functor.map]
intros i
{ intros i, by_cases h : i = e x, { simp [h, equiv.perm.decompose_fin, equiv_functor.map] }, { have h' : some (e x) ‚â† some i := Œª H, h (option.some_injective _ H).symm, have h'' : (e x).succ ‚â† i.succ := Œª H, h (fin.succ_injective _ H).symm, simp [h, h'', fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h'] } }
by_cases h : i = e x
{ simp [h, equiv.perm.decompose_fin, equiv_functor.map] }
simp [h, equiv.perm.decompose_fin, equiv_functor.map]
have h' : some (e x) ‚â† some i := Œª H, h (option.some_injective _ H).symm
{ have h' : some (e x) ‚â† some i := Œª H, h (option.some_injective _ H).symm, have h'' : (e x).succ ‚â† i.succ := Œª H, h (fin.succ_injective _ H).symm, simp [h, h'', fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h'] }
have h'' : (e x).succ ‚â† i.succ := Œª H, h (fin.succ_injective _ H).symm
simp [h, h'', fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h']
intros
induction xs with z xs IH generalizing x y
{ simp }
simp
{ simp [IH] }
simp [IH]
intros
intro x
simp only [perm.coe_mul, function.comp_app, ne.def, set.mem_union_eq, set.mem_set_of_eq]
by_cases hq : q x = x; simp [hq]
by_cases hq : q x = x
simp [hq]
simp [hq]
intros
refine ‚ü®Œª h, _, Œª h, h.symm ‚ñ∏ disjoint_one_left 1‚ü©
ext x
cases h x with hx hx; simp [hx]
cases h x with hx hx
simp [hx]
simp [hx]
simp [hx]
simp [hx]
intros
ext
ext; simp
simp
intros
refine le_antisymm _ (sup_le (le_comap_map _ _) (ker_le_comap _ _))
intros x hx
simp only [exists_prop, mem_map, mem_comap] at hx
rcases hx with ‚ü®y, hy, hy'‚ü©
have : y‚Åª¬π * x ‚àà f.ker
rw mem_ker
{ rw mem_ker, simp [hy'] }
simp [hy']
convert mul_mem _ (mem_sup_left hy) (mem_sup_right this)
simp
intros
intros s hs
rw [set_like.mem_coe, ‚Üêsubgroup.inv_mem_iff]
exact subset_closure (mem_inv.mp hs)
intros
rw [div_eq_mul_inv]
exact mul_mem_center ha (inv_mem_center hb)
intros
ext
ext; simp
simp
intros
rw [‚Üê line_map_apply_one_sub, left_vsub_line_map]
intros
rw [lt_iff_le_not_le, not_le_iff_exists]
intros
rw [‚Üêset.image_univ, ‚Üêset.image_univ, ‚Üêfinset.coe_univ] at h
exact finset.univ.centroid_eq_of_inj_on_of_image_eq k _ (Œª _ _ _ _ he, affine_independent.injective s‚ÇÅ.independent he) (Œª _ _ _ _ he, affine_independent.injective s‚ÇÇ.independent he) h
intros
rw [span_nat_eq_add_submonoid_closure, s.closure_eq]
intros
rw mem_span_insert
split
rintro ‚ü®a, z, hz, rfl‚ü©
{ rintro ‚ü®a, z, hz, rfl‚ü©, exact ‚ü®-a, by simp [hz, add_assoc]‚ü© }
exact ‚ü®-a, by simp [hz, add_assoc]‚ü©
rintro ‚ü®a, h‚ü©
{ rintro ‚ü®a, h‚ü©, exact ‚ü®-a, _, h, by simp [add_comm, add_left_comm]‚ü© }
exact ‚ü®-a, _, h, by simp [add_comm, add_left_comm]‚ü©
intros
refine le_antisymm _ (sup_le (le_comap_map _ _) (comap_mono bot_le))
rintro x ‚ü®y, hy, e‚ü©
exact mem_sup.2 ‚ü®y, hy, x - y, by simpa using sub_eq_zero.2 e.symm, by simp‚ü©
intros
ext m
have hg : N.subtype.comp (g^k) m = 0
rw [‚Üê commute_pow_left_of_commute h, hG, zero_comp, zero_apply]
{ rw [‚Üê commute_pow_left_of_commute h, hG, zero_comp, zero_apply], }
simp only [submodule.subtype_apply, comp_app, submodule.coe_eq_zero, coe_comp] at hg
rw [hg, linear_map.zero_apply]
intros
rw [coe_extend, subtype.range_coe_subtype, set_of_mem_eq]
intros
dunfold is_ortho
split
split; intro H
intro H
rw [smul_right, mul_eq_zero] at H
{ rw [smul_right, mul_eq_zero] at H, cases H, { trivial }, { exact H }}
cases H
{ trivial }
trivial
{ exact H }
exact H
intro H
{ rw [smul_right, H, mul_zero] }
rw [smul_right, H, mul_zero]
intros
{ rw [basis.det_apply, basis.to_matrix_map, basis.det_apply] }
rw [basis.det_apply, basis.to_matrix_map, basis.det_apply]
intros
apply le_trans
exact cardinal.lift_mk_le.mpr ‚ü®(equiv.of_injective _ hv.injective).to_embedding‚ü©
{ exact cardinal.lift_mk_le.mpr ‚ü®(equiv.of_injective _ hv.injective).to_embedding‚ü©, }
simp only [cardinal.lift_le]
{ simp only [cardinal.lift_le], apply le_trans, swap, exact cardinal.le_sup _ ‚ü®range v, hv.coe_range‚ü©, exact le_refl _, }
apply le_trans
swap
exact cardinal.le_sup _ ‚ü®range v, hv.coe_range‚ü©
exact le_refl _
intros
{ classical, exact (basis.of_vector_space K V).eval_ker }
classical
exact (basis.of_vector_space K V).eval_ker
intros
rintro rfl
exact h linear_map.ker_id
intros
rw [‚Üê submodule.dim_sup_add_dim_inf_eq, top_le_iff.1 h.2, le_bot_iff.1 h.1, finrank_bot, add_zero]
exact finrank_top
intros
{ contrapose h, simp [finrank_of_infinite_dimensional h] }
contrapose h
simp [finrank_of_infinite_dimensional h]
intros
convert finrank_eq_dim K (‚ä• : submodule K V)
rw dim_bot
norm_cast
intros
let f : t.map (embedding.subtype s) ‚Üí s := Œª x, ‚ü®x.1, begin obtain ‚ü®x, h‚ü© := x, rw [finset.mem_map] at h, obtain ‚ü®a, ha, rfl‚ü© := h, simp only [subtype.coe_prop, embedding.coe_subtype], end‚ü©
convert linear_independent.comp li f _
rintros ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©
rw [finset.mem_map] at hx hy
obtain ‚ü®a, ha, rfl‚ü© := hx
obtain ‚ü®b, hb, rfl‚ü© := hy
simp only [imp_self, subtype.mk_eq_mk]
intros
let indep : set Œπ ‚Üí Prop := Œª I, linear_independent R (s ‚àò coe : I ‚Üí M)
let X := { I : set Œπ // indep I }
let r : X ‚Üí X ‚Üí Prop := Œª I J, I.1 ‚äÜ J.1
have key : ‚àÄ c : set X, zorn.chain r c ‚Üí indep (‚ãÉ (I : X) (H : I ‚àà c), I)
intros c hc
{ intros c hc, dsimp [indep], rw [linear_independent_comp_subtype], intros f hsupport hsum, rcases eq_empty_or_nonempty c with rfl | ‚ü®a, hac‚ü©, { simpa using hsupport }, haveI : is_refl X r := ‚ü®Œª _, set.subset.refl _‚ü©, obtain ‚ü®I, I_mem, hI‚ü© : ‚àÉ I ‚àà c, (f.support : set Œπ) ‚äÜ I := finset.exists_mem_subset_of_subset_bUnion_of_directed_on hac hc.directed_on hsupport, exact linear_independent_comp_subtype.mp I.2 f hI hsum }
dsimp [indep]
rw [linear_independent_comp_subtype]
intros f hsupport hsum
rcases eq_empty_or_nonempty c with rfl | ‚ü®a, hac‚ü©
{ simpa using hsupport }
simpa using hsupport
haveI : is_refl X r := ‚ü®Œª _, set.subset.refl _‚ü©
obtain ‚ü®I, I_mem, hI‚ü© : ‚àÉ I ‚àà c, (f.support : set Œπ) ‚äÜ I := finset.exists_mem_subset_of_subset_bUnion_of_directed_on hac hc.directed_on hsupport
exact linear_independent_comp_subtype.mp I.2 f hI hsum
have trans : transitive r := Œª I J K, set.subset.trans
obtain ‚ü®‚ü®I, hli : indep I‚ü©, hmax : ‚àÄ a, r ‚ü®I, hli‚ü© a ‚Üí r a ‚ü®I, hli‚ü©‚ü© := @zorn.exists_maximal_of_chains_bounded _ r (Œª c hc, ‚ü®‚ü®‚ãÉ I ‚àà c, (I : set Œπ), key c hc‚ü©, Œª I, set.subset_bUnion_of_mem‚ü©) trans
exact ‚ü®I, hli, Œª J hsub hli, set.subset.antisymm hsub (hmax ‚ü®J, hli‚ü© hsub)‚ü©
intros
ext
{ ext, simp only [basis.to_matrix_apply, basis.map, linear_equiv.trans_apply] }
simp only [basis.to_matrix_apply, basis.map, linear_equiv.trans_apply]
intros
{ have h := finite_field.trace_pow_card M, rwa zmod.card at h, }
have h := finite_field.trace_pow_card M
rwa zmod.card at h
intros
rw [dot_product, finset.sum_eq_single i, linear_map.std_basis_same]
exact Œª _ _ hb, by rw [linear_map.std_basis_ne _ _ _ _ hb, mul_zero]
exact Œª hi, false.elim (hi $ finset.mem_univ _)
intros
rw [‚Üê matrix.to_lin_symm, linear_equiv.symm_apply_apply]
intros
refine pi_tensor_product.induction_on' x _ _
intros z f
{ intros z f, rw [smul_tprod_coeff' r z f, lift_aux_tprod_coeff, lift_aux_tprod_coeff, smul_assoc] }
rw [smul_tprod_coeff' r z f, lift_aux_tprod_coeff, lift_aux_tprod_coeff, smul_assoc]
intros z y ihz ihy
{ intros z y ihz ihy, rw [smul_add, (lift_aux œÜ).map_add, ihz, ihy, (lift_aux œÜ).map_add, smul_add] }
rw [smul_add, (lift_aux œÜ).map_add, ihz, ihy, (lift_aux œÜ).map_add, smul_add]
intros
{ rintros ‚ü®y, z‚ü©, simp {contextual := tt} }
rintros ‚ü®y, z‚ü©
simp {contextual := tt}
intros
ext
ext; refl
refl
refl
intros
rw [‚Üêis_scalar_tower.algebra_map_smul R a x, polar_smul_left, algebra.smul_def]
intros
simp [or_comm, decidable.forall_or_distrib_left]
intros
simp only [and.comm, ‚Üê and.congr_right_iff]
intros
{ rw forall_swap, simp }
rw forall_swap
simp
intros
{ rw [nontrivial_iff, subsingleton_iff], push_neg, refl }
rw [nontrivial_iff, subsingleton_iff]
push_neg
refl
intros
rw small_congr (equiv.of_injective f hf)
apply_instance
intros
apply measurable_of_is_open
intros s hs
rw [‚Üê measurable_set.compl_iff, ‚Üê preimage_compl]
apply hf
rw [is_closed_compl_iff]
exact hs
intros
cases eq_empty_or_nonempty s with h2s h2s
{ simp [h2s, measurable_const] }
simp [h2s, measurable_const]
apply measurable_of_Iic
{ apply measurable_of_Iic, intro y, simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall], exact measurable_set.bInter hs (Œª i hi, measurable_set_le (hf i) measurable_const) }
intro y
simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
exact measurable_set.bInter hs (Œª i hi, measurable_set_le (hf i) measurable_const)
intros
choose s h1s h2s using hC
haveI := fintype.encodable Œπ
let e : ‚Ñï ‚Üí (Œπ ‚Üí ‚Ñï) := Œª n, (decode (Œπ ‚Üí ‚Ñï) n).iget
refine ‚ü®Œª n, pi univ (Œª i, s i (e n i)), Œª n, mem_image_of_mem _ (Œª i _, h1s i _), _‚ü©
simp_rw [(surjective_decode_iget (Œπ ‚Üí ‚Ñï)).Union_comp (Œª x, pi univ (Œª i, s i (x i))), Union_univ_pi s, h2s, pi_univ]
intros
{ rw measure.prod, exact bind_zero_left _ }
rw measure.prod
exact bind_zero_left _
intros
refine (eq_singular_part _ (s.rn_deriv Œº + t.rn_deriv Œº) ((mutually_singular_singular_part s Œº).add_left (mutually_singular_singular_part t Œº)) _).symm
erw [with_density·µ•_add (integrable_rn_deriv s Œº) (integrable_rn_deriv t Œº)]
rw [add_assoc, add_comm (t.singular_part Œº), add_assoc, add_comm _ (t.singular_part Œº), singular_part_add_with_density_rn_deriv_eq, ‚Üê add_assoc, singular_part_add_with_density_rn_deriv_eq]
intros
{ rw comp‚ÇÇ_eq_mk, apply coe_fn_mk }
rw comp‚ÇÇ_eq_mk
apply coe_fn_mk
intros
simp only [ae_seq_eq_mk_of_mem_ae_seq_set hf hx i, mk_eq_fun_of_mem_ae_seq_set hf hx i]
intros
refine le_antisymm _ (Limsup_le_Limsup_of_le (map_restrict_ae_le_map_indicator_ae hs) (by is_bounded_default) (by is_bounded_default))
refine Limsup_le_Limsup (by is_bounded_default) (by is_bounded_default) (Œª c h_restrict_le, _)
rw eventually_map at h_restrict_le ‚ä¢
rw ae_restrict_iff' hs at h_restrict_le
have hc : 0 ‚â§ c
suffices : ‚àÉ x, 0 ‚â§ f x ‚àß f x ‚â§ c
{ suffices : ‚àÉ x, 0 ‚â§ f x ‚àß f x ‚â§ c, by { obtain ‚ü®x, hx‚ü© := this, exact hx.1.trans hx.2, }, refine frequently.exists _, { exact Œº.ae, }, rw [eventually_le, ae_restrict_iff' hs] at hf, have hs' : ‚àÉ·µê x ‚àÇŒº, x ‚àà s, { contrapose! hs_not_null, rw [not_frequently, ae_iff] at hs_not_null, suffices : {a : Œ± | ¬¨a ‚àâ s} = s, by rwa ‚Üê this, simp, }, refine hs'.mp (hf.mp (h_restrict_le.mono (Œª x hxs_imp_c hxf_nonneg hxs, _))), rw pi.zero_apply at hxf_nonneg, exact ‚ü®hxf_nonneg hxs, hxs_imp_c hxs‚ü©, }
obtain ‚ü®x, hx‚ü© := this
obtain ‚ü®x, hx‚ü© := this
{ obtain ‚ü®x, hx‚ü© := this, exact hx.1.trans hx.2, }
{ obtain ‚ü®x, hx‚ü© := this, exact hx.1.trans hx.2, }
exact hx.1.trans hx.2
exact hx.1.trans hx.2
refine frequently.exists _
{ exact Œº.ae, }
exact Œº.ae
rw [eventually_le, ae_restrict_iff' hs] at hf
have hs' : ‚àÉ·µê x ‚àÇŒº, x ‚àà s
contrapose! hs_not_null
{ contrapose! hs_not_null, rw [not_frequently, ae_iff] at hs_not_null, suffices : {a : Œ± | ¬¨a ‚àâ s} = s, by rwa ‚Üê this, simp, }
rw [not_frequently, ae_iff] at hs_not_null
suffices : {a : Œ± | ¬¨a ‚àâ s} = s
rwa ‚Üê this
rwa ‚Üê this
simp
refine hs'.mp (hf.mp (h_restrict_le.mono (Œª x hxs_imp_c hxf_nonneg hxs, _)))
rw pi.zero_apply at hxf_nonneg
exact ‚ü®hxf_nonneg hxs, hxs_imp_c hxs‚ü©
refine h_restrict_le.mono (Œª x hxc, _)
by_cases hxs : x ‚àà s
{ simpa [hxs] using hxc hxs, }
simpa [hxs] using hxc hxs
{ simpa [hxs] using hc, }
simpa [hxs] using hc
intros
simp only [pi.neg_apply, nnnorm_neg]
intros
cases f
cases g
simp only [subtype.mk_eq_mk]
exact ae_eq_fun.ext h
intros
simp_rw [snorm_ess_sup, nnnorm_indicator_eq_indicator_nnnorm, ennreal.coe_indicator]
by_cases hs_null : Œº s = 0
rw measure.restrict_zero_set hs_null
{ rw measure.restrict_zero_set hs_null, simp only [ess_sup_measure_zero, ennreal.ess_sup_eq_zero_iff, ennreal.bot_eq_zero], have hs_empty : s =·µê[Œº] (‚àÖ : set Œ±), by { rw ae_eq_set, simpa using hs_null, }, refine (indicator_ae_eq_of_ae_eq_set hs_empty).trans _, rw set.indicator_empty, refl, }
simp only [ess_sup_measure_zero, ennreal.ess_sup_eq_zero_iff, ennreal.bot_eq_zero]
have hs_empty : s =·µê[Œº] (‚àÖ : set Œ±)
rw ae_eq_set
rw ae_eq_set
{ rw ae_eq_set, simpa using hs_null, }
{ rw ae_eq_set, simpa using hs_null, }
simpa using hs_null
simpa using hs_null
refine (indicator_ae_eq_of_ae_eq_set hs_empty).trans _
rw set.indicator_empty
refl
rw ess_sup_indicator_eq_ess_sup_restrict (eventually_of_forall (Œª x, _)) hs hs_null
rw pi.zero_apply
exact zero_le _
intros
rw [snorm_ess_sup, ess_sup_const _ hŒº]
intros
simp_rw [ae_fin_strongly_measurable, ae_measurable, fin_strongly_measurable_iff_measurable]
intros
ext
{ ext, rw [map_apply, real.norm_eq_abs, abs_of_nonneg], exact le_max_right _ _ }
rw [map_apply, real.norm_eq_abs, abs_of_nonneg]
exact le_max_right _ _
intros
rw integral_eq_lintegral_of_nonneg_ae _ hf.1.norm
simp_rw [of_real_norm_eq_coe_nnnorm, ennreal.of_real_to_real (lt_top_iff_ne_top.mp hf.2)]
{ simp_rw [of_real_norm_eq_coe_nnnorm, ennreal.of_real_to_real (lt_top_iff_ne_top.mp hf.2)], }
{ refine ae_of_all _ _, simp, }
refine ae_of_all _ _
simp
intros
simp only [interval_integral, integral_smul, smul_sub]
intros
refine measure.ext (Œª s hs, _)
rw [with_density_apply _ hs, measure.coe_smul, pi.smul_apply, with_density_apply _ hs, smul_eq_mul, ‚Üê lintegral_const_mul r hf]
refl
intros
refine fin_meas_supp_iff.2 (Œª b hb, _)
rw [f.lintegral_eq_of_subset' (finset.subset_insert b _)] at h
refine ennreal.lt_top_of_mul_ne_top_right _ hb
exact (lt_top_of_sum_ne_top h (finset.mem_insert_self _ _)).ne
intros
by_cases hf : integrable f Œº
rw [set_to_fun_eq hT hf, set_to_fun_eq hT, integrable.to_L1_smul', L1.set_to_L1_smul hT h_smul c _]
{ rw [set_to_fun_eq hT hf, set_to_fun_eq hT, integrable.to_L1_smul', L1.set_to_L1_smul hT h_smul c _], }
by_cases hr : c = 0
{ by_cases hr : c = 0, { rw hr, simp, }, { have hf' : ¬¨ integrable (c ‚Ä¢ f) Œº, by rwa [integrable_smul_iff hr f], rw [set_to_fun_undef hT hf, set_to_fun_undef hT hf', smul_zero], }, }
{ rw hr, simp, }
rw hr
simp
have hf' : ¬¨ integrable (c ‚Ä¢ f) Œº
{ have hf' : ¬¨ integrable (c ‚Ä¢ f) Œº, by rwa [integrable_smul_iff hr f], rw [set_to_fun_undef hT hf, set_to_fun_undef hT hf', smul_zero], }
rwa [integrable_smul_iff hr f]
rwa [integrable_smul_iff hr f]
rw [set_to_fun_undef hT hf, set_to_fun_undef hT hf', smul_zero]
intros
dsimp [opens]
rw subtype.forall
apply induced_outer_measure_caratheodory
apply inner_content_Union_nat
apply inner_content_mono'
intros
have := nat.Inf_mem (index_defined hK hV)
{ have := nat.Inf_mem (index_defined hK hV), rwa [mem_image] at this }
rwa [mem_image] at this
intros
refine (tendsto_pre m s).comp (tendsto_inf.2 ‚ü®ennreal.tendsto_inv_nat_nhds_zero, _‚ü©)
refine tendsto_principal.2 (eventually_of_forall $ Œª n, _)
simp
intros
simp [volume_val]
intros
simp [measure.trim, outer_measure.to_measure_zero]
intros
rw [map_top, hf.range_eq, restrict_univ]
intros
simp only [bind_on_support_apply, tsum_eq_zero_iff (bind_on_support.summable p f b), mul_eq_zero, or_iff_not_imp_left]
exact ‚ü®Œª h a ha, trans (dif_neg ha).symm (h a ha), Œª h a ha, trans (dif_neg ha) (h a ha)‚ü©
intros
obtain ‚ü®_, ‚ü®b, b_mem, b_ne_zero, rfl‚ü©, min‚ü© := @int.exists_least_of_bdd (Œª a, ‚àÉ b ‚àà (I : ideal S), b ‚â† (0 : S) ‚àß abv (algebra.norm R b) = a) _ _
refine ‚ü®b, b_mem, b_ne_zero, _‚ü©
{ refine ‚ü®b, b_mem, b_ne_zero, _‚ü©, intros c hc lt, contrapose! lt with c_ne_zero, exact min _ ‚ü®c, hc, c_ne_zero, rfl‚ü© }
intros c hc lt
contrapose! lt with c_ne_zero
exact min _ ‚ü®c, hc, c_ne_zero, rfl‚ü©
use 0
{ use 0, rintros _ ‚ü®b, b_mem, b_ne_zero, rfl‚ü©, apply abv.nonneg }
rintros _ ‚ü®b, b_mem, b_ne_zero, rfl‚ü©
apply abv.nonneg
obtain ‚ü®b, b_mem, b_ne_zero‚ü© := (I : ideal S).ne_bot_iff.mp (non_zero_divisors.coe_ne_zero I)
{ obtain ‚ü®b, b_mem, b_ne_zero‚ü© := (I : ideal S).ne_bot_iff.mp (non_zero_divisors.coe_ne_zero I), exact ‚ü®_, ‚ü®b, b_mem, b_ne_zero, rfl‚ü©‚ü© }
exact ‚ü®_, ‚ü®b, b_mem, b_ne_zero, rfl‚ü©‚ü©
intros
dsimp [lucas_lehmer_residue] at h
rw s_zmod_eq_s p' at h
simp [zmod.int_coe_zmod_eq_zero_iff_dvd] at h
cases h with k h
use k
replace h := congr_arg (Œª (n : ‚Ñ§), (n : X (q (p'+2)))) h
dsimp at h
rw closed_form at h
replace h := congr_arg (Œª x, œâ^2^p' * x) h
dsimp at h
have t : 2^p' + 2^p' = 2^(p'+1) := by ring_exp
rw [mul_add, ‚Üêpow_add œâ, t, ‚Üêmul_pow œâ œâb (2^p'), œâ_mul_œâb, one_pow] at h
rw [mul_comm, coe_mul] at h
rw [mul_comm _ (k : X (q (p'+2)))] at h
replace h := eq_sub_of_add_eq h
exact_mod_cast h
intros
unfold padic_val_rat
split_ifs
{ simp, }
simp
intros
ext x
rw ring_hom.mem_ker
split
intro h
{ intro h, simpa only [h, zmod.cast_zero, sub_zero] using to_zmod_spec x, }
simpa only [h, zmod.cast_zero, sub_zero] using to_zmod_spec x
intro h
{ intro h, rw ‚Üê sub_zero x at h, dsimp [to_zmod, to_zmod_hom], convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h, apply sub_zmod_repr_mem, }
rw ‚Üê sub_zero x at h
dsimp [to_zmod, to_zmod_hom]
convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h
apply sub_zmod_repr_mem
intros
have hz : z ‚â† 0
apply ne_of_gt hzpos
have h2 : y = m ^ 2 - n ^ 2 ‚àß z = m ^ 2 + n ^ 2
apply rat.div_int_inj hzpos hm2n2 (h.coprime_of_coprime hc) H
{ apply rat.div_int_inj hzpos hm2n2 (h.coprime_of_coprime hc) H, rw [hw2], norm_cast }
rw [hw2]
norm_cast
use [m, n]
apply and.intro _ (and.intro co pp)
right
refine ‚ü®_, h2.left‚ü©
rw [‚Üê rat.coe_int_inj _ _, ‚Üê div_left_inj' ((mt (rat.coe_int_inj z 0).mp) hz), hv2, h2.right]
norm_cast
intros
cases nat.prime.eq_two_or_odd (fact.out p.prime) with hp2 hp_odd
{ substI p, exact dec_trivial }
substI p
exact dec_trivial
haveI := fact.mk hp_odd
have neg_one_ne_zero : (-1 : zmod p) ‚â† 0
from mt neg_eq_zero.1 one_ne_zero
rw [euler_criterion p neg_one_ne_zero, neg_one_pow_eq_pow_mod_two]
cases mod_two_eq_zero_or_one (p / 2) with p_half_even p_half_odd
rw [p_half_even, pow_zero, eq_self_iff_true, true_iff]
{ rw [p_half_even, pow_zero, eq_self_iff_true, true_iff], contrapose! p_half_even with hp, rw [‚Üê nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl, hp], exact dec_trivial }
contrapose! p_half_even with hp
rw [‚Üê nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl, hp]
exact dec_trivial
rw [p_half_odd, pow_one, iff_false_intro (ne_neg_self p one_ne_zero).symm, false_iff, not_not]
{ rw [p_half_odd, pow_one, iff_false_intro (ne_neg_self p one_ne_zero).symm, false_iff, not_not], rw [‚Üê nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl] at p_half_odd, rw [‚Üê nat.mod_mul_left_mod _ 2, show 2 * 2 = 4, from rfl] at hp_odd, have hp : p % 4 < 4, from nat.mod_lt _ dec_trivial, revert hp hp_odd p_half_odd, generalize : p % 4 = k, dec_trivial! }
rw [‚Üê nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl] at p_half_odd
rw [‚Üê nat.mod_mul_left_mod _ 2, show 2 * 2 = 4, from rfl] at hp_odd
have hp : p % 4 < 4
from nat.mod_lt _ dec_trivial
revert hp hp_odd p_half_odd
generalize : p % 4 = k
dec_trivial!
intros
{ simp [ext], ring }
simp [ext]
ring
intros
rw [inf_of_le_right (@sdiff_le _ x y _)]
intros
rw [inf_sup_left, inf_sdiff_left, sup_inf_self]
intros
{ intro h, rw [‚Üêh, disjoint_self] at hab, exact ha hab }
intro h
rw [‚Üêh, disjoint_self] at hab
exact ha hab
intros
simp only [bdd_below, lower_bounds_empty, univ_nonempty]
intros
classical
rw is_compact_element_iff_le_of_directed_Sup_le
intros d hemp hdir hsup
change f with id ‚àò f
rw ‚Üêfinset.sup_finset_image
apply finset.sup_le_of_le_directed d hemp hdir
rintros x hx
obtain ‚ü®p, ‚ü®hps, rfl‚ü©‚ü© := finset.mem_image.mp hx
specialize h p hps
rw is_compact_element_iff_le_of_directed_Sup_le at h
specialize h d hemp hdir (le_trans (finset.le_sup hps) hsup)
simpa only [exists_prop]
intros
rw [infi_inf_eq, infi_const]
intros
rw [‚Üê tendsto_map'_iff, map_add_at_top_eq_nat]
intros
simpa only [mul_comm] using hf.neg_const_mul_at_top hr
intros
ext t
rw [hl.mem_iff, hl'.mem_iff]
intros
simp [imp_iff_not_or, not_eventually, frequently_or_distrib]
intros
ext W
suffices : (‚àÉ (t : set Œ±), t ‚àà f ‚àß (Œª (y : Œ±), x) ‚Åª¬π' t ‚äÜ W) ‚Üî W = univ
simpa
simpa
split
rintro ‚ü®V, V_in, hW‚ü©
{ rintro ‚ü®V, V_in, hW‚ü©, simpa [preimage_const_of_mem (h V V_in), univ_subset_iff] using hW }
simpa [preimage_const_of_mem (h V V_in), univ_subset_iff] using hW
rintro rfl
{ rintro rfl, use univ, simp [univ_mem] }
use univ
simp [univ_mem]
intros
haveI := nonempty_subtype.2 ne
simp only [infi_subtype']
exact map_infi_eq h.directed_coe
intros
simp only [tendsto, le_principal_iff, mem_map', filter.eventually]
intros
rw [principal_coprod_principal, map_principal]
congr
ext ‚ü®b', i'‚ü©
split
rintro ‚ü®‚ü®a'', i''‚ü©, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
{ rintro ‚ü®‚ü®a'', i''‚ü©, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©, simp }
simp
rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
{ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, use (a, i'), simpa using h‚ÇÅ.symm }
use (a, i')
simpa using h‚ÇÅ.symm
intros
rw [infi_subtype', infi_sup_right, infi_subtype']
intros
ext S
simp only [mem_coprod_iff, exists_prop, mem_comap, mem_cofinite]
split
rintro ‚ü®‚ü®A, hAf, hAS‚ü©, B, hBf, hBS‚ü©
{ rintro ‚ü®‚ü®A, hAf, hAS‚ü©, B, hBf, hBS‚ü©, rw [‚Üê compl_subset_compl, ‚Üê preimage_compl] at hAS hBS, exact (hAf.prod hBf).subset (subset_inter hAS hBS) }
rw [‚Üê compl_subset_compl, ‚Üê preimage_compl] at hAS hBS
exact (hAf.prod hBf).subset (subset_inter hAS hBS)
intro hS
{ intro hS, refine ‚ü®‚ü®(prod.fst '' S·∂ú)·∂ú, _, _‚ü©, ‚ü®(prod.snd '' S·∂ú)·∂ú, _, _‚ü©‚ü©, { simpa using hS.image prod.fst }, { simpa [compl_subset_comm] using subset_preimage_image prod.fst S·∂ú }, { simpa using hS.image prod.snd }, { simpa [compl_subset_comm] using subset_preimage_image prod.snd S·∂ú } }
refine ‚ü®‚ü®(prod.fst '' S·∂ú)·∂ú, _, _‚ü©, ‚ü®(prod.snd '' S·∂ú)·∂ú, _, _‚ü©‚ü©
{ simpa using hS.image prod.fst }
simpa using hS.image prod.fst
{ simpa [compl_subset_comm] using subset_preimage_image prod.fst S·∂ú }
simpa [compl_subset_comm] using subset_preimage_image prod.fst S·∂ú
{ simpa using hS.image prod.snd }
simpa using hS.image prod.snd
{ simpa [compl_subset_comm] using subset_preimage_image prod.snd S·∂ú }
simpa [compl_subset_comm] using subset_preimage_image prod.snd S·∂ú
intros
rw [‚Üê principal_empty, lift'_principal hh]
intros
{ rw ‚Üê h, simp }
rw ‚Üê h
simp
intros
simp [Limsup]; exact cInf_upper_bounds_eq_cSup h hs
simp [Limsup]
exact cInf_upper_bounds_eq_cSup h hs
intros
rw [symm_diff_comm, compl_symm_diff_self]
intros
classical
revert hf
apply f.induction_on
intro h
{ intro h, simp [set.is_pwo_empty.is_wf], }
simp [set.is_pwo_empty.is_wf]
intros s f sf hf hsf
{ intros s f sf hf hsf, rw finset.sup_insert, exact (hsf s (finset.mem_insert_self _ _)).union (hf (Œª s' s'f, hsf _ (finset.mem_insert_of_mem s'f))) }
rw finset.sup_insert
exact (hsf s (finset.mem_insert_self _ _)).union (hf (Œª s' s'f, hsf _ (finset.mem_insert_of_mem s'f)))
intros
rw [inv_eq_iff, inv_div, div_eq_iff, sub_eq_iff_eq_add, mul_comm]
conv_lhs { rw ‚Üê div_X_mul_X_add p }
rw [alg_hom.map_add, alg_hom.map_mul, aeval_X, aeval_C]
exact aeval_ne
intros
simpa [group.fg_iff_monoid.fg] using finite_type_iff_fg
intros
rcases I with ‚ü®I, aI, haI, hI‚ü©
rcases J with ‚ü®J, aJ, haJ, hJ‚ü©
use aI * aJ
use S.mul_mem haI haJ
intros b hb
apply submodule.mul_induction_on hb
intros m hm n hn
{ intros m hm n hn, obtain ‚ü®n', hn'‚ü© := hJ n hn, rw [mul_smul, mul_comm m, ‚Üê smul_mul_assoc, ‚Üê hn', ‚Üê algebra.smul_def], apply hI, exact submodule.smul_mem _ _ hm }
obtain ‚ü®n', hn'‚ü© := hJ n hn
rw [mul_smul, mul_comm m, ‚Üê smul_mul_assoc, ‚Üê hn', ‚Üê algebra.smul_def]
apply hI
exact submodule.smul_mem _ _ hm
intros x y hx hy
{ intros x y hx hy, rw smul_add, apply is_integer_add hx hy }
rw smul_add
apply is_integer_add hx hy
intros
rw [‚Üêset.singleton_one, span_singleton_one]
intros
{ ext x, rw [ring_hom.comp_apply, factor_mk] }
ext x
rw [ring_hom.comp_apply, factor_mk]
intros
{ rw [‚Üê f.injective_iff, injective_iff_ker_eq_bot] }
rw [‚Üê f.injective_iff, injective_iff_ker_eq_bot]
intros
simp only [mk_ker, sup_idem, sup_comm, quot_left_to_quot_sup, quotient.factor, ker_quotient_lift, map_eq_iff_sup_ker_eq_of_surjective I^.quotient.mk quotient.mk_surjective, ‚Üê sup_assoc]
intros
split
split; intro hr
intro hr
rcases hr with ‚ü®p, hmp, hpr‚ü©
{ rcases hr with ‚ü®p, hmp, hpr‚ü©, refine ‚ü®_, set.finite_mem_finset _, p.restriction, monic_restriction.2 hmp, _‚ü©, erw [‚Üê aeval_def, is_scalar_tower.aeval_apply _ R, map_restriction, aeval_def, hpr] }
refine ‚ü®_, set.finite_mem_finset _, p.restriction, monic_restriction.2 hmp, _‚ü©
erw [‚Üê aeval_def, is_scalar_tower.aeval_apply _ R, map_restriction, aeval_def, hpr]
intro hr
rcases hr with ‚ü®s, hs, hsr‚ü©
exact is_integral_of_subring _ hsr
intros
refine eq_bot_iff.trans _
split
rw is_integrally_closed_iff K
{ rw is_integrally_closed_iff K, intros h x hx, exact set.mem_range.mp (algebra.mem_bot.mp (h hx)), assumption }
intros h x hx
exact set.mem_range.mp (algebra.mem_bot.mp (h hx))
assumption
{ intros h x hx, rw [algebra.mem_bot, set.mem_range], exactI is_integral_iff.mp hx }
intros h x hx
rw [algebra.mem_bot, set.mem_range]
exactI is_integral_iff.mp hx
intros
rintros x y hxy
obtain ‚ü®a, b, rfl‚ü© := mk'_surjective M x
obtain ‚ü®c, d, rfl‚ü© := mk'_surjective M y
rw [map_mk' _ a b, map_mk' _ c d, mk'_eq_iff_eq] at hxy
refine mk'_eq_iff_eq.2 (congr_arg (algebra_map _ _) (hg _))
convert is_localization.injective _ hM hxy
convert is_localization.injective _ hM hxy; simp
simp
simp
intros
split
split; intro h
intro h
rw [‚Üê mk'_spec S x y, mul_comm]
{ rw [‚Üê mk'_spec S x y, mul_comm], exact I.mul_mem_left ((algebra_map R S) y) h }
exact I.mul_mem_left ((algebra_map R S) y) h
intro h
rw ‚Üê mk'_spec S x y at h
{ rw ‚Üê mk'_spec S x y at h, obtain ‚ü®b, hb‚ü© := is_unit_iff_exists_inv.1 (map_units S y), have := I.mul_mem_left b h, rwa [mul_comm, mul_assoc, hb, mul_one] at this }
obtain ‚ü®b, hb‚ü© := is_unit_iff_exists_inv.1 (map_units S y)
have := I.mul_mem_left b h
rwa [mul_comm, mul_assoc, hb, mul_one] at this
intros
classical
let sp : M ‚Üí submodule R M := Œª a, span R {a}
have supr_rw : ‚àÄ t : finset M, (‚®Ü x ‚àà t, sp x) = (‚®Ü x ‚àà (‚Üët : set M), sp x)
from Œª t, by refl
split
rintro ‚ü®t, rfl‚ü©
{ rintro ‚ü®t, rfl‚ü©, rw [span_eq_supr_of_singleton_spans, ‚Üêsupr_rw, ‚Üê(finset.sup_eq_supr t sp)], apply complete_lattice.finset_sup_compact_of_compact, exact Œª n _, singleton_span_is_compact_element n, }
rw [span_eq_supr_of_singleton_spans, ‚Üêsupr_rw, ‚Üê(finset.sup_eq_supr t sp)]
apply complete_lattice.finset_sup_compact_of_compact
exact Œª n _, singleton_span_is_compact_element n
intro h
{ intro h, have sSup : s = Sup (sp '' ‚Üës), by rw [Sup_eq_supr, supr_image, ‚Üêspan_eq_supr_of_singleton_spans, eq_comm, span_eq], obtain ‚ü®u, ‚ü®huspan, husup‚ü©‚ü© := h (sp '' ‚Üës) (le_of_eq sSup), have ssup : s = u.sup id, { suffices : u.sup id ‚â§ s, from le_antisymm husup this, rw [sSup, finset.sup_id_eq_Sup], exact Sup_le_Sup huspan, }, obtain ‚ü®t, ‚ü®hts, rfl‚ü©‚ü© := finset.subset_image_iff.mp huspan, rw [finset.sup_finset_image, function.comp.left_id, finset.sup_eq_supr, supr_rw, ‚Üêspan_eq_supr_of_singleton_spans, eq_comm] at ssup, exact ‚ü®t, ssup‚ü©, }
have sSup : s = Sup (sp '' ‚Üës)
rw [Sup_eq_supr, supr_image, ‚Üêspan_eq_supr_of_singleton_spans, eq_comm, span_eq]
rw [Sup_eq_supr, supr_image, ‚Üêspan_eq_supr_of_singleton_spans, eq_comm, span_eq]
obtain ‚ü®u, ‚ü®huspan, husup‚ü©‚ü© := h (sp '' ‚Üës) (le_of_eq sSup)
have ssup : s = u.sup id
suffices : u.sup id ‚â§ s
{ suffices : u.sup id ‚â§ s, from le_antisymm husup this, rw [sSup, finset.sup_id_eq_Sup], exact Sup_le_Sup huspan, }
from le_antisymm husup this
rw [sSup, finset.sup_id_eq_Sup]
exact Sup_le_Sup huspan
obtain ‚ü®t, ‚ü®hts, rfl‚ü©‚ü© := finset.subset_image_iff.mp huspan
rw [finset.sup_finset_image, function.comp.left_id, finset.sup_eq_supr, supr_rw, ‚Üêspan_eq_supr_of_singleton_spans, eq_comm] at ssup
exact ‚ü®t, ssup‚ü©
intros
{ rw [norm_apply, linear_map.det], split_ifs with h, refl }
rw [norm_apply, linear_map.det]
split_ifs with h
refl
intros
by_cases hf0 : f = 0
rw hf0
{ rw hf0, exact iff_of_true (valuation.map_zero _) rfl }
exact iff_of_true (valuation.map_zero _) rfl
obtain ‚ü®n, hn‚ü© : ‚àÉ n, coeff _ _ n f ‚â† 0 := not_forall.1 (Œª h, hf0 $ perfection.ext h)
show val_aux K v O hv p f = 0 ‚Üî f = 0
refine iff_of_false (Œª hvf, hn _) hf0
rw val_aux_eq hn at hvf
replace hvf := pow_eq_zero hvf
rwa mod_p.pre_val_eq_zero at hvf
intros
dsimp [bernstein_polynomial]
split_ifs
{ subst h, simp, }
subst h
simp
{ simp [zero_pow (nat.pos_of_ne_zero h)], }
simp [zero_pow (nat.pos_of_ne_zero h)]
intros
rw pochhammer
intros
by_cases hq : q = 0
rw [hq, degree_zero] at hpq
{ rw [hq, degree_zero] at hpq, have := not_lt_bot hpq, contradiction }
have := not_lt_bot hpq
contradiction
rwa [degree_eq_nat_degree hp, degree_eq_nat_degree hq, with_bot.coe_lt_coe] at hpq
intros
have := coe_monomial 0 a
rwa power_series.monomial_zero_eq_C_apply at this
intros
rw [‚Üê range_eq_top, ‚Üê range_eq_bot, or_comm]
apply eq_bot_or_eq_top
intros
have hx' : _root_.is_integral L x := is_integral_of_is_scalar_tower _ hx
rw [‚Üê is_integral_algebra_map_iff (algebra_map L (algebraic_closure F)).injective, trace_eq_sum_roots]
refine (is_integral.multiset_sum _).nsmul _
{ refine (is_integral.multiset_sum _).nsmul _, intros y hy, rw mem_roots_map (minpoly.ne_zero hx') at hy, use [minpoly R x, minpoly.monic hx], rw ‚Üê aeval_def at ‚ä¢ hy, exact minpoly.aeval_of_is_scalar_tower R x y hy }
intros y hy
rw mem_roots_map (minpoly.ne_zero hx') at hy
use [minpoly R x, minpoly.monic hx]
rw ‚Üê aeval_def at ‚ä¢ hy
exact minpoly.aeval_of_is_scalar_tower R x y hy
{ apply is_alg_closed.splits_codomain }
apply is_alg_closed.splits_codomain
{ apply_instance }
apply_instance
intros
rw [card, zmod.card]
intros
ext x n
simp only [coeff_frobenius_char_p, map_coeff, frobenius_def]
intros
simp only [witt_polynomial_eq_sum_C_mul_X_pow]
rw [sum_range_succ, ‚Üê nat.cast_pow, char_p.cast_eq_zero (zmod (p^(n+1))) (p^(n+1)), C_0, zero_mul, add_zero, alg_hom.map_sum, sum_congr rfl]
intros k hk
rw [alg_hom.map_mul, alg_hom.map_pow, expand_X, alg_hom_C, ‚Üê pow_mul, ‚Üê pow_succ]
congr
rw mem_range at hk
rw [add_comm, nat.add_sub_assoc (nat.lt_succ_iff.mp hk), ‚Üê add_comm]
intros
transitivity _
{ transitivity _, rw [‚Üêquotient.out_eq c, ‚Üêquotient.out_eq c'], refl }
rw [‚Üêquotient.out_eq c, ‚Üêquotient.out_eq c']
refl
intros
simpa using cof_le_card c.ord
simp
intros
simp only [log, dif_pos b1]
intros
cases h with _ _ _ _ eb _ h‚ÇÅ h‚ÇÇ h‚ÇÉ; exact h‚ÇÉ
cases h with _ _ _ _ eb _ h‚ÇÅ h‚ÇÇ h‚ÇÉ
exact h‚ÇÉ
intros
simp only [eq_self_iff_true, pow_half_move_left]
intros
simp [h.symm, termg]
simp [h.symm, termg]; ac_refl
ac_refl
intros
have h'' : y ‚â§ z
{ transitivity, apply le_of_lt h, assumption }
transitivity
apply le_of_lt h
assumption
apply @nat.lt_of_add_lt_add_right _ x
rw [nat.sub_add_cancel h']
apply @lt_of_le_of_lt _ _ _ (z - y + y)
rw [nat.sub_add_cancel h'']
apply nat.add_lt_add_left h
intros
rwa [‚Üê hb, ‚Üê sub_eq_add_neg] at h
intros
simp [h‚ÇÇ.symm, h‚ÇÅ.symm, horner, add_mul, mul_right_comm]
intros
rw nhds_infty_eq
exact (has_basis_coclosed_compact.map _).sup_pure _
intros
rw ‚Üê singletons_open_iff_discrete
intro g
suffices : {g} = (Œª (x : G), g‚Åª¬π * x) ‚Åª¬π' {1}
rw this
{ rw this, exact (continuous_mul_left (g‚Åª¬π)).is_open_preimage _ h, }
exact (continuous_mul_left (g‚Åª¬π)).is_open_preimage _ h
simp only [mul_one, set.preimage_mul_left_singleton, eq_self_iff_true, inv_inv, set.singleton_eq_singleton_iff]
intros
simpa only [div_eq_mul_inv] using is_closed_map_mul_right (a‚Åª¬π)
intros
refine ‚ü®Œª h, hf.add_compl h, Œª h, _‚ü©
rw [has_sum_subtype_iff_indicator] at hf ‚ä¢
rw [set.indicator_compl]
simpa only [add_sub_cancel'] using h.sub hf
intros
{ ext x, exact symm_apply_apply e x }
ext x
exact symm_apply_apply e x
intros
apply is_open_compl_iff.1
refine is_open_iff_forall_mem_open.2 (Œª x hx, ‚ü®(Œª y, y * x‚Åª¬π) ‚Åª¬π' U, _, _, _‚ü©)
{ intros u hux, simp only [set.mem_preimage, set.mem_compl_iff, mem_coe] at hux hx ‚ä¢, refine mt (Œª hu, _) hx, convert U.mul_mem (U.inv_mem hux) hu, simp }
intros u hux
simp only [set.mem_preimage, set.mem_compl_iff, mem_coe] at hux hx ‚ä¢
refine mt (Œª hu, _) hx
convert U.mul_mem (U.inv_mem hux) hu
simp
{ exact U.is_open.preimage (continuous_mul_right _) }
exact U.is_open.preimage (continuous_mul_right _)
{ simp [U.one_mem] }
simp [U.one_mem]
intros
simpa using nhds_basis_abs_sub_lt (0 : Œ±)
intros
rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, ‚Üê range_comp, supr]
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Ici _ _ _ _ (a‚Åª¬π)
intros
rw ‚Üê frontier_compl; convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]
rw ‚Üê frontier_compl; convert frontier_le_subset_eq hg hf
rw ‚Üê frontier_compl
convert frontier_le_subset_eq hg hf
simp [ext_iff, eq_comm]
simp [ext_iff, eq_comm]
intros
let m := (add_monoid_hom.mul : Œ± ‚Üí+ Œ± ‚Üí+ Œ±).compr‚ÇÇ to_compl
have : continuous (Œª p : Œ± √ó Œ±, m p.1 p.2)
from (continuous_coe Œ±).comp continuous_mul
have di : dense_inducing (to_compl : Œ± ‚Üí completion Œ±)
from dense_inducing_coe
convert di.extend_Z_bilin di this
ext ‚ü®x, y‚ü©
refl
intros
rw [rtendsto'_def]
{ rw [rtendsto'_def], apply all_mem_nhds_filter, apply rel.preimage_mono }
apply all_mem_nhds_filter
apply rel.preimage_mono
intros
split
introsI hf x‚ÇÅ x‚ÇÇ h
{ introsI hf x‚ÇÅ x‚ÇÇ h, let g‚ÇÅ : of punit ‚ü∂ X := ‚ü®Œª _, x‚ÇÅ, continuous_of_discrete_topology‚ü©, let g‚ÇÇ : of punit ‚ü∂ X := ‚ü®Œª _, x‚ÇÇ, continuous_of_discrete_topology‚ü©, have : g‚ÇÅ ‚â´ f = g‚ÇÇ ‚â´ f, by { ext, exact h }, rw cancel_mono at this, apply_fun (Œª e, e punit.star) at this, exact this }
let g‚ÇÅ : of punit ‚ü∂ X := ‚ü®Œª _, x‚ÇÅ, continuous_of_discrete_topology‚ü©
let g‚ÇÇ : of punit ‚ü∂ X := ‚ü®Œª _, x‚ÇÇ, continuous_of_discrete_topology‚ü©
have : g‚ÇÅ ‚â´ f = g‚ÇÇ ‚â´ f
ext
ext
{ ext, exact h }
{ ext, exact h }
exact h
exact h
rw cancel_mono at this
apply_fun (Œª e, e punit.star) at this
exact this
rw ‚Üê category_theory.mono_iff_injective
{ rw ‚Üê category_theory.mono_iff_injective, apply faithful_reflects_mono (forget CompHaus) }
apply faithful_reflects_mono (forget CompHaus)
intros
simp
intros
intros s hs
rw is_open_sigma_iff
intro j
classical
by_cases h : i = j
subst j
{ subst j, convert hs, exact set.preimage_image_eq _ sigma_mk_injective }
convert hs
exact set.preimage_image_eq _ sigma_mk_injective
convert is_open_empty
{ convert is_open_empty, apply set.eq_empty_of_subset_empty, rintro x ‚ü®y, _, hy‚ü©, have : i = j, by cc, contradiction }
apply set.eq_empty_of_subset_empty
rintro x ‚ü®y, _, hy‚ü©
have : i = j
cc
cc
contradiction
intros
unfold continuous_within_at at *
rw [nhds_within_prod_eq, prod.map, nhds_prod_eq]
exact hf.prod_map hg
intros
rcases mem_nhds_within_iff_exists_mem_nhds_inter.mp h2 with ‚ü®_, Hw, hw‚ü©
exact (nhds a).sets_of_superset ((nhds a).inter_sets Hw h1) hw
intros
rcases a
{ rcases a, refl }
refl
intros
rw [coord_change, e.apply_symm_apply' h]
intros
rw [h.embedding.closure_eq_preimage_closure_image, h.image_preimage]
intros
simp only [nhds_top', tendsto_infi, tendsto_principal, mem_Ioi]
intros
rw [mul_comm, mul_supr]; congr; funext; rw [mul_comm]
rw [mul_comm, mul_supr]; congr; funext
rw [mul_comm, mul_supr]; congr
rw [mul_comm, mul_supr]
congr
funext
rw [mul_comm]
intros
refine nnreal.summable_of_le (Œª a, le_trans (le_of_eq (s.indicator_apply f a)) _) hf
split_ifs
exact le_refl (f a)
exact zero_le_coe
intros
rcases p with ‚ü®x, y‚ü©
induction x using ereal.rec; induction y using ereal.rec
induction x using ereal.rec
induction y using ereal.rec
{ exact continuous_at_add_bot_bot }
exact continuous_at_add_bot_bot
{ exact continuous_at_add_bot_coe _ }
exact continuous_at_add_bot_coe _
{ simpa using h' }
simpa using h'
induction y using ereal.rec
{ exact continuous_at_add_coe_bot _ }
exact continuous_at_add_coe_bot _
{ exact continuous_at_add_coe_coe _ _ }
exact continuous_at_add_coe_coe _ _
{ exact continuous_at_add_coe_top _ }
exact continuous_at_add_coe_top _
induction y using ereal.rec
{ simpa using h }
simpa using h
{ exact continuous_at_add_top_coe _ }
exact continuous_at_add_top_coe _
{ exact continuous_at_add_top_top }
exact continuous_at_add_top_top
intros
haveI : nonempty Œ± := ‚ü®x‚ü©
convert (((hf.to_local_homeomorph f).continuous_at_iff_continuous_at_comp_right) _).symm
apply (local_homeomorph.left_inv _ _).symm
{ apply (local_homeomorph.left_inv _ _).symm, simp, }
simp
{ simp, }
simp
intros
ext s
{ ext s, simp [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff, subset_def, real.dist_0_eq_abs] }
simp [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff, subset_def, real.dist_0_eq_abs]
intros
rcases eq_empty_or_nonempty s with rfl|hne
unfreezingI { rcases eq_empty_or_nonempty s with rfl|hne }
exact ‚ü®r / 2, ‚ü®half_pos hr, half_lt_self hr‚ü©, empty_subset _‚ü©
{ exact ‚ü®r / 2, ‚ü®half_pos hr, half_lt_self hr‚ü©, empty_subset _‚ü© }
have : is_compact s
from compact_of_is_closed_subset (proper_space.is_compact_closed_ball x r) hs (subset.trans h ball_subset_closed_ball)
obtain ‚ü®y, hys, hy‚ü© : ‚àÉ y ‚àà s, s ‚äÜ closed_ball x (dist y x)
from this.exists_forall_ge hne (continuous_id.dist continuous_const).continuous_on
have hyr : dist y x < r
from h hys
rcases exists_between hyr with ‚ü®r', hyr', hrr'‚ü©
exact ‚ü®r', ‚ü®dist_nonneg.trans_lt hyr', hrr'‚ü©, subset.trans hy $ closed_ball_subset_ball hyr'‚ü©
intros
simp only [‚Üê nnreal.eq_iff, ‚Üê dist_nndist, imp_self, nnreal.coe_zero, dist_eq_zero]
intros
apply emetric.complete_of_convergent_controlled_sequences (Œªn, ennreal.of_real (B n))
{ simp [hB] }
simp [hB]
assume u Hu
{ assume u Hu, apply H, assume N n m hn hm, rw [‚Üê ennreal.of_real_lt_of_real_iff (hB N), ‚Üê edist_dist], exact Hu N n m hn hm }
apply H
assume N n m hn hm
rw [‚Üê ennreal.of_real_lt_of_real_iff (hB N), ‚Üê edist_dist]
exact Hu N n m hn hm
intros
rcases h with ‚ü®y, hy‚ü©
apply lt_top_iff_ne_top.1
calc inf_edist x s ‚â§ edist x y : inf_edist_le_edist_of_mem hy ... < ‚ä§ : lt_top_iff_ne_top.2 (edist_ne_top _ _)
intros
ext
{ ext, refl }
refl
intros
rcases precise_refinement (Œª i, option.elim i s·∂ú u) (option.forall.2 ‚ü®is_open_compl_iff.2 hs, uo‚ü©) _ with ‚ü®v, vo, vc, vf, vu‚ü©
refine ‚ü®v ‚àò some, Œª i, vo _, _, vf.comp_injective (option.some_injective _), Œª i, vu _‚ü©
simp only [Union_option, ‚Üê compl_subset_iff_union] at vc
{ simp only [Union_option, ‚Üê compl_subset_iff_union] at vc, exact subset.trans (subset_compl_comm.1 $ vu option.none) vc }
exact subset.trans (subset_compl_comm.1 $ vu option.none) vc
simpa only [Union_option, option.elim, ‚Üê compl_subset_iff_union, compl_compl]
{ simpa only [Union_option, option.elim, ‚Üê compl_subset_iff_union, compl_compl] }
intros
convert Œ≥.truncate_self 0; exact Œ≥.extend_zero.symm
convert Œ≥.truncate_self 0
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
exact Œ≥.extend_zero.symm
intros
assume y hy
by_cases h : ‚àÉ l, l < f x
obtain ‚ü®z, zlt, hz‚ü© : ‚àÉ z < f x, Ioc z (f x) ‚äÜ g ‚Åª¬π' (Ioi y) := exists_Ioc_subset_of_mem_nhds (hg (Ioi_mem_nhds hy)) h
{ obtain ‚ü®z, zlt, hz‚ü© : ‚àÉ z < f x, Ioc z (f x) ‚äÜ g ‚Åª¬π' (Ioi y) := exists_Ioc_subset_of_mem_nhds (hg (Ioi_mem_nhds hy)) h, filter_upwards [hf z zlt], assume a ha, calc y < g (min (f x) (f a)) : hz (by simp [zlt, ha, le_refl]) ... ‚â§ g (f a) : gmon (min_le_right _ _) }
filter_upwards [hf z zlt]
assume a ha
calc y < g (min (f x) (f a)) : hz (by simp [zlt, ha, le_refl]) ... ‚â§ g (f a) : gmon (min_le_right _ _)
simp only [not_exists, not_lt] at h
{ simp only [not_exists, not_lt] at h, exact filter.eventually_of_forall (Œª a, hy.trans_le (gmon (h (f a)))) }
exact filter.eventually_of_forall (Œª a, hy.trans_le (gmon (h (f a))))
intros
rcases exists_compact_mem_nhds x with ‚ü®K, hKc, hxK‚ü©
rcases mem_nhds_iff.1 hxK with ‚ü®t, h1t, h2t, h3t‚ü©
exact ‚ü®t, h2t, h3t, compact_closure_of_subset_compact hKc h1t‚ü©
intros
simp only [‚Üê ne_empty_iff_nonempty] at hsZ ‚ä¢
apply mt (hs.elim_finite_subfamily_closed Z hZc)
push_neg
exact hsZ
intros
rw [(@map_nhds_subtype_coe_eq Œ± _ s a (mem_of_mem_nhds ha) ha).symm]
rw [(@map_nhds_subtype_coe_eq Œ± _ s a (mem_of_mem_nhds ha) ha).symm]; exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)
exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)
intros
rw [map_swap_eq_comap_swap]; from map_le_iff_le_comap.1 tendsto_swap_uniformity
rw [map_swap_eq_comap_swap]
from map_le_iff_le_comap.1 tendsto_swap_uniformity
intros
rw uniform_continuous_iff
exact infi_le (Œª j, uniform_space.comap (Œª (a : Œ† (i : Œπ), Œ± i), a j) (U j)) i
intros
assume u hu
apply (h u hu).mono (Œª n hn, _)
exact Œª x, hn _
