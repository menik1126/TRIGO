intros
unfold even
rw corec_eq
refl
intros
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw [‚Üê nat.zero_add (m*n), add_mul_mod_self_left, zero_mod]
intros
cases n
simp
simp
intros
rw [‚Üê vsub_vadd_eq_vsub_sub, vsub_vadd_comm, vsub_vadd_eq_vsub_sub]
intros
rw [‚Üê mul_assoc, ‚Üê commutes, mul_assoc]
intros
simp [bit1, add_smul]
intros
induction n
simp [*, pow_succ, associates.mk_mul_mk.symm]
simp [*, pow_succ, associates.mk_mul_mk.symm]
intros
rw [mul_comm, mul_prod_erase s f h]
intros
haveI := classical.dec_eq Œ±
by_cases h‚ÇÅ : a ‚àà s
by_cases h‚ÇÇ : b ‚àà s
exact prod_eq_mul_of_mem a b h‚ÇÅ h‚ÇÇ hn h‚ÇÄ
rw [hb h‚ÇÇ, mul_one]
apply prod_eq_single_of_mem a h‚ÇÅ
exact Œª c hc hca, h‚ÇÄ c hc ‚ü®hca, ne_of_mem_of_not_mem hc h‚ÇÇ‚ü©
by_cases h‚ÇÇ : b ‚àà s
rw [ha h‚ÇÅ, one_mul]
apply prod_eq_single_of_mem b h‚ÇÇ
exact Œª c hc hcb, h‚ÇÄ c hc ‚ü®ne_of_mem_of_not_mem hc h‚ÇÅ, hcb‚ü©
rw [ha h‚ÇÅ, hb h‚ÇÇ, mul_one]
exact trans (prod_congr rfl (Œª c hc, h‚ÇÄ c hc ‚ü®ne_of_mem_of_not_mem hc h‚ÇÅ, ne_of_mem_of_not_mem hc h‚ÇÇ‚ü©)) prod_const_one
intros
split_ifs with h
rw [finset.prod_eq_single a, dif_pos rfl]
intros
rw dif_neg
cc
cc
rw finset.prod_eq_one
intros
rw dif_neg
intro
cc
intros
rw [univ_filter_zero_lt, sum_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
rcases eq_or_ne x 0 with rfl|hx
simp
exact ((smul_add_hom R M).flip x).map_finsum_of_injective (smul_left_injective R hx) _
intros
lift s to finset Œ± using hs
lift t to finset Œ± using ht
classical
rw [‚Üê finset.coe_union, ‚Üê finset.coe_inter]
simp only [finprod_mem_coe_finset, finset.prod_union_inter]
intros
rw [‚Üê prod_antidiagonal_swap, prod_antidiagonal_succ, ‚Üê prod_antidiagonal_swap]
refl
intros
refine (multiset.prod_le_of_forall_le (s.val.map f) n _).trans _
simpa using h
simpa
intros
simp only [lt_top_iff_ne_top, ne.def, sum_eq_top_iff, not_exists]
intros
convert colimit.iso_colimit_cocone_Œπ_hom _ _
refl
refl
refl
refl
refl
intros
rw [commute.add_pow h, finset.sum_range_succ_comm, nat.sub_self, pow_zero, nat.choose_self]
rw [nat.cast_one, mul_one, mul_one]
congr' 1
convert finset.sum_eq_single 0 _ _
simp only [mul_one, one_mul, nat.choose_zero_right, nat.sub_zero, nat.cast_one, pow_zero]
intros b h1 h2
suffices : (p.choose b : R) = 0
rw this
simp
rw char_p.cast_eq_zero_iff R p
refine nat.prime.dvd_choose_self (pos_iff_ne_zero.mpr h2) _ (fact.out _)
rwa ‚Üê finset.mem_range
intro h1
contrapose! h1
rw finset.mem_range
exact nat.prime.pos (fact.out _)
intros
rcases hu with ‚ü®u, rfl‚ü©
apply units.dvd_mul_right
intros
simp only [geom_sum_Ico hx hmn]
convert neg_div_neg_eq (x^m - x^n) (1-x)
abel
abel
intros
rw [sub_eq_iff_eq_add, sub_add_eq_add_sub, sub_eq_iff_eq_add', add_sub_assoc]
intros
by_cases h : P
simp [h]
simp [h]
intros
let iM : div_inv_monoid M := m‚ÇÅ
cases m‚ÇÅ with mul‚ÇÅ _ one‚ÇÅ one_mul‚ÇÅ mul_one‚ÇÅ npow‚ÇÅ npow_zero‚ÇÅ npow_succ‚ÇÅ inv‚ÇÅ div‚ÇÅ div_eq_mul_inv‚ÇÅ gpow‚ÇÅ gpow_zero'‚ÇÅ gpow_succ'‚ÇÅ gpow_neg'‚ÇÅ
cases m‚ÇÇ with mul‚ÇÇ _ one‚ÇÇ one_mul‚ÇÇ mul_one‚ÇÇ npow‚ÇÇ npow_zero‚ÇÇ npow_succ‚ÇÇ inv‚ÇÇ div‚ÇÇ div_eq_mul_inv‚ÇÇ gpow‚ÇÇ gpow_zero'‚ÇÇ gpow_succ'‚ÇÇ gpow_neg'‚ÇÇ
change mul‚ÇÅ = mul‚ÇÇ at h_mul
subst h_mul
have h_one : one‚ÇÅ = one‚ÇÇ
rw ‚Üêone_mul‚ÇÇ one‚ÇÅ
exact mul_one‚ÇÅ one‚ÇÇ
subst h_one
have h_npow : npow‚ÇÅ = npow‚ÇÇ
ext n
induction n with d hd
rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ]
rw [npow_succ‚ÇÅ, npow_succ‚ÇÇ, hd]
subst h_npow
change inv‚ÇÅ = inv‚ÇÇ at h_inv
subst h_inv
have h_div : div‚ÇÅ = div‚ÇÇ
ext a b
convert (rfl : a * b‚Åª¬π = a * b‚Åª¬π)
exact div_eq_mul_inv‚ÇÅ a b
exact div_eq_mul_inv‚ÇÇ a b
subst h_div
have h_gpow_aux : ‚àÄ n g, gpow‚ÇÅ (int.of_nat n) g = gpow‚ÇÇ (int.of_nat n) g
intros n g
induction n with n IH
convert (rfl : (1 : M) = 1)
exact gpow_zero'‚ÇÅ g
exact gpow_zero'‚ÇÇ g
rw [gpow_succ'‚ÇÅ, gpow_succ'‚ÇÇ, IH]
have h_gpow : gpow‚ÇÅ = gpow‚ÇÇ
ext z
cases z with z z
exact h_gpow_aux z x
rw [gpow_neg'‚ÇÅ, gpow_neg'‚ÇÇ]
congr'
exact h_gpow_aux _ _
subst h_gpow
intros
cases f
cases g
cases h
refl
intros
ext
simp only [one_hom.map_one, one_hom.coe_comp, function.comp_app, one_hom.one_apply]
intros
ext
simp only [map_one, coe_comp, function.comp_app, one_apply]
intros
rw [‚Üê mul_one (m : R)]
exact (one_left a).cast_int_mul_left m
intros
rw [div_eq_mul_inv, mul_assoc, mul_comm b, ‚Üê mul_assoc, div_eq_mul_inv]
intros
rw [‚Üê mul_div_assoc, mul_comm, mul_div_assoc]
intros
simp [single_map_homological_complex, h]
intros
rcases h : c.next i with _ | ‚ü®j,w‚ü©
ext
refl
dsimp
simp only [next, h]
symmetry
apply zero_of_target_iso_zero
exact X_next_iso_zero _ h
ext
refl
dsimp
simp [next, h]
intros
change ite (1 = 0 + 1) (ùüô X‚ÇÅ ‚â´ d‚ÇÄ) 0 = d‚ÇÄ
rw [if_pos rfl, category.id_comp]
intros
dsimp [prev_d]
rcases c.prev j with _|‚ü®j',w‚ü©
exact zero_comp.symm
dsimp [prev_d]
simp
intros
ext
simp
intros
ext
simp
intros
funext
simp only [indicator]
split_ifs
refl
rw mul_zero
intros
rw mul_indicator_eq_self at h1 ‚ä¢
exact subset.trans h1 h2
intros
erw mem_skew_adjoint_matrices_submodule
simp only [matrix.is_skew_adjoint, matrix.is_adjoint_pair, matrix.mul_one, matrix.one_mul]
intros
rw map_le_iff_le_comap
erw lie_submodule.lie_span_le
intros x hx
obtain ‚ü®‚ü®y‚ÇÅ, hy‚ÇÅ‚ü©, ‚ü®y‚ÇÇ, hy‚ÇÇ‚ü©, hx‚ü© := hx
rw ‚Üê hx
let fy‚ÇÅ : ‚Ü•(map f I‚ÇÅ) := ‚ü®f y‚ÇÅ, mem_map hy‚ÇÅ‚ü©
let fy‚ÇÇ : ‚Ü•(map f I‚ÇÇ) := ‚ü®f y‚ÇÇ, mem_map hy‚ÇÇ‚ü©
change _ ‚àà comap f ‚ÅÖmap f I‚ÇÅ, map f I‚ÇÇ‚ÅÜ
simp only [submodule.coe_mk, mem_comap, lie_hom.map_lie]
exact lie_submodule.lie_coe_mem_lie _ _ fy‚ÇÅ fy‚ÇÇ
intros
rw [is_lie_abelian_iff_center_eq_top R L, center_eq_bot_of_semisimple] at h
exact (lie_submodule.subsingleton_iff R L L).mp (subsingleton_of_bot_eq_top h)
intros
rw [‚Üê coe_to_submodule, Inf_coe_to_submodule, submodule.Inf_coe]
ext x
simpa only [mem_Inter, mem_set_of_eq, forall_apply_eq_imp_iff‚ÇÇ, exists_imp_distrib]
intros
split
intros h x hx
specialize h hx
rw mem_ker at h
exact h
intros h x hx
rw mem_ker
apply h x hx
intros
simp only [coe_lift_lie_eq_lift_coe, lie_module_hom.coe_to_linear_map, lift_apply]
intros
rw [‚Üêfunction.comp_apply (lift R f) (Œπ R) x, Œπ_comp_lift]
intros
have h‚ÇÄ : (0 : L ‚Üí R) ‚àò (‚ä§ : lie_subalgebra R L).incl = 0
ext
refl
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule, ‚Üê h‚ÇÄ, coe_weight_space_of_top, ‚Üê infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M]
refl
intros
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_of_pos h (neg_pos_of_neg hc)
intros
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_iff_of_pos (neg_pos_of_neg hc)
intros
rintros x ‚ü®y, h, rfl‚ü© i hi
exact smul_mem_smul_set (h i hi)
intros
rw [infi, Inf_coe]
ext a
simp
intros
by_cases ha : a = 0
simp [ha]
refine (mul_self_eq_mul_self_iff.mp (by rw [‚Üê abv.map_mul, neg_mul_neg, abv.map_mul])).resolve_right _
exact ((neg_lt_zero.mpr (abv.pos ha)).trans (abv.pos (neg_ne_zero.mpr ha))).ne'
intros
rw [‚Üê neg_sub, abv_neg abv]
intros
cases o
exacts [iff.rfl, eq_comm, iff.rfl]
intros
rw [mul_comm, le_div_iff hc]
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 hc)
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
simp [hb, hb.not_lt, hb.ne, div_lt_one_of_neg]
simp [zero_lt_one]
simp [hb, hb.not_lt, div_lt_one, hb.ne.symm]
intros
simpa using inv_le_inv_of_le ha h
intros
refine ‚ü®eq_or_eq_neg_of_abs_eq, _‚ü©
rintro (rfl|rfl)
simp only [abs_neg, abs_of_nonneg hb]
simp only [abs_neg, abs_of_nonneg hb]
intros
rw [‚Üê mul_lt_mul_iff_right a, inv_mul_self, one_mul]
intros
rw [div_le_iff_le_mul, mul_comm]
intros
exact rfl
intros
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg, Œª h, h.elim (and_imp.2 decidable.mul_nonneg) (and_imp.2 decidable.mul_nonneg_of_nonpos_of_nonpos)‚ü©
intros
cases abs_choice b with h h
simp only [h, dvd_neg]
simp only [h, dvd_neg]
intros
haveI := @linear_order.decidable_le Œ± _
exact lt_of_not_ge (assume h1 : b ‚â§ a, have h2 : c * b ‚â§ c * a, from decidable.mul_le_mul_of_nonneg_left h1 hc, h2.not_lt h)
intros
haveI := @linear_order.decidable_le Œ± _
exact lt_of_not_ge (assume h1 : b ‚â§ a, have h2 : b * c ‚â§ a * c, from decidable.mul_le_mul_of_nonneg_right h1 hc, h2.not_lt h)
intros
simpa using leading_coeff_multiset_prod' (s.1.map f) (by simpa using h)
intros
split
apply (act x).symm.injective
rintro rfl
refl
intros
ext
simp
ring_exp
simp
ring_exp
simp
ring_exp
simp
ring_exp
intros
simpa only [le_antisymm_iff, norm_sq_nonneg, and_true] using @norm_sq_eq_zero _ _ a
intros
simp only [semiconj_by, left_distrib, right_distrib, ha.eq, hb.eq]
intros
by_cases h : P
simp [h]
simp [h]
intros
simpa only [sub_eq_add_neg, neg_mul_eq_neg_mul] using add_mul a (-b) c
intros
rw [mul_add, mul_one, mul_self, add_self]
intros
classical
rw support_single
split_ifs
simp
intros
cases le_total x y with h h
rw [add_eq_left h, add_eq_left (pow_le_pow_of_le_left' h _)]
rw [add_eq_right h, add_eq_right (pow_le_pow_of_le_left' h _)]
intros
rw [‚Üê restrict_stalk_iso_hom_eq_germ, category.assoc, iso.hom_inv_id, category.comp_id]
intros
rw right_inv
intros
cases n
exact false.elim (zero_lt_two.not_le hn)
cases n
exact false.elim (one_lt_two.not_le hn)
simp only [right_inv, neg_inj]
congr' 1
ext v
have N : 0 < n + 2
dec_trivial
have : (p 1) (Œª (i : fin 1), 0) = 0 := continuous_multilinear_map.map_zero _
simp [comp_right_inv_aux1 N, lt_irrefl n, this, comp_right_inv_aux2]
intros
rcases (em $ c = 0) with ‚ü®rfl, h‚ü©
exact (tendsto_congr' $ is_equivalent_zero_iff_eventually_zero.mp hu).mpr tendsto_const_nhds
exact (is_equivalent_const_iff_tendsto h).mp hu
intros
have cne0 : ‚à•c‚à• ‚â† 0
from mt norm_eq_zero.mp hc
rw [‚Üêis_O_norm_left]
simp only [norm_smul]
rw [is_O_const_mul_left_iff cne0, is_O_norm_left]
intros
simp only [is_o, is_O_with_pi, le_of_lt] { contextual := tt }
exact ‚ü®Œª h i c hc, h hc i, Œª h c hc i, h i hc‚ü©
intros
unfold is_O_with
subst c‚ÇÇ
apply filter.eventually_congr
filter_upwards [hf, hg]
assume x e‚ÇÅ e‚ÇÇ
rw [e‚ÇÅ, e‚ÇÇ]
intros
unfold is_o
exact forall_congr (Œª _, (forall_congr (Œª _, is_O_with_neg_left)))
intros
have := hf.iterate hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
convert hc.mul ((has_strict_deriv_at_inv hx).comp x hd)
simp only [div_eq_mul_inv]
field_simp
ring
intros
rw [‚Üê Iic_diff_right, has_deriv_within_at_diff_singleton]
intros
rwa hL.has_deriv_at_filter_iff hx rfl
intros
have := hc.smul (has_deriv_within_at_const x s f)
rwa [smul_zero, zero_add] at this
intros
rw [‚Üê fderiv_within_univ, ‚Üê fderiv_within_univ]
exact iso.comp_fderiv_within unique_diff_within_at_univ
intros
rw [has_fderiv_at, has_fderiv_at_filter, is_o_iff]
exact (Œª c hc, tendsto_id.prod_mk_nhds tendsto_const_nhds (is_o_iff.1 hf hc))
intros
rcases metric.mem_nhds_iff.1 hf with ‚ü®Œµ, Œµpos, hŒµ‚ü©
have A : (interior (metric.ball x Œµ)).nonempty
rwa [metric.is_open_ball.interior_eq, metric.nonempty_ball]
exact convex.second_derivative_within_at_symmetric (convex_ball x Œµ) A (Œª y hy, hŒµ (interior_subset hy)) (metric.mem_ball_self Œµpos) hx.has_fderiv_within_at v w
intros
simp [hf.implicit_to_local_homeomorph_of_complemented_apply]
intros
refine lhopital_zero_right_on_Ioo hab hff' hgg' hg' _ _ hdiv
rw [‚Üê hfa, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab]
exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
rw [‚Üê hga, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab]
exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
intros
have hIccIoo := @Ioo_subset_Icc_self ‚Ñù _ 0 1
set g : ‚Ñù ‚Üí E := Œª t, x + t ‚Ä¢ (y - x)
have hseg : ‚àÄ t ‚àà Icc (0:‚Ñù) 1, g t ‚àà segment ‚Ñù x y
rw segment_eq_image'
simp only [mem_image, and_imp, add_right_inj]
intros t ht
exact ‚ü®t, ht, rfl‚ü©
have hseg' : Icc 0 1 ‚äÜ g ‚Åª¬π' s
rw ‚Üê image_subset_iff
unfold image
change ‚àÄ _, _
intros z Hz
rw mem_set_of_eq at Hz
rcases Hz with ‚ü®t, Ht, hgt‚ü©
rw ‚Üê hgt
exact hs.segment_subset xs ys (hseg t Ht)
have hfg: ‚àÄ t ‚àà Icc (0:‚Ñù) 1, has_deriv_within_at (f ‚àò g) ((f' (g t) : E ‚Üí ‚Ñù) (y-x)) (Icc (0:‚Ñù) 1) t
intros t Ht
have hg : has_deriv_at g (y-x) t
have := ((has_deriv_at_id t).smul_const (y - x)).const_add x
rwa one_smul at this
exact (hf (g t) $ hseg' Ht).comp_has_deriv_within_at _ hg.has_deriv_within_at hseg'
have hMVT : ‚àÉ (t ‚àà Ioo (0:‚Ñù) 1), ((f' (g t) : E ‚Üí ‚Ñù) (y-x)) = (f (g 1) - f (g 0)) / (1 - 0)
refine exists_has_deriv_at_eq_slope (f ‚àò g) _ (by norm_num) _ _
unfold continuous_on
exact Œª t Ht, (hfg t Ht).continuous_within_at
refine Œª t Ht, (hfg t $ hIccIoo Ht).has_deriv_at _
refine _root_.mem_nhds_iff.mpr _
use (Ioo (0:‚Ñù) 1)
refine ‚ü®hIccIoo, _, Ht‚ü©
simp [real.Ioo_eq_ball, is_open_ball]
rcases hMVT with ‚ü®t, Ht, hMVT'‚ü©
use g t
refine ‚ü®hseg t $ hIccIoo Ht, _‚ü©
simp [g, hMVT']
intros
let h := Œª x, (g b - g a) * f x - (f b - f a) * g x
have hI : h a = h b
simp only [h]
ring
let h' := Œª x, (g b - g a) * f' x - (f b - f a) * g' x
have hhh' : ‚àÄ x ‚àà Ioo a b, has_deriv_at h (h' x) x
from Œª x hx, ((hff' x hx).const_mul (g b - g a)).sub ((hgg' x hx).const_mul (f b - f a))
have hhc : continuous_on h (Icc a b)
from (continuous_on_const.mul hfc).sub (continuous_on_const.mul hgc)
rcases exists_has_deriv_at_eq_zero h h' hab hhc hI hhh' with ‚ü®c, cmem, hc‚ü©
exact ‚ü®c, cmem, sub_eq_zero.1 hc‚ü©
intros
simpa only [zero_mul, sub_nonpos] using hD.image_sub_le_mul_sub_of_deriv_le hf hf' hf'_nonpos
intros
simp [times_cont_diff_on, e.comp_times_cont_diff_within_at_iff]
intros
rw times_cont_diff_iff_times_cont_diff_at
exact Œª x, hf.times_cont_diff_at.inv (h x)
intros
have A : times_cont_diff_at ‚Ñù n (coe : ‚Ñù ‚Üí ‚ÑÇ) z
from of_real_clm.times_cont_diff.times_cont_diff_at
have B : times_cont_diff_at ‚Ñù n e z := h.restrict_scalars ‚Ñù
have C : times_cont_diff_at ‚Ñù n re (e z)
from re_clm.times_cont_diff.times_cont_diff_at
exact C.comp z (B.comp z A)
intros
intros x y xs ys a b ha hb hab
rw [mem_preimage, convex.combo_affine_apply hab]
exact hs xs ys ha hb hab
intros
use subset.trans (inter_subset_left _ _) hAB.1
rintro x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x ‚ü®hxB, hxC‚ü© hx
obtain ‚ü®hx‚ÇÅB, hx‚ÇÇB‚ü© := hAB.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxB hx
obtain ‚ü®hx‚ÇÅC, hx‚ÇÇC‚ü© := hAC.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxC hx
exact ‚ü®‚ü®hx‚ÇÅB, hx‚ÇÅC‚ü©, hx‚ÇÇB, hx‚ÇÇC‚ü©
intros
rintro ‚ü®x, r‚ü© ‚ü®y, t‚ü© ‚ü®hx, hr‚ü© ‚ü®hy, ht‚ü© a b ha hb hab
refine ‚ü®hf.1 hx hy ha hb hab, _‚ü©
calc f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y : hf.2 hx hy ha hb hab ... ‚â§ a ‚Ä¢ r + b ‚Ä¢ t : add_le_add (smul_le_smul_of_nonneg hr ha) (smul_le_smul_of_nonneg ht hb)
intros
rw [‚Üê @of_real_inj ùïú, im_eq_conj_sub]
simp [inner_conj_sym]
intros
convert sum_inner l.support (Œª a, l a ‚Ä¢ v a) x
simp [inner_smul_left, finsupp.sum]
intros
convert complex.basis_one_I.equiv_fun_symm_apply x
simpa
simp
intros
exact_mod_cast real.pow_arith_mean_le_arith_mean_pow s _ _ (Œª i _, (w i).coe_nonneg) (by exact_mod_cast hw') (Œª i _, (z i).coe_nonneg) n
intros
have h := rpow_arith_mean_le_arith_mean_rpow (univ : finset (fin 2)) (fin.cons w‚ÇÅ $ fin.cons w‚ÇÇ fin_zero_elim) (fin.cons z‚ÇÅ $ fin.cons z‚ÇÇ $ fin_zero_elim) _ hp
simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h
simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero]
intros
rcases eq_or_lt_of_le hp with rfl|hp
simp [finset.sum_add_distrib]
have hpq := real.is_conjugate_exponent_conjugate_exponent hp
have := is_greatest_Lp s (f + g) hpq
simp only [pi.add_apply, add_mul, sum_add_distrib] at this
rcases this.1 with ‚ü®œÜ, hœÜ, H‚ü©
rw ‚Üê H
exact add_le_add ((is_greatest_Lp s f hpq).2 ‚ü®œÜ, hœÜ, rfl‚ü©) ((is_greatest_Lp s g hpq).2 ‚ü®œÜ, hœÜ, rfl‚ü©)
intros
simp only [edist_nndist]
apply_mod_cast nndist_vadd_vadd_le
intros
ext
refl
intros
rw [‚Üê (point_reflection ùïú x).dist_map y x, point_reflection_self]
intros
rw [frontier, closure_closed_ball, interior_closed_ball' x r, closed_ball_diff_ball]
intros
refine isometry_emetric_iff_metric.2 (Œªx y, _)
rw [dist_eq_norm, dist_eq_norm, ‚Üê ring_hom.map_sub, norm_algebra_map_eq]
intros
simpa using (norm_algebra_map_eq ùïú' (1:ùïú))
intros
simpa using continuous_linear_map.le_of_op_norm_le _ (inclusion_in_double_dual_norm_le ùïú E) x
intros
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun ùïú _ (finrank ùïú E)).symm
have : uniform_embedding e.to_linear_equiv.to_equiv.symm := e.symm.uniform_embedding
exact (complete_space_congr this).1 (by apply_instance)
intros
rw ‚Üê coe_to_isometric
exact isometric.range_eq_univ _
intros
split
assume h
ext m
simpa [h] using f.le_op_norm m
rintro rfl
apply le_antisymm (op_norm_le_bound 0 le_rfl (Œªm, _)) (op_norm_nonneg _)
simp
intros
dsimp [has_sum] at h ‚ä¢
convert ((continuous_eval_left m).tendsto _).comp h
ext s
simp
intros
have Rpos : 0 < R := (norm_nonneg _).trans_lt hR
have : ‚à•c‚à• / R < 1
rw div_lt_iff Rpos
simpa using hR
rcases riesz_lemma hFc hF this with ‚ü®x, xF, hx‚ü©
have x0 : x ‚â† 0 := Œª H, by simpa [H] using xF
obtain ‚ü®d, d0, dxlt, ledx, -‚ü© : ‚àÉ (d : ùïú), d ‚â† 0 ‚àß ‚à•d ‚Ä¢ x‚à• < R ‚àß R / ‚à•c‚à• ‚â§ ‚à•d ‚Ä¢ x‚à• ‚àß ‚à•d‚à•‚Åª¬π ‚â§ R‚Åª¬π * ‚à•c‚à• * ‚à•x‚à• := rescale_to_shell hc Rpos x0
refine ‚ü®d ‚Ä¢ x, dxlt.le, Œª y hy, _‚ü©
set y' := d‚Åª¬π ‚Ä¢ y with hy'
have y'F : y' ‚àà F
simp [hy', submodule.smul_mem _ _ hy]
have yy' : y = d ‚Ä¢ y'
simp [hy', smul_smul, mul_inv_cancel d0]
calc 1 = (‚à•c‚à•/R) * (R/‚à•c‚à•) : by field_simp [Rpos.ne', (zero_lt_one.trans hc).ne'] ... ‚â§ (‚à•c‚à•/R) * (‚à•d ‚Ä¢ x‚à•) : mul_le_mul_of_nonneg_left ledx (div_nonneg (norm_nonneg _) Rpos.le) ... = ‚à•d‚à• * (‚à•c‚à•/R * ‚à•x‚à•) : by { simp [norm_smul], ring } ... ‚â§ ‚à•d‚à• * ‚à•x - y'‚à• : mul_le_mul_of_nonneg_left (hx y' (by simp [hy', submodule.smul_mem _ _ hy])) (norm_nonneg _) ... = ‚à•d ‚Ä¢ x - y‚à• : by simp [yy', ‚Üê smul_sub, norm_smul]
intros
convert add_le_add_left (nsmul_le_nsmul_of_le_right (sum_condensed_le' hf n) 2) (f 1)
simp [sum_range_succ', add_comm, pow_succ, mul_nsmul, sum_nsmul]
intros
simp [arg, hx]
intros
rw [‚Üê exp_lt_exp, exp_log hx, exp_log hy]
intros
rw ‚Üê log_one
exact log_lt_log_iff zero_lt_one hx
intros
rw integral_deriv_eq_sub'
norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
intros
convert integral_sin_pow_even_mul_cos_pow_even 1 1 using 1
have h1 : ‚àÄ c : ‚Ñù, (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4 := Œª c, by ring
have h2 : continuous (Œª x, cos (2 * x) ^ 2) := by continuity
have h3 : ‚àÄ x, cos x * sin x = sin (2 * x) / 2
intro
rw sin_two_mul
ring
have h4 : ‚àÄ d : ‚Ñù, 2 * (2 * d) = 4 * d := Œª d, by ring
simp [h1, h2.interval_integrable, integral_comp_mul_left (Œª x, cos x ^ 2), h3, h4]
ring
intros
rcases lt_trichotomy z 0 with H|H|H
cases x
simp [H, ne_of_lt]
by_cases hx : x = 0
simp [hx, H, ne_of_lt]
simp [coe_rpow_of_ne_zero hx]
simp [H]
cases x
simp [H, ne_of_gt]
simp [coe_rpow_of_nonneg _ (le_of_lt H)]
intros
simp only [rpow_def, complex.cpow_def]
split_ifs
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
intros
rw [‚Üê complex.of_real_inj, complex.of_real_cpow (rpow_nonneg_of_nonneg hx _), complex.of_real_cpow hx, complex.of_real_mul, complex.cpow_mul, complex.of_real_cpow hx]
simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
intros
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
rw exp_le_exp
exact mul_le_mul_of_nonneg_left hyz (log_nonneg hx)
intros
simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]
exact (classical.some_spec exists_cos_eq_zero).2
intros
simp [arccos, sub_eq_iff_eq_add]
intros
convert dist_le_tsum_of_dist_le_of_tendsto _ hu‚ÇÇ (summable_geometric_two' C) ha n
simp only [add_comm n, pow_add, ‚Üê div_div_eq_div_mul]
symmetry
exact ((has_sum_geometric_two' C).div_const _).tsum_eq
intros
rw [sub_def, ‚Üêlift_sub_lift, sub_def, category.assoc, œÉ_comp, prod.lift_map_assoc]
refl
intros
rw equiv.symm_apply_eq
simp
intros
simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]
intros
simp only [cancel_mono]
intros
cases F
refl
intros
let E := (forget C).map_cocone D
let hE : is_colimit E := is_colimit_of_preserves _ hD
let G := types.colimit_cocone (F ‚ãô forget C)
let hG := types.colimit_cocone_is_colimit (F ‚ãô forget C)
let T : E ‚âÖ G := hE.unique_up_to_iso hG
let TX : E.X ‚âÖ G.X := (cocones.forget _).map_iso T
suffices : function.surjective (TX.hom ‚àò ff)
intro a
obtain ‚ü®b, hb‚ü© := this (TX.hom a)
refine ‚ü®b, _‚ü©
apply_fun TX.inv at hb
change (TX.hom ‚â´ TX.inv) (ff b) = (TX.hom ‚â´ TX.inv) _ at hb
simpa only [TX.hom_inv_id] using hb
have : TX.hom ‚àò ff = Œª a, G.Œπ.app a.1 a.2
ext a
change (E.Œπ.app a.1 ‚â´ hE.desc G) a.2 = _
rw hE.fac
rw this
rintro ‚ü®‚ü®j,a‚ü©‚ü©
exact ‚ü®‚ü®j,a‚ü©,rfl‚ü©
intros
ext
rw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.lift_œÄ, limit.lift_œÄ]
refl
intros
ext1
simp [‚Üê category.assoc]
intros
ext T f
simpa [cocone_of_representable_Œπ_app] using functor_to_types.naturality _ _ Œ± f.op _
intros
simp
intros
ext
simp
simp
intros
ext
simp [add_comp]
simp [add_comp]
simp [add_comp]
simp [add_comp]
intros
simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.Œπ_œÄ_assoc, comp_dite, dite_comp]
intros
rw [‚Üês.w right, parallel_pair_map_right]
intros
conv { to_lhs, congr, skip, rw ‚Üêimage_mono_iso_source_inv_Œπ f, }
rw [‚Üêcategory.assoc, iso.hom_inv_id, category.id_comp]
intros
rw [cofork.condition, zero_comp]
intros
apply (limit_equiv_sections F).injective
ext j
simp [w j]
intros
change quot.mk _ _ = quot.mk _ _ ‚Üî _
rw [quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]
intros
ext
simp [‚Üêunitors_equal]
intros
rw [‚Üêtensor_comp, f.hom_inv_id]
intros
ext
dsimp [embedding]
simp only [‚ÜêF.map_comp, biproduct.lift_œÄ, biproduct.matrix_œÄ, category.assoc]
simp only [‚ÜêF.map_comp, ‚ÜêF.map_sum, biproduct.lift_desc, biproduct.lift_œÄ_assoc, comp_sum]
simp only [comp_def, comp_dite, comp_zero, finset.sum_dite_eq', finset.mem_univ, if_true]
dsimp
simp only [finset.sum_singleton, dite_comp, zero_comp]
congr
symmetry
convert finset.sum_fn _ _
simp only [finset.sum_fn, finset.sum_dite_eq]
ext
simp
intros
haveI := subsingleton_of_forall_eq (0 : X ‚ü∂ Y) (Œª f, begin have p := not_congr (is_iso_iff_nonzero f), simp only [not_not, ne.def] at p, refine p.mp (Œª _, by exactI h (as_iso f)), end)
exact finrank_zero_of_subsingleton
intros
simp [covers_iff]
intros
cases J‚ÇÅ
cases J‚ÇÇ
congr
apply h
intros
ext T h
split
rintro ‚ü®hk‚ü©
exact pullback_arrows.mk _ _ (of_arrows.mk hk)
rintro ‚ü®W, k, hk‚ÇÅ‚ü©
cases hk‚ÇÅ with i hi
apply of_arrows.mk
intros
rw [‚Üê id_mem_iff_eq_top, pullback_apply, category.id_comp]
intros
cases f
congr
ext
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
intros
simp [blocks_fun, ones, blocks, i.2]
intros
by_cases h : ‚àÄ (s : finset Œπ), s.nonempty ‚Üí s ‚â† univ ‚Üí s.card < (s.bUnion t).card
exact hall_hard_inductive_step_A hn ht @ih h
push_neg at h
rcases h with ‚ü®s, sne, snu, sle‚ü©
have seq := nat.le_antisymm (ht _) sle
exact hall_hard_inductive_step_B hn ht @ih s sne snu seq
intros
revert Œπ
refine nat.strong_induction_on n (Œª n' ih, _)
intros _ _ t hn ht
rcases n' with (_|_)
exact hall_hard_inductive_zero t hn
apply hall_hard_inductive_step hn ht
introsI Œπ' _ _ hŒπ'
exact ih (fintype.card Œπ') (nat.lt_succ_of_le hŒπ') rfl
intros
rw set.disjoint_iff
rintro w ‚ü®h, h'‚ü©
rw [mem_neighbor_set, compl_adj] at h'
exact h'.2 h
intros
rw [common_neighbors, set.inter_comm]
refl
intros
convert univ.card.pred_eq_sub_one
erw [degree, neighbor_finset_eq_filter, filter_ne, card_erase_of_mem (mem_univ v)]
intros
obtain ‚ü®t, ht : _ = _‚ü© := min_of_nonempty (univ_nonempty.image (Œª v, G.degree v))
obtain ‚ü®v, _, rfl‚ü© := mem_image.mp (mem_of_min ht)
refine ‚ü®v, by simp [min_degree, ht]‚ü©
intros
rcases G.even_card_odd_degree_vertices with ‚ü®k, hg‚ü©
have hk : 0 < k
have hh : (filter (Œª (v : V), odd (G.degree v)) univ).nonempty
use v
simp only [true_and, mem_filter, mem_univ]
use h
rwa [‚Üêcard_pos, hg, zero_lt_mul_left] at hh
exact zero_lt_two
have hc : (Œª (w : V), w ‚â† v ‚àß odd (G.degree w)) = (Œª (w : V), odd (G.degree w) ‚àß w ‚â† v)
ext w
rw and_comm
simp only [hc, filter_congr_decidable]
rw [‚Üêfilter_filter, filter_ne', card_erase_of_mem]
use k - 1
rw [nat.pred_eq_succ_iff, hg, nat.mul_sub_left_distrib, ‚Üê nat.sub_add_comm, eq_comm, ‚Üê (nat.sub_eq_iff_eq_add _).symm]
ring
exact add_le_add_right (zero_le (2 * k)) 2
exact nat.mul_le_mul_left _ hk
simpa only [true_and, mem_filter, mem_univ]
intros
haveI : decidable_eq V
classical
apply_instance
rcases G.odd_card_odd_degree_vertices_ne v h with ‚ü®k, hg‚ü©
have hg' : (filter (Œª (w : V), w ‚â† v ‚àß odd (G.degree w)) univ).card > 0
rw hg
apply nat.succ_pos
rcases card_pos.mp hg' with ‚ü®w, hw‚ü©
simp only [true_and, mem_filter, mem_univ, ne.def] at hw
exact ‚ü®w, hw‚ü©
intros
rw language.mem_star at hy
rcases hy with ‚ü® S, rfl, hS ‚ü©
induction S with a S ih
refl
have ha := hS a (list.mem_cons_self _ _)
rw set.mem_singleton_iff at ha
rw [list.join, eval_from_of_append, ha, hx]
apply ih
intros z hz
exact hS z (list.mem_cons_of_mem a hz)
intros
simp [encode_code_eq, encode_code, -add_comm]
have := nat.mul_le_mul_right _ (dec_trivial : 1 ‚â§ 2*2)
rw [one_mul, mul_assoc, ‚Üê bit0_eq_two_mul, ‚Üê bit0_eq_two_mul] at this
have := lt_of_le_of_lt this (lt_add_of_pos_right _ (dec_trivial:0<4))
exact ‚ü® lt_of_le_of_lt (nat.left_le_mkpair _ _) this, lt_of_le_of_lt (nat.right_le_mkpair _ _) this‚ü©
intros
simp [encode_code_eq, encode_code, -add_comm]
have := nat.mul_le_mul_right _ (dec_trivial : 1 ‚â§ 2*2)
rw [one_mul, mul_assoc, ‚Üê bit0_eq_two_mul, ‚Üê bit0_eq_two_mul] at this
refine lt_of_le_of_lt (le_trans this _) (lt_add_of_pos_right _ (dec_trivial:0<4))
exact le_of_lt (nat.bit0_lt_bit1 $ le_of_lt $ nat.bit0_lt_bit1 $ le_refl _)
intros
induction pf
exact const 0
exact primrec.succ.comp vector_head
case nat.primrec'.nth : n i { exact vector_nth.comp primrec.id (const i) }
case nat.primrec'.comp : m n f g _ _ hf hg { exact hf.comp (vector_of_fn (Œª i, hg i)) }
case nat.primrec'.prec : n f g _ _ hf hg { exact nat_elim' vector_head (hf.comp vector_tail) (hg.comp $ vector_cons.comp (fst.comp snd) $ vector_cons.comp (snd.comp snd) $ (@vector_tail _ _ (n+1)).comp fst).to‚ÇÇ }
intros
simpa using cond hc hf hg
intros
simp [head]
intros
rcases s with _|_|_
refl
refl
refl
intros
conv {to_lhs, rw [‚Üê list_blank.cons_head_tail l]}
exact quotient.induction_on' l.tail (Œª l, rfl)
intros
induction l‚ÇÅ
simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
intros
apply coe_inj
ext1 Œ±
exact funext (h Œ±)
intros
rw ‚Üêrev_list_reverse
exact list.mem_reverse.trans mem_rev_list
intros
simp [H]
intros
by_cases p
simp *
simp *
intros
split
introI
constructor
intros _ _ hn
obtain ‚ü®_, _, h‚ü© := bounded.exists (@parser.decorate_errors Œ± msgs p) hn
simp [decorate_errors_eq_fail] at h
exact h.right.right
introI
constructor
intros _ _ hn
obtain ‚ü®_, _, h‚ü© := bounded.exists p hn
simp [h]
apply not_step_of_static_done
simp [remaining_eq_done]
intros
simp [eq_comm]
intros
simp [many, foldr_eq_fail]
intros
simp [many1, seq_eq_done, map_eq_done]
intros
simp [bit0]
intros
simp [norm_sq]
intros
simp [norm_sq_eq_def]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
intros
have := I_mul_I_ax
tauto
intros
ext j
have := apply_ite (Œª x : Œ†‚ÇÄ i, Œ≤ i, x j) (p i) (single i x) 0
dsimp at this
rw [filter_apply, this]
obtain rfl | hij := decidable.eq_or_ne i j
refl
rw [single_eq_of_ne hij, if_t_t, if_t_t]
intros
apply (equiv.set.sum_diff_subset h).injective
simp only [apply_symm_apply, sum_diff_subset_apply_inr]
exact subtype.eq rfl
intros
by_cases hab : a = b
simp [hab]
by_cases hax : x = a
simp [hax, eq_comm]
by_cases hbx : x = b
simp [hbx]
simp [hab, hax, hbx, swap_apply_of_ne_of_ne]
intros
ext x
cases x
simp [sum.map, swap_apply_def]
split_ifs
refl
refl
refl
simp [sum.map, swap_apply_of_ne_of_ne]
intros
ext
simp [and_assoc]
intros
cases n
refl
refl
intros
mfld_set_tac
intros
let h
show classical.some h = a
have := classical.some_spec h
exact cast (congr_fun this a).symm rfl
intros
have : ¬¨ (nat_add m i : ‚Ñï) < m
from (le_coe_nat_add _ _).not_lt
rw [add_cases, dif_neg this]
refine eq_of_heq ((eq_rec_heq _ _).trans _)
congr' 1
simp
intros
ext j
by_cases h : j = 0
rw h
refl
let j' := pred j h
have : j'.succ = j := succ_pred j h
rw [‚Üê this, cons_succ, comp_app, cons_succ]
intros
simp [insert_nth_zero]
intros
rw fin.eq_iff_veq
exact coe_val_of_lt a.property
intros
rw [‚Üêfin.of_nat_eq_coe, fin.of_nat, fin.last]
simp only [nat.mod_eq_of_lt n.lt_succ_self]
intros
ext
exact coe_val_of_lt (nat.lt.step a.is_lt)
intros
by_cases hi : i ‚àà s
simpa [hi]
simpa [hi]
intros
simp only [filter_not, inter_sdiff_self]
intros
haveI := classical.dec_eq Œ±
exact finset.induction_on s rfl (Œª a s has ih, by simp only [image_insert, bUnion_insert, ih])
intros
rw [finset.disjoint_left, set.disjoint_left]
refl
intros
rcases one_lt_card.1 h‚ÇÇ with ‚ü®a, ha, b, hb, hab‚ü©
exact s.min'_lt_max' ha hb hab
intros
assume v‚ÇÅ v‚ÇÇ eq
ext a
have : map_domain f v‚ÇÅ (f a) = map_domain f v‚ÇÇ (f a)
rw eq
rwa [map_domain_apply hf, map_domain_apply hf] at this
intros
rw [finsupp.mem_support_iff, finsupp.on_finset_apply]
intros
dsimp [finsupp.prod]
rw f.support.prod_ite_eq'
intros
ext
simp
intros
simp [fintype.pi_finset, card_map]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, int.add_div_of_dvd_right ((dvd_neg c b).mpr hcb)]
congr
exact neg_div_of_dvd hcb
intros
unfold bit1
unfold bit0
simp
intros
rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul]
apply nat.gcd_mul_right
intros
rw [int.lcm, int.lcm]
exact nat.lcm_comm _ _
intros
unfold gcd_a gcd_b
cases xgcd x y
refl
intros
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
intros
rw even_mul
convert n.even_or_odd
simp with parity_simps
intros
simpa only [exists_or_distrib, ‚Üê odd, ‚Üê even] using even_or_odd n
intros
rcases le_iff_exists_add.1 h with ‚ü®m, rfl‚ü©
rw [nat.add_sub_cancel_left, add_comm, modify_nth_tail_modify_nth_tail]
intros
cases le_or_lt n l.length with hn hn
rw length_insert_nth _ _ hn
exact (nat.lt_succ_self _).le
rw insert_nth_of_length_lt _ _ _ hn
intros
induction L‚ÇÅ
refl
simp only [*, join, cons_append, append_assoc]
intros
induction l with b l IH
contradiction
by_cases h : p b
rw find_cons_of_pos _ h at H
cases H
apply mem_cons_self
rw find_cons_of_neg _ h at H
exact mem_cons_of_mem _ (IH H)
intros
simp only [filter_map, h]
intros
rw [‚Üêmem_iff_nth, ‚Üêmem_iff_nth, reduce_option_mem_iff]
intros
simp
intros
induction ys generalizing f f'
simp *
simp *
apply ys_ih
simp [H]
intros
induction ys with y ys ih generalizing l
simp {contextual := tt}
rw [permutations_aux2_snd_cons, show (Œª (x : list Œ±), l ++ y :: x) = append (l ++ [y]), by funext; simp, mem_cons_iff, ih]
split
intro h
rcases h with e | ‚ü®l‚ÇÅ, l‚ÇÇ, l0, ye, _‚ü©
subst l'
exact ‚ü®[], y::ys, by simp‚ü©
substs l' ys
exact ‚ü®y::l‚ÇÅ, l‚ÇÇ, l0, by simp‚ü©
intro h
rcases h with ‚ü®_ | ‚ü®y', l‚ÇÅ‚ü©, l‚ÇÇ, l0, ye, rfl‚ü©
simp [ye]
simp at ye
rcases ye with ‚ü®rfl, rfl‚ü©
exact or.inr ‚ü®l‚ÇÅ, l‚ÇÇ, l0, by simp‚ü©
intros
by_cases a ‚àà l
simp only [insert_of_mem h]
simp only [insert_of_not_mem h, suffix_cons]
intros
induction l
refl
simp only [*, diff_cons, erase_of_not_mem (not_mem_nil _)]
intros
cases bs
refl
refl
intros
induction l
simp only [*, concat]
split
simp only [*, concat]
split
intros
simp
intros
induction l
refl
simp only [cons_append, last_cons _ (Œª H, cons_ne_nil _ _ (append_eq_nil.1 H).2), *]
intros
intro e
rw e at h
cases h
intros
simpa [duplicate_cons_iff, hx.symm] using h
intros
induction h
constructor
constructor
solve_by_elim
solve_by_elim
intros
cases k
refl
refl
intros
induction l with y l IH generalizing x
simp [take_while]
rw [permutations'_aux, count_cons_self]
by_cases hx : x = y
subst hx
simpa [take_while, nat.succ_inj'] using IH _
rw take_while
rw if_neg hx
cases permutations'_aux x l with a as
simp
rw [count_eq_zero_of_not_mem, length, zero_add]
simp [hx, ne.symm hx]
intros
rw [rotate_eq_rotate', rotate_eq_rotate', rotate_eq_rotate', rotate'_rotate']
intros
rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod, h, zip_with_append, ‚Üêzip_with_distrib_drop, ‚Üêzip_with_distrib_take, list.length_zip_with, h, min_self]
rw [length_drop, length_drop, h]
intros
split
intro h
cases l.length.zero_le.eq_or_lt with hl' hl'
simp [‚Üêlength_eq_zero, ‚Üêhl']
left
rw nodup_iff_nth_le_inj at hl
refine hl _ _ (mod_lt _ hl') hl' _
rw ‚Üênth_le_rotate' _ n
simp_rw [h, nat.sub_add_cancel (mod_lt _ hl').le, mod_self]
rintro (h|h)
rw [‚Üêrotate_mod, h]
exact rotate_zero l
simp [h]
intros
obtain rfl | h := eq_or_ne l []
simp
rw length_cyclic_permutations_of_ne_nil _ h at hn
simp [init_eq_take, cyclic_permutations_of_ne_nil _ h, nth_le_take', rotate_eq_drop_append_take hn.le]
intros
rw rotate'_eq_drop_append_take (le_refl _)
simp
intros
rw [keys, kerase, ‚Üêerasep_map sigma.fst l, erase_eq_erasep]
intros
induction p generalizing l
refl
case list.perm.cons : hd tl‚ÇÅ tl‚ÇÇ p ih { simp [ih (kerase hd.1 l), perm.cons] }
case list.perm.swap : s‚ÇÅ s‚ÇÇ l { simp [kerase_comm, perm.swap] }
case list.perm.trans : l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ‚ÇÇ p‚ÇÇ‚ÇÉ ih‚ÇÅ‚ÇÇ ih‚ÇÇ‚ÇÉ { exact perm.trans (ih‚ÇÅ‚ÇÇ l) (ih‚ÇÇ‚ÇÉ l) }
intros
cases l
cases l'
simp
simp
cases l'
simp
simp
intros
rw [‚Üê zip_map, map_id]
intros
ext i j
simp
intros
ext
simp only [diagonal, map_apply]
split_ifs
simp [h]
simp [h]
intros
ext
apply dot_product_assoc
intros
simp only [coe_scalar, smul_eq_mul, mul_one, one_apply_eq, pi.smul_apply]
intros
simp [commute, semiconj_by]
intros
unfold std_basis_matrix
ext
simp
intros
ext
simp
intros
ext i
simp [mul_vec, mul_comm]
intros
ext i
refine fin.cases _ _ i
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
simp [multiset.sigma, (‚àò)]
intros
simp [countp_eq_card_filter, h, filter_le_filter]
intros
split
assume h
induction h
simp *
simp *
assume h
subst h
exact rel_eq_refl
intros
simpa using add_le_add_left (zero_le t) s
intros
classical
rw [‚Üê h.le_erase_dup_iff_le, iff.comm, ‚Üê h.le_erase_dup_iff_le]
simp [hn]
intros
simp [ndinter, le_filter, subset_iff]
intros
simp only [antidiagonal, list.nat.antidiagonal_succ, coe_map, cons_coe]
intros
simp [powerset_len_aux_eq_map_coe]
intros
ext
simp
simp
intros
rw [œÜ.as_sum, ring_hom.map_sum, finset.sum_eq_zero]
intros d hd
obtain ‚ü®i, hi, hgi‚ü© : ‚àÉ i ‚àà d.support, g i = 0 := h d (finsupp.mem_support_iff.mp hd)
rw [eval‚ÇÇ_hom_monomial, finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [hgi, zero_pow]
rwa [pos_iff_ne_zero, ‚Üê finsupp.mem_support_iff]
intros
rw [bit1, nat.dvd_add_right two_dvd_bit0, nat.dvd_one]
cc
intros
rintros ‚ü®c, rfl‚ü©
rcases nat.eq_zero_or_pos c with (rfl | hc)
exact lt_irrefl 0 h1
exact not_lt.2 (le_mul_of_pos_right hc) h2
intros
unfold bodd div2
cases bodd_div2 n
refl
intros
cases le_or_lt a c with h' h'
left
exact h'
right
replace h' := add_lt_add_right h' d
rw h at h'
cases b.eq_zero_or_pos with hb hb
rw hb
exact zero_le d
rw [a.add_sub_assoc hb, add_lt_add_iff_left] at h'
exact nat.le_of_pred_lt h'
intros
simp [land]
intros
induction L with d L ih
refl
simp [of_digits, list.sum_cons, ih]
intros
rw ‚Üêof_digits_one
conv { congr, skip, rw ‚Üê(of_digits_digits b' n) }
convert of_digits_modeq _ _ _
exact h.symm
intros
rw [digits, digits_aux_def]
exact succ_pos n
intros
rw [mul_comm k n, mul_comm k m, dist_mul_right, mul_comm]
intros
rw [‚Üê coe_inj, coe_get]
intros
rw [clog, if_neg (Œª h : 1 < b ‚àß 1 < n, h.1.not_le hb)]
intros
symmetry
rw ‚Üê list.repeat_perm
apply nat.factors_unique (list.prod_repeat p n)
intros q hq
rwa eq_of_mem_repeat hq
intros
simpa only [pow_two] using eq_sqrt
intros
cases n
refl
refl
refl
intros
cases n
refl
refl
refl
intros
cases n
refl
refl
intros
rw [‚Üê of_nat_to_znum, zneg_to_znum]
intros
cases x
refl
refl
intros
cases x
simp
simp
intros
cases x
simp [is_some]
simp [is_some]
intros
simp [node3_l, node3_r, dual_node']
intros
rw [balance_r_eq_balance' hl hr sl sr H, all_balance']
intros
simp [restrict]
intros
simp [dom, part.dom_iff_mem]
intros
rw [corec_def,dest_mk]
intros
induction d with d ih
refl
rw [succ_nsmul, prod_add, ih, nat.succ_eq_add_one, pow_succ, mul_comm]
intros
apply le_antisymm
apply le_inf_iff.mpr
split
apply factor_multiset_le_iff.mpr
exact gcd_dvd_left m n
apply factor_multiset_le_iff.mpr
exact gcd_dvd_right m n
rw[‚Üê prime_multiset.prod_dvd_iff, prod_factor_multiset]
apply dvd_gcd
rw[prime_multiset.prod_dvd_iff']
exact inf_le_left
rw[prime_multiset.prod_dvd_iff']
exact inf_le_right
intros
rcases p
simp [coeff, neg_to_finsupp]
intros
unfold nat_degree
rw h
intros
rintro rfl
simpa [monic] using hp
intros
simp only [‚ÜêC_eq_nat_cast, nat_trailing_degree_C]
intros
apply polynomial.induction_on' p
intros p q ph qh
simp only [add_mul, eval_add, ph, qh]
intros n a
simp only [‚Üêmonomial_one_one_eq_X, monomial_mul_monomial, eval_monomial, mul_one, pow_succ', mul_assoc]
intros
unfold leading_coeff
rw [coeff_map, nat_degree_map_of_leading_coeff_ne_zero f hf]
intros
rw [sub_eq_add_neg, eval‚ÇÇ_add, eval‚ÇÇ_neg, sub_eq_add_neg]
intros
ext x
rw [set.mem_singleton_iff, mem_root_set, aeval_mul, aeval_C, aeval_X_pow, mul_eq_zero]
simp_rw [ring_hom.map_eq_zero, pow_eq_zero_iff (nat.pos_of_ne_zero hn), or_iff_right_iff_imp]
exact Œª ha', (ha ha').elim
exact mul_ne_zero (mt C_eq_zero.mp ha) (pow_ne_zero n X_ne_zero)
intros
rw [eq_C_of_degree_eq_zero (degree_coe_units u), eq_C_of_degree_eq_zero (degree_coe_units u‚Åª¬π), coeff_C, coeff_C, inv_eq_one_div]
split_ifs
rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ‚Üê eval_mul, ‚Üê units.coe_mul, inv_mul_self]
simp
simp
intros
simp only [hasse_deriv_apply, derivative_apply, monomial_eq_C_mul_X, nat.choose_one_right, (nat.cast_commute _ _).eq]
intros
simp only [coe_map_ring_hom, lifts, set.mem_range, ring_hom.mem_srange]
intros
conv_lhs { rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm] }
suffices : C (p.coeff p.nat_degree) = 1
rw [this, one_mul]
exact congr_arg C hp
intros
by_cases a ‚â§ b
simp [h, min_def]
simp [h, min_def]
intros
apply tsum_le_tsum _ (summable_cantor_function f h1 h2) (summable_cantor_function g h1 h2)
intro n
cases h : f n
simp [h, cantor_function_aux_nonneg h1]
replace h3 : g n = tt := h3 n h
simp [h, h3]
intros
rw [mul_comm, mul_div_cancel h0 hI]
intros
simpa only [lt_top_iff_ne_top] using add_lt_top
intros
unfold_coes
simp [real.to_ereal]
intros
unfold st
split_ifs
exact classical.some_spec h
exact false.elim (hx (by unfold st; split_ifs; refl))
intros
simpa only [sub_eq_add_neg] using h.neg.rat_add q
intros
simp [nnreal.coe_lt_coe.symm, real.to_nnreal, lt_irrefl]
intros
rw [div_eq_inv_mul, ‚Üê mul_le_iff_le_inv hr, mul_comm]
intros
refine lt_of_le_of_ne (sign_mul_nonneg r) (Œª h, hr _)
have hs0 := (zero_eq_mul.mp h).resolve_right hr
exact sign_eq_zero_iff.mp hs0
simp [sqrt]
intros
ext x y
reflexivity
intros
unfold comp
ext x w
split
rintros ‚ü®z, ‚ü®y, rxy, syz‚ü©, tzw‚ü©
exact ‚ü®y, rxy, z, syz, tzw‚ü©
rintros ‚ü®y, rxy, z, syz, tzw‚ü©
exact ‚ü®z, ‚ü®y, rxy, syz‚ü©, tzw‚ü©
intros
apply subtype.eq
funext n
induction h : s.val n
refl
refine absurd _ H
exact ‚ü®‚ü®_, _, h.symm‚ü©‚ü©
intros
apply subtype.eq
simp [of_stream, cons]
rw stream.map_cons
intros
rw [lift_rel_destruct_iff]
simp
intros
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]
simp
intros
ext ‚ü®x, y‚ü©
simp [diagonal, eq_comm]
intros
ext f
split
assume h
split
{ rintros i ‚ü®his, hpi‚ü©, simpa [*] using h i }
rintros i ‚ü®his, hpi‚ü©
simpa [*] using h i
rintros ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü© i his
by_cases p i
simp * at *
simp * at *
intros
ext x
split
intro h
convert h i hi
simp
intros hx j hj
by_cases h : j = i
cases h
simpa
rw [update_noteq h]
exact hf j hj h
intros
refine ‚ü®Œª h y, _, surjective.preimage_injective‚ü©
obtain ‚ü®x, hx‚ü© : (f ‚Åª¬π' {y}).nonempty
rw [h.nonempty_apply_iff preimage_empty]
apply singleton_nonempty
exact ‚ü®x, hx‚ü©
intros
rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_distrib_right, and_not_self, or_false, and_iff_left_iff_imp]
rintro rfl
refine ne_comm.1 (ne_empty_iff_nonempty.2 (singleton_nonempty _))
intros
rw [fintype_insert', fintype.card_of_finset]
simp [finset.card, to_finset]
refl
intros
haveI := classical.dec_eq Œ±
exact ‚ü®by apply_instance‚ü©
intros
rw [‚Üê finset.coe_sort_coe _, h.coe_to_finset]
intros
rw range_subset_iff
intro x
simp [nat.lt_succ_iff, nat.find_greatest_le]
intros
rw [Ioc_union_Ioc, max_self]
exact (min_le_right _ _).trans (le_max_right _ _)
exact (min_le_right _ _).trans (le_max_right _ _)
intros
classical
by_cases ha : a ‚àà s
by_cases hb : b ‚àà s
refine or.inl (subset.antisymm hc _)
rwa [‚Üê Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ‚Üê Icc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho
refine (or.inr $ or.inl $ subset.antisymm _ _)
rw [‚Üê Icc_diff_right]
exact subset_diff_singleton hc hb
rwa [‚Üê Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho
by_cases hb : b ‚àà s
refine (or.inr $ or.inr $ or.inl $ subset.antisymm _ _)
rw [‚Üê Icc_diff_left]
exact subset_diff_singleton hc ha
rwa [‚Üê Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho
refine (or.inr $ or.inr $ or.inr $ subset.antisymm _ ho)
rw [‚Üê Ico_diff_left, ‚Üê Icc_diff_right]
apply_rules [subset_diff_singleton]
intros
rw [Ico_disjoint_Ico, min_eq_left (le_of_lt h2.2), le_max_iff] at h
apply le_antisymm h2.1
exact h.elim (Œª h, absurd hx (not_lt_of_le h)) id
intros
simp [‚Üê Ici_inter_Iio, ‚Üê Ioi_inter_Iic, inter_comm]
intros
simp [‚Üê Ioi_inter_Iic, ‚Üê Ici_inter_Iio, inter_comm]
intros
simp [‚Üê Ioi_inter_Iic, ‚Üê Ici_inter_Iio, inter_comm]
intros
simp [add_comm]
intros
simp
intros
convert image_mul_right_Icc hbc ha using 1
simp only [mul_comm _ a]
simp only [mul_comm _ a]
intros
ext ‚ü®a, b‚ü©
split
rintro ‚ü®ha, hb‚ü©
exact ‚ü®prod.mk a, ‚ü®a, ha, rfl‚ü©, b, hb, rfl‚ü©
rintro ‚ü®f, ‚ü®x, hx, rfl‚ü©, y, hy, eq‚ü©
rw ‚Üê eq
exact ‚ü®hx, hy‚ü©
intros
simp [‚Üê ne_empty_iff_nonempty]
intros
rw eqv_gen_eq
apply congr_arg Inf
simp only [le_def, or_imp_distrib, ‚Üê forall_and_distrib]
intros
cases hl : l.as_string
exact string_imp.mk.inj hl.symm
intros
tidy
apply rel.trans
assumption
assumption
intros
rw [‚Üê comp_assoc,to_subtype_of_subtype]
simp
intros
cases v
simp [vector.reverse]
intros
casesI n
exfalso
exact nat.not_lt_zero 0 (fact.out _)
exact fin.is_lt a
intros
casesI n
exfalso
exact nat.not_lt_zero 0 (fact.out (0 < 0))
refl
intros
rw [dist_comm, real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ‚Üê sub_eq_add_neg]
exact ‚ü®f.lt_map_map_zero g, f.map_map_zero_lt g‚ü©
intros
refine (tendsto_iff_dist_tendsto_zero.2 $ squeeze_zero (Œª _, dist_nonneg) (Œª n, _) ((tendsto_const_div_at_top_nhds_0_nat 1).comp (tendsto_add_at_top_nat 1)))
dsimp
have : (0:‚Ñù) < n + 1 := n.cast_add_one_pos
rw [real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ‚Üê real.dist_eq, abs_of_pos this, div_le_div_right this, ‚Üê nat.cast_add_one]
apply dist_pow_map_zero_mul_translation_number_le
intros
simp only [frequently_at_top, @forall_swap (_ ‚àà s), ae_all_iff]
intro n
filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]
simp
intros
apply nat.eq_prime_pow_of_dvd_least_prime_pow hp.out
rwa ‚Üê is_periodic_pt_iff_minimal_period_dvd
rwa ‚Üê is_periodic_pt_iff_minimal_period_dvd
intros
apply_instance
intros
intros x hx
cases hx with f hf
rw ‚Üê hf
exact adjoin.algebra_map_mem F S f
intros
have h := finite_field.pow_card x
rwa zmod.card p at h
intros
have h := finite_field.expand_card f
rwa zmod.card p at h
intros
cases field.exists_primitive_element F E with Œ± h1
use [minpoly F Œ±, separable F Œ±, is_galois.splits F Œ±]
rw [eq_top_iff, ‚Üêintermediate_field.top_to_subalgebra, ‚Üêh1]
rw intermediate_field.adjoin_simple_to_subalgebra_of_integral F Œ± (integral F Œ±)
apply algebra.adjoin_mono
rw [set.singleton_subset_iff, finset.mem_coe, multiset.mem_to_finset, polynomial.mem_roots]
dsimp only [polynomial.is_root]
rw [polynomial.eval_map, ‚Üêpolynomial.aeval_def]
exact minpoly.aeval _ _
exact polynomial.map_ne_zero (minpoly.ne_zero (integral F Œ±))
intros
refine minpoly.dvd K x _
rw [‚Üê is_scalar_tower.aeval_apply, minpoly.aeval]
intros
split
intro h
have zero_root := zero_is_root_of_coeff_zero_eq_zero h
rw ‚Üê root hx zero_root
exact ring_hom.map_zero _
rintro rfl
simp
intros
letI : algebra E E' := ring_hom.to_algebra f.to_ring_hom
haveI : is_scalar_tower F E E' := is_scalar_tower.of_algebra_map_eq (Œª x, (f.commutes x).symm)
exact is_separable_tower_bot_of_is_separable F E E'
intros
refine ‚ü®Œª h, _, inner_eq_neg_mul_norm_of_angle_eq_pi‚ü©
have h‚ÇÅ : (‚à•x‚à• * ‚à•y‚à•) ‚â† 0 := (mul_pos (norm_pos_iff.mpr hx) (norm_pos_iff.mpr hy)).ne'
rw [angle, h, neg_div, div_self h‚ÇÅ, real.arccos_neg_one]
intros
rw dist_comm
exact dist_circumcenter_eq_circumradius _ _
intros
have h := s.circumcenter_circumradius_unique_dist_eq.2 (p, r)
simp only [hp, hr, forall_const, eq_self_iff_true, and_self, prod.ext_iff] at h
exact h.2
intros
simp_rw [sum_points_with_circumcenter, monge_point_weights_with_circumcenter, sum_const, card_fin, nsmul_eq_mul]
have hn1 : (n + 1 : ‚Ñù) ‚â† 0
exact_mod_cast nat.succ_ne_zero _
field_simp [hn1]
ring
intros
rw div_eq_mul_inv
exact ((smooth_mul I).comp (hf.prod_mk hg.inv) : _)
intros
unfold_coes
simp only with mfld_simps
intros
split
intro Hfh
rw [‚Üê h.symm_apply_apply x] at Hfh
simpa only [(‚àò), h.apply_symm_apply] using Hfh.comp (h x) (h.symm.times_cont_mdiff_within_at.of_le hm) (maps_to_preimage _ _)
rw ‚Üê h.image_eq_preimage
exact Œª hf, hf.comp x (h.times_cont_mdiff_within_at.of_le hm) (maps_to_image _ _)
intros
have := unique_mdiff_within_at.inter (unique_mdiff_within_at_univ I) (is_open.mem_nhds hs xs)
rwa univ_inter at this
intros
apply le_antisymm le_top
assume u hu
change u ‚àà times_cont_diff_groupoid 0 I
rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid]
simp only [times_cont_diff_on_zero]
split
apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _)
apply continuous_on.comp u.continuous_to_fun I.continuous_symm.continuous_on (inter_subset_left _ _)
apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _)
apply continuous_on.comp u.continuous_inv_fun I.continuous_inv_fun.continuous_on (inter_subset_left _ _)
intros
refine (times_cont_mdiff_within_at_iff' h (mem_chart_source _ _)).2 _
refine ‚ü®(ext_chart_at_continuous_at' _ _ _).continuous_within_at, _‚ü©
rwa ext_chart_at_source
refine times_cont_diff_within_at_id.congr' _ _
simp only [h] with mfld_simps { contextual := tt }
simp only [h] with mfld_simps { contextual := tt }
intros
simp [‚Üê times_cont_mdiff_within_at_univ, times_cont_mdiff_within_at_iff_times_cont_mdiff_on_nhds, nhds_within_univ]
intros
rw ‚Üê fintype.card_prod
exact fintype.card_congr (subgroup.group_equiv_quotient_times_subgroup)
intros
rintros ‚ü®m, w, h‚ü© ‚ü®m', w', h'‚ü© he
by_cases hm : m = 1
by_cases hm' : m' = 1
simp only [rcons, dif_pos hm, dif_pos hm'] at he
cc
exfalso
simp only [rcons, dif_pos hm, dif_neg hm'] at he
rw he at h
exact h rfl
by_cases hm' : m' = 1
exfalso
simp only [rcons, dif_pos hm', dif_neg hm] at he
rw ‚Üêhe at h'
exact h' rfl
have : m = m' ‚àß w.to_list = w'.to_list
simpa only [rcons, dif_neg hm, dif_neg hm', true_and, eq_self_iff_true, subtype.mk_eq_mk, heq_iff_eq, ‚Üêsubtype.ext_iff_val] using he
rcases this with ‚ü®rfl, h‚ü©
congr
exact word.ext _ _ h
intros
exact {smul_assoc := Œª n, @smul_assoc _ _ _ _ _ _ _ (g n) }
intros
split_ifs
refl
refl
intros
rw [tree_hom, unique.default_eq]
intros
induction n with d hd
simp [nat.nat_zero_eq_zero]
rintros a ‚ü®x, hx : x ‚àà lower_central_series G d.succ, rfl‚ü©
refine closure_induction hx _ (by simp [f.map_one, subgroup.one_mem _]) (Œª y z hy hz, by simp [monoid_hom.map_mul, subgroup.mul_mem _ hy hz]) (Œª y hy, by simp [f.map_inv, subgroup.inv_mem _ hy])
rintros a ‚ü®y, hy, z, ‚ü®-, rfl‚ü©‚ü©
apply mem_closure.mpr
exact Œª K hK, hK ‚ü®f y, hd (mem_map_of_mem f hy), by simp‚ü©
intros
convert is_periodic_pt_minimal_period ((*) x) _
rw [order_of, mul_left_iterate, mul_one]
intros
intros y hy
rw [mem_support, cycle_of_apply] at hy
split_ifs at hy
exact mem_support.mpr hy
exact absurd rfl hy
intros
simp [cycle_factors_finset_eq_finset]
intros
cases n
simp
have : j = (fin.cast_le (nat.succ_le_of_lt i.is_lt)).to_embedding ‚ü®j, lt_of_le_of_lt h (nat.lt_succ_self i)‚ü©
simp
ext
rw [this, cycle_range, of_left_inverse'_eq_of_injective, ‚Üêfunction.embedding.to_equiv_range_eq_of_injective, ‚Üêvia_fintype_embedding, via_fintype_embedding_apply_image, rel_embedding.coe_fn_to_embedding, coe_cast_le, coe_fin_rotate]
simp only [fin.ext_iff, coe_last, coe_mk, coe_zero, fin.eta, apply_ite coe, cast_le_mk]
split_ifs with heq
refl
rw fin.coe_add_one_of_lt
exact lt_of_lt_of_le (lt_of_le_of_ne h (mt (congr_arg coe) heq)) (le_last i)
intros
rw [is_three_cycle, cycle_type_cycle_range]
dec_trivial
dec_trivial
intros
simp [equiv.perm.decompose_fin]
intros
induction n with n ih
refl
rw [pow_succ, perm.mul_apply, apply_mem_support, ih]
intros
simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
by_cases h : f y = x
split
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split_ifs at hy
cc
cc
intros
by_cases h : f = 1
exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one
exact ne_of_gt (one_lt_card_support_of_ne_one h)
intros
ext
simp
simp
let x : equiv.perm (fin 5) := ‚ü®![1, 2, 0, 3, 4], ![2, 0, 1, 3, 4], dec_trivial, dec_trivial‚ü©
let y : equiv.perm (fin 5) := ‚ü®![3, 4, 2, 0, 1], ![3, 4, 2, 0, 1], dec_trivial, dec_trivial‚ü©
let z : equiv.perm (fin 5) := ‚ü®![0, 3, 2, 1, 4], ![0, 3, 2, 1, 4], dec_trivial, dec_trivial‚ü©
have x_ne_one : x ‚â† 1
rw [ne.def, equiv.ext_iff]
dec_trivial
have key : x = z * (x * (y * x * y‚Åª¬π) * x‚Åª¬π * (y * x * y‚Åª¬π)‚Åª¬π) * z‚Åª¬π
ext a
dec_trivial!
refine not_solvable_of_mem_derived_series x_ne_one (Œª n, _)
induction n with n ih
exact mem_top x
rw key
exact (derived_series_normal _ _).conj_mem _ (general_commutator_containment _ _ ih ((derived_series_normal _ _).conj_mem _ ih _)) _
intros
rw ‚Üêmem_coe at h
rw [‚Üêaffine_span_insert_affine_span, set.insert_eq_of_mem h, affine_span_coe]
intros
rcases hp1 with ‚ü®p1a, ‚ü®hp1a, ‚ü®v1, ‚ü®hv1, hv1p‚ü©‚ü©‚ü©‚ü©
rcases hp2 with ‚ü®p2a, ‚ü®hp2a, ‚ü®v2, ‚ü®hv2, hv2p‚ü©‚ü©‚ü©‚ü©
rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub (v1 +·µ• p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]
have hv1v2 : v1 - v2 ‚àà vector_span k s
rw sub_eq_add_neg
apply (vector_span k s).add_mem hv1
rw ‚Üêneg_one_smul k v2
exact (vector_span k s).smul_mem (-1 : k) hv2
refine (vector_span k s).add_mem _ hv1v2
exact vsub_mem_vector_span k hp1a hp2a
intros
ext v
rw mem_direction_iff_eq_vsub (mk'_nonempty _ _)
split
rintros ‚ü®p1, ‚ü®v1, hv1, hp1‚ü©, p2, ‚ü®v2, hv2, hp2‚ü©, hv‚ü©
rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right]
exact direction.sub_mem hv1 hv2
exact Œª hv, ‚ü®v +·µ• p, vadd_mem_mk' _ hv, p, self_mem_mk' _ _, (vadd_vsub _ _).symm‚ü©
intros
cases S.nonempty with p
ext v
refine ‚ü®imp_intro submodule.mem_top, Œª hv, _‚ü©
have hpv : (v +·µ• p -·µ• p : V) ‚àà (‚ä§ : affine_subspace k P).direction := vsub_mem_direction (mem_top k V _) (mem_top k V _)
rwa vadd_vsub at hpv
intros
rw vector_span_def
refine le_antisymm _ (submodule.span_mono _)
rw submodule.span_le
rintros v ‚ü®p1, p2, hp1, hp2, hv‚ü©
rw ‚Üêvsub_sub_vsub_cancel_left p1 p2 p at hv
rw [‚Üêhv, set_like.mem_coe, submodule.mem_span]
exact Œª m hm, submodule.sub_mem _ (hm ‚ü®p2, hp2, rfl‚ü©) (hm ‚ü®p1, hp1, rfl‚ü©)
rintros v ‚ü®p2, hp2, hv‚ü©
exact ‚ü®p, p2, hp, hp2, hv‚ü©
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_left k (set.mem_image_of_mem p hi), ‚Üêset.insert_eq_of_mem hi, ‚Üêset.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
intros
erw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ‚Üê@vsub_eq_zero_iff_eq V, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, ‚Üêadd_sub_assoc, add_comm, add_sub_assoc, ‚Üêsum_sub_distrib]
conv_lhs { congr, skip, congr, skip, funext, rw [‚Üêsmul_sub, vsub_sub_vsub_cancel_left] }
rw [‚Üêsum_smul, h, one_smul, vsub_add_vsub_cancel, vsub_self]
intros
rw [collinear_iff_finrank_le_one, affine_independent_iff_not_finrank_vector_span_le k p (fintype.card_fin 3)]
intros
rw [slope, slope, ‚Üê neg_vsub_eq_vsub_rev, smul_neg, ‚Üê neg_smul, neg_inv, neg_sub]
intros
ext
rw [set_like.mem_coe, mem_sup, set.mem_add]
simp
intros
rw [ker_comp, hg, submodule.comap_bot]
intros
classical
intro g
refine ‚ü®Œª x, if h : ‚àÉ y, f y = x then g h.some else 0, _‚ü©
ext
dsimp only [fun_left_apply]
split_ifs with w
congr
exact hf w.some_spec
simpa only [not_true, exists_apply_eq_apply] using w
intros
ext x
exact alg_hom.congr_fun (map_comp_map Q‚ÇÅ Q‚ÇÇ Q‚ÇÉ _ _ _ _) x
intros
apply quaternion_algebra.lift.symm.injective
ext1
dsimp [quaternion_algebra.basis.lift]
simp
dsimp [quaternion_algebra.basis.lift]
simp
intros
ext
simp
intros
apply le_antisymm
exact f.to_linear_map.lift_dim_le_of_injective f.injective
exact f.symm.to_linear_map.lift_dim_le_of_injective f.symm.injective
intros
ext i x
apply dual_basis_apply
intros
ext i
rw [h.coeffs_apply, h.dual_lc]
intros
haveI := classical.dec_pred (Œª (x : Œ±), x ‚àà s)
simp [mem_supported, set.subset_def, not_imp_comm]
intros
refine ‚ü®Œª h x hx, _, disjoint_supported_supported‚ü©
rcases exists_ne (0 : M) with ‚ü®y, hy‚ü©
have := h ‚ü®single_mem_supported R y hx.1, single_mem_supported R y hx.2‚ü©
rw [mem_bot, single_eq_zero] at this
exact hy this
intros
ext
simp [total_apply]
intros
have p : (span.repr R (set.range v) x).equiv_map_domain (equiv.of_injective _ hv.injective).symm = hv.repr x
apply (linear_independent.total_equiv hv).injective
ext
simp
ext ‚ü®_, ‚ü®i, rfl‚ü©‚ü©
simp [‚Üêp]
intros
simp_rw [e.to_matrix_apply, e.sum_repr]
intros
ext
simp
intros
refine (inv_eq_left_inv _).symm
rw [‚Üêmul_eq_mul, ‚Üêunits.coe_mul, inv_mul_self, units.coe_one]
intros
haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
exact adjugate_subsingleton _
intros
simp only [submodule.eq_bot_iff, linear_map.mem_ker, matrix.to_lin'_apply]
intros
simp
intros
ext ‚ü®x, y‚ü©
simp
intros
tidy
exact 0
intros
cases Q
cases Q'
congr
funext
apply H
intros
rw [ker_liftq, le_antisymm h h', mkq_map_self]
intros
simp only [‚Üê submodule.map_top, ‚Üê span_tmul_eq_top, submodule.map_span, set.mem_image, set.mem_set_of_eq]
congr
ext t
split
rintros ‚ü®_, ‚ü®‚ü®m, n, rfl‚ü©, rfl‚ü©‚ü©
use [m, n]
simp only [map_tmul]
rintros ‚ü®m, n, rfl‚ü©
use [m ‚äó‚Çú n, m, n]
simp only [map_tmul]
intros
simp [@eq_comm _ a']
intros
rcases exists_pair_ne Œ≤ with ‚ü®x, y, h‚ü©
rcases hf x with ‚ü®x', hx'‚ü©
rcases hf y with ‚ü®y', hy'‚ü©
have : x' ‚â† y'
contrapose! h
rw [‚Üê hx', ‚Üê hy', h]
exact ‚ü®‚ü®x', y', this‚ü©‚ü©
intros
classical
exact decidable.exists_ne x
intros
induction hab generalizing c
case refl_trans_gen.refl : c hac { exact single hac }
case refl_trans_gen.tail : d b hab hdb IH { exact tail (IH hdb) hbc }
intros
rw [ae_seq_set, compl_compl, measure_to_measurable]
have hf_eq := Œª i, (hf i).ae_eq_mk
simp_rw [filter.eventually_eq, ‚Üêae_all_iff] at hf_eq
exact filter.eventually.and hf_eq hp
intros
simp only [ae_seq, hx, if_true]
rw funext (Œª n, mk_eq_fun_of_mem_ae_seq_set hf hx n)
have h_ss : ae_seq_set hf p ‚äÜ {x | p x (Œª n, f n x)}
rw [‚Üêcompl_compl {x | p x (Œª n, f n x)}, ae_seq_set, set.compl_subset_compl]
refine set.subset.trans (set.compl_subset_compl.mpr _) (subset_to_measurable _ _)
exact Œª x hx, hx.2
have hx' := set.mem_of_subset_of_mem h_ss hx
exact hx'
intros
obtain ‚ü®g, hg_meas, hfg‚ü© := hf
exact ‚ü®g, hg_meas, ae_eq_of_ae_eq_trim hfg‚ü©
intros
obtain ‚ü®f', hf'_meas, hff'‚ü© := hf
exact ‚ü®f', hf'_meas, hfg.symm.trans hff'‚ü©
intros
simp_rw [integrable, has_finite_integral, mem_‚Ñíp, snorm_one_eq_lintegral_nnnorm]
intros
rw [norm_def, ennreal.of_real_to_real]
exact ne_of_lt (has_finite_integral_coe_fn f)
intros
change (snorm ‚áë(0 : Œ± ‚Üí‚Çò[Œº] E) p Œº).to_real = 0
simp [snorm_congr_ae ae_eq_fun.coe_fn_zero, snorm_zero]
intros
refine ‚ü®h_lim_meas, _‚ü©
rw ennreal.tendsto_at_top_zero at h_tendsto
cases (h_tendsto 1 ennreal.zero_lt_one) with N h_tendsto_1
specialize h_tendsto_1 N (le_refl N)
have h_add : f_lim = f_lim - f N + f N
abel
rw h_add
refine lt_of_le_of_lt (snorm_add_le (h_lim_meas.sub (hf N).1) (hf N).1 hp) _
rw ennreal.add_lt_top
split
refine lt_of_le_of_lt _ ennreal.one_lt_top
have h_neg : f_lim - f N = -(f N - f_lim)
simp
rwa [h_neg, snorm_neg]
exact (hf N).2
intros
simp [snorm'_const c hq_pos, measure_univ]
intros
simp [snorm']
intros
have h_le : ‚à´‚Åª (a : Œ±), ‚Üë(nnnorm (f a)) ^ q ‚àÇŒº ‚â§ ‚à´‚Åª (a : Œ±), (snorm_ess_sup f Œº) ^ q ‚àÇŒº
refine lintegral_mono_ae _
have h_nnnorm_le_snorm_ess_sup := coe_nnnorm_ae_le_snorm_ess_sup f Œº
refine h_nnnorm_le_snorm_ess_sup.mono (Œª x hx, ennreal.rpow_le_rpow hx (le_of_lt hq_pos))
rw [snorm', ‚Üêennreal.rpow_one (snorm_ess_sup f Œº)]
nth_rewrite 1 ‚Üêmul_inv_cancel (ne_of_lt hq_pos).symm
rw [ennreal.rpow_mul, one_div, ‚Üêennreal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ‚â§ q‚Åª¬π)]
refine ennreal.rpow_le_rpow _ (by simp [hq_pos.le])
rwa lintegral_const at h_le
intros
have h_le_Œº := snorm'_le_snorm'_mul_rpow_measure_univ hp0_lt hpq hf
rwa [measure_univ, ennreal.one_rpow, mul_one] at h_le_Œº
intros
rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_to_real]
rw lintegral_congr_ae
refine hf.mp (eventually_of_forall _)
intros x hx
rw [lt_top_iff_ne_top] at hx
simp [hx]
exact (eventually_of_forall $ Œª x, ennreal.to_real_nonneg)
intros
refine (normed_space.eq_iff_forall_dual_eq ‚Ñù).2 (Œª g, _)
rw [‚Üê g.interval_integral_comp_comm f'int, g.map_sub]
exact integral_eq_sub_of_has_deriv_right_of_le_real' hab (g.continuous.comp_continuous_on hcont) (Œª x hx, g.has_fderiv_at.comp_has_deriv_within_at x (hderiv x hx)) (g.integrable_comp ((interval_integrable_iff_integrable_Icc_of_le hab).1 f'int))
intros
simpa only [mul_comm c] using integral_comp_mul_right f hc
intros
simpa only [one_mul, one_smul, inv_one] using integral_comp_sub_mul f one_ne_zero d
intros
rw [lintegral_const, measure.restrict_apply_univ]
intros
set S : set Œ± := { x | f x < 0 } with hSdef
have hS : measurable_set S := measurable_set_lt hf measurable_const
refine ‚ü®S, hS, _, _‚ü©
rw [with_density_apply _ hS, hSdef]
have hf0 : ‚àÄ·µê x ‚àÇŒº, x ‚àà S ‚Üí ennreal.of_real (f x) = 0
refine ae_of_all _ (Œª _ hx, _)
rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)]
rw set_lintegral_congr_fun hS hf0
exact lintegral_zero
rw [with_density_apply _ hS.compl, hSdef]
have hf0 : ‚àÄ·µê x ‚àÇŒº, x ‚àà S·∂ú ‚Üí ennreal.of_real (-f x) = 0
refine ae_of_all _ (Œª x hx, _)
rw ennreal.of_real_eq_zero.2
rwa [neg_le, neg_zero, ‚Üê not_lt]
rw set_lintegral_congr_fun hS.compl hf0
exact lintegral_zero
intros
simp only [coe_range, sep_mem_eq, set.mem_range, function.comp_app, coe_map, finset.coe_filter, ‚Üê mem_preimage, inter_comm, preimage_inter_range]
apply preimage_comp
intros
rw ‚Üê@lintegral_zero_fun Œ± _ Œº
refine lintegral_congr_ae _
suffices h_mul_zero : f * g =·µê[Œº] 0 * g
rwa zero_mul at h_mul_zero
have hf_eq_zero : f =·µê[Œº] 0
from ae_eq_zero_of_lintegral_rpow_eq_zero hp0_lt hf hf_zero
exact filter.eventually_eq.mul hf_eq_zero (ae_eq_refl g)
intros
simpa using (@measurable_set.empty Œ± _).compl
intros
haveI : locally_compact_space G := K‚ÇÄ.locally_compact_space_of_group
rw [haar_measure_apply K‚ÇÄ.2.1.measurable_set, ennreal.div_self]
rw [‚Üê pos_iff_ne_zero]
exact haar_content_outer_measure_self_pos
exact ne_of_lt (content.outer_measure_lt_top_of_is_compact _ K‚ÇÄ.2.1)
intros
rw [‚Üê map_coe_Ioi_at_bot, tendsto_map'_iff]
simp only [mk_metric', outer_measure.supr_apply, supr_subtype']
exact tendsto_at_bot_supr (Œª r r' hr, mono_pre _ hr _)
intros
simp [‚Üê measure_congr Ioi_ae_eq_Ici]
intros
simp only [volume_pi_ball a hr, volume_ball, finset.prod_const]
exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr.le) _).symm
intros
rw [‚Üê bUnion_of_singleton s, ‚Üê nonpos_iff_eq_zero]
refine le_trans (measure_bUnion_le h _) _
simp
intros
refine le_antisymm _ (le_map_apply f.measurable s)
rw [measure_eq_infi' Œº]
refine le_infi _
rintro ‚ü®t, hst, ht‚ü©
rw [subtype.coe_mk]
have : f.symm '' s = f ‚Åª¬π' s := f.symm.to_equiv.image_eq_preimage s
rw [‚Üê this, image_subset_iff] at hst
convert measure_mono hst
rw [map_apply, preimage_preimage]
refine congr_arg Œº (eq.symm _)
convert preimage_id
exact funext f.left_inv
exacts [f.measurable, f.measurable_inv_fun ht]
intros
rw [‚Üê (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]
intros
contrapose! H
apply tsum_measure_le_measure_univ hs
exact Œª i j hij x hx, H i j hij ‚ü®x, hx‚ü©
intros
simpa only [‚Üê measure_eq_trim] using Œº.to_outer_measure.exists_measurable_superset_eq_trim s
intros
refine ‚ü®Œª h, ‚ü®_, _‚ü©, Œª h, measure_union_lt_top h.1 h.2‚ü©
exact (measure_mono (set.subset_union_left s t)).trans_lt h
exact (measure_mono (set.subset_union_right s t)).trans_lt h
intros
intros U hU r hr
rcases H' hU r hr with ‚ü®F, hFU, hqF, hF‚ü©
rcases H hqF _ hF with ‚ü®K, hKF, hpK, hrK‚ü©
exact ‚ü®K, hKF.trans hFU, hpK, hrK‚ü©
intros
rw stieltjes_function.measure
exact f.outer_Ioc a b
intros
ext i hi
simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_zero_le_apply _ _ _ hi]
intros
ext i hi
simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_le_zero_apply _ _ _ hi]
intros
refine hf.ae_eq_of_forall_set_integral_eq f g hg (Œª i hi _, _)
rw [‚Üê with_density·µ•_apply hf hi, hfg, with_density·µ•_apply hg hi]
intros
ext
simp
norm_num [bernoulli]
intros
rw [bernoulli'_def', ‚Üê fin.sum_univ_eq_sum_range]
refl
rw bernoulli'_def
norm_num
intros
apply finset.subset_iff.2
intros x hx
exact nat.mem_proper_divisors.2 (‚ü®(nat.mem_divisors.1 hx).1.trans h, lt_of_le_of_lt (divisor_le hx) (lt_of_le_of_ne (divisor_le (nat.mem_divisors.2 ‚ü®h, hzero‚ü©)) hdiff)‚ü©)
ext
simp
intros
simp [padic_norm]
intros
simp [padic_norm, hq]
intros
unfold has_norm.norm
exact_mod_cast nonarchimedean' _ _
intros
simp [zsqrtd.ext]
intros
convert h.normalize.mul_is_classified (int.gcd x y) (is_classified_of_is_primitive_classified h.normalize hc)
rw int.mul_div_cancel'
exact int.gcd_dvd_left x y
rw int.mul_div_cancel'
exact int.gcd_dvd_right x y
rw int.mul_div_cancel'
exact h.gcd_dvd
intros
suffices : 0 < z * z
rintro rfl
norm_num at this
rw [‚Üê h.eq, ‚Üê sq, ‚Üê sq]
have hc' : int.gcd x y ‚â† 0
rw hc
exact one_ne_zero
cases int.ne_zero_of_gcd hc' with hxz hyz
apply lt_add_of_pos_of_le (sq_pos_of_ne_zero x hxz) (sq_nonneg y)
apply lt_add_of_le_of_pos (sq_nonneg x) (sq_pos_of_ne_zero y hyz)
intros
by_contradiction H
obtain ‚ü®p, hp, hpy, hpz‚ü© := nat.prime.not_coprime_iff_dvd.mp H
apply hp.not_dvd_one
rw [‚Üê hc]
apply nat.dvd_gcd (int.prime.dvd_nat_abs_of_coe_dvd_sq hp _ _) hpy
rw [sq, eq_sub_of_add_eq h]
rw [‚Üê int.coe_nat_dvd_left] at hpy hpz
exact dvd_sub ((hpz).mul_right _) ((hpy).mul_right _)
intros
cases h.even_odd_of_coprime hc with h1 h2
exact (h.is_primitive_classified_of_coprime_of_odd_of_pos hc h1.right hzpos)
rw int.gcd_comm at hc
obtain ‚ü®m, n, H‚ü© := (h.symm.is_primitive_classified_of_coprime_of_odd_of_pos hc h2.left hzpos)
use [m, n]
tauto
intros
simp [ext]
intros
simp [ext, sub_eq_add_neg, mul_comm]
intros
apply complex.ext
simp [to_complex_def]
simp [to_complex_def]
intros
rw [sdiff_eq, compl_compl]
intros
simp only [disjoint_iff, inf_sup_left, sup_eq_bot_iff]
intros
simp [bdd_above]
intros
apply le_antisymm
apply Sup_le (Œª b hb, _)
rcases hb with ‚ü®t, ts, bt‚ü©
apply le_trans _ (le_supr _ t)
exact le_trans (le_Sup bt) (le_supr _ ts)
apply supr_le (Œª t, _)
exact supr_le (Œª ts, Sup_le_Sup (Œª x xt, ‚ü®t, ts, xt‚ü©))
intros
have := propext pq
subst this
congr' with x
apply f
intros
rw [infi, range_const, Inf_singleton]
intros
simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]
intros
rw frequently_at_top' at h
exact extraction_of_frequently_at_top' h
intros
simp only [tendsto, (hla.map f).le_iff, image_subset_iff]
refl
intros
rw ‚Üêimage_univ
exact image_mem_map univ_mem
intros
rw [filter.prod, comap_sup, inf_sup_right, ‚Üê filter.prod, ‚Üê filter.prod]
intros
simpa only [filter.eventually, set_of_forall] using @countable_bInter_mem _ _ l _ _ hS (Œª i hi, {x | p x i hi})
intros
simp [filter.lift]
intros
rintros s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©
refine ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.refl _‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.refl _‚ü©, _‚ü©
have := subset.trans (preimage_mono t‚ÇÅt‚ÇÇ) mt
exact subset.trans (preimage_mul_preimage_subset _) this
intros
rw [‚Üê sup_assoc, sup_idem]
intros
rw [‚Üê sup_assoc, ‚Üê sup_assoc, @sup_comm Œ± _ a]
intros
simp_rw liminf_eq_supr_infi_of_nat
exact supr_infi_ge_nat_add f k
intros
split
intros
transitivity œâSup c
exact le_œâSup _ _
assumption
intros
exact œâSup_le _ _ ‚Äπ_‚Ä∫
intros
split_ifs
simp *
simp *
intros
rw [hf.map_Sup', Sup_image]
intros
rw [symm_diff_comm, symm_diff_sdiff_left]
intros
classical
split
intros h f hf
exact h.exists_monotone_subseq f hf
intros h f hf
obtain ‚ü®g, gmon‚ü© := h f hf
refine ‚ü®g 0, g 1, g.lt_iff_lt.2 zero_lt_one, gmon _ _ zero_le_one‚ü©
intros
dsimp [conjugate]
simp only [‚Üêi.map_smul, h, ‚Üêmul_smul, single_mul_single, mul_one, mul_left_inv]
change (1 : monoid_algebra k G) ‚Ä¢ v = v
simp
intros
have f'_monic : monic _ := monic_mul_leading_coeff_inv hf
refine (minpoly.unique K _ f'_monic _ _).symm
rw [alg_hom.map_mul, aeval_eq, mk_self, zero_mul]
intros q q_monic q_aeval
have commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f
ext
simp only [ring_hom.comp_apply, mk_C, lift_of]
refl
simp only [ring_hom.comp_apply, mk_X, lift_root]
rw [degree_eq_nat_degree f'_monic.ne_zero, degree_eq_nat_degree q_monic.ne_zero, with_bot.coe_le_coe, nat_degree_mul hf, nat_degree_C, add_zero]
apply nat_degree_le_of_dvd
have : mk f q = 0
rw [‚Üêcommutes, ring_hom.comp_apply, mk_self, ring_hom.map_zero]
rwa [‚Üêideal.mem_span_singleton, ‚Üêideal.quotient.eq_zero_iff_mem]
exact q_monic.ne_zero
rwa [ne.def, C_eq_zero, inv_eq_zero, leading_coeff_eq_zero]
intros
rw mem_inv_iff (fractional_ideal.coe_ideal_ne_zero hI)
intros y hy
rw one_mul
exact coe_ideal_le_one hy
assumption
intros
split
rw iff_quotient_mv_polynomial'
rintro ‚ü®Œπ, hfintype, ‚ü®f, hsur‚ü©‚ü©
letI := hfintype
obtain ‚ü®equiv‚ü© := @fintype.trunc_equiv_fin Œπ (classical.dec_eq Œπ) hfintype
replace equiv := mv_polynomial.rename_equiv R equiv
exact ‚ü®fintype.card Œπ, alg_hom.comp f equiv.symm, function.surjective.comp hsur (alg_equiv.symm equiv).surjective‚ü©
rintro ‚ü®n, ‚ü®f, hsur‚ü©‚ü©
exact finite_type.of_surjective (finite_type.mv_polynomial R (fin n)) f hsur
intros
letI := f.to_algebra
letI := g.to_algebra
letI := (g.comp f).to_algebra
letI : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C
letI : module.finite A C := h
exact module.finite.of_restrict_scalars_finite A B C
intros
refine ‚ü®Œª h, _, Œª h, submodule.subset_span $ set.mem_image_of_mem (of R M) h‚ü©
rw [of, monoid_hom.coe_mk, ‚Üê finsupp.supported_eq_span_single, finsupp.mem_supported, finsupp.support_single_ne_zero (@one_ne_zero R _ (by apply_instance))] at h
simpa using h
intros
ext
refine (mem_span_singleton S).trans ((exists_congr _).trans (mem_one_iff S).symm)
intro x'
rw [algebra.smul_def, mul_one]
intros
obtain ‚ü®a, a_mem, ha‚ü© := J.is_fractional
use [a, a_mem]
intros b b_mem
exact ha b (hIJ b_mem)
intros
simp [‚Üê ring_equiv.to_ring_hom_eq_coe, comap_comap]
intros
obtain ‚ü®p, p_monic, hpx‚ü© := integral
refine comap_lt_comap_of_root_mem_sdiff hIJ mem _ _
swap
apply map_monic_ne_zero p_monic
apply quotient.nontrivial
apply mt comap_eq_top_iff.mp
apply hI.1
convert I.zero_mem
intros
ext n
rw [‚Üê sub_add_cancel n x.order, single_mul_coeff_add, sub_add_cancel, one_mul]
by_cases h : x.order ‚â§ n
rw [int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), coeff_coe_power_series, power_series_part_coeff, ‚Üê int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), add_sub_cancel'_right]
rw [coe_power_series, of_power_series_apply, emb_domain_notin_range]
contrapose! h
exact order_le_of_coeff_ne_zero h.symm
contrapose! h
simp only [set.mem_range, rel_embedding.coe_fn_mk, function.embedding.coe_fn_mk, int.nat_cast_eq_coe_nat] at h
obtain ‚ü®m, hm‚ü© := h
rw [‚Üê sub_nonneg, ‚Üê hm]
exact int.zero_le_of_nat _
intros
rw [coe_submodule, submodule.map_top, submodule.one_eq_range]
intros
simp [matrix_equiv_tensor, to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
refl
intros
refine classical.by_contradiction (Œª hf, (rel_embedding.well_founded_iff_no_descending_seq.1 (well_founded_submodule_gt R M)).elim' _)
have f : ‚Ñï ‚Ü™ s
from @infinite.nat_embedding s ‚ü®Œª f, hf ‚ü®f‚ü©‚ü©
have : ‚àÄ n, (coe ‚àò f) '' {m | m ‚â§ n} ‚äÜ s
rintros n x ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©
subst hy‚ÇÇ
exact (f y).2
have : ‚àÄ a b : ‚Ñï, a ‚â§ b ‚Üî span R ((coe ‚àò f) '' {m | m ‚â§ a}) ‚â§ span R ((coe ‚àò f) '' {m | m ‚â§ b})
assume a b
rw [span_le_span_iff hs (this a) (this b), set.image_subset_image_iff (subtype.coe_injective.comp f.injective), set.subset_def]
exact ‚ü®Œª hab x (hxa : x ‚â§ a), le_trans hxa hab, Œª hx, hx a (le_refl a)‚ü©
exact ‚ü®‚ü®Œª n, span R ((coe ‚àò f) '' {m | m ‚â§ n}), Œª x y, by simp [le_antisymm_iff, (this _ _).symm] {contextual := tt}‚ü©, by dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]; tauto‚ü©
intros
intros p hp x hx
rw ‚Üê mem_vanishing_ideal_singleton_iff
rw radical_eq_Inf at hp
refine (mem_Inf.mp hp) ‚ü®le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (Œª y hy, hy.symm ‚ñ∏ hx)), is_maximal.is_prime' _‚ü©
intros
ext i
simp only [mem_support_iff, not_iff_not, ne.def]
conv_rhs { rw [‚Üê coeff_restriction] }
exact ‚ü®Œª H, by { rw H, refl }, Œª H, subtype.coe_injective H‚ü©
intros
simp only [restriction, finset.sum_empty, support_zero]
intros
dsimp [bernstein_polynomial]
suffices : ‚Üë((n + 1).choose (ŒΩ + 1)) * ((‚ÜëŒΩ + 1) * X ^ ŒΩ) * (1 - X) ^ (n - ŒΩ) -(‚Üë((n + 1).choose (ŒΩ + 1)) * X ^ (ŒΩ + 1) * (‚Üë(n - ŒΩ) * (1 - X) ^ (n - ŒΩ - 1))) = (‚Üën + 1) * (‚Üë(n.choose ŒΩ) * X ^ ŒΩ * (1 - X) ^ (n - ŒΩ) - ‚Üë(n.choose (ŒΩ + 1)) * X ^ (ŒΩ + 1) * (1 - X) ^ (n - (ŒΩ + 1)))
simpa [polynomial.derivative_pow, ‚Üêsub_eq_add_neg]
conv_rhs { rw mul_sub, }
refine congr (congr_arg has_sub.sub _) _
simp only [‚Üêmul_assoc]
refine congr (congr_arg (*) (congr (congr_arg (*) _) rfl)) rfl
exact_mod_cast congr_arg (Œª m : ‚Ñï, (m : polynomial R)) (nat.succ_mul_choose_eq n ŒΩ).symm
rw nat.sub_sub
rw [‚Üêmul_assoc,‚Üêmul_assoc]
congr' 1
rw mul_comm
rw [‚Üêmul_assoc,‚Üêmul_assoc]
congr' 1
norm_cast
congr' 1
convert (nat.choose_mul_succ_eq n (ŒΩ + 1)).symm using 1
convert mul_comm _ _ using 2
simp
apply mul_comm
intros
rw content_eq_gcd_range_of_lt p (max p.nat_degree q.nat_degree).succ (lt_of_le_of_lt (le_max_left _ _) (nat.lt_succ_self _))
rw content_eq_gcd_range_of_lt q (max p.nat_degree q.nat_degree).succ (lt_of_le_of_lt (le_max_right _ _) (nat.lt_succ_self _))
apply finset.gcd_eq_of_dvd_sub
intros x hx
cases h with w hw
use w.coeff x
rw [‚Üê coeff_sub, hw, coeff_C_mul]
intros
apply is_homogeneous_monomial
simp only [finsupp.support_single_ne_zero one_ne_zero, finset.sum_singleton]
exact finsupp.single_eq_same
intros
simp only [monic, leading_coeff, nat_degree_scale_roots, coeff_scale_roots_nat_degree]
intros
have := coe_monomial 0 (1:R)
rwa power_series.monomial_zero_eq_C_apply at this
intros
simpa using coeff_add_monomial_mul 0 n œÜ a
intros
refine ‚ü®h1, _‚ü©
intros l hl
apply dvd_trans _ (k.gcd_dvd_right l)
suffices : k.gcd l = k
rw this
rw eq_iff_le_not_lt
refine ‚ü®nat.le_of_dvd hk (k.gcd_dvd_left l), _‚ü©
intro h'
apply h _ (nat.gcd_pos_of_pos_left _ hk) h'
exact pow_gcd_eq_one _ h1 hl
intros
apply (eq_or_eq_neg_of_sq_eq_sq Œ∂ 1 _).resolve_left
rw [‚Üê pow_one Œ∂]
apply h.pow_ne_one_of_pos_of_lt
dec_trivial
dec_trivial
simp only [h.pow_eq_one, one_pow]
intros
obtain ‚ü®d, rfl‚ü© := h
intros Œ∂ h
simp only [mem_roots_of_unity, pnat.mul_coe, pow_mul, one_pow, *] at *
intros
rw [‚Üê ker_eq_bot, ‚Üê ker_eq_top]
apply eq_bot_or_eq_top
intros
by_cases H : ‚àÉ (s : finset L), nonempty (basis s K L)
rw [trace_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]
simp [trace_eq_zero_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis_finset H]
intros
split
intros hg p ha hb hp
refine ((associates.prime_mk _).mpr hp).not_unit (is_unit_of_dvd_one _ _)
rw ‚Üê hg
exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb)
contrapose
intros hg hc
obtain ‚ü®p, hp, hpa, hpb‚ü© := exists_prime_dvd_of_not_inf_one ha0 hb0 hg
exact hc hpa hpb hp
intros
rw from_padic_int_comp_to_padic_int
intros
induction n with n ih
simp only [witt_mul_n, nat.cast_zero, zero_mul, bind‚ÇÅ_zero_witt_polynomial]
rw [witt_mul_n, ‚Üê bind‚ÇÅ_bind‚ÇÅ, witt_add, witt_structure_int_prop]
simp only [alg_hom.map_add, nat.cast_succ, bind‚ÇÅ_X_right]
rw [add_mul, one_mul, bind‚ÇÅ_rename, bind‚ÇÅ_rename]
simp only [ih, function.uncurry, function.comp, bind‚ÇÅ_X_left, alg_hom.id_apply, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
intros
rw [submodule.eq_bot_iff]
intros x hx
ext
simp only [witt_vector.mem_ker_truncate, ideal.mem_infi, witt_vector.zero_coeff] at hx ‚ä¢
exact hx _ _ (nat.lt_succ_self _)
intros
ext1 x
rw [‚Üê sub_eq_zero, ‚Üê ideal.mem_bot, ‚Üê infi_ker_truncate, ideal.mem_infi]
intro i
simp only [ring_hom.mem_ker, g_compat, ‚Üêring_hom.comp_apply, truncate_comp_lift, ring_hom.map_sub, sub_self]
intros
simp only [witt_polynomial_eq_sum_C_mul_X_pow, sum_range_succ_comm, range_one, sum_singleton, one_mul, pow_one, C_1, pow_zero]
intros
rw [image_eq_range] at h
convert mk_preimage_of_subset_range _ _ h using 1
rw [mk_sep]
refl
rw [‚Üê to_nat_cast 0, nat.cast_zero]
intros
simp [bit0]
intros
rw [‚Üê not_lt, ‚Üê not_lt, aleph_idx_lt]
simpa using cof_le_card 0
intros
simp_rw [cardinal.infinite_iff] at ‚ä¢ w'
cases infinite_pigeonhole_card_lt f w w' with a ha
exact ‚ü®a, w'.trans ha.le‚ü©
intros
simp only [ord_le, card_ord]
intros
rw [limit_rec_on, well_founded.fix_eq, dif_pos rfl]
refl
intros
simp [bit0]
intros
simp [bit1, bit0]
intros
simpa [eq.symm h1, eq.symm h2, int.coe_nat_lt]
intros
simp *
intros
rwa [‚Üê e2, ‚Üê e1, ‚Üê hn, normalize_fin, add_comm, nat.add_mul_mod_self_left] at h
intros
simp only [normalize_fin, ‚Üê h] at *
rw [nat.add_mod, ‚Üê ha, ‚Üê hb, fin.add_def]
intros
simp [h‚ÇÉ.symm, h‚ÇÇ.symm, h‚ÇÅ.symm, horner, add_mul, mul_comm (x ^ n)]
cc
intros
rw ‚Üê (horner_expr.cseval_of_csexpr t _).2
rw ‚Üê (horner_expr.cseval_of_csexpr t _).2
rw H
intros
apply ne_of_gt
apply nat.lt_add_of_pos_right
apply nat.pos_of_ne_zero
contradiction
intros
rw [continuous_at, nhds_coe_eq, tendsto_map'_iff, continuous_at]
intros
refine ‚ü®Œª h, _, Œª h, _‚ü©
simp only [algebra.smul_def]
exact (h.comp continuous_fst).mul continuous_snd
rw algebra_map_eq_smul_one'
exact h.comp (continuous_id.prod_mk continuous_const)
intros
by_cases hP : P
simp [hP]
simp [hP]
intros
by_cases hg : summable g
exact hg.has_sum.nonneg h
simp [tsum_eq_zero_of_not_summable hg]
intros
by_cases hf : summable f
exact hf.has_sum.nonpos h
simp [tsum_eq_zero_of_not_summable hf]
intros
ext x
refl
intros
rw set_like.ext'_iff at hs ‚ä¢
simp only [submodule.topological_closure_coe, submodule.top_coe, ‚Üê dense_iff_closure_eq] at hs ‚ä¢
exact hf'.dense_image f.continuous hs
intros
rw ((nhds_basis_Ioo_pos (1 : Œ±)).prod $ nhds_basis_Ioo_pos (1 : Œ±)).tendsto_iff (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : Œ±) < 1))
intros Œµ hŒµ
have hŒµ' : 0 ‚â§ 1 - Œµ / 4 := by linarith
have Œµ_pos : 0 < Œµ / 4 := by linarith
have Œµ_pos' : 0 < Œµ / 2 := by linarith
simp only [and_imp, prod.forall, mem_Ioo, function.uncurry_apply_pair, mem_prod, prod.exists]
refine ‚ü®Œµ/4, Œµ/4, ‚ü®Œµ_pos, Œµ_pos‚ü©, Œª a b ha ha' hb hb', _‚ü©
have ha0 : 0 ‚â§ a := le_trans hŒµ' (le_of_lt ha)
have hb0 : 0 ‚â§ b := le_trans hŒµ' (le_of_lt hb)
refine ‚ü®lt_of_le_of_lt _ (mul_lt_mul'' ha hb hŒµ' hŒµ'), lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _‚ü©
calc 1 - Œµ = 1 - Œµ / 2 - Œµ/2 : by ring_nf ... ‚â§ 1 - Œµ/2 - Œµ/2 + (Œµ/2)*(Œµ/2) : le_add_of_nonneg_right (le_of_lt (mul_pos Œµ_pos' Œµ_pos')) ... = (1 - Œµ/2) * (1 - Œµ/2) : by ring_nf ... ‚â§ (1 - Œµ/4) * (1 - Œµ/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hŒµ'
calc (1 + Œµ/4) * (1 + Œµ/4) = 1 + Œµ/2 + (Œµ/4)*(Œµ/4) : by ring_nf ... = 1 + Œµ/2 + (Œµ * Œµ) / 16 : by ring_nf ... ‚â§ 1 + Œµ/2 + Œµ/2 : add_le_add_left (div_le_div (le_of_lt hŒµ.1) (le_trans ((mul_le_mul_left hŒµ.1).2 hŒµ.2) (le_of_eq $ mul_one Œµ)) zero_lt_two (by linarith)) (1 + Œµ/2) ... ‚â§ 1 + Œµ : by ring_nf
intros
refine (has_basis.tendsto_iff at_top_basis ‚ü®Œª s, mem_nhds_within_Ioi_iff_exists_Ioc_subset‚ü©).2 _
refine Œª b hb, ‚ü®b‚Åª¬π, trivial, Œª x hx, _‚ü©
have : 0 < x := lt_of_lt_of_le (inv_pos.2 hb) hx
exact ‚ü®inv_pos.2 this, (inv_le this hb).2 hx‚ü©
intros
simp [frontier]
intros
cases le_total (f a) (f b)
simp [*, is_preconnected_interval.intermediate_value]
simp [*, is_preconnected_interval.intermediate_value]
intros
simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]
intros
convert is_closed_closure
intros
rw ‚Üê set.image_subset_iff
exact image_closure_subset_closure_image h
intros
rw ‚Üê subset_interior_iff_open
simp only [subset_def, mem_interior]
intros
continuity
intros
have mem_closure : p ‚àà (polynomial_functions (set.Icc (-‚à•f‚à•) (‚à•f‚à•))).topological_closure := continuous_map_mem_polynomial_functions_closure _ _ p
have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure
apply mem_closure_iff_frequently.mpr
refine ((comp_right_continuous_map ‚Ñù (attach_bound (f : C(X, ‚Ñù)))).continuous_at p).tendsto .frequently_map _ _ frequently_mem_polynomials
rintros _ ‚ü®g, ‚ü®-,rfl‚ü©‚ü©
simp only [set_like.mem_coe, alg_hom.coe_to_ring_hom, comp_right_continuous_map_apply, polynomial.to_continuous_map_on_alg_hom_apply]
apply polynomial_comp_attach_bound_mem
intros
tauto
intros
ext ‚ü®‚ü©
refl
intros
change ite _ _ _ = _
split_ifs
rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem]
refl
rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem]
refl
intros
rw [nhds_bot', mem_infi_of_directed]
refl
exact Œª x y, ‚ü®min x y, by simp [le_refl], by simp [le_refl]‚ü©
intros
rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.target_inter_inv_preimage_preimage, e.nhds_within_target_inter (e.map_source hx)]
intros
intros s hs
rcases hf.is_closed_iff.1 hs with ‚ü®t, ht, rfl‚ü©
rw image_preimage_eq_inter_range
exact is_closed.inter ht h
intros
rw [metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff]
intros
ext p
simp [dist_pi_le_iff hr]
intros
simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y
intros
simp [nndist, edist_dist, real.to_nnreal, max_eq_left dist_nonneg, ennreal.of_real]
intros
ext
simp [dist_comm, uniform_space.ball]
intros
simp [dist_comm]
intros
ext y
simp [edist_dist]
rw ennreal.of_real_le_of_real_iff h
intros
rw edist_comm
refl
intros
cases s.eq_empty_or_nonempty with hs hs
cases t.eq_empty_or_nonempty with ht ht
exact or.inl ‚ü®hs, ht‚ü©
rw Hausdorff_edist_comm at fin
exact or.inr ‚ü®nonempty_of_Hausdorff_edist_ne_top ht fin, ht‚ü©
exact or.inr ‚ü®hs, nonempty_of_Hausdorff_edist_ne_top hs fin‚ü©
intros
rw [dist_edist, dist_edist, hf]
intros
simp [is_œâSup, is_lub, is_least, upper_bounds, lower_bounds]
intros
refine is_topological_basis_of_open_of_nhds (Œª u hu, hu.1) _
rintros x U memU hU
obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
obtain ‚ü®t, h, ht, xt‚ü© := mem_interior.1 xs
let u : set s := (coe : s ‚Üí H)‚Åª¬π' (interior s)
have u_open_in_s : is_open u := is_open_interior.preimage continuous_subtype_coe
let X : s := ‚ü®x, h xt‚ü©
have Xu : X ‚àà u := xs
haveI : compact_space s := is_compact_iff_compact_space.1 comp
obtain ‚ü®V : set s, clopen_in_s, Vx, V_sub‚ü© := compact_exists_clopen_in_open u_open_in_s Xu
have V_clopen : is_clopen ((coe : s ‚Üí H) '' V)
refine ‚ü®_, (comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed).1 clopen_in_s.2‚ü©
let v : set u := (coe : u ‚Üí s)‚Åª¬π' V
have : (coe : u ‚Üí H) = (coe : s ‚Üí H) ‚àò (coe : u ‚Üí s) := rfl
have f0 : embedding (coe : u ‚Üí H) := embedding_subtype_coe.comp embedding_subtype_coe
have f1 : open_embedding (coe : u ‚Üí H)
refine ‚ü®f0, _‚ü©
have : set.range (coe : u ‚Üí H) = interior s
rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe]
apply set.inter_eq_self_of_subset_left interior_subset
rw this
apply is_open_interior
have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe
have f3 : (coe : s ‚Üí H) '' V = (coe : u ‚Üí H) '' v
rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
rw f3
apply f1.is_open_map v f2
refine ‚ü®coe '' V, V_clopen, by simp [Vx, h xt], _‚ü©
transitivity s
simp
assumption
intros
obtain ‚ü®V, Vsub, Vne, Vcls, hV‚ü© := hS.exists_minimal_nonempty_closed_subset hne
by_cases hnt : ‚àÉ (x y : Œ±) (hx : x ‚àà V) (hy : y ‚àà V), x ‚â† y
exfalso
obtain ‚ü®x, y, hx, hy, hne‚ü© := hnt
obtain ‚ü®U, hU, hsep‚ü© := t0_space.t0 _ _ hne
have : ‚àÄ (z w : Œ±) (hz : z ‚àà V) (hw : w ‚àà V) (hz' : z ‚àà U) (hw' : ¬¨ w ‚àà U), false
intros z w hz hw hz' hw'
have uvne : (V ‚à© U·∂ú).nonempty
use w
simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq]
specialize hV (V ‚à© U·∂ú) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU))
have : V ‚äÜ U·∂ú
rw ‚ÜêhV
exact set.inter_subset_right _ _
exact this hz hz'
cases hsep
exact this x y hx hy hsep.1 hsep.2
exact this y x hy hx hsep.1 hsep.2
push_neg at hnt
obtain ‚ü®z, hz‚ü© := Vne
refine ‚ü®z, Vsub hz, _‚ü©
convert Vcls
ext
simp only [set.mem_singleton_iff, set.mem_compl_eq]
split
rintro rfl
exact hz
exact Œª hx, hnt x z hx hz
intros
classical
haveI : nonempty (partial_refinement u s) := ‚ü®‚ü®u, ‚àÖ, uo, us, Œª _, false.elim, Œª _ _, rfl‚ü©‚ü©
have : ‚àÄ c : set (partial_refinement u s), chain (‚â§) c ‚Üí c.nonempty ‚Üí ‚àÉ ub, ‚àÄ v ‚àà c, v ‚â§ ub
from Œª c hc ne, ‚ü®partial_refinement.chain_Sup c hc ne uf us, Œª v hv, partial_refinement.le_chain_Sup _ _ _ _ hv‚ü©
rcases zorn_nonempty_partial_order this with ‚ü®v, hv‚ü©
suffices : ‚àÄ i, i ‚àà v.carrier
from ‚ü®v, v.subset_Union, Œª i, v.is_open _, Œª i, v.closure_subset (this i)‚ü©
contrapose! hv
rcases hv with ‚ü®i, hi‚ü©
rcases v.exists_gt hs i hi with ‚ü®v', hlt‚ü©
exact ‚ü®v', hlt.le, hlt.ne'‚ü©
intros
rw topological_space.nhds_generate_from
simp only [comap_infi, comap_principal]
intros s hs
rw ‚Üêle_principal_iff
refine infi_le_of_le {u | s ‚àà u} _
refine infi_le_of_le ‚ü®hs, ‚ü®s, rfl‚ü©‚ü© _
exact principal_mono.2 (Œª a, id)
intros
apply eq_bot_of_singletons_open
intros x
use [{u : ultrafilter Œ± | {x} ‚àà u}, ultrafilter_is_open_basic _]
simp
intros
rw union_eq_Union
exact compact_Union (Œª b, by cases b; assumption)
intros
rw [continuous_within_at, tendsto_nhds_right]
intros
unfold symmetric_rel at *
rw [preimage_inter, hU, hV]
intros
assume u hu
apply (h u hu).mono (Œª n hn, _)
exact Œª x hx, hn _ hx
intros
set c : urysohns.CU X := ‚ü®s, t·∂ú, hs, ht.is_open_compl, Œª _, disjoint_left.1 hd‚ü©
exact ‚ü®‚ü®c.lim, c.continuous_lim‚ü©, c.lim_of_mem_C, Œª x hx, c.lim_of_nmem_U _ (Œª h, h hx), c.lim_mem_Icc‚ü©
